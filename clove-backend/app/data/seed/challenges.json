[
  {
    "id": 1,
    "subtopic_id": 1,
    "type": "output_tracing",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "The Pathfinder's AI is learning to track magical energy. A `SparkSpell` initializes a variable `spellPower`. Your task is to trace the code and determine the output displayed by the system.",
    "story_context": "The Pathfinder's AI needs to track magical energy levels. Your task is to trace the code execution and predict the output.",
    "challenge_data": {
      "code": "public class SparkSpell {\n    public static void main(String[] args) {\n        int spellPower = 10;\n        System.out.println(spellPower);\n    }\n}",
      "expected_output": [
        "10"
      ],
      "choices": [
        "10",
        "0",
        "Error",
        "System.out.println"
      ],
      "explanation": "The `int spellPower = 10;` line declares an integer variable named `spellPower` and initializes it with the value `10`. The `System.out.println(spellPower);` line then prints the current value stored in the `spellPower` variable, which is `10`."
    },
    "hints": {
      "1": "Identify the variable's initial assignment.",
      "2": "Follow the flow of execution, especially the last command.",
      "3": "Consider what `System.out.println()` does."
    }
  },
  {
    "id": 2,
    "subtopic_id": 1,
    "type": "output_tracing",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `PotionInventory` system tracks magical ingredients. The `moonpetalDust` variable is initially set, then updated. Your task is to trace the code and determine its final value printed by the system.",
    "story_context": "The PotionInventory system needs to track ingredient quantities. Your task is to trace the variable reassignment and predict the output.",
    "challenge_data": {
      "code": "public class PotionInventory {\n    public static void main(String[] args) {\n        int moonpetalDust = 5;\n        moonpetalDust = 7;\n        System.out.println(moonpetalDust);\n    }\n}",
      "expected_output": [
        "7"
      ],
      "choices": [
        "5",
        "7",
        "12",
        "Error"
      ],
      "explanation": "The variable `moonpetalDust` is first initialized to `5`. Then, `moonpetalDust = 7;` reassigns the variable, overwriting the previous value `5` with `7`. When `System.out.println(moonpetalDust);` is executed, it prints the most recently assigned value, which is `7`."
    },
    "hints": {
      "1": "Notice that the variable `moonpetalDust` is assigned a value twice.",
      "2": "In programming, a variable holds only its most recent value.",
      "3": "The `println` statement displays the value at the moment it's executed."
    }
  },
  {
    "id": 3,
    "subtopic_id": 1,
    "type": "output_tracing",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "An `ArtifactLabeler` creates labels for magical items. The `artifactName` variable holds the name of an artifact. Your task is to trace the code and determine the complete label that will be printed.",
    "story_context": "The ArtifactLabeler needs to create proper labels for magical items. Your task is to trace the string concatenation and predict the output.",
    "challenge_data": {
      "code": "public class ArtifactLabeler {\n    public static void main(String[] args) {\n        String artifactName = \"Amulet of Zarthus\";\n        System.out.println(\"Label: \" + artifactName);\n    }\n}",
      "expected_output": [
        "Label: Amulet of Zarthus"
      ],
      "choices": [
        "Amulet of Zarthus",
        "Label: Amulet of Zarthus",
        "Label: artifactName",
        "Error"
      ],
      "explanation": "The `String artifactName = \"Amulet of Zarthus\";` line declares a String variable `artifactName` and assigns it the text `\"Amulet of Zarthus\"`. The `System.out.println(\"Label: \" + artifactName);` line uses string concatenation (`+`) to join the literal string `\"Label: \"` with the *value* of `artifactName`. Therefore, the output will be `Label: Amulet of Zarthus`."
    },
    "hints": {
      "1": "Observe how the `+` operator is used with a `String` literal and a variable.",
      "2": "Think about what happens when text is combined with a variable's value.",
      "3": "Does the variable name itself get printed, or its content?"
    }
  },
  {
    "id": 4,
    "subtopic_id": 1,
    "type": "output_tracing",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `MagicSurgeMonitor` detects magical energy fluctuations. The `majorSurgeDetected` flag indicates if a surge is active. Your task is to trace the code and determine which status message is printed based on the flag's value.",
    "story_context": "The MagicSurgeMonitor needs to detect magical energy fluctuations. Your task is to trace the boolean condition and predict the output.",
    "challenge_data": {
      "code": "public class MagicSurgeMonitor {\n    public static void main(String[] args) {\n        boolean majorSurgeDetected = false;\n        if (majorSurgeDetected) {\n            System.out.println(\"Major Magic Surge Detected!\");\n        } else {\n            System.out.println(\"Energy levels stable.\");\n        }\n    }\n}",
      "expected_output": [
        "Energy levels stable."
      ],
      "choices": [
        "Major Magic Surge Detected!",
        "Energy levels stable.",
        "Error",
        "Nothing"
      ],
      "explanation": "The `boolean majorSurgeDetected = false;` line initializes the `majorSurgeDetected` variable to `false`. The `if (majorSurgeDetected)` condition checks if `majorSurgeDetected` is `true`. Since it's `false`, the `if` block is skipped, and the code inside the `else` block, `System.out.println(\"Energy levels stable.\");`, is executed."
    },
    "hints": {
      "1": "Consider the initial value assigned to the boolean variable.",
      "2": "An `if` statement's code block only runs if its condition evaluates to `true`.",
      "3": "If the `if` condition is `false`, the `else` block (if present) will execute."
    }
  },
  {
    "id": 5,
    "subtopic_id": 1,
    "type": "output_tracing",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "An `OrbIdentifier` system assigns a unique ID to each magical orb. The `orbID` variable holds a single character. Your task is to trace the code and determine the full Orb ID that is displayed.",
    "story_context": "The OrbIdentifier system needs to create unique identifiers for magical orbs. Your task is to trace the character variable and predict the output.",
    "challenge_data": {
      "code": "public class OrbIdentifier {\n    public static void main(String[] args) {\n        char orbID = 'A';\n        System.out.println(\"Orb ID: \" + orbID);\n    }\n}",
      "expected_output": [
        "Orb ID: A"
      ],
      "choices": [
        "A",
        "Orb ID: A",
        "Orb ID: orbID",
        "Error"
      ],
      "explanation": "The `char orbID = 'A';` line declares a character variable `orbID` and assigns it the single character `'A'`. The `System.out.println(\"Orb ID: \" + orbID);` statement uses string concatenation to combine the literal string `\"Orb ID: \"` with the value of the `orbID` variable. Thus, the output will be `Orb ID: A`."
    },
    "hints": {
      "1": "Identify the data type used for `orbID`.",
      "2": "Recall how characters are typically printed in Java.",
      "3": "The `+` symbol combines a literal string with the value of the variable."
    }
  },
  {
    "id": 6,
    "subtopic_id": 1,
    "type": "output_tracing",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "An `ElementalInvocation` ritual is being performed. The `elementalCharge` is calculated by adding an `amplifier` value, and then the `amplifier` itself is reassigned. Your task is to trace the code and determine the final `Charge` and `Amplifier` values that are printed.",
    "story_context": "The ElementalInvocation ritual needs to calculate and track elemental charges. Your task is to trace multiple variable changes and predict the outputs.",
    "challenge_data": {
      "code": "public class ElementalInvocation {\n    public static void main(String[] args) {\n        int elementalCharge = 25;\n        int amplifier = 5;\n        elementalCharge = elementalCharge + amplifier;\n        amplifier = 10;\n        System.out.println(\"Charge: \" + elementalCharge);\n        System.out.println(\"Amplifier: \" + amplifier);\n    }\n}",
      "expected_output": [
        "Charge: 30",
        "Amplifier: 10"
      ],
      "choices": [
        "Charge: 25",
        "Amplifier: 5",
        "Charge: 30",
        "Amplifier: 10",
        "Charge: 35"
      ],
      "explanation": "Initially, `elementalCharge` is `25` and `amplifier` is `5`. \n1. `elementalCharge = elementalCharge + amplifier;` calculates `25 + 5`, resulting in `30`. `elementalCharge` is now `30`.\n2. `amplifier = 10;` changes `amplifier` to `10`. This happens *after* `amplifier` was used in the `elementalCharge` calculation.\n3. The first `System.out.println()` prints \"Charge: 30\" (value of `elementalCharge`).\n4. The second `System.out.println()` prints \"Amplifier: 10\" (current value of `amplifier`)."
    },
    "hints": {
      "1": "Trace the `elementalCharge` variable first, observing where its value changes.",
      "2": "Then, trace the `amplifier` variable. Notice when its value is used versus when it's updated.",
      "3": "Remember that `System.out.println()` outputs the *current* value of a variable at the time of execution."
    }
  },
  {
    "id": 7,
    "subtopic_id": 1,
    "type": "output_tracing",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `ScrollInventory` system tracks different types of magical scrolls. The `illusionScrolls` count is updated based on `abjurationScrolls`. Your task is to trace the code and determine the final counts for both types of scrolls.",
    "story_context": "The ScrollInventory system needs to track different types of magical scrolls. Your task is to trace variable reassignment and predict the outputs.",
    "challenge_data": {
      "code": "public class ScrollInventory {\n    public static void main(String[] args) {\n        int illusionScrolls = 10;\n        int abjurationScrolls = 5;\n        illusionScrolls = abjurationScrolls + 3; // Reassigns illusionScrolls\n        System.out.println(\"Illusion Scrolls: \" + illusionScrolls);\n        System.out.println(\"Abjuration Scrolls: \" + abjurationScrolls);\n    }\n}",
      "expected_output": [
        "Illusion Scrolls: 8",
        "Abjuration Scrolls: 5"
      ],
      "choices": [
        "Illusion Scrolls: 10",
        "Illusion Scrolls: 8",
        "Abjuration Scrolls: 5",
        "Abjuration Scrolls: 8",
        "Illusion Scrolls: 13"
      ],
      "explanation": "Initially, `illusionScrolls` is `10` and `abjurationScrolls` at `5`. \n1. The line `illusionScrolls = abjurationScrolls + 3;` first calculates `5 + 3`, which is `8`. It then assigns this `8` to `illusionScrolls`. So, `illusionScrolls` is now `8`.\n2. The value of `abjurationScrolls` remains `5` throughout the code.\n3. The first `System.out.println()` prints \"Illusion Scrolls: 8\".\n4. The second `System.out.println()` prints \"Abjuration Scrolls: 5\"."
    },
    "hints": {
      "1": "Pay close attention to which variable is being reassigned in the line `illusionScrolls = abjurationScrolls + 3;`.",
      "2": "The value of `abjurationScrolls` is *read* for the calculation, but its own value is not *changed* by that line.",
      "3": "The two `System.out.println()` statements will print the current values of both variables independently."
    }
  },
  {
    "id": 8,
    "subtopic_id": 1,
    "type": "output_tracing",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `TransmutationCharm` controls magical transformations. The `charmActive` status is copied to `canTransmute`, then `charmActive` is changed. Your task is to trace the code and determine the final states of both variables.",
    "story_context": "The TransmutationCharm needs to control magical transformations. Your task is to trace boolean variable copying and predict the outputs.",
    "challenge_data": {
      "code": "public class TransmutationCharm {\n    public static void main(String[] args) {\n        boolean charmActive = true;\n        boolean canTransmute = charmActive;\n        charmActive = false; // Charm becomes inactive\n        System.out.println(\"Can Transmute: \" + canTransmute);\n        System.out.println(\"Charm Active: \" + charmActive);\n    }\n}",
      "expected_output": [
        "Can Transmute: true",
        "Charm Active: false"
      ],
      "choices": [
        "Can Transmute: false",
        "Can Transmute: true",
        "Charm Active: false",
        "Charm Active: true",
        "Can Transmute: charmActive"
      ],
      "explanation": "1. `charmActive` is initialized to `true`.\n2. `boolean canTransmute = charmActive;` means `canTransmute` is assigned the current value of `charmActive`, so `canTransmute` becomes `true`.\n3. `charmActive = false;` then changes `charmActive` to `false`. This only affects `charmActive`; `canTransmute` retains its `true` value from the assignment on line 2.\n4. The first `System.out.println()` prints \"Can Transmute: true\".\n5. The second `System.out.println()` prints \"Charm Active: false\"."
    },
    "hints": {
      "1": "Variables store *copies* of values.",
      "2": "When `canTransmute = charmActive;` executes, `canTransmute` gets the *current* value of `charmActive`.",
      "3": "Subsequent changes to `charmActive` do not affect `canTransmute` because it already received its value."
    }
  },
  {
    "id": 9,
    "subtopic_id": 1,
    "type": "output_tracing",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `ProphecyVerifier` calculates arcane numbers based on mystical entities. The `mythicalBeasts` count is affected by `ancientSecrets` through multiple operations. Your task is to trace the code and determine the final `Prophecy Number` and `Ancient Secrets Remaining`.",
    "story_context": "The ProphecyVerifier needs to calculate arcane numbers through multiple operations. Your task is to trace complex calculations and predict the outputs.",
    "challenge_data": {
      "code": "public class ProphecyVerifier {\n    public static void main(String[] args) {\n        int mythicalBeasts = 7;\n        int ancientSecrets = 3;\n        mythicalBeasts = mythicalBeasts * ancientSecrets; // First calculation\n        ancientSecrets = 5; // Reassigns ancientSecrets\n        mythicalBeasts = mythicalBeasts / ancientSecrets; // Second calculation\n        System.out.println(\"Prophecy Number: \" + mythicalBeasts);\n        System.out.println(\"Ancient Secrets Remaining: \" + ancientSecrets);\n    }\n}",
      "expected_output": [
        "Prophecy Number: 4",
        "Ancient Secrets Remaining: 5"
      ],
      "choices": [
        "Prophecy Number: 21",
        "Prophecy Number: 4",
        "Ancient Secrets Remaining: 3",
        "Ancient Secrets Remaining: 5",
        "Prophecy Number: 7"
      ],
      "explanation": "1. `mythicalBeasts` starts as `7`, `ancientSecrets` as `3`. \n2. `mythicalBeasts = mythicalBeasts * ancientSecrets;` becomes `mythicalBeasts = 7 * 3;`, so `mythicalBeasts` is now `21`. \n3. `ancientSecrets = 5;` changes `ancientSecrets` to `5`. \n4. `mythicalBeasts = mythicalBeasts / ancientSecrets;` becomes `mythicalBeasts = 21 / 5;`. In integer division, `21 / 5` is `4` (the remainder `1` is discarded). So `mythicalBeasts` is now `4`. \nFinally, `System.out.println(\"Prophecy Number: \" + mythicalBeasts);` prints `Prophecy Number: 4`."
    },
    "hints": {
      "1": "Track the value of `mythicalBeasts` through each line of code.",
      "2": "Perform the calculations in the order they appear.",
      "3": "Remember that integer division (`/`) truncates the decimal part."
    }
  },
  {
    "id": 10,
    "subtopic_id": 1,
    "type": "output_tracing",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `PortalNavigator` manages magical portal destinations. The `portalDestination` is initially set, then redirected to a `backupDestination`. The `backupDestination` is then updated separately. Your task is to trace the code and determine the final `Current Portal Destination` and `Next Backup Destination`.",
    "story_context": "The PortalNavigator needs to manage magical portal destinations. Your task is to trace string variable reassignment and predict the outputs.",
    "challenge_data": {
      "code": "public class PortalNavigator {\n    public static void main(String[] args) {\n        String portalDestination = \"Ethereal Realm\";\n        String backupDestination = \"Shadowfell\";\n        portalDestination = backupDestination; // Portal redirects\n        backupDestination = \"Astral Plane\"; // Backup is updated separately\n        System.out.println(\"Current Portal Destination: \" + portalDestination);\n        System.out.println(\"Next Backup Destination: \" + backupDestination);\n    }\n}",
      "expected_output": [
        "Current Portal Destination: Shadowfell",
        "Next Backup Destination: Astral Plane"
      ],
      "choices": [
        "Current Portal Destination: Ethereal Realm",
        "Current Portal Destination: Shadowfell",
        "Next Backup Destination: Shadowfell",
        "Next Backup Destination: Astral Plane",
        "Current Portal Destination: Astral Plane"
      ],
      "explanation": "1. `portalDestination` is \"Ethereal Realm\", `backupDestination` is \"Shadowfell\".\n2. `portalDestination = backupDestination;` makes `portalDestination` take on the *current value* of `backupDestination`, which is \"Shadowfell\". So, `portalDestination` is now \"Shadowfell\".\n3. `backupDestination = \"Astral Plane\";` changes `backupDestination` to \"Astral Plane\". This change does not affect `portalDestination`, as `portalDestination` received a copy of the *value* of `backupDestination` from the previous line.\nTherefore, the output will be `Current Portal Destination: Shadowfell` and `Next Backup Destination: Astral Plane`."
    },
    "hints": {
      "1": "Follow the value assigned to `portalDestination`.",
      "2": "When `portalDestination = backupDestination;`, `portalDestination` takes on the *current value* of `backupDestination`.",
      "3": "A later change to `backupDestination` does not change what `portalDestination` already received."
    }
  },
  {
    "id": 11,
    "subtopic_id": 1,
    "type": "output_tracing",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `SpellManifestation` ritual is being performed. `rawMagic` is used to create `refinedMana`, then `rawMagic` changes. An `incantationPhrase` is combined with `refinedMana` to form a `finalIncantation`. Your task is to trace the code and determine the final `Current Raw Magic`, `Refined Mana`, and `Final Incantation` values that are printed.",
    "story_context": "The SpellManifestation ritual needs to process multiple variables through complex operations. Your task is to trace multiple variable changes and predict the outputs.",
    "challenge_data": {
      "code": "public class SpellManifestation {\n    public static void main(String[] args) {\n        int rawMagic = 100;\n        int refinedMana = 50;\n        String incantationPhrase = \"Whisper of Elements\";\n\n        refinedMana = rawMagic / 2;\n\n        String finalIncantation = incantationPhrase + \" \" + refinedMana;\n\n        rawMagic = rawMagic - 70;\n\n        int remnantEnergy = rawMagic + 5;\n\n        System.out.println(\"Current Raw Magic: \" + rawMagic);\n        System.out.println(\"Refined Mana: \" + refinedMana);\n        System.out.println(\"Final Incantation: \" + finalIncantation);\n    }\n}",
      "expected_output": [
        "Current Raw Magic: 30",
        "Refined Mana: 50",
        "Final Incantation: Whisper of Elements 50"
      ],
      "choices": [
        "Current Raw Magic: 100",
        "Refined Mana: 50",
        "Final Incantation: Whisper of Elements 50",
        "Current Raw Magic: 30",
        "Refined Mana: 30",
        "Final Incantation: Whisper of Elements 30"
      ],
      "explanation": "1. `rawMagic` starts at `100`, `refinedMana` at `50`, `incantationPhrase` at \"Whisper of Elements\".\n2. `refinedMana = rawMagic / 2;` updates `refinedMana` to `100 / 2 = 50`.\n3. `String finalIncantation = incantationPhrase + \" \" + refinedMana;` concatenates \"Whisper of Elements\", a space, and the *current value* of `refinedMana` (which is `50`), resulting in `finalIncantation` being \"Whisper of Elements 50\".\n4. `rawMagic = rawMagic - 70;` updates `rawMagic` to `100 - 70 = 30`.\n5. `int remnantEnergy = rawMagic + 5;` updates `remnantEnergy` to `30 + 5 = 35`. This variable is calculated but not printed.\n6. The first `System.out.println()` prints \"Current Raw Magic: \" followed by the final `rawMagic` value (`30`).\n7. The second `System.out.println()` prints \"Refined Mana: \" followed by the final `refinedMana` value (`50`).\n8. The third `System.out.println()` prints \"Final Incantation: \" followed by `finalIncantation` (\"Whisper of Elements 50\")."
    },
    "hints": {
      "1": "Follow each variable's value independently through every line of code, noting when it's assigned a new value.",
      "2": "Pay special attention to string concatenation (`+`) â€“ it combines the literal string with the *value* of the variable at that moment.",
      "3": "Ensure you perform calculations in the correct order, especially when a variable is used *before* its own value is changed later."
    }
  },
  {
    "id": 12,
    "subtopic_id": 1,
    "type": "output_tracing",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `RunicCompiler` processes magical runes. `runeCount` and `glyphID` are updated based on conditions involving `magicActive`. Your task is to trace the code and determine the final `Phase A`, `Phase B`, and `Phase C` outputs.",
    "story_context": "The RunicCompiler needs to process magical runes through complex conditional logic. Your task is to trace nested conditions and predict the outputs.",
    "challenge_data": {
      "code": "public class RunicCompiler {\n    public static void main(String[] args) {\n        int runeCount = 15;\n        char glyphID = 'X';\n        boolean magicActive = true;\n        \n        if (runeCount > 10) {\n            int localModifier = 5;\n            runeCount = runeCount + localModifier;\n            System.out.println(\"Phase A: \" + runeCount);\n            if (magicActive) {\n                glyphID = 'A';\n            }\n        } else {\n            runeCount = 5;\n        }\n\n        magicActive = !magicActive;\n\n        System.out.println(\"Phase B: \" + glyphID);\n        System.out.println(\"Phase C: \" + magicActive);\n    }\n}",
      "expected_output": [
        "Phase A: 20",
        "Phase B: A",
        "Phase C: false"
      ],
      "choices": [
        "Phase A: 15",
        "Phase A: 20",
        "Phase B: A",
        "Phase C: false",
        "Phase C: true",
        "Phase B: X"
      ],
      "explanation": "1. `runeCount` is `15`, `glyphID` is `'X'`, `magicActive` is `true`.\n2. `if (runeCount > 10)`: `15 > 10` is `true`.\n3. Inside the first `if` block:\n    * `int localModifier = 5;` declares a variable only visible in this block.\n    * `runeCount = runeCount + localModifier;` updates `runeCount` to `15 + 5 = 20`.\n    * `System.out.println(\"Phase A: \" + runeCount);` prints \"Phase A: 20\".\n    * `if (magicActive)`: `magicActive` is `true`.\n        * `glyphID = 'A';` updates `glyphID` to `'A'`.\n4. After the `if-else` structure, `magicActive = !magicActive;` flips `magicActive` from `true` to `false`.\n5. `System.out.println(\"Phase B: \" + glyphID);` prints \"Phase B: \" followed by the final `glyphID` (`'A'`).\n6. `System.out.println(\"Phase C: \" + magicActive);` prints \"Phase C: \" followed by the final `magicActive` value (`false`)."
    },
    "hints": {
      "1": "Carefully trace `runeCount` and `glyphID` through the `if` blocks, noting when each variable is modified.",
      "2": "Remember that `localModifier` only exists within its specific `if` block.",
      "3": "The `!` operator flips the boolean value."
    }
  },
  {
    "id": 13,
    "subtopic_id": 1,
    "type": "output_tracing",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `ArtifactAttunement` ritual determines the status of a magical artifact. `attunementScore` is calculated, then `activeGlyph` and `statusMessage` are conditionally updated. Your task is to trace the code and determine the `Final Score`, `Glyph Status`, and `Ritual Progress` outputs.",
    "story_context": "The ArtifactAttunement ritual needs to determine artifact status through complex calculations. Your task is to trace multiple operations and predict the outputs.",
    "challenge_data": {
      "code": "public class ArtifactAttunement {\n    public static void main(String[] args) {\n        double currentPower = 75.5;\n        int crystalPurity = 8;\n        String enchantmentType = \"Arcane\";\n        boolean activeGlyph = false;\n\n        double attunementScore = currentPower * crystalPurity / 10.0;\n\n        if (attunementScore > 60 && enchantmentType.equals(\"Arcane\")) {\n            activeGlyph = true;\n        }\n\n        String statusMessage = \"Attunement: \" + (activeGlyph ? \"Complete\" : \"Pending\");\n\n        if (activeGlyph) {\n            statusMessage = \"Attunement: Perfect\";\n        }\n        \n        int ritualProgress = (int) (attunementScore + crystalPurity);\n\n        System.out.println(\"Final Score: \" + attunementScore);\n        System.out.println(\"Glyph Status: \" + activeGlyph);\n        System.out.println(\"Ritual Progress: \" + ritualProgress + \"%\");\n    }\n}",
      "expected_output": [
        "Final Score: 60.4",
        "Glyph Status: true",
        "Ritual Progress: 68%"
      ],
      "choices": [
        "Final Score: 60.4",
        "Glyph Status: true",
        "Ritual Progress: 68%",
        "Final Score: 75.5",
        "Ritual Progress: 68.4%",
        "Glyph Status: false"
      ],
      "explanation": "1. Variables initialized: `currentPower = 75.5`, `crystalPurity = 8`, `enchantmentType = \"Arcane\"`, `activeGlyph = false`.\n2. `attunementScore = currentPower * crystalPurity / 10.0;` calculates `75.5 * 8 = 604.0`, then `604.0 / 10.0 = 60.4`. So, `attunementScore` is `60.4`.\n3. `if (attunementScore > 60 && enchantmentType.equals(\"Arcane\"))`: `60.4 > 60` is `true`, AND `enchantmentType.equals(\"Arcane\")` is `true`. The condition is `true`.\n    * `activeGlyph = true;` updates `activeGlyph` to `true`.\n4. `String statusMessage = \"Attunement: \" + (activeGlyph ? \"Complete\" : \"Pending\");` evaluates `activeGlyph` (which is `true`), so `statusMessage` becomes \"Attunement: Complete\".\n5. `if (activeGlyph)`: This condition (`true`) is met.\n    * `statusMessage = \"Attunement: Perfect\";` updates `statusMessage` to \"Attunement: Perfect\".\n6. `int ritualProgress = (int) (attunementScore + crystalPurity);` calculates `60.4 + 8 = 68.4`. Casting to `int` truncates the decimal, so `ritualProgress` becomes `68`.\n7. **Output 1**: `System.out.println(\"Final Score: \" + attunementScore);` prints \"Final Score: 60.4\".\n8. **Output 2**: `System.out.println(\"Glyph Status: \" + activeGlyph);` prints \"Glyph Status: true\".\n9. **Output 3**: `System.out.println(\"Ritual Progress: \" + ritualProgress + \"%\");` prints \"Ritual Progress: 68%\"."
    },
    "hints": {
      "1": "Calculate `attunementScore` precisely, noting the use of `10.0` for floating-point division.",
      "2": "Carefully evaluate the `if` condition involving `attunementScore` and `enchantmentType` to determine `activeGlyph`'s state.",
      "3": "Pay attention to the final values of all three variables being printed: `attunementScore`, `activeGlyph`, and `ritualProgress`."
    }
  },
  {
    "id": 14,
    "subtopic_id": 1,
    "type": "output_tracing",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `ScrollCataloger` organizes magical scrolls by `catalogID` and `volumeCount`, tracking if they are `damaged` or have a `legendaryMark`. Your task is to trace the code and determine the final `Catalog ID`, `Total Volume`, and `Is Collection Rare` outputs.",
    "story_context": "The ScrollCataloger needs to organize magical scrolls with complex conditional logic. Your task is to trace nested conditions and predict the outputs.",
    "challenge_data": {
      "code": "public class ScrollCataloger {\n    public static void main(String[] args) {\n        String baseID = \"ARC-\";\n        int volumeCount = 20;\n        boolean isDamaged = false;\n        boolean hasLegendaryMark = true;\n\n        String catalogID = baseID + volumeCount;\n\n        if (isDamaged || hasLegendaryMark) {\n            boolean rareScroll = hasLegendaryMark;\n            if (volumeCount > 15 && rareScroll) {\n                catalogID = catalogID + \"-LEGEND\";\n            }\n            System.out.println(\"Catalog ID: \" + catalogID);\n        } else {\n            System.out.println(\"Regular Scroll.\");\n        }\n\n        volumeCount = volumeCount * 2;\n        boolean isRare = hasLegendaryMark && !isDamaged;\n\n        System.out.println(\"Total Volume: \" + volumeCount);\n        System.out.println(\"Is Collection Rare: \" + isRare);\n    }\n}",
      "expected_output": [
        "Catalog ID: ARC-20-LEGEND",
        "Total Volume: 40",
        "Is Collection Rare: true"
      ],
      "choices": [
        "Catalog ID: ARC-20",
        "Catalog ID: ARC-20-LEGEND",
        "Total Volume: 40",
        "Is Collection Rare: true",
        "Is Collection Rare: false",
        "Total Volume: 20"
      ],
      "explanation": "1. Variables initialized: `baseID = \"ARC-\"`, `volumeCount = 20`, `isDamaged = false`, `hasLegendaryMark = true`.\n2. `catalogID = baseID + volumeCount;` sets `catalogID` to \"ARC-20\".\n3. `if (isDamaged || hasLegendaryMark)`: `false || true` evaluates to `true`. So the block is entered.\n    * `boolean rareScroll = hasLegendaryMark;` sets `rareScroll` to `true`.\n    * `if (volumeCount > 15 && rareScroll)`: `20 > 15` is `true`, AND `rareScroll` (`true`) is `true`. The condition is `true`.\n        * `catalogID = catalogID + \"-LEGEND\";` appends \"-LEGEND\", making `catalogID` \"ARC-20-LEGEND\".\n    * `System.out.println(\"Catalog ID: \" + catalogID);` prints \"Catalog ID: ARC-20-LEGEND\".\n4. The `else` block for the first `if` is skipped.\n5. `volumeCount = volumeCount * 2;` updates `volumeCount` to `20 * 2 = 40`.\n6. `boolean isRare = hasLegendaryMark && !isDamaged;` evaluates `true && !false` which is `true && true`, so `isRare` becomes `true`.\n7. `System.out.println(\"Total Volume: \" + volumeCount);\n` prints \"Total Volume: 40\".\n8. `System.out.println(\"Is Collection Rare: \" + isRare);` prints \"Is Collection Rare: true\"."
    },
    "hints": {
      "1": "Trace `catalogID` carefully; it's initialized and then potentially modified inside an `if` block.",
      "2": "Follow `volumeCount` through its initial value and subsequent calculation.",
      "3": "Determine `isRare` by evaluating the final states of `hasLegendaryMark` and `isDamaged` and their logical `&&` operation."
    }
  },
  {
    "id": 15,
    "subtopic_id": 1,
    "type": "output_tracing",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "An `ElementalConduit` manages magical `flowRate` and `conduitState`. A `stabilizerEngaged` flag is conditionally set, and `flowRate` is adjusted. Your task is to trace the code and determine the `Final Flow Rate`, `Conduit State`, and `Stabilizer Engaged` status.",
    "story_context": "The ElementalConduit needs to manage magical flow rates through complex conditional logic. Your task is to trace nested conditions and predict the outputs.",
    "challenge_data": {
      "code": "public class ElementalConduit {\n    public static void main(String[] args) {\n        int flowRate = 200;\n        String conduitState = \"Open\";\n        boolean stabilizerEngaged = false;\n        \n        if (flowRate > 150) {\n            flowRate = flowRate / 2;\n            if (conduitState.equals(\"Open\")) {\n                stabilizerEngaged = true;\n                conduitState = \"Stabilized\";\n            } else {\n                stabilizerEngaged = false;\n            }\n        } else {\n            flowRate = flowRate + 50;\n        }\n\n        conduitState = conduitState + \"!\";\n\n        if (stabilizerEngaged) {\n            flowRate = flowRate + 50;\n        }\n\n        System.out.println(\"Final Flow Rate: \" + flowRate);\n        System.out.println(\"Conduit State: \" + conduitState);\n        System.out.println(\"Stabilizer Engaged: \" + stabilizerEngaged);\n    }\n}",
      "expected_output": [
        "Final Flow Rate: 150",
        "Conduit State: Stabilized!",
        "Stabilizer Engaged: true"
      ],
      "choices": [
        "Final Flow Rate: 100",
        "Stabilizer Engaged: false",
        "Final Flow Rate: 150",
        "Conduit State: Stabilized!",
        "Stabilizer Engaged: true",
        "Conduit State: Open!"
      ],
      "explanation": "1. Variables initialized: `flowRate = 200`, `conduitState = \"Open\"`, `stabilizerEngaged = false`.\n2. `if (flowRate > 150)`: `200 > 150` is `true`. Block is entered.\n    * `flowRate = flowRate / 2;` updates `flowRate` to `200 / 2 = 100`.\n    * `if (conduitState.equals(\"Open\"))`: `\"Open\".equals(\"Open\")` is `true`. Nested block is entered.\n        * `stabilizerEngaged = true;` updates `stabilizerEngaged` to `true`.\n        * `conduitState = \"Stabilized\";` updates `conduitState` to \"Stabilized\".\n3. After the initial `if-else` block:\n    * `conduitState = conduitState + \"!\";` concatenates \"!\" to `conduitState`, making it \"Stabilized!\".\n4. `if (stabilizerEngaged)`: `stabilizerEngaged` is `true`. Block is entered.\n    * `flowRate = flowRate + 50;` updates `flowRate` to `100 + 50 = 150`.\n5. **Output 1**: `System.out.println(\"Final Flow Rate: \" + flowRate);` prints \"Final Flow Rate: 150\".\n6. **Output 2**: `System.out.println(\"Conduit State: \" + conduitState);` prints \"Conduit State: Stabilized!\".\n7. **Output 3**: `System.out.println(\"Stabilizer Engaged: \" + stabilizerEngaged);` prints \"Stabilizer Engaged: true\"."
    },
    "hints": {
      "1": "Carefully follow `flowRate` through its initial calculation in the first `if` and its final adjustment based on `stabilizerEngaged`.",
      "2": "Track `conduitState` through both its assignment within the nested `if` and its final concatenation.",
      "3": "Determine the final state of `stabilizerEngaged` by evaluating its assignment within the nested `if` block."
    }
  },
  {
    "id": 16,
    "subtopic_id": 1,
    "type": "code_fixer",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `ManaCounter` is being used to track magical crystals. However, the code attempts to print the `manaCrystals` variable before it has been declared, causing a compilation error. Fix the code to ensure `manaCrystals` is declared before it's used.",
    "story_context": "The ManaCounter system is malfunctioning. Restore the system by fixing all code errors so the magical crystals can be properly tracked.",
    "challenge_data": {
      "initial_code": "public class ManaCounter {\n    public static void main(String[] args) {\n        System.out.println(\"Mana Crystals: \" + manaCrystals);\n        int manaCrystals = 10;\n    }\n}",
      "expected_output": [
        "Mana Crystals: 10"
      ],
      "solution_code": "public class ManaCounter {\n    public static void main(String[] args) {\n        int manaCrystals = 10;\n        System.out.println(\"Mana Crystals: \" + manaCrystals);\n    }\n}",
      "errors": [
        {
          "id": "error_1",
          "line": 3,
          "type": "variable_used_before_declaration",
          "description": "Variable manaCrystals is used before declaration",
          "fix": "Move declaration before usage"
        }
      ],
      "number_of_errors": 1
    },
    "hints": {
      "1": "In Java, a variable must be introduced before it can be used.",
      "2": "Think about the order of operations: declaration first, then usage.",
      "3": "Imagine trying to grab something that hasn't been placed on a shelf yet."
    }
  },
  {
    "id": 17,
    "subtopic_id": 1,
    "type": "code_fixer",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `PotionMixer` tracks the `PotionStrength` of a brew. However, the variable name `PotionStrength` has inconsistent casing, which can cause issues in Java. Fix the code to follow Java's camelCase naming convention for variables.",
    "story_context": "The PotionMixer system has inconsistent variable naming. Restore proper Java conventions by fixing the variable casing issues.",
    "challenge_data": {
      "initial_code": "public class PotionMixer {\n    public static void main(String[] args) {\n        int PotionStrength = 50;\n        System.out.println(\"Potion Strength: \" + PotionStrength);\n    }\n}",
      "expected_output": [
        "Potion Strength: 50"
      ],
      "solution_code": "public class PotionMixer {\n    public static void main(String[] args) {\n        int potionStrength = 50;\n        System.out.println(\"Potion Strength: \" + potionStrength);\n    }\n}",
      "errors": [
        {
          "id": "error_1",
          "line": 3,
          "type": "naming_convention_violation",
          "description": "Variable name PotionStrength violates camelCase convention",
          "fix": "Change to potionStrength (lowercase first letter)"
        }
      ],
      "number_of_errors": 1
    },
    "hints": {
      "1": "Java is case-sensitive, meaning `PotionStrength` is different from `potionStrength`.",
      "2": "Follow Java's common naming convention for variables (camelCase).",
      "3": "Ensure the variable name is consistent everywhere it's used."
    }
  },
  {
    "id": 18,
    "subtopic_id": 1,
    "type": "code_fixer",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `GolemController` manages the number of active `golemCount`. The code has a syntax error, as a statement is missing its terminator. Fix the code to ensure the `golemCount` variable is correctly declared.",
    "story_context": "The GolemController system has a syntax error. Restore proper Java syntax by adding the missing statement terminator.",
    "challenge_data": {
      "initial_code": "public class GolemController {\n    public static void main(String[] args) {\n        int golemCount = 3\n        System.out.println(\"Active Golems: \" + golemCount);\n    }\n}",
      "expected_output": [
        "Active Golems: 3"
      ],
      "solution_code": "public class GolemController {\n    public static void main(String[] args) {\n        int golemCount = 3;\n        System.out.println(\"Active Golems: \" + golemCount);\n    }\n}",
      "errors": [
        {
          "id": "error_1",
          "line": 3,
          "type": "missing_semicolon",
          "description": "Missing semicolon at end of statement",
          "fix": "Add semicolon after variable declaration"
        }
      ],
      "number_of_errors": 1
    },
    "hints": {
      "1": "Most statements in Java need a specific character to mark their end.",
      "2": "Think of it as a period at the end of a sentence.",
      "3": "Look for where one statement transitions to the next."
    }
  },
  {
    "id": 19,
    "subtopic_id": 1,
    "type": "code_fixer",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "An `EssenceCollector` attempts to track `magicEssence`. However, the variable `magicEssence` is declared twice in the same scope, which is not allowed in Java. Fix the code to correctly update the `magicEssence` variable.",
    "story_context": "The EssenceCollector system has duplicate variable declarations. Restore proper Java variable handling by fixing the duplicate declaration issue.",
    "challenge_data": {
      "initial_code": "public class EssenceCollector {\n    public static void main(String[] args) {\n        int magicEssence = 20;\n        int magicEssence = 30; // Problem here: duplicate declaration\n        System.out.println(\"Collected Essence: \" + magicEssence);\n    }\n}",
      "expected_output": [
        "Collected Essence: 30"
      ],
      "solution_code": "public class EssenceCollector {\n    public static void main(String[] args) {\n        int magicEssence = 20;\n        magicEssence = 30; // Proper reassignment\n        System.out.println(\"Collected Essence: \" + magicEssence);\n    }\n}",
      "errors": [
        {
          "id": "error_1",
          "line": 4,
          "type": "duplicate_variable_declaration",
          "description": "Variable magicEssence is declared twice in the same scope",
          "fix": "Remove the second int keyword to make it a reassignment"
        }
      ],
      "number_of_errors": 1
    },
    "hints": {
      "1": "A variable only needs to be declared once in its scope.",
      "2": "If you want to change a variable's value after its initial declaration, you just assign a new value.",
      "3": "Look for the repeated use of the `int` keyword for the same variable."
    }
  },
  {
    "id": 20,
    "subtopic_id": 1,
    "type": "code_fixer",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `CharmActivator` sets the `isActivated` status. However, the `isActivated` variable is used before it is initialized, causing a compilation error. Fix the code to initialize `isActivated` before it's accessed.",
    "story_context": "The CharmActivator system has an uninitialized variable. Restore proper Java variable initialization by fixing the uninitialized variable issue.",
    "challenge_data": {
      "initial_code": "public class CharmActivator {\n    public static void main(String[] args) {\n        boolean isActivated;\n        System.out.println(\"Charm Status: \" + isActivated);\n    }\n}",
      "expected_output": [
        "Charm Status: false"
      ],
      "solution_code": "public class CharmActivator {\n    public static void main(String[] args) {\n        boolean isActivated = false;\n        System.out.println(\"Charm Status: \" + isActivated);\n    }\n}",
      "errors": [
        {
          "id": "error_1",
          "line": 3,
          "type": "uninitialized_variable",
          "description": "Local variable isActivated is used before initialization",
          "fix": "Initialize the variable with a value"
        }
      ],
      "number_of_errors": 1
    },
    "hints": {
      "1": "Local variables in Java don't get a default value automatically.",
      "2": "Before you use a variable in a calculation or print it, it needs to hold something.",
      "3": "Consider what a common starting state for a boolean might be if not explicitly known."
    }
  },
  {
    "id": 21,
    "subtopic_id": 1,
    "type": "code_fixer",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A CharmActivator sets the activation status. However, the isActivated variable is used before it is initialized, causing a compilation error. Fix the code to initialize isActivated before it's accessed.",
    "story_context": "The CharmActivator system has an uninitialized variable. Restore proper Java variable initialization by fixing the uninitialized variable issue.",
    "challenge_data": {
      "initial_code": "public class CharmActivator {\n    public static void main(String[] args) {\n        boolean isActivated;\n        System.out.println(\"Charm Status: \" + isActivated);\n    }\n}",
      "expected_output": [
        "Charm Status: false"
      ],
      "solution_code": "public class CharmActivator {\n    public static void main(String[] args) {\n        boolean isActivated = false;\n        System.out.println(\"Charm Status: \" + isActivated);\n    }\n}",
      "errors": [
        {
          "id": "error_1",
          "line": 3,
          "type": "uninitialized_variable",
          "description": "Local variable isActivated is used before initialization",
          "fix": "Initialize the variable with a value"
        }
      ],
      "number_of_errors": 1
    },
    "hints": {
      "1": "Local variables in Java don't get a default value automatically.",
      "2": "Before you use a variable in a calculation or print it, it needs to hold something.",
      "3": "Consider what a common starting state for a boolean might be if not explicitly known."
    }
  },
  {
    "id": 22,
    "subtopic_id": 1,
    "type": "code_fixer",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "An `UltimateSpellCaster` is preparing to cast a powerful spell. The `ultimateSpellName` variable is assigned conditionally, but Java's compiler is being conservative about its initialization, causing an error. Fix the code to ensure `ultimateSpellName` is always initialized.",
    "story_context": "The UltimateSpellCaster system has conditional variable initialization. Restore proper Java variable handling by ensuring the variable is always initialized.",
    "challenge_data": {
      "initial_code": "public class UltimateSpellCaster {\n    public static void main(String[] args) {\n        String ultimateSpellName;\n        if (true) {\n            ultimateSpellName = \"Oblivion Gate\";\n        }\n        System.out.println(\"Casting: \" + ultimateSpellName);\n    }\n}",
      "expected_output": [
        "Casting: Oblivion Gate"
      ],
      "solution_code": "public class UltimateSpellCaster {\n    public static void main(String[] args) {\n        String ultimateSpellName = null;\n        if (true) {\n            ultimateSpellName = \"Oblivion Gate\";\n        }\n        System.out.println(\"Casting: \" + ultimateSpellName);\n    }\n}",
      "errors": [
        {
          "id": "error_1",
          "line": 3,
          "type": "conditional_initialization",
          "description": "Variable ultimateSpellName may not be initialized in all code paths",
          "fix": "Initialize the variable with a default value"
        }
      ],
      "number_of_errors": 1
    },
    "hints": {
      "1": "Variables declared inside `if` blocks or loops are *local* to those blocks.",
      "2": "Java needs a guarantee that a local variable *will* definitely be assigned a value before it's used, regardless of conditional paths.",
      "3": "Consider what initial value `ultimateSpellName` holds if the `if` block hypothetically didn't run."
    }
  },
  {
    "id": 23,
    "subtopic_id": 1,
    "type": "code_fixer",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "An `ElixirDensityCalculator` measures the density of a magical elixir. The `elixirDensity` variable is declared as a `float`, but the literal value assigned to it is treated as a `double` by default, causing a potential loss of precision. Fix the code to ensure the `float` variable correctly stores the decimal value.",
    "story_context": "The ElixirDensityCalculator system has a type precision issue. Restore proper Java type handling by fixing the floating-point precision problem.",
    "challenge_data": {
      "initial_code": "public class ElixirDensityCalculator {\n    public static void main(String[] args) {\n        float elixirDensity = 3.1415926535;\n        System.out.println(\"Elixir Density: \" + elixirDensity);\n    }\n}",
      "expected_output": [
        "Elixir Density: 3.1415926535"
      ],
      "solution_code": "public class ElixirDensityCalculator {\n    public static void main(String[] args) {\n        double elixirDensity = 3.1415926535;\n        System.out.println(\"Elixir Density: \" + elixirDensity);\n    }\n}",
      "errors": [
        {
          "id": "error_1",
          "line": 3,
          "type": "type_precision_mismatch",
          "description": "Float variable assigned double literal without explicit casting",
          "fix": "Change float to double for better precision"
        }
      ],
      "number_of_errors": 1
    },
    "hints": {
      "1": "Not all floating-point data types offer the same level of decimal accuracy.",
      "2": "Consider which primitive type in Java is specifically designed for *double precision*.",
      "3": "The value `3.1415926535` itself is by default interpreted as a specific floating-point type."
    }
  },
  {
    "id": 24,
    "subtopic_id": 1,
    "type": "code_fixer",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `PortalConfigurator` attempts to set `destinationCoordinates` for a magical portal. However, the value assigned is a string, while the variable is declared as a `char`, leading to a type mismatch. Fix the code to correctly store the portal's destination.",
    "story_context": "The PortalConfigurator system has a type mismatch. Restore proper Java type handling by fixing the data type assignment issue.",
    "challenge_data": {
      "initial_code": "public class PortalConfigurator {\n    public static void main(String[] args) {\n        char destinationCoordinates = \"XYZ-789\";\n        System.out.println(\"Portal Destination: \" + destinationCoordinates);\n    }\n}",
      "expected_output": [
        "Portal Destination: XYZ-789"
      ],
        "solution_code": "public class PortalConfigurator {\n    public static void main(String[] args) {\n        String destinationCoordinates = \"XYZ-789\";\n        System.out.println(\"Portal Destination: \" + destinationCoordinates);\n    }\n}",
        "errors": [
        {
          "id": "error_1",
          "line": 3,
          "type": "type_mismatch",
          "description": "Cannot assign String literal to char variable",
          "fix": "Change char to String data type"
        }
      ],
      "number_of_errors": 1
    },
    "hints": {
      "1": "Characters are single symbols; sequences of characters form a different type.",
      "2": "Think about the difference between single quotes (`' '`) and double quotes (`\" \"`).",
      "3": "Recall the non-primitive data type commonly used for text in Java."
    }
  },
  {
    "id": 25,
    "subtopic_id": 1,
    "type": "code_fixer",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "An `OrbTally` counts `arcaneOrbs`. However, a decimal value is assigned to an `int` variable, causing a compilation error due to potential data loss. Fix the code to correctly store the count of `arcaneOrbs`.",
    "story_context": "The OrbTally system has a type conversion issue. Restore proper Java type handling by fixing the integer-decimal assignment problem.",
    "challenge_data": {
      "initial_code": "public class OrbTally {\n    public static void main(String[] args) {\n        int arcaneOrbs = 7.5;\n        System.out.println(\"Arcane Orbs: \" + arcaneOrbs);\n    }\n}",
      "expected_output": [
        "Arcane Orbs: 7"
      ],
      "solution_code": "public class OrbTally {\n    public static void main(String[] args) {\n        int arcaneOrbs = 7;\n        System.out.println(\"Arcane Orbs: \" + arcaneOrbs);\n    }\n}",
      "errors": [
        {
          "id": "error_1",
          "line": 3,
          "type": "type_conversion_error",
          "description": "Cannot assign decimal value to int variable",
          "fix": "Change to whole number or use double type"
        }
      ],
      "number_of_errors": 1
    },
    "hints": {
      "1": "Integer types can only store whole numbers.",
      "2": "Decimal numbers require a floating-point data type.",
      "3": "Consider whether the intent is to have a whole number count or a precise decimal value."
    }
  },
  {
    "id": 26,
    "subtopic_id": 1,
    "type": "code_fixer",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `GolemGuardian` is designed to monitor and report its status. However, the `guardianStatus` variable is declared within an `if` block, making it inaccessible outside, leading to a compilation error. Fix the code to ensure `guardianStatus` can be printed after the conditional check.",
    "story_context": "The GolemGuardian system has a scope issue. Restore proper Java variable scope by fixing the variable accessibility problem.",
    "challenge_data": {
      "initial_code": "public class GolemGuardian {\n    public static void main(String[] args) {\n        if (true) {\n            String guardianStatus = \"Awake\";\n        }\n        System.out.println(\"Guardian State: \" + guardianStatus);\n    }\n}",
      "expected_output": [
        "Guardian State: Awake"
      ],
      "solution_code": "public class GolemGuardian {\n    public static void main(String[] args) {\n        String guardianStatus;\n        if (true) {\n            guardianStatus = \"Awake\";\n        }\n        System.out.println(\"Guardian State: \" + guardianStatus);\n    }\n}",
      "errors": [
        {
          "id": "error_1",
          "line": 4,
          "type": "scope_error",
          "description": "Variable guardianStatus declared inside if block is not accessible outside",
          "fix": "Move variable declaration outside the if block"
        }
      ],
      "number_of_errors": 1
    },
    "hints": {
      "1": "A variable's \"scope\" defines where it can be seen and used in your code.",
      "2": "Variables declared inside curly braces `{}` are generally only visible within those braces.",
      "3": "To make a variable accessible in a larger block, it needs to be declared in that larger block."
    }
  },
  {
    "id": 27,
    "subtopic_id": 1,
    "type": "code_fixer",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `PotionRegistry` attempts to extract an `essenceValue` from a `masterPotion` which is a `String` object. However, directly casting a `String` to an `int` is not allowed in Java, causing a compilation error. Fix the code to assign a numerical `essenceValue` correctly.",
    "story_context": "The PotionRegistry system has an invalid type casting issue. Restore proper Java type handling by fixing the invalid casting operation.",
    "challenge_data": {
      "initial_code": "public class PotionRegistry {\n    public static void main(String[] args) {\n        Object masterPotion = \"Elixir of Life\";\n        int essenceValue = (int) masterPotion;\n        System.out.println(\"Potion Essence: \" + essenceValue);\n    }\n}",
      "expected_output": [
        "Potion Essence: 75"
      ],
      "solution_code": "public class PotionRegistry {\n    public static void main(String[] args) {\n        Object masterPotion = \"Elixir of Life\";\n        int essenceValue = 75;\n        System.out.println(\"Potion Essence: \" + essenceValue);\n    }\n}",
      "errors": [
        {
          "id": "error_1",
          "line": 4,
          "type": "invalid_type_cast",
          "description": "Cannot cast String object to int primitive type",
          "fix": "Assign numerical value directly instead of casting"
        }
      ],
      "number_of_errors": 1
    },
    "hints": {
      "1": "Remember that `Object` is a very general type; it doesn't mean you can arbitrarily convert its contained value to any other type.",
      "2": "Strings represent text, not raw numbers, even if they *look* like numbers. Direct casting from `String` to `int` is not allowed.",
      "3": "Consider the actual type of data `essenceValue` is meant to hold and assign it directly, or use parsing if the intent was to extract a number from a string."
    }
  },
  {
    "id": 28,
    "subtopic_id": 1,
    "type": "code_fixer",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `ScrollArchive` manages `ancientScrolls`. Inside an `if` block, a new variable with the same name `ancientScrolls` is declared, unintentionally shadowing the outer variable and preventing its update. Fix the code to ensure the outer `ancientScrolls` variable is correctly modified.",
    "story_context": "The ScrollArchive needs to manage ancient scrolls. Your task is to fix the variable shadowing issue.",
    "challenge_data": {
      "initial_code": "public class ScrollArchive {\n    public static void main(String[] args) {\n        int ancientScrolls = 50;\n        \n        if (ancientScrolls > 40) {\n            int ancientScrolls = 20;\n            System.out.println(\"Vault Scrolls: \" + ancientScrolls);\n        }\n        System.out.println(\"Total Ancient Scrolls: \" + ancientScrolls);\n    }\n}",
      "expected_output": [
        "Vault Scrolls: 20",
        "Total Ancient Scrolls: 20"
      ],
      "solution_code": "public class ScrollArchive {\n    public static void main(String[] args) {\n        int ancientScrolls = 50;\n        \n        if (ancientScrolls > 40) {\n            ancientScrolls = 20;\n            System.out.println(\"Vault Scrolls: \" + ancientScrolls);\n        }\n        System.out.println(\"Total Ancient Scrolls: \" + ancientScrolls);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 6,
          "type": "variable_shadowing",
          "description": "Declaring a new variable that shadows the outer variable",
          "fix": "Remove 'int' keyword: ancientScrolls = 20;"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The error is a classic case of **variable shadowing**. Inside the `if` block, `int ancientScrolls = 20;` declares a *new*, local variable also named `ancientScrolls`, which *shadows* (hides) the outer `ancientScrolls` variable within that specific `if` block. Therefore, the outer `ancientScrolls` (which remained `50`) was never updated. The fix involves removing the `int` keyword from the line inside the `if` block, turning it into a simple reassignment (`ancientScrolls = 20;`) that correctly modifies the outer variable."
    },
    "hints": {
      "1": "Variables declared inside a block (like an `if` statement's curly braces) are distinct from variables with the same name declared in an outer block.",
      "2": "If you want to modify an existing variable from an outer scope, you should not redeclare it with the data type keyword (`int`, `String`, etc.).",
      "3": "Observe where the `int` keyword is used for `ancientScrolls` inside the `if` block."
    }
  },
  {
    "id": 29,
    "subtopic_id": 1,
    "type": "code_fixer",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `FateInscriber` records a `fateMessage` that is intended to be unchangeable after its initial inscription. However, the code attempts to reassign `fateMessage`, which should not be allowed for a constant. Fix the code to declare `fateMessage` as a constant and prevent its reassignment.",
    "story_context": "The FateInscriber's prophecy must remain immutable once inscribed. Your task is to enforce this by making the fateMessage constant.",
    "challenge_data": {
      "initial_code": "public class FateInscriber {\n    public static void main(String[] args) {\n        String fateMessage = \"Prophecy of Dawn\";\n        System.out.println(\"Initial Fate: \" + fateMessage);\n        \n        fateMessage = \"Prophecy of Dusk\";\n        System.out.println(\"Altered Fate: \" + fateMessage);\n    }\n}",
      "expected_output": [
        "Initial Fate: Prophecy of Dawn",
        "Altered Fate (unchanged): Prophecy of Dawn"
      ],
      "solution_code": "public class FateInscriber {\n    public static void main(String[] args) {\n        final String fateMessage = \"Prophecy of Dawn\";\n        System.out.println(\"Initial Fate: \" + fateMessage);\n        \n        // fateMessage = \"Prophecy of Dusk\"; // This line would cause compilation error\n        System.out.println(\"Altered Fate (unchanged): \" + fateMessage);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 3,
          "type": "variable_declaration",
          "description": "Missing 'final' keyword to make fateMessage constant",
          "fix": "Add 'final' keyword: final String fateMessage = \"Prophecy of Dawn\";"
        },
        {
          "id": 2,
          "line": 6,
          "line_end": 6,
          "type": "assignment",
          "description": "Attempting to reassign a constant variable",
          "fix": "Comment out or remove the reassignment line"
        }
      ],
      "number_of_errors": 2,
      "explanation": "The problem implies that `fateMessage` *should* be a constant, but `String fateMessage = \"Prophecy of Dawn\";` only declares a regular variable, which can be reassigned. The `final` keyword in Java is used to declare a constant; once a `final` variable is initialized, its value cannot be changed. The fix involves adding the `final` keyword to the declaration: `final String fateMessage = \"Prophecy of Dawn\";`. To achieve the desired immutable behavior, the line attempting to reassign `fateMessage` must then be removed or commented out, as it would cause a compilation error with `final`. The expected output reflects the `final` value not changing."
    },
    "hints": {
      "1": "There's a special keyword in Java to ensure a variable's value cannot be changed after initialization.",
      "2": "Think about variables whose values are fixed or immutable.",
      "3": "The goal is to enforce \"one time assignment\" for `fateMessage`."
    }
  },
  {
    "id": 30,
    "subtopic_id": 1,
    "type": "code_fixer",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "An `EnergyManifestation` ritual calculates `manifestedEnergy` from `initialCharge` and `energyFactor`. However, the code incorrectly casts `energyFactor` prematurely, leading to a loss of decimal precision in the `manifestedEnergy` calculation. Fix the code to preserve floating-point precision in the calculation.",
    "story_context": "The EnergyManifestation ritual requires precise calculations. Your task is to fix the type casting that's causing loss of precision.",
    "challenge_data": {
      "initial_code": "public class EnergyManifestation {\n    public static void main(String[] args) {\n        int initialCharge = 7;\n        double energyFactor = 2.5;\n        int manifestedEnergy = initialCharge * (int)energyFactor;\n        System.out.println(\"Manifested Energy: \" + manifestedEnergy);\n    }\n}",
      "expected_output": [
        "Manifested Energy: 17.5"
      ],
      "solution_code": "public class EnergyManifestation {\n    public static void main(String[] args) {\n        int initialCharge = 7;\n        double energyFactor = 2.5;\n        double manifestedEnergy = initialCharge * energyFactor;\n        System.out.println(\"Manifested Energy: \" + manifestedEnergy);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 5,
          "type": "type_casting",
          "description": "Premature casting of energyFactor to int causes loss of precision",
          "fix": "Remove the (int) cast: double manifestedEnergy = initialCharge * energyFactor;"
        },
        {
          "id": 2,
          "line": 5,
          "type": "variable_declaration",
          "description": "manifestedEnergy should be double to preserve precision",
          "fix": "Change int to double: double manifestedEnergy = initialCharge * energyFactor;"
        }
      ],
      "number_of_errors": 2,
      "explanation": "The original code explicitly cast `energyFactor` to `int` (`(int)energyFactor`), which truncated `2.5` to `2`. Then, `initialCharge * 2` resulted in `14`, an integer. Even if `manifestedEnergy` was a `double`, the damage to precision was already done by the cast. To retain precision, the multiplication should happen between at least one floating-point number, and the result should be stored in a floating-point type (`double` or `float`). By removing the unnecessary cast and declaring `manifestedEnergy` as `double`, Java's type promotion rules ensure the calculation `7 * 2.5` yields `17.5`, which is then correctly stored."
    },
    "hints": {
      "1": "Integer arithmetic (even with a cast to integer) will always produce an integer result, losing decimals.",
      "2": "To retain decimal precision in a calculation involving different numeric types, the result must be stored in a type capable of holding decimals.",
      "3": "Consider Java's rules for *type promotion* in arithmetic operations."
    }
  },
  {
    "id": 31,
    "subtopic_id": 1,
    "type": "code_completion",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `GlyphIndexer` system generates unique IDs for magical glyphs by combining a `prefix` with a `code`. The `glyphIdentifier` variable is intended to store this combined text. Complete the declaration of `glyphIdentifier` to correctly store the combined text.",
    "story_context": "The GlyphIndexer needs to create unique identifiers for magical glyphs. Your task is to complete the variable declaration.",
    "challenge_data": {
      "initial_code": "public class GlyphIndexer {\n    public static void main(String[] args) {\n        int code = 42;\n        String prefix = \"Code \";\n        ??? glyphIdentifier = prefix + code;\n        System.out.println(\"Glyph ID: \" + glyphIdentifier);\n    }\n}",
      "expected_output": [
        "Glyph ID: Code 42"
      ],
      "solution_code": "public class GlyphIndexer {\n    public static void main(String[] args) {\n        int code = 42;\n        String prefix = \"Code \";\n        String glyphIdentifier = prefix + code;\n        System.out.println(\"Glyph ID: \" + glyphIdentifier);\n    }\n}",
      "choices": [
        "char",
        "int",
        "double",
        "String"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 4,
          "type": "variable_declaration",
          "description": "Variable type declaration for glyphIdentifier",
          "correct_answer": "String",
          "explanation": "The result of `prefix + code` (string concatenation) is a `String`. Therefore, `glyphIdentifier` must be declared as a `String` type to correctly store this combined textual value."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": "When a `String` is combined with a number using `+`, the result is always a `String`.",
      "2": "What data type is needed to hold a sequence of characters like \"Code 42\"?",
      "3": "The blank needs a keyword to declare the variable's type."
    }
  },
  {
    "id": 32,
    "subtopic_id": 1,
    "type": "code_completion",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `FireballSpell` is being prepared, and its `spellPower` needs to be declared to hold an integer value. Complete the declaration of the `spellPower` variable.",
    "story_context": "The FireballSpell needs to track its power level. Your task is to complete the variable declaration.",
    "challenge_data": {
      "initial_code": "public class FireballSpell {\n    public static void main(String[] args) {\n        ??? spellPower = 15;\n        System.out.println(\"Fireball Power: \" + spellPower);\n    }\n}",
      "expected_output": [
        "Fireball Power: 15"
      ],
      "solution_code": "public class FireballSpell {\n    public static void main(String[] args) {\n        int spellPower = 15;\n        System.out.println(\"Fireball Power: \" + spellPower);\n    }\n}",
      "choices": [
        "char",
        "int",
        "double",
        "String"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 3,
          "type": "variable_declaration",
          "description": "Variable type declaration for spellPower",
          "correct_answer": "int",
          "explanation": "The variable `spellPower` is intended to hold a whole number (`15`). The `int` data type is used in Java to store integer (whole number) values."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": "The variable `spellPower` is meant to hold a whole number.",
      "2": "Consider the data type for integer (whole number) values in Java.",
      "3": "What keyword is used before the variable name to declare its type?"
    }
  },
  {
    "id": 33,
    "subtopic_id": 1,
    "type": "code_completion",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `NewIncantation` is discovered and its `spellName` needs to be declared to store the text of the incantation. Complete the declaration of the `spellName` variable.",
    "story_context": "The NewIncantation needs to store the spell name. Your task is to complete the variable declaration.",
    "challenge_data": {
      "initial_code": "public class NewIncantation {\n    public static void main(String[] args) {\n        ??? spellName = \"Whisper of Aether\";\n        System.out.println(\"New Spell: \" + spellName);\n    }\n}",
      "expected_output": [
        "New Spell: Whisper of Aether"
      ],
      "solution_code": "public class NewIncantation {\n    public static void main(String[] args) {\n        String spellName = \"Whisper of Aether\";\n        System.out.println(\"New Spell: \" + spellName);\n    }\n}",
      "choices": [
        "char",
        "int",
        "boolean",
        "String"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 3,
          "type": "variable_declaration",
          "description": "Variable type declaration for spellName",
          "correct_answer": "String",
          "explanation": "The value `\"Whisper of Aether\"` is a literal string, a sequence of characters. In Java, the `String` class is used to represent text."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": "The value assigned (`\"Whisper of Aether\"`) is a sequence of characters.",
      "2": "Recall the data type specifically designed for storing text in Java.",
      "3": "Notice the use of double quotes for the value."
    }
  },
  {
    "id": 34,
    "subtopic_id": 1,
    "type": "code_completion",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `RelicStatusMonitor` tracks whether a relic is active. The `isActive` variable needs to be declared as a boolean and initialized to `true`. Complete the declaration and initialization.",
    "story_context": "The RelicStatusMonitor needs to track the relic's active status. Your task is to complete the variable declaration and initialization.",
    "challenge_data": {
      "initial_code": "public class RelicStatusMonitor {\n    public static void main(String[] args) {\n        boolean ??? = ???;\n        System.out.println(\"Relic Active: \" + isActive);\n    }\n}",
      "expected_output": [
        "Relic Active: true"
      ],
      "solution_code": "public class RelicStatusMonitor {\n    public static void main(String[] args) {\n        boolean isActive = true;\n        System.out.println(\"Relic Active: \" + isActive);\n    }\n}",
      "choices": [
        "true",
        "false",
        "relicState",
        "isActive"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 3,
          "type": "variable_name",
          "description": "Variable name for the boolean relic status",
          "correct_answer": "isActive",
          "explanation": "The `System.out.println()` statement clearly shows that the variable should be named `isActive`."
        },
        {
          "id": "slot_2",
          "line": 3,
          "type": "variable_initialization",
          "description": "Boolean value initialization for relic status",
          "correct_answer": "true",
          "explanation": "The scenario specifies that the relic should initially be set to `true`."
        }
      ],
      "number_of_slots": 2
    },
    "hints": {
      "1": "The print statement indicates the variable should be named `isActive`.",
      "2": "The scenario states the relic's initial status should be `true`.",
      "3": "Remember how boolean values are written in Java."
    }
  },
  { 
    "id": 35,
    "subtopic_id": 1,
    "type": "code_completion",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `RuneCreator` assigns a single symbol to `runeSymbol`. Complete the declaration and initialization of `runeSymbol` to store the character 'F'.",
    "story_context": "The RuneCreator needs to store a single rune symbol. Your task is to complete the variable declaration and initialization.",
    "challenge_data": {
      "initial_code": "public class RuneCreator {\n    public static void main(String[] args) {\n        ??? = ???;\n        System.out.println(\"Rune Symbol: \" + runeSymbol);\n    }\n}",
      "expected_output": [
        "Rune Symbol: F"
      ],
      "solution_code": "public class RuneCreator {\n    public static void main(String[] args) {\n        char runeSymbol = 'F';\n        System.out.println(\"Rune Symbol: \" + runeSymbol);\n    }\n}",
      "choices": [
        "'F'",
        "char runeSymbol",
        "\"F\"",
        "String runeSymbol"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 3,
          "type": "variable_declaration",
          "description": "Complete variable declaration for runeSymbol",
          "correct_answer": "char runeSymbol",
          "explanation": "The variable `runeSymbol` is meant to store a single character. The `char` data type is used for single characters in Java."
        },
        {
          "id": "slot_2",
          "line": 3,
          "type": "variable_initialization",
          "description": "Character value initialization for runeSymbol",
          "correct_answer": "'F'",
          "explanation": "Character literals are enclosed in single quotes in Java."
        }
      ],
      "number_of_slots": 2
    },
    "hints": {
      "1": "The variable `runeSymbol` should hold a single character.",
      "2": "Recall the data type used for single characters in Java.",
      "3": "How are single character literals typically enclosed in Java code?"
    }
  },
  {
    "id": 36,
    "subtopic_id": 1,
    "type": "code_completion",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `PotionVolumeTracker` measures the `potionVolume`. The `potionVolume` variable needs to be declared to store a decimal value. Complete the declaration.",
    "story_context": "The PotionVolumeTracker needs to measure precise potion volumes. Your task is to complete the variable declaration.",
    "challenge_data": {
      "initial_code": "public class PotionVolumeTracker {\n    public static void main(String[] args) {\n        ??? potionVolume = 7.25;\n        System.out.println(\"Potion Volume: \" + potionVolume);\n    }\n}",
      "expected_output": [
        "Potion Volume: 7.25"
      ],
      "solution_code": "public class PotionVolumeTracker {\n    public static void main(String[] args) {\n        double potionVolume = 7.25;\n        System.out.println(\"Potion Volume: \" + potionVolume);\n    }\n}",
      "choices": [
        "int",
        "long",
        "float",
        "double"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 3,
          "type": "variable_declaration",
          "description": "Variable type declaration for potionVolume",
          "correct_answer": "double",
          "explanation": "The value `7.25` is a decimal number (a floating-point literal). In Java, `double` is the default and most commonly used data type for floating-point numbers due to its higher precision."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": "The value `7.25` contains a decimal point.",
      "2": "Recall the data type that typically handles floating-point numbers with high precision.",
      "3": "Floating-point literals in Java are `double` by default unless specified otherwise."
    }
  },
  {
    "id": 37,
    "subtopic_id": 1,
    "type": "code_completion",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `ScrollEvaluator` checks the condition of a magical scroll. The `scrollCondition` variable needs to be declared and initialized to hold a character representing its status, and `isPristine` needs to be declared as a boolean.",
    "story_context": "The ScrollEvaluator needs to check scroll conditions. Your task is to complete the variable declarations and initialization.",
    "challenge_data": {
      "initial_code": "public class ScrollEvaluator {\n    public static void main(String[] args) {\n        ??? scrollCondition = ???;\n        boolean isPristine;\n\n        if (scrollCondition == '0') {\n            isPristine = true;\n        } else {\n            isPristine = false;\n        }\n        System.out.println(\"Scroll Condition: \" + scrollCondition);\n        System.out.println(\"Is Pristine: \" + isPristine);\n    }\n}",
      "expected_output": [
        "Scroll Condition: 0",
        "Is Pristine: true"
      ],
      "solution_code": "public class ScrollEvaluator {\n    public static void main(String[] args) {\n        char scrollCondition = '0';\n        boolean isPristine;\n\n        if (scrollCondition == '0') {\n            isPristine = true;\n        } else {\n            isPristine = false;\n        }\n        System.out.println(\"Scroll Condition: \" + scrollCondition);\n        System.out.println(\"Is Pristine: \" + isPristine);\n    }\n}",
      "choices": [
        "char",
        "0",
        "'0'",
        "String"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 3,
          "type": "variable_declaration",
          "description": "Variable type declaration for scrollCondition",
          "correct_answer": "char",
          "explanation": "The `scrollCondition` variable is meant to store a single character, as implied by its comparison with `'0'`."
        },
        {
          "id": "slot_2",
          "line": 3,
          "type": "variable_initialization",
          "description": "Character value initialization for scrollCondition",
          "correct_answer": "'0'",
          "explanation": "To assign the character `0` as a literal, it must be enclosed in single quotes (`'0'`)."
        }
      ],
      "number_of_slots": 2
    },
    "hints": {
      "1": "The variable `scrollCondition` is expected to hold a single character.",
      "2": "The value `0` should be treated as a character, not a number.",
      "3": "How do you denote a character literal in Java?"
    }
  },
  {
    "id": 38,
    "subtopic_id": 1,
    "type": "code_completion",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `GolemCrafter` system manages the `golemWeight`. The `golemWeight` variable needs to be declared as a `float` to store a specific floating-point literal. Complete the declaration.",
    "story_context": "The GolemCrafter needs to track golem weight precisely. Your task is to complete the variable declaration.",
    "challenge_data": {
      "initial_code": "public class GolemCrafter {\n    public static void main(String[] args) {\n        ??? = 500.0f;\n        System.out.println(\"Golem Weight: \" + golemWeight);\n    }\n}",
      "expected_output": [
        "Golem Weight: 500.0"
      ],
      "solution_code": "public class GolemCrafter {\n    public static void main(String[] args) {\n        float golemWeight = 500.0f;\n        System.out.println(\"Golem Weight: \" + golemWeight);\n    }\n}",
      "choices": [
        "float golemWeight",
        "int golemWeight",
        "long golemWeight",
        "double golemWeight"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 3,
          "type": "variable_declaration",
          "description": "Complete variable declaration for golemWeight",
          "correct_answer": "float golemWeight",
          "explanation": "The literal `500.0f` is explicitly a `float` literal due to the `f` suffix. To correctly declare a variable that can hold this specific type of floating-point number, the `float` data type must be used."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": "Notice the `f` suffix on the numerical literal.",
      "2": "This suffix explicitly designates the literal as a specific primitive floating-point type.",
      "3": "The variable name is `golemWeight`."
    }
  },
  {
    "id": 39,
    "subtopic_id": 1,
    "type": "code_completion",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `ChargeCalculator` determines the `arcaneCharge` based on `baseCharge` and a `multiplier`. Complete the declaration of `arcaneCharge` to correctly store the result of the multiplication.",
    "story_context": "The ChargeCalculator needs to compute arcane charge values. Your task is to complete the variable declaration.",
    "challenge_data": {
      "initial_code": "public class ChargeCalculator {\n    public static void main(String[] args) {\n        int baseCharge = 25;\n        int multiplier = 3;\n        ??? = baseCharge * multiplier;\n        System.out.println(\"Arcane Charge: \" + arcaneCharge);\n    }\n}",
      "expected_output": [
        "Arcane Charge: 75"
      ],
      "solution_code": "public class ChargeCalculator {\n    public static void main(String[] args) {\n        int baseCharge = 25;\n        int multiplier = 3;\n        int arcaneCharge = baseCharge * multiplier;\n        System.out.println(\"Arcane Charge: \" + arcaneCharge);\n    }\n}",
      "choices": [
        "arcaneCharge",
        "int arcaneCharge",
        "double arcaneCharge",
        "String arcaneCharge"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 5,
          "type": "variable_declaration",
          "description": "Complete variable declaration for arcaneCharge",
          "correct_answer": "int arcaneCharge",
          "explanation": "The expression `baseCharge * multiplier` (`25 * 3`) results in `75`, which is an integer. Therefore, `int` is the appropriate primitive data type for `arcaneCharge`."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": "The result of `int * int` multiplication is always an `int`.",
      "2": "The missing part requires both the type and name for the `arcaneCharge` variable.",
      "3": "Ensure the chosen type can hold a whole number."
    }
  },
  {
    "id": 40,
    "subtopic_id": 1,
    "type": "code_completion",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `GolemTracker` records a `locationCode` based on an `asciiValue`. Complete the declaration and type casting to correctly convert the integer `asciiValue` into a `char` for `locationCode`.",
    "story_context": "The GolemTracker needs to convert ASCII values to location codes. Your task is to complete the variable declaration and type casting.",
    "challenge_data": {
      "initial_code": "public class GolemTracker {\n    public static void main(String[] args) {\n        int asciiValue = 90;\n        ??? = ???;\n        System.out.println(\"Golem Location: \" + locationCode);\n    }\n}",
      "expected_output": [
        "Golem Location: Z"
      ],
      "solution_code": "public class GolemTracker {\n    public static void main(String[] args) {\n        int asciiValue = 90;\n        char locationCode = (char) asciiValue;\n        System.out.println(\"Golem Location: \" + locationCode);\n    }\n}",
      "choices": [
        "asciiValue",
        "(char) asciiValue",
        "int locationCode",
        "char locationCode"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 4,
          "type": "variable_declaration",
          "description": "Variable declaration for locationCode",
          "correct_answer": "char locationCode",
          "explanation": "The `locationCode` is intended to be a character, derived from an integer ASCII value. The `char` primitive type is used for characters."
        },
        {
          "id": "slot_2",
          "line": 4,
          "type": "type_casting",
          "description": "Type casting expression for asciiValue",
          "correct_answer": "(char) asciiValue",
          "explanation": "To convert an `int` to a `char` explicitly, a type cast `(char)` is required, applying it to `asciiValue`."
        }
      ],
      "number_of_slots": 2
    },
    "hints": {
      "1": "The `locationCode` is intended to be a character.",
      "2": "An integer (`asciiValue`) needs to be converted to a character explicitly.",
      "3": "Recall the syntax for explicit type casting."
    }
  },
  {
    "id": 41,
    "subtopic_id": 1,
    "type": "code_completion",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `ManaOverflowMonitor` tracks a large `manaReservoir` and sets a `warningFlag` based on `additionalMana` that might cause an overflow. Complete the declaration of `manaReservoir` and ensure `warningFlag` is assigned in all conditional paths.",
    "story_context": "The ManaOverflowMonitor needs to track large mana reservoirs and set warning flags. Your task is to complete the variable declaration and assignments.",
    "challenge_data": {
      "initial_code": "public class ManaOverflowMonitor {\n    public static void main(String[] args) {\n        ??? manaReservoir = 5000000000L;\n        int additionalMana = 1000000000;\n        boolean warningFlag;\n\n        if (additionalMana > (Integer.MAX_VALUE - (int)manaReservoir)) {\n             ??? = true;\n        } else {\n             ??? = false;\n        }\n        \n        System.out.println(\"Mana Reservoir: \" + manaReservoir);\n        System.out.println(\"Warning Flag: \" + warningFlag);\n    }\n}",
      "expected_output": [
        "Mana Reservoir: 5000000000",
        "Warning Flag: false"
      ],
      "solution_code": "public class ManaOverflowMonitor {\n    public static void main(String[] args) {\n        long manaReservoir = 5000000000L;\n        int additionalMana = 1000000000;\n        boolean warningFlag;\n\n        if (additionalMana > (Integer.MAX_VALUE - (int)manaReservoir)) {\n             warningFlag = true;\n        } else {\n             warningFlag = false;\n        }\n        \n        System.out.println(\"Mana Reservoir: \" + manaReservoir);\n        System.out.println(\"Warning Flag: \" + warningFlag);\n    }\n}",
      "choices": [
        "int",
        "long",
        "warningFlag",
        "isWarning"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 3,
          "type": "variable_declaration",
          "description": "Variable type declaration for manaReservoir",
          "correct_answer": "long",
          "explanation": "`manaReservoir` needs to store `5000000000L`, which is a `long` literal. Therefore, `long` is the correct data type."
        },
        {
          "id": "slot_2",
          "line": 7,
          "type": "variable_assignment",
          "description": "Boolean assignment in if branch",
          "correct_answer": "warningFlag",
          "explanation": "The `warningFlag` is a local boolean variable that needs to be definitively assigned a value before it's printed."
        },
        {
          "id": "slot_3",
          "line": 9,
          "type": "variable_assignment",
          "description": "Boolean assignment in else branch",
          "correct_answer": "warningFlag",
          "explanation": "The `warningFlag` variable needs to be assigned a value in both `if` and `else` branches."
        }
      ],
      "number_of_slots": 3
    },
    "hints": {
      "1": "The value `5000000000L` is too large for an `int`.",
      "2": "The `warningFlag` variable needs to be assigned a value in both `if` and `else` branches.",
      "3": "The blank in the `if` and `else` blocks should refer to the already declared boolean variable."
    }
  },
  {
    "id": 42,
    "subtopic_id": 1,
    "type": "code_completion",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "An `AlchemistMixture` calculates a `volatileMixture` from `baseConcentration`. The `volatileMixture` must be a `float`, and `stableStatus` is determined by its value. Complete the declarations and the assignment for `stableStatus` in the `else` block.",
    "story_context": "The AlchemistMixture needs to calculate volatile mixtures and determine stability. Your task is to complete the variable declarations and assignments.",
    "challenge_data": {
      "initial_code": "public class AlchemistMixture {\n    public static void main(String[] args) {\n        double baseConcentration = 1.0 / 3.0;\n        ??? volatileMixture = (float) (baseConcentration * 3.0);\n        boolean stableStatus;\n\n        if (volatileMixture == 1.0f) {\n            stableStatus = true;\n        } else {\n            ??? = false;\n        }\n        \n        System.out.println(\"Mixture Purity: \" + volatileMixture);\n        System.out.println(\"Stable Status: \" + stableStatus);\n    }\n}",
      "expected_output": [
        "Mixture Purity: 0.99999994",
        "Stable Status: false"
      ],
      "solution_code": "public class AlchemistMixture {\n    public static void main(String[] args) {\n        double baseConcentration = 1.0 / 3.0;\n        float volatileMixture = (float) (baseConcentration * 3.0);\n        boolean stableStatus;\n\n        if (volatileMixture == 1.0f) {\n            stableStatus = true;\n        } else {\n            stableStatus = false;\n        }\n        \n        System.out.println(\"Mixture Purity: \" + volatileMixture);\n        System.out.println(\"Stable Status: \" + stableStatus);\n    }\n}",
      "choices": [
        "stableStatus",
        "float",
        "volatileMixture",
        "double"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 4,
          "type": "variable_declaration",
          "description": "Variable type declaration for volatileMixture",
          "correct_answer": "float",
          "explanation": "The problem states that `volatileMixture` must be a `float`. The expression `(float) (baseConcentration * 3.0)` correctly calculates the result and casts it to `float`."
        },
        {
          "id": "slot_2",
          "line": 9,
          "type": "variable_assignment",
          "description": "Boolean assignment in else branch",
          "correct_answer": "stableStatus",
          "explanation": "The `stableStatus` boolean variable needs to be assigned a value in both the `if` and `else` branches to satisfy Java's definite assignment rules."
        }
      ],
      "number_of_slots": 2
    },
    "hints": {
      "1": "The first blank needs the data type for `volatileMixture`, which must be a `float`.",
      "2": "The result of `baseConcentration * 3.0` is a `double`. How do you assign a `double` result to a `float` variable?",
      "3": "The `stableStatus` variable needs to be assigned a value in all conditional paths."
    }
  },
  {
    "id": 43,
    "subtopic_id": 1,
    "type": "code_completion",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "An `OathInscriber` manages `oathText` and `hasBeenSworn` status. The `oathText` is intended to be a constant, and `hasBeenSworn` is set based on its length. Complete the `final` declaration for `oathText` and the assignment for `hasBeenSworn`.",
    "story_context": "The OathInscriber needs to manage oath texts and sworn status. Your task is to complete the final declaration and variable assignment.",
    "challenge_data": {
      "initial_code": "public class OathInscriber {\n    public static void main(String[] args) {\n        ??? String oathText = \"By ancient magic, I swear.\";\n        boolean hasBeenSworn = false;\n\n        if (oathText.length() > 20) {\n            ??? = true;\n        }\n\n        System.out.println(\"Oath: \" + oathText);\n        System.out.println(\"Sworn: \" + hasBeenSworn);\n    }\n}",
      "expected_output": [
        "Oath: By ancient magic, I swear.",
        "Sworn: true"
      ],
      "solution_code": "public class OathInscriber {\n    public static void main(String[] args) {\n        final String oathText = \"By ancient magic, I swear.\";\n        boolean hasBeenSworn = false;\n\n        if (oathText.length() > 20) {\n            hasBeenSworn = true;\n        }\n\n        System.out.println(\"Oath: \" + oathText);\n        System.out.println(\"Sworn: \" + hasBeenSworn);\n    }\n}",
      "choices": [
        "static",
        "hasBeenSworn",
        "isSworn",
        "final"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 3,
          "type": "keyword",
          "description": "Final keyword for constant declaration",
          "correct_answer": "final",
          "explanation": "To make `oathText` a constant that cannot be changed after initialization, the `final` keyword must be placed before its declaration."
        },
        {
          "id": "slot_2",
          "line": 6,
          "type": "variable_assignment",
          "description": "Boolean assignment in if block",
          "correct_answer": "hasBeenSworn",
          "explanation": "The blank inside the `if` block is assigning a value to the `hasBeenSworn` variable, so its name should be placed there."
        }
      ],
      "number_of_slots": 2
    },
    "hints": {
      "1": "The `oathText` is meant to be permanent. What keyword makes a variable immutable?",
      "2": "The boolean variable `hasBeenSworn` is updated inside the `if` block.",
      "3": "What should be placed in that blank?"
    }
  },
  {
    "id": 44,
    "subtopic_id": 1,
    "type": "code_completion",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `SentinelSystem` manages `sentinelEnergy`, `shieldStatus`, and `dangerProtocol`. `sentinelEnergy` is an integer. `shieldStatus` and `dangerProtocol` are set conditionally in an `if-else` structure. Complete the declaration of `sentinelEnergy` and the assignments for `shieldStatus` and `dangerProtocol` in the `else` block.",
    "story_context": "The SentinelSystem needs to manage energy levels and shield protocols. Your task is to complete the variable declarations and assignments.",
    "challenge_data": {
      "initial_code": "public class SentinelSystem {\n    public static void main(String[] args) {\n        ??? sentinelEnergy = 120;\n        String shieldStatus;\n        boolean dangerProtocol;\n\n        if (sentinelEnergy > 100) {\n            shieldStatus = \"Shields Online.\";\n            dangerProtocol = false;\n        } else {\n            ??? = \"Shields Offline.\";\n            ??? = true;\n        }\n        \n        System.out.println(\"Energy: \" + sentinelEnergy);\n        System.out.println(\"Status: \" + shieldStatus);\n        System.out.println(\"Protocol: \" + dangerProtocol);\n    }\n}",
      "expected_output": [
        "Energy: 120",
        "Status: Shields Online.",
        "Protocol: false"
      ],
      "solution_code": "public class SentinelSystem {\n    public static void main(String[] args) {\n        int sentinelEnergy = 120;\n        String shieldStatus;\n        boolean dangerProtocol;\n\n        if (sentinelEnergy > 100) {\n            shieldStatus = \"Shields Online.\";\n            dangerProtocol = false;\n        } else {\n            shieldStatus = \"Shields Offline.\";\n            dangerProtocol = true;\n        }\n        \n        System.out.println(\"Energy: \" + sentinelEnergy);\n        System.out.println(\"Status: \" + shieldStatus);\n        System.out.println(\"Protocol: \" + dangerProtocol);\n    }\n}",
      "choices": [
        "int",
        "boolean",
        "shieldStatus",
        "dangerProtocol"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 3,
          "type": "variable_declaration",
          "description": "Variable type declaration for sentinelEnergy",
          "correct_answer": "int",
          "explanation": "`sentinelEnergy` stores a whole number (`120`), so `int` is the correct data type for its declaration."
        },
        {
          "id": "slot_2",
          "line": 10,
          "type": "variable_assignment",
          "description": "String assignment in else branch",
          "correct_answer": "shieldStatus",
          "explanation": "In the `else` block, the first blank assigns a string literal `\"Shields Offline.\"`, so the variable name `shieldStatus` should fill this blank."
        },
        {
          "id": "slot_3",
          "line": 11,
          "type": "variable_assignment",
          "description": "Boolean assignment in else branch",
          "correct_answer": "dangerProtocol",
          "explanation": "The second blank in the `else` block assigns a boolean literal `true`, so the variable name `dangerProtocol` should fill this blank."
        }
      ],
      "number_of_slots": 3
    },
    "hints": {
      "1": "The `sentinelEnergy` variable stores a whole number.",
      "2": "The blank in the `else` block that assigns a string value should be the `shieldStatus` variable.",
      "3": "The blank that assigns a boolean value in the `else` block should be the `dangerProtocol` variable."
    }
  },
  {
    "id": 45,
    "subtopic_id": 1,
    "type": "code_completion",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "An `ElementalOrb` monitors `currentTemperature` and determines `statusReport` and `dangerLevel`. `currentTemperature` is a decimal, and `dangerLevel` is an integer. Complete the declarations and the assignment for `dangerLevel` in the `else` block.",
    "story_context": "The ElementalOrb needs to monitor temperature and determine danger levels. Your task is to complete the variable declarations and assignments.",
    "challenge_data": {
      "initial_code": "public class ElementalOrb {\n    public static void main(String[] args) {\n        ??? currentTemperature = 95.0;\n        String statusReport = \"Orb operating normally.\";\n        ??? dangerLevel;\n\n        if (currentTemperature > 90.0) {\n            statusReport = \"WARNING: Overheating!\";\n            dangerLevel = 3;\n        } else {\n            ??? = 1;\n        }\n\n        System.out.println(\"Temperature: \" + currentTemperature);\n        System.out.println(\"Report: \" + statusReport);\n        System.out.println(\"Danger Level: \" + dangerLevel);\n    }\n}",
      "expected_output": [
        "Temperature: 95.0",
        "Report: WARNING: Overheating!",
        "Danger Level: 3"
      ],
      "solution_code": "public class ElementalOrb {\n    public static void main(String[] args) {\n        double currentTemperature = 95.0;\n        String statusReport = \"Orb operating normally.\";\n        int dangerLevel;\n\n        if (currentTemperature > 90.0) {\n            statusReport = \"WARNING: Overheating!\";\n            dangerLevel = 3;\n        } else {\n            dangerLevel = 1;\n        }\n\n        System.out.println(\"Temperature: \" + currentTemperature);\n        System.out.println(\"Report: \" + statusReport);\n        System.out.println(\"Danger Level: \" + dangerLevel);\n    }\n}",
      "choices": [
        "dangerLevel",
        "boolean",
        "String",
        "double",
        "int"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 3,
          "type": "variable_declaration",
          "description": "Variable type declaration for currentTemperature",
          "correct_answer": "double",
          "explanation": "`currentTemperature` needs to store a decimal value (`95.0`), so `double` is the correct data type for its declaration."
        },
        {
          "id": "slot_2",
          "line": 5,
          "type": "variable_declaration",
          "description": "Variable type declaration for dangerLevel",
          "correct_answer": "int",
          "explanation": "`dangerLevel` needs to hold whole numbers (`3` or `1`), so `int` is the correct data type for its declaration."
        },
        {
          "id": "slot_3",
          "line": 10,
          "type": "variable_assignment",
          "description": "Integer assignment in else branch",
          "correct_answer": "dangerLevel",
          "explanation": "`dangerLevel` is a local variable used after an `if-else` block, so it must be initialized in all branches to satisfy Java's \"definitely assigned\" rule."
        }
      ],
      "number_of_slots": 3
    },
    "hints": {
      "1": "The `currentTemperature` is a decimal value.",
      "2": "`dangerLevel` needs to hold whole numbers and must be initialized across all conditional paths.",
      "3": "The blank in the `else` block should assign a value to the already declared `dangerLevel` variable."
    }
  },
  {
    "id": 46,
    "subtopic_id": 2,
    "type": "output_tracing",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `MagicCounter` tracks arcane energy. The `energyCount` is initially set, then increased by 1. Your task is to trace the code and determine the final `Energy Count` that is printed.",
    "story_context": "The MagicCounter needs to track arcane energy levels. Your task is to trace the increment operation and predict the output.",
    "challenge_data": {
      "code": "public class MagicCounter {\n    public static void main(String[] args) {\n        int energyCount = 5;\n        energyCount = energyCount + 1;\n        System.out.println(\"Energy Count: \" + energyCount);\n    }\n}",
      "expected_output": [
        "Energy Count: 6"
      ],
      "choices": [
        "Energy Count: 5",
        "Energy Count: 6",
        "Energy Count: 1",
        "Error"
      ],
      "explanation": "The `int energyCount = 5;` line initializes `energyCount` to `5`. Then, `energyCount = energyCount + 1;` adds `1` to `energyCount`, making its new value `6`. Finally, `System.out.println(\"Energy Count: \" + energyCount);` prints \"Energy Count: 6\"."
    },
    "hints": {
      "1": "Follow the variable's value from its initialization.",
      "2": "The `+ 1` operation adds one to the current value.",
      "3": "The `println` statement displays the value after the operation."
    }
  },
  {
    "id": 47,
    "subtopic_id": 2,
    "type": "output_tracing",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `TorchMonitor` tracks the state of a magical torch. The `torchLit` boolean is initially `false`, but a condition checks if `5 > 3`. Your task is to trace the code and determine the final `Torch Lit` status.",
    "story_context": "The TorchMonitor needs to track the state of magical torches. Your task is to trace the boolean condition and predict the output.",
    "challenge_data": {
      "code": "public class TorchMonitor {\n    public static void main(String[] args) {\n        boolean torchLit = false;\n        if (5 > 3) {\n            torchLit = true;\n        }\n        System.out.println(\"Torch Lit: \" + torchLit);\n    }\n}",
      "expected_output": [
        "Torch Lit: true"
      ],
      "choices": [
        "Torch Lit: false",
        "Torch Lit: true",
        "Error",
        "Nothing"
      ],
      "explanation": "The `boolean torchLit = false;` line initializes `torchLit` to `false`. The `if (5 > 3)` condition evaluates to `true` (since `5` is indeed greater than `3`). Therefore, the code inside the `if` block, `torchLit = true;`, is executed, changing `torchLit` to `true`. Finally, `System.out.println(\"Torch Lit: \" + torchLit);` prints \"Torch Lit: true\"."
    },
    "hints": {
      "1": "Evaluate the condition inside the `if` statement.",
      "2": "If the condition is true, the code inside the `if` block executes.",
      "3": "The final `println` shows the most recent value of `torchLit`."
    }
  },
  {
    "id": 48,
    "subtopic_id": 2,
    "type": "output_tracing",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `RuneWriter` inscribes magical runes. The `runeCharacter` is assigned a single character. Your task is to trace the code and determine the `Rune` that is printed.",
    "story_context": "The RuneWriter needs to inscribe magical runes. Your task is to trace the character assignment and predict the output.",
    "challenge_data": {
      "code": "public class RuneWriter {\n    public static void main(String[] args) {\n        char runeCharacter = 'G';\n        System.out.println(\"Rune: \" + runeCharacter);\n    }\n}",
      "expected_output": [
        "Rune: G"
      ],
      "choices": [
        "Rune: G",
        "G",
        "Rune: runeCharacter",
        "Error"
      ],
      "explanation": "The `char runeCharacter = 'G';` line declares a character variable `runeCharacter` and assigns it the literal character `'G'`. The `System.out.println(\"Rune: \" + runeCharacter);` statement concatenates the string \"Rune: \" with the value of `runeCharacter`, resulting in the output \"Rune: G\"."
    },
    "hints": {
      "1": "A `char` variable stores a single character.",
      "2": "The `+` operator concatenates a string literal and the variable's value.",
      "3": "The character itself, not its ASCII value, is printed by default."
    }
  },
  {
    "id": 49,
    "subtopic_id": 2,
    "type": "output_tracing",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `PotionVolume` system measures liquid volumes. The `liquidVolume` is assigned a decimal value. Your task is to trace the code and determine the exact `Volume` that is printed.",
    "story_context": "The PotionVolume system needs to measure liquid volumes with precision. Your task is to trace the double variable and string concatenation to predict the output.",
    "challenge_data": {
      "code": "public class PotionVolume {\n    public static void main(String[] args) {\n        double liquidVolume = 12.345;\n        System.out.println(\"Volume: \" + liquidVolume + \" liters\");\n    }\n}",
      "expected_output": [
        "Volume: 12.345 liters"
      ],
      "choices": [
        "Volume: 12 liters",
        "Volume: 12.345 liters",
        "12.345",
        "Error"
      ],
      "explanation": "The `double liquidVolume = 12.345;` line declares `liquidVolume` as a `double` and initializes it with `12.345`. The `System.out.println()` statement then concatenates the string literal \"Volume: \", the value of `liquidVolume`, and the string literal \" liters\". This results in the precise output \"Volume: 12.345 liters\"."
    },
    "hints": {
      "1": "A `double` variable retains decimal precision.",
      "2": "String concatenation (`+`) combines all parts into a single output string.",
      "3": "The literal text and the variable's value will be printed as they appear."
    }
  },
  {
    "id": 50,
    "subtopic_id": 2,
    "type": "output_tracing",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `BlastCalculator` determines the force of a magical blast. The `forceMagnitude` is calculated by multiplying `baseForce` and a `multiplier`. Your task is to trace the code and determine the final `Force Magnitude` that is printed.",
    "story_context": "The BlastCalculator needs to determine the force of magical blasts. Your task is to trace the multiplication operation and predict the output.",
    "challenge_data": {
      "code": "public class BlastCalculator {\n    public static void main(String[] args) {\n        int baseForce = 10;\n        int multiplier = 3;\n        int forceMagnitude = baseForce * multiplier;\n        System.out.println(\"Force Magnitude: \" + forceMagnitude);\n    }\n}",
      "expected_output": [
        "Force Magnitude: 30"
      ],
      "choices": [
        "Force Magnitude: 10",
        "Force Magnitude: 3",
        "Force Magnitude: 30",
        "Error"
      ],
      "explanation": "The `int baseForce = 10;` and `int multiplier = 3;` lines initialize the respective variables. The `int forceMagnitude = baseForce * multiplier;` line calculates `10 * 3`, which is `30`, and assigns this result to `forceMagnitude`. Finally, `System.out.println(\"Force Magnitude: \" + forceMagnitude);` prints \"Force Magnitude: 30\"."
    },
    "hints": {
      "1": "Follow the multiplication operation.",
      "2": "The result of `baseForce * multiplier` is assigned to `forceMagnitude`.",
      "3": "The final `println` displays this calculated value."
    }
  },
  {
    "id": 51,
    "subtopic_id": 2,
    "type": "output_tracing",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `PotionDilution` system calculates `potencyValue` and determines if a `stabilizerNeeded` based on it. Your task is to trace the code and determine the final `Potency` and `Stabilizer Needed` status.",
    "story_context": "The PotionDilution system needs to calculate potency values and determine stabilizer requirements. Your task is to trace the calculation and conditional logic to predict the outputs.",
    "challenge_data": {
      "code": "public class PotionDilution {\n    public static void main(String[] args) {\n        int baseConcentration = 100;\n        double dilutionFactor = 0.5;\n        boolean stabilizerNeeded = true;\n\n        double potencyValue = baseConcentration * dilutionFactor;\n\n        if (potencyValue < 60.0) {\n            stabilizerNeeded = false;\n        }\n\n        System.out.println(\"Final Potency: \" + potencyValue);\n        System.out.println(\"Stabilizer Needed: \" + stabilizerNeeded);\n    }\n}",
      "expected_output": [
        "Final Potency: 50.0",
        "Stabilizer Needed: false"
      ],
      "choices": [
        "Final Potency: 50.0",
        "Final Potency: 100.0",
        "Stabilizer Needed: false",
        "Stabilizer Needed: true",
        "Final Potency: 500.0"
      ],
      "explanation": "1. `baseConcentration` is `100`, `dilutionFactor` is `0.5`, `stabilizerNeeded` is `true`.\n2. `double potencyValue = baseConcentration * dilutionFactor;` calculates `100 * 0.5 = 50.0`. So, `potencyValue` becomes `50.0`.\n3. `if (potencyValue < 60.0)`: `50.0 < 60.0` is `true`.\n    * `stabilizerNeeded = false;` updates `stabilizerNeeded` to `false`.\n4. The first `System.out.println()` prints \"Final Potency: 50.0\".\n5. The second `System.out.println()` prints \"Stabilizer Needed: false\"."
    },
    "hints": {
      "1": "Perform the multiplication to find `potencyValue` first, noting that an `int` multiplied by a `double` results in a `double`.",
      "2": "Evaluate the `if` condition using the calculated `potencyValue` to determine the final state of `stabilizerNeeded`.",
      "3": "Both `println` statements will output the final state of their respective variables."
    }
  },
  {
    "id": 52,
    "subtopic_id": 2,
    "type": "output_tracing",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `RuneWeaver` processes `runeCode`s and `modifier`s, determining `activationStatus` based on potential integer overflow. Your task is to trace the code and determine the final `Rune Code` and `Activation Status`.",
    "story_context": "The RuneWeaver needs to process rune codes and handle integer overflow scenarios. Your task is to trace the overflow calculation and conditional logic to predict the outputs.",
    "challenge_data": {
      "code": "public class RuneWeaver {\n    public static void main(String[] args) {\n        int runeCode = 2000000000;\n        long modifier = 500000000L;\n        boolean activationStatus = false;\n\n        runeCode = (int) (runeCode + modifier);\n\n        if (runeCode < 0) {\n            activationStatus = true;\n        }\n\n        System.out.println(\"Final Rune Code: \" + runeCode);\n        System.out.println(\"Activation Status: \" + activationStatus);\n    }\n}",
      "expected_output": [
        "Final Rune Code: -1794967296",
        "Activation Status: true"
      ],
      "choices": [
        "Final Rune Code: 2500000000",
        "Final Rune Code: -1794967296",
        "Activation Status: false",
        "Activation Status: true",
        "Final Rune Code: 2000000000"
      ],
      "explanation": "1. `runeCode` is `2,000,000,000`, `modifier` is `500,000,000L`, `activationStatus` is `false`.\n2. `runeCode = (int) (runeCode + modifier);` attempts to calculate `2,000,000,000 + 500,000,000 = 2,500,000,000`.\n3. However, `2,500,000,000` exceeds the maximum value an `int` can hold (`2,147,483,647`). When this sum is cast back to `int`, it results in an **integer overflow**, causing the value to wrap around to the minimum negative value. `2,500,000,000 - 2^32` (or `2,500,000,000 - 4,294,967,296` for unsigned interpretation, or more simply, `2,500,000,000 - 2 * 2,147,483,648` then wrap) results in `-1794967296`. So, `runeCode` becomes `-1794967296`.\n4. `if (runeCode < 0)`: `-1794967296 < 0` is `true`.\n    * `activationStatus = true;` updates `activationStatus` to `true`.\n5. The first `System.out.println()` prints \"Final Rune Code: -1794967296\".\n6. The second `System.out.println()` prints \"Activation Status: true\"."
    },
    "hints": {
      "1": "Be aware of integer overflow. Adding a large `long` to an `int` might exceed the `int`'s maximum value.",
      "2": "An `int` in Java has a maximum value of `2,147,483,647`. What happens if `2,000,000,000 + 500,000,000` is forced back into an `int`?",
      "3": "Evaluate the `if` condition carefully based on the final (potentially overflowed) `runeCode`."
    }
  },
  {
    "id": 53,
    "subtopic_id": 2,
    "type": "output_tracing",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `CelestialCartographer` calculates `celestialCoordinate` and determines if a `starFound` based on floating-point comparison. Your task is to trace the code and determine the final `Final Coordinate` and `Star Found` status.",
    "story_context": "The CelestialCartographer needs to calculate celestial coordinates and handle floating-point precision. Your task is to trace the floating-point calculation and conditional logic to predict the outputs.",
    "challenge_data": {
      "code": "public class CelestialCartographer {\n    public static void main(String[] args) {\n        float baseDistance = 1000.0f;\n        float accuracyFactor = 0.0001f;\n        boolean starFound = false;\n\n        float celestialCoordinate = baseDistance * accuracyFactor;\n\n        if (celestialCoordinate == 0.1f) {\n            starFound = true;\n        }\n\n        System.out.println(\"Final Coordinate: \" + celestialCoordinate);\n        System.out.println(\"Star Found: \" + starFound);\n    }\n}",
      "expected_output": [
        "Final Coordinate: 0.10000001",
        "Star Found: false"
      ],
      "choices": [
        "Final Coordinate: 0.1",
        "Final Coordinate: 0.10000001",
        "Star Found: false",
        "Star Found: true",
        "Final Coordinate: 0.101"
      ],
      "explanation": "1. `baseDistance` is `1000.0f`, `accuracyFactor` is `0.0001f`, `starFound` is `false`.\n2. `float celestialCoordinate = baseDistance * accuracyFactor;` computes `0.1f`. However, due to the nature of floating-point representation, `0.1` often cannot be perfectly represented in binary, leading to a slight precision error (e.g., stored as `0.10000001`).\n3. `if (celestialCoordinate == 0.1f)`: Because of this tiny precision error, `celestialCoordinate` is *not* exactly equal to `0.1f`. Therefore, this condition evaluates to `false`.\n    * `starFound` remains `false`.\n4. The first `System.out.println()` prints \"Final Coordinate: 0.10000001\" (or a similar slightly imprecise value).\n5. The second `System.out.println()` prints \"Star Found: false\"."
    },
    "hints": {
      "1": "Understand that floating-point arithmetic (especially with `float`) can introduce tiny inaccuracies.",
      "2": "Direct comparison (`==`) of floating-point numbers (`float` or `double`) is often unreliable due to these inaccuracies.",
      "3": "Perform the multiplication to get `celestialCoordinate` and then carefully evaluate the `if` condition."
    }
  },
  {
    "id": 54,
    "subtopic_id": 2,
    "type": "output_tracing",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `WardActivator` system strengthens magical wards. `wardStrength` is updated, potentially causing a byte overflow, which then affects whether a `spellBlocked`. Your task is to trace the code and determine the final `Ward Strength` and `Spell Blocked` status.",
    "story_context": "The WardActivator system needs to strengthen magical wards and handle overflow scenarios. Your task is to trace the overflow calculation and conditional logic to predict the outputs.",
    "challenge_data": {
      "code": "public class WardActivator {\n    public static void main(String[] args) {\n        byte wardStrength = 120;\n        int incomingSpellPower = 10;\n        boolean spellBlocked = false;\n\n        wardStrength = (byte) (wardStrength + incomingSpellPower);\n\n        if (wardStrength < 0) {\n            spellBlocked = true;\n        }\n\n        System.out.println(\"Final Ward Strength: \" + wardStrength);\n        System.out.println(\"Spell Blocked: \" + spellBlocked);\n    }\n}",
      "expected_output": [
        "Final Ward Strength: -126",
        "Spell Blocked: true"
      ],
      "choices": [
        "Final Ward Strength: 130",
        "Final Ward Strength: -126",
        "Spell Blocked: false",
        "Spell Blocked: true",
        "Final Ward Strength: 120"
      ],
      "explanation": "1. `wardStrength` is `120`, `incomingSpellPower` is `10`, `spellBlocked` is `false`.\n2. `wardStrength = (byte) (wardStrength + incomingSpellPower);` calculates `120 + 10 = 130`.\n3. However, `130` exceeds the maximum value a `byte` can hold (`127`). When `130` is cast back to `byte`, it results in a **byte overflow**. The value \"wraps around\" from `127` to `-128`, then continues counting up from there (`127 -> -128 -> -127 -> ...`). `130` becomes `-126` after wrapping. So, `wardStrength` becomes `-126`.\n4. `if (wardStrength < 0)`: `-126 < 0` is `true`.\n    * `spellBlocked = true;` updates `spellBlocked` to `true`.\n5. The first `System.out.println()` prints \"Final Ward Strength: -126\".\n6. The second `System.out.println()` prints \"Spell Blocked: true\"."
    },
    "hints": {
      "1": "Recall the maximum positive value a `byte` can hold in Java.",
      "2": "Consider what happens when you add a number that pushes a `byte` beyond its maximum positive limit.",
      "3": "The `if` condition explicitly checks for a negative result, which is a common indicator of a `byte` overflow."
    }
  },
  {
    "id": 55,
    "subtopic_id": 2,
    "type": "output_tracing",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `MagicCommunicator` translates numerical codes into characters. `signalCharacter` is cast from `characterCode`, then conditionally modified. Your task is to trace the code and determine the final `Signal Character` and `Signal Received` status.",
    "story_context": "The MagicCommunicator needs to translate numerical codes into characters and track signal status. Your task is to trace the character casting and conditional logic to predict the outputs.",
    "challenge_data": {
      "code": "public class MagicCommunicator {\n    public static void main(String[] args) {\n        int characterCode = 65;\n        char signalCharacter = (char) characterCode;\n        boolean signalReceived = false;\n\n        if (signalCharacter == 'A') {\n            signalReceived = true;\n        } else {\n            signalCharacter = 'Z';\n        }\n\n        System.out.println(\"Signal Character: \" + signalCharacter);\n        System.out.println(\"Signal Received: \" + signalReceived);\n    }\n}",
      "expected_output": [
        "Signal Character: A",
        "Signal Received: true"
      ],
      "choices": [
        "Signal Character: A",
        "Signal Character: Z",
        "Signal Received: false",
        "Signal Received: true",
        "Signal Character: AZ"
      ],
      "explanation": "1. `characterCode` is `65`, `signalCharacter` is initialized by casting `65` to `char`, making `signalCharacter` `'A'`. `signalReceived` is `false`.\n2. `if (signalCharacter == 'A')`: `'A' == 'A'` is `true`.\n    * `signalReceived = true;` updates `signalReceived` to `true`.\n3. The `else` block is skipped.\n4. The first `System.out.println()` prints \"Signal Character: A\".\n5. The second `System.out.println()` prints \"Signal Received: true\"."
    },
    "hints": {
      "1": "Remember that `char` can represent characters using their numerical (ASCII/Unicode) codes.",
      "2": "The `(char)` cast converts the integer code to its corresponding character.",
      "3": "Carefully evaluate the `if` condition to determine the `signalReceived` status and potential character change."
    }
  },
  {
    "id": 56,
    "subtopic_id": 2,
    "type": "output_tracing",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `RunicConverter` processes `manaInput` and `conversionFactor`, potentially causing a `short` overflow that triggers an `overflowWarning` and sets a `diagnosticCode`. Your task is to trace the code and determine the final `Aetheric Flow`, `Overflow Warning`, and `Diagnostic Code`.",
    "story_context": "The RunicConverter needs to process mana inputs and handle overflow scenarios. Your task is to trace the overflow calculation and conditional logic to predict the outputs.",
    "challenge_data": {
      "code": "public class RunicConverter {\n    public static void main(String[] args) {\n        short manaInput = 32700;\n        byte conversionFactor = 100;\n        boolean overflowWarning = false;\n        char diagnosticCode = 'A';\n\n        short aethericFlow = (short) (manaInput + conversionFactor);\n        \n        if (aethericFlow < 0) {\n            overflowWarning = true;\n            diagnosticCode = 'X';\n        } else {\n            diagnosticCode = 'O';\n        }\n        \n        aethericFlow = (short) (aethericFlow / 5);\n\n        System.out.println(\"Final Aetheric Flow: \" + aethericFlow);\n        System.out.println(\"Overflow Warning: \" + overflowWarning);\n        System.out.println(\"Diagnostic Code: \" + diagnosticCode);\n    }\n}",
      "expected_output": [
        "Final Aetheric Flow: -6547",
        "Overflow Warning: true",
        "Diagnostic Code: X"
      ],
      "choices": [
        "Final Aetheric Flow: 32100",
        "Final Aetheric Flow: -6547",
        "Overflow Warning: true",
        "Diagnostic Code: X",
        "Diagnostic Code: XX",
        "Overflow Warning: false"
      ],
      "explanation": "1. `manaInput` is `32700`, `conversionFactor` is `100`.\n2. `short aethericFlow = (short) (manaInput + conversionFactor);` calculates `32700 + 100 = 32800`. This exceeds `short`'s maximum (`32767`), causing a **short overflow**. `32800` wraps around to `-32736`. So `aethericFlow` becomes `-32736`.\n3. `if (aethericFlow < 0)`: `-32736 < 0` is `true`.\n    * `overflowWarning = true;` updates `overflowWarning` to `true`.\n    * `diagnosticCode = 'X';` updates `diagnosticCode` to `'X'`.\n4. `aethericFlow = (short) (aethericFlow / 5);` calculates `-32736 / 5 = -6547.2`. Integer division truncates to `-6547`. So `aethericFlow` becomes `-6547`.\n5. The first `System.out.println()` prints \"Final Aetheric Flow: -6547\".\n6. The second `System.out.println()` prints \"Overflow Warning: true\".\n7. The third `System.out.println()` prints \"Diagnostic Code: X\"."
    },
    "hints": {
      "1": "Recall the maximum value for a `short` data type (32767) and consider what happens when a value exceeds it.",
      "2": "Carefully evaluate the `if` condition based on the potentially overflowed `aethericFlow` to determine `overflowWarning` and `diagnosticCode`.",
      "3": "Don't forget the final integer division operation and how it affects the `aethericFlow`."
    }
  },
  {
    "id": 57,
    "subtopic_id": 2,
    "type": "output_tracing",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `StardustRefinery` calculates `stardustWeight` from `rawMaterial` and `conversionRate`, then determines `refinementComplete` and `magicalEssencePresent` based on floating-point comparisons. Your task is to trace the code and determine the `Final Stardust Weight`, `Refinement Complete` status, and `Magical Essence Present` status.",
    "story_context": "The StardustRefinery needs to process raw materials and handle floating-point precision. Your task is to trace the floating-point calculations and conditional logic to predict the outputs.",
    "challenge_data": {
      "code": "public class StardustRefinery {\n    public static void main(String[] args) {\n        float rawMaterial = 100.0f;\n        double conversionRate = 0.005;\n        boolean refinementComplete = false;\n        boolean magicalEssencePresent = false;\n\n        double stardustWeight = rawMaterial * conversionRate;\n\n        if (stardustWeight > 0.5f) {\n            refinementComplete = true;\n        }\n\n        if (refinementComplete && stardustWeight < 0.6) {\n            magicalEssencePresent = true;\n        }\n        \n        System.out.println(\"Final Stardust Weight: \" + stardustWeight);\n        System.out.println(\"Refinement Complete: \" + refinementComplete);\n        System.out.println(\"Magical Essence Present: \" + magicalEssencePresent);\n    }\n}",
      "expected_output": [
        "Final Stardust Weight: 0.5000000000000001",
        "Refinement Complete: true",
        "Magical Essence Present: true"
      ],
      "choices": [
        "Final Stardust Weight: 0.5000000000000001",
        "Refinement Complete: true",
        "Magical Essence Present: true",
        "Final Stardust Weight: 0.5",
        "Refinement Complete: false",
        "Magical Essence Present: false"
      ],
      "explanation": "1. `rawMaterial` is `100.0f`, `conversionRate` is `0.005`.\n2. `double stardustWeight = rawMaterial * conversionRate;` calculates `100.0f * 0.005`. The `float` is promoted to `double`, and the result is `0.5`. Due to floating-point representation, it's often stored as `0.5000000000000001`.\n3. `if (stardustWeight > 0.5f)`: `0.5000000000000001` (double) is indeed greater than `0.5f` (float). So this condition evaluates to `true`.\n    * `refinementComplete = true;` updates `refinementComplete` to `true`.\n4. `if (refinementComplete && stardustWeight < 0.6)`: `true && (0.5 < 0.6)` is `true && true`, which evaluates to `true`.\n    * `magicalEssencePresent = true;` updates `magicalEssencePresent` to `true`.\n5. All three `System.out.println()` statements print the final values."
    },
    "hints": {
      "1": "When a `float` and `double` are involved in an operation, the result typically promotes to `double` for precision.",
      "2": "Be extremely cautious with direct comparisons (`==`, `>`, `<`) involving floating-point numbers due to potential precision issues. `0.5f` might not be the same as `0.5` (double).",
      "3": "Trace the boolean variables carefully through all conditional statements."
    }
  },
  {
    "id": 58,
    "subtopic_id": 2,
    "type": "output_tracing",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `SecurityEnchantment` system evaluates `entryCode` and `maxAttempts` to determine if `isLocked` and `lockStatus`. `entryCode` is cast to an `int`, potentially causing an overflow. Your task is to trace the code and determine the `Final Entry Code`, `System Locked` status, and `Lock Status Message`.",
    "story_context": "The SecurityEnchantment system needs to evaluate security codes and handle overflow scenarios. Your task is to trace the overflow calculation and conditional logic to predict the outputs.",
    "challenge_data": {
      "code": "public class SecurityEnchantment {\n    public static void main(String[] args) {\n        long entryCode = 123456789123L;\n        int maxAttempts = 5;\n        boolean isLocked = true;\n        String lockStatus = \"Secure\";\n\n        byte remainingAttempts = (byte) (maxAttempts - 1);\n\n        if (entryCode % 2 == 0) {\n            isLocked = false;\n        } else {\n            lockStatus = \"Breach Detected\";\n        }\n        \n        if (remainingAttempts < 5 && isLocked) {\n            lockStatus = \"Emergency Lockdown\";\n        }\n\n        System.out.println(\"Final Entry Code: \" + (int)entryCode);\n        System.out.println(\"System Locked: \" + isLocked);\n        System.out.println(\"Lock Status Message: \" + lockStatus);\n    }\n}",
      "expected_output": [
        "Final Entry Code: 1539151595",
        "System Locked: true",
        "Lock Status Message: Emergency Lockdown"
      ],
      "choices": [
        "Final Entry Code: 123456789123",
        "Final Entry Code: 1539151595",
        "System Locked: true",
        "Lock Status Message: Emergency Lockdown",
        "Final Entry Code: 12345678912345",
        "System Locked: false"
      ],
      "explanation": "1. Variables are initialized: `entryCode = 123456789123L`, `maxAttempts = 5`, `isLocked = true`, `lockStatus = \"Secure\"`.\n2. `byte remainingAttempts = (byte) (maxAttempts - 1);` calculates `5 - 1 = 4`, casts to `byte`, so `remainingAttempts` is `4`.\n3. `if (entryCode % 2 == 0)`: `123456789123` is an odd number, so `entryCode % 2` is `1`. `1 == 0` is `false`. The `else` block executes.\n    * `lockStatus = \"Breach Detected\";` updates `lockStatus` to \"Breach Detected\". `isLocked` remains `true`.\n4. `if (remainingAttempts < 5 && isLocked)`: `4 < 5` is `true`, AND `isLocked` (`true`) is `true`. The condition `true && true` is `true`. The block is entered.\n    * `lockStatus = \"Emergency Lockdown\";` updates `lockStatus` to \"Emergency Lockdown\".\n5. **Output 1**: `System.out.println(\"Final Entry Code: \" + (int)entryCode);` The `long` value `123456789123L` is cast to `int`, causing an **integer overflow**. The result is `1539151595`.\n6. **Output 2**: `System.out.println(\"System Locked: \" + isLocked);` prints \"System Locked: true\".\n7. **Output 3**: `System.out.println(\"Lock Status Message: \" + lockStatus);` prints \"Lock Status Message: Emergency Lockdown\"."
    },
    "hints": {
      "1": "Pay attention to the final `System.out.println` for `entryCode` which explicitly casts a `long` to an `int`. Consider the impact of this conversion on a large number.",
      "2": "Evaluate `entryCode % 2` to determine if the `long` code is even or odd, which affects `isLocked` and `lockStatus`.",
      "3": "Trace `isLocked` and `lockStatus` through both `if` conditions sequentially."
    }
  },
  {
    "id": 59,
    "subtopic_id": 2,
    "type": "output_tracing",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `ChronomancerCalibrator` adjusts `timeWarpFactor` and calculates `stabilityRating`. Conditional logic determines if the system `calibratedSuccessfully` based on precise floating-point comparisons. Your task is to trace the code and determine the `Final Time Warp Factor`, `Stability Rating`, and `Calibrated Successfully` status.",
    "story_context": "The ChronomancerCalibrator needs to adjust time warp factors and handle floating-point precision. Your task is to trace the floating-point calculations and conditional logic to predict the outputs.",
    "challenge_data": {
      "code": "public class ChronomancerCalibrator {\n    public static void main(String[] args) {\n        double initialWarp = 1.0 / 3.0;\n        double adjustment = 0.0000000001;\n        int stabilityThreshold = 5;\n        boolean calibratedSuccessfully = false;\n\n        double timeWarpFactor = initialWarp * 3.0 + adjustment;\n        \n        int stabilityRating = (int) (timeWarpFactor * stabilityThreshold);\n\n        if (timeWarpFactor == 1.0) {\n            calibratedSuccessfully = true;\n        } else if (timeWarpFactor > 1.0 - 0.0000001) {\n            calibratedSuccessfully = true;\n        }\n\n        System.out.println(\"Final Time Warp Factor: \" + timeWarpFactor);\n        System.out.println(\"Stability Rating: \" + stabilityRating);\n        System.out.println(\"Calibrated Successfully: \" + calibratedSuccessfully);\n    }\n}",
      "expected_output": [
        "Final Time Warp Factor: 1.0000000000999999",
        "Stability Rating: 5",
        "Calibrated Successfully: true"
      ],
      "choices": [
        "Final Time Warp Factor: 0.9999999999",
        "Calibrated Successfully: false",
        "Final Time Warp Factor: 1.0000000001",
        "Stability Rating: 5",
        "Calibrated Successfully: true",
        "Stability Rating: 50"
      ],
      "explanation": "1. `initialWarp` is `1.0 / 3.0` (approximately `0.3333333333333333`).\n2. `timeWarpFactor = initialWarp * 3.0 + adjustment;` calculates `0.3333333333333333 * 3.0` which is `0.9999999999999999`. Adding `0.0000000001` makes `timeWarpFactor` approximately `1.0000000000999999`.\n3. `stabilityRating = (int) (timeWarpFactor * stabilityThreshold);` calculates `(int) (5.0000000004999995)`. Casting to `int` truncates, so `stabilityRating` becomes `5`.\n4. `if (timeWarpFactor == 1.0)`: `1.0000000000999999 == 1.0` is `false` due to floating-point imprecision.\n5. `else if (timeWarpFactor > 1.0 - 0.0000001)`: `1.0000000000999999 > 0.9999999` is `true`.\n    * `calibratedSuccessfully = true;` updates `calibratedSuccessfully` to `true`.\n6. The `System.out.println()` statements display the final values: `timeWarpFactor` (e.g., `1.0000000001`), `stabilityRating` (`5`), and `calibratedSuccessfully` (`true`)."
    },
    "hints": {
      "1": "Understand that division of integers can produce repeating decimals, and floating-point arithmetic might not be perfectly precise.",
      "2": "Direct comparison (`==`) of `double` values is often unreliable; `if-else if` conditions might use a tolerance.",
      "3": "Trace the exact numerical values through each calculation and comparison, including type conversions and truncation."
    }
  },
  {
    "id": 60,
    "subtopic_id": 2,
    "type": "output_tracing",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "An `OracleEngine` predicts destiny based on `initialScore` and `modifier`, leading to a `destinyScore` that may overflow. `omenType` and `prophecyFulfilled` are set conditionally. Your task is to trace the code and determine the `Final Destiny Score`, `Omen Type`, and `Prophecy Fulfilled` status.",
    "story_context": "The OracleEngine needs to predict destiny based on scores and handle overflow scenarios. Your task is to trace the overflow calculation and conditional logic to predict the outputs.",
    "challenge_data": {
      "code": "public class OracleEngine {\n    public static void main(String[] args) {\n        byte initialScore = 125;\n        short modifier = 10;\n        char omenType = '?';\n        boolean prophecyFulfilled = false;\n\n        byte destinyScore = (byte) (initialScore + modifier);\n\n        if (destinyScore < 0) {\n            omenType = '!';\n            prophecyFulfilled = true;\n        } else if (destinyScore > 100) {\n            omenType = '+';\n        } else {\n            omenType = '.';\n        }\n        \n        if (!prophecyFulfilled) {\n            omenType = '#';\n        }\n\n        System.out.println(\"Final Destiny Score: \" + destinyScore);\n        System.out.println(\"Omen Type: \" + omenType);\n        System.out.println(\"Prophecy Fulfilled: \" + prophecyFulfilled);\n    }\n}",
      "expected_output": [
        "Final Destiny Score: -121",
        "Omen Type: !",
        "Prophecy Fulfilled: true"
      ],
      "choices": [
        "Final Destiny Score: 135",
        "Prophecy Fulfilled: false",
        "Final Destiny Score: -121",
        "Omen Type: !",
        "Prophecy Fulfilled: true",
        "Omen Type: +"
      ],
      "explanation": "1. Variables initialized: `initialScore = 125`, `modifier = 10`.\n2. `byte destinyScore = (byte) (initialScore + modifier);` calculates `125 + 10 = 135`. `135` exceeds `byte` max (`127`), causing an **overflow**. `135` wraps around to `-121`. So, `destinyScore` is `-121`.\n3. `if (destinyScore < 0)`: `-121 < 0` is `true`. The block is entered.\n    * `omenType = '!';` updates `omenType` to `'!'`.\n    * `prophecyFulfilled = true;` updates `prophecyFulfilled` to `true`.\n4. `if (!prophecyFulfilled)`: `!true` is `false`. This block is skipped.\n5. **Output 1**: `System.out.println(\"Final Destiny Score: \" + destinyScore);` prints \"Final Destiny Score: -121\".\n6. **Output 2**: `System.out.println(\"Omen Type: \" + omenType);` prints \"Omen Type: !\"'.\n7. **Output 3**: `System.out.println(\"Prophecy Fulfilled: \" + prophecyFulfilled);` prints \"Prophecy Fulfilled: true\"."
    },
    "hints": {
      "1": "Carefully calculate the `destinyScore`, remembering the `byte` data type's range (`-128` to `127`) and how overflow occurs.",
      "2": "Trace `omenType` and `prophecyFulfilled` through the first `if-else if-else` chain based on the `destinyScore`.",
      "3": "Then, evaluate the final `if (!prophecyFulfilled)` condition to see if `omenType` is *further* modified."
    }
  },
  {
    "id": 61,
    "subtopic_id": 2,
    "type": "code_fixer",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `ViscosityTester` measures `arcaneViscosity`. The `elixirDensity` variable is declared as a `float`, but the literal value assigned to it is treated as a `double` by default, causing a potential loss of precision. Fix the code to ensure the `float` variable correctly stores the decimal value.",
    "story_context": "The ViscosityTester needs precise measurements. Your task is to fix the float literal declaration.",
    "challenge_data": {
      "initial_code": "public class ViscosityTester {\n    public static void main(String[] args) {\n        float arcaneViscosity = 3.14;\n        System.out.println(\"Arcane Viscosity: \" + arcaneViscosity);\n    }\n}",
      "expected_output": [
        "Arcane Viscosity: 3.14"
      ],
      "solution_code": "public class ViscosityTester {\n    public static void main(String[] args) {\n        float arcaneViscosity = 3.14f;\n        System.out.println(\"Arcane Viscosity: \" + arcaneViscosity);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 3,
          "type": "literal_declaration",
          "description": "Missing 'f' suffix for float literal",
          "fix": "Add 'f' suffix: float arcaneViscosity = 3.14f;"
        }
      ],
      "number_of_errors": 1,
      "explanation": "In Java, floating-point literals (numbers with decimal points like `3.14`) are treated as `double` by default. Attempting to assign a `double` literal directly to a `float` variable without casting or explicit `f` suffix causes a \"possible lossy conversion\" error. The fix is to add the `f` (or `F`) suffix to the literal (`3.14f`), explicitly marking it as a `float` literal."
    },
    "hints": {
      "1": "By default, decimal numbers in Java are treated as a specific precision type.",
      "2": "If you want a decimal number to be explicitly a `float`, it needs a special marker.",
      "3": "Look for a simple way to tell Java \"this is a `float`, not a `double`.\""
    }
  },
  {
    "id": 62,
    "subtopic_id": 2,
    "type": "code_fixer",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `DustCollector` tracks `crystalDust`. The literal value assigned to `crystalDust` is too large for an `int` variable, leading to a compilation error. Fix the code to correctly store this large integer value.",
    "story_context": "The DustCollector needs to track large amounts of crystal dust. Your task is to fix the data type for the large integer value.",
    "challenge_data": {
      "initial_code": "public class DustCollector {\n    public static void main(String[] args) {\n        int crystalDust = 3000000000;\n        System.out.println(\"Crystal Dust: \" + crystalDust);\n    }\n}",
      "expected_output": [
        "Crystal Dust: 3000000000"
      ],
      "solution_code": "public class DustCollector {\n    public static void main(String[] args) {\n        long crystalDust = 3000000000L;\n        System.out.println(\"Crystal Dust: \" + crystalDust);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 3,
          "type": "variable_declaration",
          "description": "Value too large for int type",
          "fix": "Change int to long: long crystalDust = 3000000000L;"
        },
        {
          "id": 2,
          "line": 3,
          "type": "literal_declaration",
          "description": "Missing 'L' suffix for long literal",
          "fix": "Add 'L' suffix: long crystalDust = 3000000000L;"
        }
      ],
      "number_of_errors": 2,
      "explanation": "The literal `3000000000` is too large to fit into an `int` variable, leading to a compilation error. `long` is the primitive data type used for larger integer values. Additionally, to explicitly tell Java that a large integer literal should be treated as a `long`, the `L` (or `l`) suffix must be appended to the number. The fix changes the type to `long` and adds the `L` suffix."
    },
    "hints": {
      "1": "An `int` has a defined maximum positive value (approx. 2.1 billion).",
      "2": "If a whole number literal exceeds this `int` limit, it's considered a different type.",
      "3": "Adding a specific suffix to a large integer literal can explicitly tell Java its intended type."
    }
  },
  {
    "id": 63,
    "subtopic_id": 2,
    "type": "code_fixer",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `CharmController` sets the `activeState` of a magical charm. However, an integer value is assigned to a `boolean` variable, causing a type mismatch. Fix the code to correctly set the `activeState`.",
    "story_context": "The CharmController needs to set the charm's active state. Your task is to fix the boolean assignment.",
    "challenge_data": {
      "initial_code": "public class CharmController {\n    public static void main(String[] args) {\n        boolean activeState = 1;\n        System.out.println(\"Charm Active: \" + activeState);\n    }\n}",
      "expected_output": [
        "Charm Active: true"
      ],
      "solution_code": "public class CharmController {\n    public static void main(String[] args) {\n        boolean activeState = true;\n        System.out.println(\"Charm Active: \" + activeState);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 3,
          "type": "type_mismatch",
          "description": "Cannot assign integer to boolean variable",
          "fix": "Change 1 to true: boolean activeState = true;"
        }
      ],
      "number_of_errors": 1,
      "explanation": "In Java, `boolean` variables can only store the literal values `true` or `false`. Attempting to assign an integer (`1`) to a `boolean` variable results in a type mismatch compilation error. The fix is to assign the correct boolean literal, `true` (or `false`), to `activeState`."
    },
    "hints": {
      "1": "Boolean variables can only store one of two specific literal values.",
      "2": "Unlike some other languages, Java does not treat numbers (like 0 or 1) as boolean equivalents.",
      "3": "Recall the exact keywords for boolean truth values."
    }
  },
  {
    "id": 64,
    "subtopic_id": 2,
    "type": "code_fixer",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `RuneSketcher` creates runes. A `char` variable `letterRune` is intended to store a single character, but a string literal is assigned to it, leading to a type mismatch. Fix the code to correctly assign the character 'X' to `letterRune`.",
    "story_context": "The RuneSketcher needs to create single character runes. Your task is to fix the character literal assignment.",
    "challenge_data": {
      "initial_code": "public class RuneSketcher {\n    public static void main(String[] args) {\n        char letterRune = \"X\";\n        System.out.println(\"Letter Rune: \" + letterRune);\n    }\n}",
      "expected_output": [
        "Letter Rune: X"
      ],
      "solution_code": "public class RuneSketcher {\n    public static void main(String[] args) {\n        char letterRune = 'X';\n        System.out.println(\"Letter Rune: \" + letterRune);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 3,
          "type": "literal_declaration",
          "description": "Using double quotes for char literal instead of single quotes",
          "fix": "Change \"X\" to 'X': char letterRune = 'X';"
        }
      ],
      "number_of_errors": 1,
      "explanation": "In Java, a `char` literal must be enclosed in single quotes (`' '`), while double quotes (`\" \"`) are used for `String` literals. Attempting to assign a `String` literal to a `char` variable results in a type mismatch. The fix is to change the double quotes to single quotes for the character literal."
    },
    "hints": {
      "1": "In Java, there's a strict difference between a single character and a string of characters.",
      "2": "Literal characters are enclosed by a specific type of quote.",
      "3": "Double quotes are typically for sequences of characters."
    }
  },
  {
    "id": 65,
    "subtopic_id": 2,
    "type": "code_fixer",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "An `ImpGathering` system counts `impsPresent`. A `byte` variable is used, but the literal value `130` is outside its valid range, causing a compilation error. Fix the code to correctly assign a value within the `byte`'s range.",
    "story_context": "The ImpGathering system needs to count imps within valid limits. Your task is to fix the byte value assignment.",
    "challenge_data": {
      "initial_code": "public class ImpGathering {\n    public static void main(String[] args) {\n        byte impsPresent = 130;\n        System.out.println(\"Imps Present: \" + impsPresent);\n    }\n}",
      "expected_output": [
        "Imps Present: 120"
      ],
      "solution_code": "public class ImpGathering {\n    public static void main(String[] args) {\n        byte impsPresent = 120;\n        System.out.println(\"Imps Present: \" + impsPresent);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 3,
          "type": "literal_declaration",
          "description": "Value 130 exceeds byte range (-128 to 127)",
          "fix": "Change 130 to 120: byte impsPresent = 120;"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The `byte` data type in Java has a range from `-128` to `127`. The literal `130` exceeds this range. Java implicitly treats integer literals as `int`s by default, and `130` (as an `int`) cannot be directly assigned to a `byte` without a lossy conversion. The simplest fix is to change the value to something within the valid `byte` range, such as `120`."
    },
    "hints": {
      "1": "Recall the maximum positive value a `byte` can store.",
      "2": "If a literal integer exceeds the `byte` range, Java treats it as an `int` by default, leading to a type mismatch when assigned to a `byte`.",
      "3": "The goal is to provide a valid `byte` literal."
    }
  },
  {
    "id": 66,
    "subtopic_id": 2,
    "type": "code_fixer",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `CrystalChargeCalibrator` measures `rawCharge` as a `double` and tries to assign it to an `int` variable `chargeLevel`, causing a compilation error due to potential data loss. Fix the code to correctly store the `chargeLevel` while preserving precision where intended.",
    "story_context": "The CrystalChargeCalibrator needs precise measurements. Your task is to fix the type assignment to preserve precision.",
    "challenge_data": {
      "initial_code": "public class CrystalChargeCalibrator {\n    public static void main(String[] args) {\n        double rawCharge = 15.7;\n        int chargeLevel = rawCharge;\n        System.out.println(\"Crystal Charge: \" + chargeLevel);\n    }\n}",
      "expected_output": [
        "Crystal Charge: 15.7"
      ],
      "solution_code": "public class CrystalChargeCalibrator {\n    public static void main(String[] args) {\n        double rawCharge = 15.7;\n        double chargeLevel = rawCharge;\n        System.out.println(\"Crystal Charge: \" + chargeLevel);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 4,
          "type": "variable_declaration",
          "description": "chargeLevel should be double to preserve precision",
          "fix": "Change int to double: double chargeLevel = rawCharge;"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The variable `rawCharge` is a `double` (a decimal number). Attempting to assign its value directly to an `int` variable (`chargeLevel`) causes a \"possible lossy conversion\" compilation error, as the fractional part (`.7`) would be lost. To retain the full precision of the charge level, `chargeLevel` must be declared as a `double` (or `float`, if less precision is acceptable and space is a concern)."
    },
    "hints": {
      "1": "Remember that `int` variables can only store whole numbers.",
      "2": "Assigning a `double` to an `int` without explicit conversion will cause a compilation error due to potential data loss.",
      "3": "Consider the data type that precisely stores decimal values."
    }
  },
  {
    "id": 67,
    "subtopic_id": 2,
    "type": "code_fixer",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `GoblinManager` counts `goblinMinions`. Adding `newArrivals` to `goblinMinions` exceeds the `byte`'s maximum range, causing an overflow. Fix the code to correctly store the total count of goblin minions.",
    "story_context": "The GoblinManager needs to track the total count of goblin minions. Your task is to fix the data type to prevent overflow.",
    "challenge_data": {
      "initial_code": "public class GoblinManager {\n    public static void main(String[] args) {\n        byte goblinMinions = 120;\n        int newArrivals = 30;\n        goblinMinions = (byte) (goblinMinions + newArrivals);\n        System.out.println(\"Total Goblin Minions: \" + goblinMinions);\n    }\n}",
      "expected_output": [
        "Total Goblin Minions: 150"
      ],
      "solution_code": "public class GoblinManager {\n    public static void main(String[] args) {\n        short goblinMinions = 120;\n        int newArrivals = 30;\n        goblinMinions = (short) (goblinMinions + newArrivals);\n        System.out.println(\"Total Goblin Minions: \" + goblinMinions);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 3,
          "type": "variable_declaration",
          "description": "byte type too small for sum of 150",
          "fix": "Change byte to short: short goblinMinions = 120;"
        },
        {
          "id": 2,
          "line": 5,
          "type": "type_casting",
          "description": "Cast to byte causes overflow, should cast to short",
          "fix": "Change (byte) to (short): goblinMinions = (short) (goblinMinions + newArrivals);"
        }
      ],
      "number_of_errors": 2,
      "explanation": "The sum `goblinMinions + newArrivals` (`120 + 30 = 150`) exceeds the maximum positive value a `byte` can hold (`127`). When `150` is cast back to `byte` using `(byte)`, it causes an overflow, resulting in `-106`. To correctly store `150`, a larger integer type like `short` (range -32,768 to 32,767) is appropriate. The fix changes `goblinMinions` to `short` and adjusts the cast."
    },
    "hints": {
      "1": "Recall the range of a `byte` data type (up to `127`).",
      "2": "The sum `120 + 30 = 150` exceeds the `byte` limit.",
      "3": "Consider a slightly larger integer primitive type that can comfortably hold `150`."
    }
  },
  {
    "id": 68,
    "subtopic_id": 2,
    "type": "code_fixer",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "An `ElementalRitual` sets `elementsAligned` based on `fireEnergy`. However, boolean literals (`true`/`false`) are incorrectly assigned to a `String` variable, causing a type mismatch. Fix the code to correctly store the `elementsAligned` status.",
    "story_context": "The ElementalRitual needs to track alignment status. Your task is to fix the variable type assignment.",
    "challenge_data": {
      "initial_code": "public class ElementalRitual {\n    public static void main(String[] args) {\n        int fireEnergy = 100;\n        String elementsAligned;\n\n        if (fireEnergy > 90) {\n            elementsAligned = true;\n        } else {\n            elementsAligned = false;\n        }\n        System.out.println(\"Elements Aligned: \" + elementsAligned);\n    }\n}",
      "expected_output": [
        "Elements Aligned: true"
      ],
      "solution_code": "public class ElementalRitual {\n    public static void main(String[] args) {\n        int fireEnergy = 100;\n        boolean elementsAligned;\n\n        if (fireEnergy > 90) {\n            elementsAligned = true;\n        } else {\n            elementsAligned = false;\n        }\n        System.out.println(\"Elements Aligned: \" + elementsAligned);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 4,
          "type": "variable_declaration",
          "description": "elementsAligned should be boolean, not String",
          "fix": "Change String to boolean: boolean elementsAligned;"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The values `true` and `false` are boolean literals. Attempting to assign these to a `String` variable (`elementsAligned`) results in a type mismatch compilation error. The fix is to change the data type of `elementsAligned` from `String` to `boolean`, allowing it to correctly store the logical state."
    },
    "hints": {
      "1": "The values `true` and `false` are specific to a certain primitive type.",
      "2": "A `String` holds sequences of characters, not logical states directly.",
      "3": "Look at the type of data being assigned to `elementsAligned`."
    }
  },
  {
    "id": 69,
    "subtopic_id": 2,
    "type": "code_fixer",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `RuneDecoder` attempts to decode a `rune` by assigning an integer ASCII value to a `char` variable. This causes a compilation error due to type conversion rules. Fix the code to correctly convert the integer value to its corresponding `char`.",
    "story_context": "The RuneDecoder needs to convert ASCII values to characters. Your task is to fix the type casting.",
    "challenge_data": {
      "initial_code": "public class RuneDecoder {\n    public static void main(String[] args) {\n        char decodedRune = 70;\n        System.out.println(\"Decoded Rune: \" + decodedRune);\n    }\n}",
      "expected_output": [
        "Decoded Rune: F"
      ],
      "solution_code": "public class RuneDecoder {\n    public static void main(String[] args) {\n        char decodedRune = (char) 70;\n        System.out.println(\"Decoded Rune: \" + decodedRune);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 3,
          "type": "type_casting",
          "description": "Missing explicit cast from int to char",
          "fix": "Add (char) cast: char decodedRune = (char) 70;"
        }
      ],
      "number_of_errors": 1,
      "explanation": "Although `char` values are internally represented by integer codes (ASCII/Unicode), directly assigning an `int` literal to a `char` variable can result in a \"possible lossy conversion\" error if the `int` value is outside the `char` range (0 to 65535). Even if it's within range, explicit casting `(char)` is often required to clarify the intent of conversion. The fix adds the `(char)` cast, telling the compiler to explicitly convert the integer `70` to its character representation ('F')."
    },
    "hints": {
      "1": "While `char` values are backed by numbers, direct assignment of an `int` literal might be ambiguous or cause a compiler error for potential loss of data (if the int value is out of char range).",
      "2": "There's a way to explicitly tell Java to treat a number as a character.",
      "3": "What's the common mechanism for converting one data type to another?"
    }
  },
  {
    "id": 70,
    "subtopic_id": 2,
    "type": "code_fixer",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `SpellTimer` records `spellCastTime`. The variable is a `float`, but the literal assigned is a `double` by default, leading to a compilation error due to potential precision loss. Fix the code to correctly assign the decimal value to the `float` variable.",
    "story_context": "The SpellTimer needs precise timing measurements. Your task is to fix the float literal declaration.",
    "challenge_data": {
      "initial_code": "public class SpellTimer {\n    public static void main(String[] args) {\n        float spellCastTime = 0.123456789;\n        System.out.println(\"Spell Cast Time: \" + spellCastTime);\n    }\n}",
      "expected_output": [
        "Spell Cast Time: 0.12345679"
      ],
      "solution_code": "public class SpellTimer {\n    public static void main(String[] args) {\n        float spellCastTime = 0.123456789f;\n        System.out.println(\"Spell Cast Time: \" + spellCastTime);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 3,
          "type": "literal_declaration",
          "description": "Missing 'f' suffix for float literal",
          "fix": "Add 'f' suffix: float spellCastTime = 0.123456789f;"
        }
      ],
      "number_of_errors": 1,
      "explanation": "In Java, a floating-point literal like `0.123456789` is by default treated as a `double`. Assigning a `double` to a `float` directly can cause a \"possible lossy conversion\" error because `double` has higher precision than `float`. The common fix is to explicitly make the literal a `float` by adding the `f` suffix (`0.123456789f`). Alternatively, the variable `spellCastTime` could be declared as a `double` if higher precision is desired."
    },
    "hints": {
      "1": "Remember that decimal literals (`0.123...`) are `double` by default in Java.",
      "2": "Assigning a `double` to a `float` can result in a compilation error if not handled.",
      "3": "Consider adding a specific suffix to the numerical literal to designate it as a `float`."
    }
  },
  {
    "id": 71,
    "subtopic_id": 2,
    "type": "code_fixer",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `CosmicDustCollector` calculates `totalDustAccumulated` using large `long` values. However, their sum exceeds the maximum capacity of a `long`, causing an integer overflow. Fix the code to correctly handle and store this extremely large sum.",
    "story_context": "The CosmicDustCollector needs to handle extremely large numbers. Your task is to fix the data type to prevent overflow.",
    "challenge_data": {
      "initial_code": "import java.math.BigInteger;\n\npublic class CosmicDustCollector {\n    public static void main(String[] args) {\n        long initialDust = 9000000000000000000L;\n        long newDust = 2000000000000000000L;\n        long totalDustAccumulated = initialDust + newDust;\n        System.out.println(\"Total Dust Accumulated: \" + totalDustAccumulated);\n    }\n}",
      "expected_output": [
        "Total Dust Accumulated: 11000000000000000000"
      ],
      "solution_code": "import java.math.BigInteger;\n\npublic class CosmicDustCollector {\n    public static void main(String[] args) {\n        BigInteger initialDust = BigInteger.valueOf(9000000000000000000L);\n        BigInteger newDust = BigInteger.valueOf(2000000000000000000L);\n        BigInteger totalDustAccumulated = initialDust.add(newDust);\n        System.out.println(\"Total Dust Accumulated: \" + totalDustAccumulated);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 5,
          "type": "variable_declaration",
          "description": "initialDust should be BigInteger to handle large values",
          "fix": "Change to BigInteger: BigInteger initialDust = BigInteger.valueOf(9000000000000000000L);"
        },
        {
          "id": 2,
          "line": 6,
          "type": "variable_declaration",
          "description": "newDust should be BigInteger to handle large values",
          "fix": "Change to BigInteger: BigInteger newDust = BigInteger.valueOf(2000000000000000000L);"
        },
        {
          "id": 3,
          "line": 7,
          "type": "variable_declaration",
          "description": "totalDustAccumulated should be BigInteger to handle large values",
          "fix": "Change to BigInteger: BigInteger totalDustAccumulated = initialDust.add(newDust);"
        },
        {
          "id": 4,
          "line": 7,
          "type": "operation",
          "description": "Use BigInteger.add() method instead of + operator",
          "fix": "Use add() method: BigInteger totalDustAccumulated = initialDust.add(newDust);"
        }
      ],
      "number_of_errors": 4,
      "explanation": "The sum of `initialDust` and `newDust` (`11 x 10^18`) exceeds the maximum value a `long` primitive can store (`9,223,372,036,854,775,807`). This results in an **integer overflow**, causing `totalDustAccumulated` to wrap around to a negative number or an incorrect positive value. For calculations involving numbers larger than `long.MAX_VALUE`, Java's `java.math.BigInteger` class (a non-primitive type, but crucial for handling numbers beyond primitive limits) must be used. The fix involves converting the `long` literals to `BigInteger` objects and performing the addition using `BigInteger`'s `add()` method."
    },
    "hints": {
      "1": "Recall the maximum value that a `long` primitive can hold (approx. 9.2 x 10^18).",
      "2": "The sum of the two given `long` literals (`9 x 10^18 + 2 x 10^18 = 11 x 10^18`) clearly exceeds this limit.",
      "3": "When primitive types cannot hold a value, Java offers a special class for arbitrary-precision arithmetic."
    }
  },
  {
    "id": 72,
    "subtopic_id": 2,
    "type": "code_fixer",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "An `ElementalConduitMonitor` tracks `currentEnergy`. Multiplying `currentEnergy` (an `int`) by `drainFactor` (a `double`) then assigning the result back to an `int` without proper casting causes a compilation error. Fix the code to correctly calculate and store the `currentEnergy`.",
    "story_context": "The ElementalConduitMonitor needs to calculate energy levels. Your task is to fix the type casting in the calculation.",
    "challenge_data": {
      "initial_code": "public class ElementalConduitMonitor {\n    public static void main(String[] args) {\n        int currentEnergy = 50;\n        double drainFactor = 0.6;\n        boolean emergencyShutdown = false;\n\n        currentEnergy = (int) currentEnergy * drainFactor;\n        \n        if (currentEnergy < 0) {\n            emergencyShutdown = true;\n        }\n        System.out.println(\"Current Energy: \" + currentEnergy);\n        System.out.println(\"Emergency Shutdown: \" + emergencyShutdown);\n    }\n}",
      "expected_output": [
        "Current Energy: 30",
        "Emergency Shutdown: false"
      ],
      "solution_code": "public class ElementalConduitMonitor {\n    public static void main(String[] args) {\n        int currentEnergy = 50;\n        double drainFactor = 0.6;\n        boolean emergencyShutdown = false;\n\n        currentEnergy = (int) (currentEnergy * drainFactor);\n        \n        if (currentEnergy < 0) {\n            emergencyShutdown = true;\n        }\n        System.out.println(\"Current Energy: \" + currentEnergy);\n        System.out.println(\"Emergency Shutdown: \" + emergencyShutdown);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 7,
          "type": "type_casting",
          "description": "Cast should apply to entire expression, not just currentEnergy",
          "fix": "Add parentheses: currentEnergy = (int) (currentEnergy * drainFactor);"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code `currentEnergy = (int) currentEnergy * drainFactor;` attempts to cast `currentEnergy` (which is already an `int`) and then multiply by `drainFactor`. However, the result of `int * double` is a `double`. Trying to assign this `double` result back to an `int` variable (`currentEnergy`) without casting the *entire expression* causes a compilation error (possible lossy conversion). The fix is to ensure the multiplication `currentEnergy * drainFactor` occurs first, and *then* the entire `double` result is explicitly cast to `int` for assignment: `currentEnergy = (int) (currentEnergy * drainFactor);`. This correctly calculates `30.0` and truncates it to `30`, and `emergencyShutdown` remains `false` as `30` is not less than `0`."
    },
    "hints": {
      "1": "The `(int)` cast has higher precedence than multiplication unless parentheses change it.",
      "2": "Multiplying an `int` by a `double` will promote the `int` to `double` for the calculation.",
      "3": "If you want the entire result of an expression involving `double` to be an `int`, the cast needs to apply to the *entire expression*."
    }
  },
  {
    "id": 73,
    "subtopic_id": 2,
    "type": "code_fixer",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "An `OracleSystem` sets a `prophecyOutcome` based on whether an `omenRevealed`. The `prophecyOutcome` variable is local and might not be initialized if the `if` condition is `false`, causing a compilation error. Fix the code to ensure `prophecyOutcome` is always initialized.",
    "story_context": "The OracleSystem needs to ensure prophecies are always available. Your task is to fix the variable initialization.",
    "challenge_data": {
      "initial_code": "public class OracleSystem {\n    public static void main(String[] args) {\n        int initialMana = 100;\n        boolean omenRevealed = false;\n        String prophecyOutcome;\n\n        if (initialMana > 90) {\n            omenRevealed = true;\n        }\n\n        if (omenRevealed) {\n            prophecyOutcome = \"Great fortune awaits!\";\n        }\n        \n        System.out.println(\"Prophecy: \" + prophecyOutcome);\n    }\n}",
      "expected_output": [
        "Prophecy: Great fortune awaits!"
      ],
      "solution_code": "public class OracleSystem {\n    public static void main(String[] args) {\n        int initialMana = 100;\n        boolean omenRevealed = false;\n        String prophecyOutcome = \"Future is uncertain.\";\n\n        if (initialMana > 90) {\n            omenRevealed = true;\n        }\n\n        if (omenRevealed) {\n            prophecyOutcome = \"Great fortune awaits!\";\n        }\n        \n        System.out.println(\"Prophecy: \" + prophecyOutcome);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 5,
          "type": "variable_initialization",
          "description": "prophecyOutcome might not be initialized if omenRevealed is false",
          "fix": "Initialize with default value: String prophecyOutcome = \"Future is uncertain.\";"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The `prophecyOutcome` variable is a local variable. Java requires all local variables to be explicitly initialized before they are used. In the original code, if `omenRevealed` were `false` (e.g., if `initialMana` was less than or equal to `90`), `prophecyOutcome` would never be assigned a value before being used in `System.out.println()`, leading to a \"variable might not have been initialized\" error. The fix is to provide a default initialization value (e.g., `\"Future is uncertain.\"`) when `prophecyOutcome` is declared, guaranteeing it always has a value."
    },
    "hints": {
      "1": "Java's \"definitely assigned\" rule for local variables is very strict.",
      "2": "Even if a condition *seems* like it will always be true or false, the compiler checks all possible execution paths.",
      "3": "Consider providing a default or initial value at the point of declaration to satisfy the compiler."
    }
  },
  {
    "id": 74,
    "subtopic_id": 2,
    "type": "code_fixer",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `SpellResultDecoder` attempts to convert a `numericalResult` (an `int`) into a `char` for `spellResultCode`. Directly assigning an `int` to a `char` (especially a negative `int`) causes a compilation error. Fix the code to correctly convert the numerical result to a `char`.",
    "story_context": "The SpellResultDecoder needs to convert numerical results to characters. Your task is to fix the type casting.",
    "challenge_data": {
      "initial_code": "public class SpellResultDecoder {\n    public static void main(String[] args) {\n        int numericalResult = -50;\n        char spellResultCode = numericalResult;\n        System.out.println(\"Spell Result Code: \" + spellResultCode);\n    }\n}",
      "expected_output": [
        "Spell Result Code: "
      ],
      "solution_code": "public class SpellResultDecoder {\n    public static void main(String[] args) {\n        int numericalResult = -50;\n        char spellResultCode = (char) numericalResult;\n        System.out.println(\"Spell Result Code: \" + spellResultCode);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 4,
          "type": "type_casting",
          "description": "Missing explicit cast from int to char",
          "fix": "Add (char) cast: char spellResultCode = (char) numericalResult;"
        }
      ],
      "number_of_errors": 1,
      "explanation": "Directly assigning an `int` value (especially a negative one like `-50`) to a `char` variable is a \"possible lossy conversion\" and causes a compilation error. While `char` is an unsigned 16-bit integer type internally (0 to 65535), `int` is signed 32-bit. To explicitly convert an `int` to a `char`, a cast `(char)` is required. When a negative `int` is cast to `char`, its bits are reinterpreted, resulting in a positive `char` value (e.g., `-50` becomes `65486`). This character might be unprintable, often displayed as a replacement character ()."
    },
    "hints": {
      "1": "The `char` data type represents Unicode characters, which have an integer value range from 0 to 65535.",
      "2": "Assigning an `int` directly to a `char` can be problematic if the `int` is negative or very large, requiring explicit conversion.",
      "3": "Consider how Java handles integer values that don't fit into a `char` when explicitly cast."
    }
  },
  {
    "id": 75,
    "subtopic_id": 2,
    "type": "code_fixer",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "An `ArcaneForceCalculator` determines `arcaneForce` from `baseStrength` (float) and `fluxFactor` (double). Assigning the `double` result of their multiplication directly to a `float` causes a compilation error due to precision loss. Fix the code to correctly store `arcaneForce` as a `float`.",
    "story_context": "The ArcaneForceCalculator needs precise force calculations. Your task is to fix the type casting to preserve precision.",
    "challenge_data": {
      "initial_code": "public class ArcaneForceCalculator {\n    public static void main(String[] args) {\n        float baseStrength = 100.5f;\n        double fluxFactor = 0.3333333333333333;\n        float arcaneForce = baseStrength * fluxFactor;\n        System.out.println(\"Arcane Force: \" + arcaneForce);\n    }\n}",
      "expected_output": [
        "Arcane Force: 33.500004"
      ],
      "solution_code": "public class ArcaneForceCalculator {\n    public static void main(String[] args) {\n        float baseStrength = 100.5f;\n        double fluxFactor = 0.3333333333333333;\n        float arcaneForce = (float) (baseStrength * fluxFactor);\n        System.out.println(\"Arcane Force: \" + arcaneForce);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 5,
          "type": "type_casting",
          "description": "Missing explicit cast from double to float",
          "fix": "Add (float) cast: float arcaneForce = (float) (baseStrength * fluxFactor);"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The expression `baseStrength * fluxFactor` involves a `float` and a `double`. Java's type promotion rules dictate that the `float` (`baseStrength`) will be promoted to a `double` for the calculation, resulting in a `double` value. Attempting to assign this `double` result directly back to a `float` variable (`arcaneForce`) causes a \"possible lossy conversion\" compilation error. To fix this, you must explicitly cast the entire result of the multiplication to `float` using `(float)`. This tells Java that you are aware of and accept the potential loss of precision. (Alternatively, changing `arcaneForce` to `double` would also resolve the error, but the prompt implies a `float` is desired)."
    },
    "hints": {
      "1": "When a `float` and `double` are involved in an arithmetic operation, Java performs `type promotion` to the higher precision type.",
      "2": "The result of the multiplication (`baseStrength * fluxFactor`) will be of the higher precision type.",
      "3": "Assigning a higher precision value to a lower precision variable without explicit handling causes a \"possible lossy conversion\" error."
    }
  },
  {
    "id": 76,
    "subtopic_id": 2,
    "type": "code_completion",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `ManaPool` system tracks its `manaCapacity`. The `manaCapacity` variable needs to be declared to hold a whole number. Complete the declaration.",
    "story_context": "The ManaPool needs to track mana capacity. Your task is to complete the variable declaration.",
    "challenge_data": {
      "initial_code": "public class ManaPool {\n    public static void main(String[] args) {\n        ??? manaCapacity = 100;\n        System.out.println(\"Mana Capacity: \" + manaCapacity);\n    }\n}",
      "expected_output": [
        "Mana Capacity: 100"
      ],
      "solution_code": "public class ManaPool {\n    public static void main(String[] args) {\n        int manaCapacity = 100;\n        System.out.println(\"Mana Capacity: \" + manaCapacity);\n    }\n}",
      "choices": [
        "char",
        "int",
        "boolean",
        "double"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 3,
          "type": "variable_declaration",
          "description": "Variable type declaration for manaCapacity",
          "correct_answer": "int",
          "explanation": "The value `100` is a whole number. The `int` primitive data type is used for integers in Java."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": "The value `100` is a whole number.",
      "2": "Recall the Java primitive type used for integers.",
      "3": "The variable name is `manaCapacity`."
    }
  },
  {
    "id": 77,
    "subtopic_id": 2,
    "type": "code_completion",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `CharmGuardian` activates a `protectionCharm`. The `protectionCharmActive` variable needs to be declared as a boolean and initialized to `true`. Complete the declaration and initialization.",
    "story_context": "The CharmGuardian needs to activate protection charms. Your task is to complete the variable declaration and initialization.",
    "challenge_data": {
      "initial_code": "public class CharmGuardian {\n    public static void main(String[] args) {\n        ??? = ???;\n        System.out.println(\"Protection Charm Active: \" + protectionCharmActive);\n    }\n}",
      "expected_output": [
        "Protection Charm Active: true"
      ],
      "solution_code": "public class CharmGuardian {\n    public static void main(String[] args) {\n        boolean protectionCharmActive = true;\n        System.out.println(\"Protection Charm Active: \" + protectionCharmActive);\n    }\n}",
      "choices": [
        "boolean protectionCharmActive",
        "int protectionCharmActive",
        "true",
        "false"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 3,
          "type": "variable_name",
          "description": "Variable name for the boolean protection charm status",
          "correct_answer": "boolean protectionCharmActive",
          "explanation": "The variable should be named `protectionCharmActive` as indicated by the print statement."
        },
        {
          "id": "slot_2",
          "line": 3,
          "type": "variable_initialization",
          "description": "Boolean value initialization for protection charm status",
          "correct_answer": "true",
          "explanation": "The scenario explicitly states the initial state should be `true`."
        }
      ],
      "number_of_slots": 2
    },
    "hints": {
      "1": "The variable should store a `true` or `false` value.",
      "2": "The scenario explicitly states the initial state.",
      "3": "Identify the correct type and literal for logical states."
    }
  },
  {
    "id": 78,
    "subtopic_id": 2,
    "type": "code_completion",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `MapPlotter` draws symbols on a magical map. The `mapSymbol` variable needs to be declared and initialized to hold the character '@'. Complete the declaration and initialization.",
    "story_context": "The MapPlotter needs to draw symbols on magical maps. Your task is to complete the variable declaration and initialization.",
    "challenge_data": {
      "initial_code": "public class MapPlotter {\n    public static void main(String[] args) {\n        ??? = ???;\n        System.out.println(\"Map Symbol: \" + mapSymbol);\n    }\n}",
      "expected_output": [
        "Map Symbol: @"
      ],
      "solution_code": "public class MapPlotter {\n    public static void main(String[] args) {\n        char mapSymbol = '@';\n        System.out.println(\"Map Symbol: \" + mapSymbol);\n    }\n}",
      "choices": [
        "String mapSymbol",
        "\"@\"",
        "char mapSymbol",
        "'@'"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 3,
          "type": "variable_declaration",
          "description": "Complete variable declaration for mapSymbol",
          "correct_answer": "char mapSymbol",
          "explanation": "The variable `mapSymbol` is meant to store a single character. The `char` primitive data type is used for single characters."
        },
        {
          "id": "slot_2",
          "line": 3,
          "type": "variable_initialization",
          "description": "Character value initialization for mapSymbol",
          "correct_answer": "'@'",
          "explanation": "Character literals are enclosed in single quotes in Java."
        }
      ],
      "number_of_slots": 2
    },
    "hints": {
      "1": "The variable is meant to hold a *single* character.",
      "2": "Recall the primitive type for single characters.",
      "3": "How are single character literals written in Java?"
    }
  },
  {
    "id": 79,
    "subtopic_id": 2,
    "type": "code_completion",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `PotionBrewer` measures `potionVolume`. The `potionVolume` variable needs to be declared to store a decimal value. Complete the declaration.",
    "story_context": "The PotionBrewer needs to measure potion volumes precisely. Your task is to complete the variable declaration.",
    "challenge_data": {
      "initial_code": "public class PotionBrewer {\n    public static void main(String[] args) {\n        ??? potionVolume = 5.75;\n        System.out.println(\"Potion Volume: \" + potionVolume);\n    }\n}",
      "expected_output": [
        "Potion Volume: 5.75"
      ],
      "solution_code": "public class PotionBrewer {\n    public static void main(String[] args) {\n        double potionVolume = 5.75;\n        System.out.println(\"Potion Volume: \" + potionVolume);\n    }\n}",
      "choices": [
        "int",
        "long",
        "float",
        "double"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 3,
          "type": "variable_declaration",
          "description": "Variable type declaration for potionVolume",
          "correct_answer": "double",
          "explanation": "The value `5.75` is a decimal number. In Java, `double` is the default and recommended primitive data type for floating-point numbers due to its higher precision."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": "The value `5.75` has a decimal point.",
      "2": "Recall the most commonly used Java primitive type for precise decimal numbers.",
      "3": "Decimal literals like `5.75` are treated as this type by default."
    }
  },
  {
    "id": 80,
    "subtopic_id": 2,
    "type": "code_completion",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "An `ImpScout` counts `impsSeen`. The `impsSeen` variable needs to be declared to store a small whole number efficiently. Complete the declaration.",
    "story_context": "The ImpScout needs to count imps efficiently. Your task is to complete the variable declaration.",
    "challenge_data": {
      "initial_code": "public class ImpScout {\n    public static void main(String[] args) {\n        ??? impsSeen = 15;\n        System.out.println(\"Imps Seen: \" + impsSeen);\n    }\n}",
      "expected_output": [
        "Imps Seen: 15"
      ],
      "solution_code": "public class ImpScout {\n    public static void main(String[] args) {\n        byte impsSeen = 15;\n        System.out.println(\"Imps Seen: \" + impsSeen);\n    }\n}",
      "choices": [
        "byte",
        "int",
        "short",
        "long"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 3,
          "type": "variable_declaration",
          "description": "Variable type declaration for impsSeen",
          "correct_answer": "byte",
          "explanation": "The value `15` is a small whole number. The `byte` primitive data type is the most memory-efficient integer type in Java, capable of storing values from `-128` to `127`."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": "The number `15` is a very small integer.",
      "2": "Recall the Java primitive type designed for the smallest range of whole numbers.",
      "3": "This type uses only 8 bits of memory."
    }
  },
  {
    "id": 81,
    "subtopic_id": 2,
    "type": "code_completion",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "An `ArcaneArchitecture` spell constructs magical spires. The `numberOfSpires` variable needs to be declared to store a medium-sized whole number. Complete the declaration.",
    "story_context": "The ArcaneArchitecture needs to track the number of magical spires. Your task is to complete the variable declaration.",
    "challenge_data": {
      "initial_code": "public class ArcaneArchitecture {\n    public static void main(String[] args) {\n        ??? = 30000;\n        System.out.println(\"Number of Spires: \" + numberOfSpires);\n    }\n}",
      "expected_output": [
        "Number of Spires: 30000"
      ],
      "solution_code": "public class ArcaneArchitecture {\n    public static void main(String[] args) {\n        short numberOfSpires = 30000;\n        System.out.println(\"Number of Spires: \" + numberOfSpires);\n    }\n}",
      "choices": [
        "byte numberOfSpires",
        "long numberOfSpires",
        "short numberOfSpires",
        "int numberOfSpires"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 3,
          "type": "variable_declaration",
          "description": "Complete variable declaration for numberOfSpires",
          "correct_answer": "short numberOfSpires",
          "explanation": "The number `30000` is an integer that exceeds the range of a `byte` (`-128` to `127`) but fits within the range of a `short` (`-32,768` to `32,767`). While `int` or `long` would also work, `short` is the most memory-efficient primitive type that can correctly store this value."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": "The number `30000` is a whole number, but too large for a `byte`.",
      "2": "Consider the primitive integer type that is larger than `byte` but smaller than `int`.",
      "3": "This type is typically 16-bit."
    }
  },
  {
    "id": 82,
    "subtopic_id": 2,
    "type": "code_completion",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `ScrollEvaluator` checks a magical scroll's condition. The `scrollCondition` variable needs to be declared and initialized as a `char` with the character '0', and `isPristine` needs to be declared as a boolean.",
    "story_context": "The ScrollEvaluator needs to check scroll conditions. Your task is to complete the variable declarations and initialization.",
    "challenge_data": {
      "initial_code": "public class ScrollEvaluator {\n    public static void main(String[] args) {\n        ??? scrollCondition = ???;\n        boolean isPristine;\n\n        if (scrollCondition == '0') {\n            isPristine = true;\n        } else {\n            isPristine = false;\n        }\n        System.out.println(\"Scroll Condition: \" + scrollCondition);\n        System.out.println(\"Is Pristine: \" + isPristine);\n    }\n}",
      "expected_output": [
        "Scroll Condition: 0",
        "Is Pristine: true"
      ],
      "solution_code": "public class ScrollEvaluator {\n    public static void main(String[] args) {\n        char scrollCondition = '0';\n        boolean isPristine;\n\n        if (scrollCondition == '0') {\n            isPristine = true;\n        } else {\n            isPristine = false;\n        }\n        System.out.println(\"Scroll Condition: \" + scrollCondition);\n        System.out.println(\"Is Pristine: \" + isPristine);\n    }\n}",
      "choices": [
        "char",
        "0",
        "'0'",
        "String"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 3,
          "type": "variable_declaration",
          "description": "Variable type declaration for scrollCondition",
          "correct_answer": "char",
          "explanation": "The `scrollCondition` variable is meant to store a single character, as implied by its comparison with `'0'`."
        },
        {
          "id": "slot_2",
          "line": 3,
          "type": "variable_initialization",
          "description": "Character value initialization for scrollCondition",
          "correct_answer": "'0'",
          "explanation": "To assign the character `0` as a literal, it must be enclosed in single quotes (`'0'`)."
        }
      ],
      "number_of_slots": 2
    },
    "hints": {
      "1": "The variable `scrollCondition` is expected to hold a single character.",
      "2": "The value `0` should be treated as a character, not a number.",
      "3": "How do you denote a character literal in Java?"
    }
  },
  {
    "id": 83,
    "subtopic_id": 2,
    "type": "code_completion",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `GolemCrafter` creates golems with a specific `golemWeight`. The `golemWeight` variable needs to be declared as a `float` to store a floating-point literal ending with 'f'. Complete the declaration.",
    "story_context": "The GolemCrafter needs to track golem weight precisely. Your task is to complete the variable declaration.",
    "challenge_data": {
      "initial_code": "public class GolemCrafter {\n    public static void main(String[] args) {\n        ??? = 500.0f;\n        System.out.println(\"Golem Weight: \" + golemWeight);\n    }\n}",
      "expected_output": [
        "Golem Weight: 500.0"
      ],
      "solution_code": "public class GolemCrafter {\n    public static void main(String[] args) {\n        float golemWeight = 500.0f;\n        System.out.println(\"Golem Weight: \" + golemWeight);\n    }\n}",
      "choices": [
        "float golemWeight",
        "int golemWeight",
        "long golemWeight",
        "double golemWeight"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 3,
          "type": "variable_declaration",
          "description": "Complete variable declaration for golemWeight",
          "correct_answer": "float golemWeight",
          "explanation": "The literal `500.0f` is explicitly a `float` literal due to the `f` suffix. To correctly declare a variable that can hold this specific type of floating-point number, the `float` data type must be used."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": "Notice the `f` suffix on the numerical literal.",
      "2": "This suffix explicitly designates the literal as a specific primitive floating-point type.",
      "3": "The variable name is `golemWeight`."
    }
  },
  {
    "id": 84,
    "subtopic_id": 2,
    "type": "code_completion",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `ChargeCalculator` determines the `arcaneCharge` based on `baseCharge` and a `multiplier`. Complete the declaration of `arcaneCharge` to correctly store the result of the multiplication.",
    "story_context": "The ChargeCalculator needs to compute arcane charge values. Your task is to complete the variable declaration.",
    "challenge_data": {
      "initial_code": "public class ChargeCalculator {\n    public static void main(String[] args) {\n        int baseCharge = 25;\n        int multiplier = 3;\n        ??? = baseCharge * multiplier;\n        System.out.println(\"Arcane Charge: \" + arcaneCharge);\n    }\n}",
      "expected_output": [
        "Arcane Charge: 75"
      ],
      "solution_code": "public class ChargeCalculator {\n    public static void main(String[] args) {\n        int baseCharge = 25;\n        int multiplier = 3;\n        int arcaneCharge = baseCharge * multiplier;\n        System.out.println(\"Arcane Charge: \" + arcaneCharge);\n    }\n}",
      "choices": [
        "arcaneCharge",
        "int arcaneCharge",
        "double arcaneCharge",
        "String arcaneCharge"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 5,
          "type": "variable_declaration",
          "description": "Complete variable declaration for arcaneCharge",
          "correct_answer": "int arcaneCharge",
          "explanation": "The expression `baseCharge * multiplier` (`25 * 3`) results in `75`, which is an integer. Therefore, `int` is the appropriate primitive data type for `arcaneCharge`."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": "The result of `int * int` multiplication is always an `int`.",
      "2": "The missing part requires both the type and name for the `arcaneCharge` variable.",
      "3": "Ensure the chosen type can hold a whole number."
    }
  },
  {
    "id": 85,
    "subtopic_id": 2,
    "type": "code_completion",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `GolemTracker` records a `locationCode` based on an `asciiValue`. Complete the declaration and type casting to correctly convert the integer `asciiValue` into a `char` for `locationCode`.",
    "story_context": "The GolemTracker needs to convert ASCII values to location codes. Your task is to complete the variable declaration and type casting.",
    "challenge_data": {
      "initial_code": "public class GolemTracker {\n    public static void main(String[] args) {\n        int asciiValue = 90;\n        ??? = ???;\n        System.out.println(\"Golem Location: \" + locationCode);\n    }\n}",
      "expected_output": [
        "Golem Location: Z"
      ],
      "solution_code": "public class GolemTracker {\n    public static void main(String[] args) {\n        int asciiValue = 90;\n        char locationCode = (char) asciiValue;\n        System.out.println(\"Golem Location: \" + locationCode);\n    }\n}",
      "choices": [
        "asciiValue",
        "(char) asciiValue",
        "int locationCode",
        "char locationCode"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 4,
          "type": "variable_declaration",
          "description": "Variable declaration for locationCode",
          "correct_answer": "char locationCode",
          "explanation": "The `locationCode` is intended to be a character, derived from an integer ASCII value. The `char` primitive type is used for characters."
        },
        {
          "id": "slot_2",
          "line": 4,
          "type": "type_casting",
          "description": "Type casting expression for asciiValue",
          "correct_answer": "(char) asciiValue",
          "explanation": "To convert an `int` to a `char` explicitly, a type cast `(char)` is required, applying it to `asciiValue`."
        }
      ],
      "number_of_slots": 2
    },
    "hints": {
      "1": "The `locationCode` is intended to be a character.",
      "2": "An integer (`asciiValue`) needs to be converted to a character explicitly.",
      "3": "Recall the syntax for explicit type casting."
    }
  },
  {
    "id": 86,
    "subtopic_id": 2,
    "type": "code_completion",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `ManaOverflowMonitor` tracks a large `manaReservoir` and sets a `warningFlag` based on `additionalMana` that might cause an overflow. Complete the declaration of `manaReservoir` and ensure `warningFlag` is assigned in all conditional paths.",
    "story_context": "The ManaOverflowMonitor needs to track large mana reservoirs and set warning flags. Your task is to complete the variable declaration and assignments.",
    "challenge_data": {
      "initial_code": "public class ManaOverflowMonitor {\n    public static void main(String[] args) {\n        ??? manaReservoir = 5000000000L;\n        int additionalMana = 1000000000;\n        boolean warningFlag;\n\n        if (additionalMana > (Integer.MAX_VALUE - (int)manaReservoir)) {\n             ??? = true;\n        } else {\n             ??? = false;\n        }\n        \n        System.out.println(\"Mana Reservoir: \" + manaReservoir);\n        System.out.println(\"Warning Flag: \" + warningFlag);\n    }\n}",
      "expected_output": [
        "Mana Reservoir: 5000000000",
        "Warning Flag: false"
      ],
      "solution_code": "public class ManaOverflowMonitor {\n    public static void main(String[] args) {\n        long manaReservoir = 5000000000L;\n        int additionalMana = 1000000000;\n        boolean warningFlag;\n\n        if (additionalMana > (Integer.MAX_VALUE - (int)manaReservoir)) {\n             warningFlag = true;\n        } else {\n             warningFlag = false;\n        }\n        \n        System.out.println(\"Mana Reservoir: \" + manaReservoir);\n        System.out.println(\"Warning Flag: \" + warningFlag);\n    }\n}",
      "choices": [
        "int",
        "long",
        "warningFlag",
        "isWarning"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 3,
          "type": "variable_declaration",
          "description": "Variable type declaration for manaReservoir",
          "correct_answer": "long",
          "explanation": "`manaReservoir` needs to store `5000000000L`, which is a `long` literal. Therefore, `long` is the correct data type."
        },
        {
          "id": "slot_2",
          "line": 7,
          "type": "variable_assignment",
          "description": "Boolean assignment in if branch",
          "correct_answer": "warningFlag",
          "explanation": "The `warningFlag` is a local boolean variable that needs to be definitively assigned a value before it's printed."
        },
        {
          "id": "slot_3",
          "line": 9,
          "type": "variable_assignment",
          "description": "Boolean assignment in else branch",
          "correct_answer": "warningFlag",
          "explanation": "The `warningFlag` variable needs to be assigned a value in both `if` and `else` branches."
        }
      ],
      "number_of_slots": 3
    },
    "hints": {
      "1": "The value `5000000000L` is too large for an `int`.",
      "2": "The `warningFlag` variable needs to be assigned a value in both `if` and `else` branches.",
      "3": "The blank in the `if` and `else` blocks should refer to the already declared boolean variable."
    }
  },
  {
    "id": 87,
    "subtopic_id": 2,
    "type": "code_completion",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "An `AlchemistMixture` calculates a `volatileMixture` from `baseConcentration`. The `volatileMixture` must be a `float`, and `stableStatus` is determined by its value. Complete the declarations and the assignment for `stableStatus` in the `else` block.",
    "story_context": "The AlchemistMixture needs to calculate volatile mixtures and determine stability. Your task is to complete the variable declarations and assignments.",
    "challenge_data": {
      "initial_code": "public class AlchemistMixture {\n    public static void main(String[] args) {\n        double baseConcentration = 1.0 / 3.0;\n        ??? volatileMixture = (float) (baseConcentration * 3.0);\n        boolean stableStatus;\n\n        if (volatileMixture == 1.0f) {\n            stableStatus = true;\n        } else {\n            ??? = false;\n        }\n        \n        System.out.println(\"Mixture Purity: \" + volatileMixture);\n        System.out.println(\"Stable Status: \" + stableStatus);\n    }\n}",
      "expected_output": [
        "Mixture Purity: 0.99999994",
        "Stable Status: false"
      ],
      "solution_code": "public class AlchemistMixture {\n    public static void main(String[] args) {\n        double baseConcentration = 1.0 / 3.0;\n        float volatileMixture = (float) (baseConcentration * 3.0);\n        boolean stableStatus;\n\n        if (volatileMixture == 1.0f) {\n            stableStatus = true;\n        } else {\n            stableStatus = false;\n        }\n        \n        System.out.println(\"Mixture Purity: \" + volatileMixture);\n        System.out.println(\"Stable Status: \" + stableStatus);\n    }\n}",
      "choices": [
        "stableStatus",
        "float",
        "volatileMixture",
        "double"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 4,
          "type": "variable_declaration",
          "description": "Variable type declaration for volatileMixture",
          "correct_answer": "float",
          "explanation": "The problem states that `volatileMixture` must be a `float`. The expression `(float) (baseConcentration * 3.0)` correctly calculates the result and casts it to `float`."
        },
        {
          "id": "slot_2",
          "line": 9,
          "type": "variable_assignment",
          "description": "Boolean assignment in else branch",
          "correct_answer": "stableStatus",
          "explanation": "The `stableStatus` boolean variable needs to be assigned a value in both the `if` and `else` branches to satisfy Java's definite assignment rules."
        }
      ],
      "number_of_slots": 2
    },
    "hints": {
      "1": "The first blank needs the data type for `volatileMixture`, which must be a `float`.",
      "2": "The result of `baseConcentration * 3.0` is a `double`. How do you assign a `double` result to a `float` variable?",
      "3": "The `stableStatus` variable needs to be assigned a value in all conditional paths."
    }
  },
  {
    "id": 88,
    "subtopic_id": 2,
    "type": "code_completion",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "An `OathInscriber` manages `oathText` and `hasBeenSworn` status. The `oathText` is intended to be a constant, and `hasBeenSworn` is set based on its length. Complete the `final` declaration for `oathText` and the assignment for `hasBeenSworn`.",
    "story_context": "The OathInscriber needs to manage oath texts and sworn status. Your task is to complete the final declaration and variable assignment.",
    "challenge_data": {
      "initial_code": "public class OathInscriber {\n    public static void main(String[] args) {\n        ??? String oathText = \"By ancient magic, I swear.\";\n        boolean hasBeenSworn = false;\n\n        if (oathText.length() > 20) {\n            ??? = true;\n        }\n\n        System.out.println(\"Oath: \" + oathText);\n        System.out.println(\"Sworn: \" + hasBeenSworn);\n    }\n}",
      "expected_output": [
        "Oath: By ancient magic, I swear.",
        "Sworn: true"
      ],
      "solution_code": "public class OathInscriber {\n    public static void main(String[] args) {\n        final String oathText = \"By ancient magic, I swear.\";\n        boolean hasBeenSworn = false;\n\n        if (oathText.length() > 20) {\n            hasBeenSworn = true;\n        }\n\n        System.out.println(\"Oath: \" + oathText);\n        System.out.println(\"Sworn: \" + hasBeenSworn);\n    }\n}",
      "choices": [
        "static",
        "hasBeenSworn",
        "isSworn",
        "final"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 3,
          "type": "keyword",
          "description": "Final keyword for constant declaration",
          "correct_answer": "final",
          "explanation": "To make `oathText` a constant that cannot be changed after initialization, the `final` keyword must be placed before its declaration."
        },
        {
          "id": "slot_2",
          "line": 6,
          "type": "variable_assignment",
          "description": "Boolean assignment in if block",
          "correct_answer": "hasBeenSworn",
          "explanation": "The blank inside the `if` block is assigning a value to the `hasBeenSworn` variable, so its name should be placed there."
        }
      ],
      "number_of_slots": 2
    },
    "hints": {
      "1": "The `oathText` is meant to be permanent. What keyword makes a variable immutable?",
      "2": "The boolean variable `hasBeenSworn` is updated inside the `if` block.",
      "3": "What should be placed in that blank?"
    }
  },
  {
    "id": 89,
    "subtopic_id": 2,
    "type": "code_completion",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `SentinelSystem` manages `sentinelEnergy`, `shieldStatus`, and `dangerProtocol`. `sentinelEnergy` is an integer. `shieldStatus` and `dangerProtocol` are set conditionally in an `if-else` structure. Complete the declaration of `sentinelEnergy` and the assignments for `shieldStatus` and `dangerProtocol` in the `else` block.",
    "story_context": "The SentinelSystem needs to manage energy levels and shield protocols. Your task is to complete the variable declarations and assignments.",
    "challenge_data": {
      "initial_code": "public class SentinelSystem {\n    public static void main(String[] args) {\n        ??? sentinelEnergy = 120;\n        String shieldStatus;\n        boolean dangerProtocol;\n\n        if (sentinelEnergy > 100) {\n            shieldStatus = \"Shields Online.\";\n            dangerProtocol = false;\n        } else {\n            ??? = \"Shields Offline.\";\n            ??? = true;\n        }\n        \n        System.out.println(\"Energy: \" + sentinelEnergy);\n        System.out.println(\"Status: \" + shieldStatus);\n        System.out.println(\"Protocol: \" + dangerProtocol);\n    }\n}",
      "expected_output": [
        "Energy: 120",
        "Status: Shields Online.",
        "Protocol: false"
      ],
      "solution_code": "public class SentinelSystem {\n    public static void main(String[] args) {\n        int sentinelEnergy = 120;\n        String shieldStatus;\n        boolean dangerProtocol;\n\n        if (sentinelEnergy > 100) {\n            shieldStatus = \"Shields Online.\";\n            dangerProtocol = false;\n        } else {\n            shieldStatus = \"Shields Offline.\";\n            dangerProtocol = true;\n        }\n        \n        System.out.println(\"Energy: \" + sentinelEnergy);\n        System.out.println(\"Status: \" + shieldStatus);\n        System.out.println(\"Protocol: \" + dangerProtocol);\n    }\n}",
      "choices": [
        "int",
        "boolean",
        "shieldStatus",
        "dangerProtocol"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 3,
          "type": "variable_declaration",
          "description": "Variable type declaration for sentinelEnergy",
          "correct_answer": "int",
          "explanation": "`sentinelEnergy` stores a whole number (`120`), so `int` is the correct data type for its declaration."
        },
        {
          "id": "slot_2",
          "line": 10,
          "type": "variable_assignment",
          "description": "String assignment in else branch",
          "correct_answer": "shieldStatus",
          "explanation": "In the `else` block, the first blank assigns a string literal `\"Shields Offline.\"`, so the variable name `shieldStatus` should fill this blank."
        },
        {
          "id": "slot_3",
          "line": 11,
          "type": "variable_assignment",
          "description": "Boolean assignment in else branch",
          "correct_answer": "dangerProtocol",
          "explanation": "The second blank in the `else` block assigns a boolean literal `true`, so the variable name `dangerProtocol` should fill this blank."
        }
      ],
      "number_of_slots": 3
    },
    "hints": {
      "1": "The `sentinelEnergy` variable stores a whole number.",
      "2": "The blank in the `else` block that assigns a string value should be the `shieldStatus` variable.",
      "3": "The blank that assigns a boolean value in the `else` block should be the `dangerProtocol` variable."
    }
  },
  {
    "id": 90,
    "subtopic_id": 2,
    "type": "code_completion",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `GlyphCalculator` calculates `glyphValue` from `initialFragment` and `enhancementFactor`, then determines `glyphStatus` based on `glyphValue`. Complete the declaration of `glyphValue` and the assignment for `glyphStatus` in the `else` block.",
    "story_context": "The GlyphCalculator needs to calculate glyph values and determine status. Your task is to complete the variable declarations and assignments.",
    "challenge_data": {
      "initial_code": "public class GlyphCalculator {\n    public static void main(String[] args) {\n        byte initialFragment = 120;\n        short enhancementFactor = 200;\n        ??? = initialFragment + enhancementFactor;\n        char glyphStatus;\n\n        if (glyphValue > 255) {\n            glyphStatus = '!';\n        } else {\n            ??? = (char) glyphValue;\n        }\n        \n        System.out.println(\"Glyph Value: \" + glyphValue);\n        System.out.println(\"Glyph Status: \" + glyphStatus);\n    }\n}",
      "expected_output": [
        "Glyph Value: 320",
        "Glyph Status: !"
      ],
      "solution_code": "public class GlyphCalculator {\n    public static void main(String[] args) {\n        byte initialFragment = 120;\n        short enhancementFactor = 200;\n        int glyphValue = initialFragment + enhancementFactor;\n        char glyphStatus;\n\n        if (glyphValue > 255) {\n            glyphStatus = '!';\n        } else {\n            glyphStatus = (char) glyphValue;\n        }\n        \n        System.out.println(\"Glyph Value: \" + glyphValue);\n        System.out.println(\"Glyph Status: \" + glyphStatus);\n    }\n}",
      "choices": [
        "char glyphStatus",
        "(byte)",
        "glyphStatus",
        "short glyphValue",
        "int glyphValue"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 5,
          "type": "variable_declaration",
          "description": "Variable type declaration for glyphValue",
          "correct_answer": "int glyphValue",
          "explanation": "The sum `initialFragment + enhancementFactor` (`120 + 200 = 320`) exceeds the maximum range of both `byte` (127) and `short` (32767). To correctly store this sum without overflow, `int` is the appropriate data type for `glyphValue`."
        },
        {
          "id": "slot_2",
          "line": 11,
          "type": "variable_assignment",
          "description": "Character assignment in else branch",
          "correct_answer": "glyphStatus",
          "explanation": "In the `else` block, the blank is assigning a value to the `glyphStatus` variable, which is of `char` type."
        }
      ],
      "number_of_slots": 2
    },
    "hints": {
      "1": "The sum of `initialFragment` and `enhancementFactor` (`120 + 200 = 320`) exceeds the range of both `byte` and `short`.",
      "2": "The `glyphValue` needs to hold this sum without overflow.",
      "3": "The blank in the `else` block should assign a value to the `glyphStatus` variable, which is a character type."
    }
  },
  {
    "id": 91,
    "subtopic_id": 3,
    "type": "output_tracing",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `SimpleSpellScroll` system records `spellName`. Your task is to trace the code and determine the exact `Spell Name` that is printed by the system.",
    "story_context": "The SimpleSpellScroll system needs to record spell names. Your task is to trace the string assignment and predict the output.",
    "challenge_data": {
      "code": "public class SimpleSpellScroll {\n    public static void main(String[] args) {\n        String spellName = \"Lumos\";\n        System.out.println(\"Spell Name: \" + spellName);\n    }\n}",
      "expected_output": [
        "Spell Name: Lumos"
      ],
      "choices": [
        "Lumos",
        "Spell Name: Lumos",
        "spellName",
        "Error"
      ],
      "explanation": "The `String spellName = \"Lumos\";` line declares a `String` variable `spellName` and assigns it the text `\"Lumos\"`. The `System.out.println(\"Spell Name: \" + spellName);` line then combines the literal string \"Spell Name: \" with the value of `spellName`, printing \"Spell Name: Lumos\"."
    },
    "hints": {
      "1": "Identify the value stored in the `spellName` variable.",
      "2": "The `+` operator combines text strings.",
      "3": "The output will combine the literal \"Spell Name: \" with the content of `spellName`."
    }
  },
  {
    "id": 92,
    "subtopic_id": 3,
    "type": "output_tracing",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `PotionIngredients` system tracks ingredients in an array. Your task is to trace the code and determine the count of the `First Ingredient` that is printed by the system.",
    "story_context": "The PotionIngredients system needs to track ingredients in arrays. Your task is to trace the array access and predict the output.",
    "challenge_data": {
      "code": "public class PotionIngredients {\n    public static void main(String[] args) {\n        int[] ingredients = {10, 5, 20};\n        System.out.println(\"First Ingredient Count: \" + ingredients[0]);\n    }\n}",
      "expected_output": [
        "First Ingredient Count: 10"
      ],
      "choices": [
        "First Ingredient Count: 10",
        "10",
        "First Ingredient Count: 0",
        "Error"
      ],
      "explanation": "The line `int[] ingredients = {10, 5, 20};` declares an array named `ingredients` and initializes it with three integer values. Array indices start from `0`. So, `ingredients[0]` refers to the first element, which is `10`. The `System.out.println()` statement then prints \"First Ingredient Count: \" concatenated with the value of `ingredients[0]`, resulting in \"First Ingredient Count: 10\"."
    },
    "hints": {
      "1": "Arrays in Java are zero-indexed, meaning the first element is at index 0.",
      "2": "Identify which value is at the specified index.",
      "3": "The `+` operator combines the string and the array element's value."
    }
  },
  {
    "id": 93,
    "subtopic_id": 3,
    "type": "output_tracing",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `PhraseComparer` checks if two `magicPhrase`s are identical. Your task is to trace the code and determine if the phrases are considered `Identical` based on Java's `String` comparison rules.",
    "story_context": "The PhraseComparer needs to check if two magic phrases are identical. Your task is to trace the string comparison and predict the output.",
    "challenge_data": {
      "code": "public class PhraseComparer {\n    public static void main(String[] args) {\n        String magicPhrase1 = \"Abra Cadabra\";\n        String magicPhrase2 = \"Abra Cadabra\";\n        boolean areIdentical = (magicPhrase1 == magicPhrase2);\n        System.out.println(\"Phrases Identical: \" + areIdentical);\n    }\n}",
      "expected_output": [
        "Phrases Identical: true"
      ],
      "choices": [
        "Phrases Identical: true",
        "Phrases Identical: false",
        "Error",
        "Abra Cadabra"
      ],
      "explanation": "When comparing `String` literals that have the exact same sequence of characters (like `\"Abra Cadabra\"`), Java's compiler often performs a trick called \"string interning.\" This means it stores only one copy of that literal in memory and makes both `magicPhrase1` and `magicPhrase2` variables point to that *exact same object*. Because they are referencing the same object in memory, `magicPhrase1 == magicPhrase2` evaluates to `true`. This behavior is specific to *literals*; for strings created dynamically (e.g., `new String(\"...\")`), `==` would typically be `false`."
    },
    "hints": {
      "1": "For `String` literals, Java often performs \"string interning\" (reusing the same object for identical literals).",
      "2": "The `==` operator for non-primitive types compares memory addresses.",
      "3": "Consider if both variables point to the exact same object in memory due to interning."
    }
  },
  {
    "id": 94,
    "subtopic_id": 3,
    "type": "output_tracing",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `CreatureList` tracks magical creatures in an array. The first creature in the list is reassigned. Your task is to trace the code and determine the `First Creature` after the update.",
    "story_context": "The CreatureList needs to track magical creatures in arrays. Your task is to trace the array modification and predict the output.",
    "challenge_data": {
      "code": "public class CreatureList {\n    public static void main(String[] args) {\n        String[] magicalCreatures = {\"Dragon\", \"Griffin\", \"Unicorn\"};\n        magicalCreatures[0] = \"Phoenix\";\n        System.out.println(\"First Creature: \" + magicalCreatures[0]);\n    }\n}",
      "expected_output": [
        "First Creature: Phoenix"
      ],
      "choices": [
        "First Creature: Dragon",
        "First Creature: Phoenix",
        "Phoenix",
        "Error"
      ],
      "explanation": "The `String[] magicalCreatures` array is initialized with \"Dragon\" at index `0`. The line `magicalCreatures[0] = \"Phoenix\";` then directly reassigns the element at index `0`, changing it from \"Dragon\" to \"Phoenix\". When `System.out.println()` executes, it prints the updated value, which is \"Phoenix\"."
    },
    "hints": {
      "1": "Arrays are mutable, meaning their elements can be changed after creation.",
      "2": "The assignment `magicalCreatures[0] = \"Phoenix\";` directly overwrites the previous value.",
      "3": "The `println` statement displays the most recent value at that index."
    }
  },
  {
    "id": 95,
    "subtopic_id": 3,
    "type": "output_tracing",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `SpellRecorder` tracks `spellSequence` and determines its length. Your task is to trace the code and determine the `Sequence Length` that is printed.",
    "story_context": "The SpellRecorder needs to track spell sequences and determine their length. Your task is to trace the string length calculation and predict the output.",
    "challenge_data": {
      "code": "public class SpellRecorder {\n    public static void main(String[] args) {\n        String spellSequence = \"Incendio\";\n        System.out.println(\"Sequence Length: \" + spellSequence.length());\n    }\n}",
      "expected_output": [
        "Sequence Length: 8"
      ],
      "choices": [
        "8",
        "Sequence Length: 8",
        "0",
        "Sequence Length: Incendio"
      ],
      "explanation": "The `String spellSequence = \"Incendio\";` line initializes `spellSequence` to the text \"Incendio\". The `spellSequence.length()` method is then called on this string. \"Incendio\" has 8 characters, so `.length()` returns `8`. Finally, `System.out.println(\"Sequence Length: \" + 8);` prints \"Sequence Length: 8\"."
    },
    "hints": {
      "1": " `String` objects have built-in methods (spells) like `.length()`.",
      "2": "The `.length()` method returns the number of characters in the string.",
      "3": "The `+` operator combines the literal string with the numerical result of the method."
    }
  },
  {
    "id": 96,
    "subtopic_id": 3,
    "type": "output_tracing",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "An `ElementalIncantation` system combines `element` and `action` into an `elementalIncantation`. Your task is to trace the code and determine the final `Incantation` and its `Length`.",
    "story_context": "The ElementalIncantation system needs to combine elements and actions. Your task is to trace the string concatenation and length calculation to predict the outputs.",
    "challenge_data": {
      "code": "public class ElementalIncantation {\n    public static void main(String[] args) {\n        String element = \"Fire\";\n        String action = \"Blast\";\n        String elementalIncantation = element + \" \" + action;\n        \n        System.out.println(\"Incantation: \" + elementalIncantation);\n        System.out.println(\"Length: \" + elementalIncantation.length());\n    }\n}",
      "expected_output": [
        "Incantation: Fire Blast",
        "Length: 9"
      ],
      "choices": [
        "Incantation: Fire",
        "Incantation: Fire Blast",
        "Length: 9",
        "Length: 10",
        "Incantation: Blast"
      ],
      "explanation": "1. `element` is \"Fire\", `action` is \"Blast\".\n2. `elementalIncantation = element + \" \" + action;` concatenates \"Fire\", a space, and \"Blast\", resulting in `elementalIncantation` being \"Fire Blast\".\n3. The first `System.out.println()` prints \"Incantation: Fire Blast\".\n4. The `elementalIncantation.length()` method counts the characters in \"Fire Blast\" (4 for \"Fire\" + 1 for space + 5 for \"Blast\"), resulting in `9`.\n5. The second `System.out.println()` prints \"Length: 9\"."
    },
    "hints": {
      "1": "Observe how the `+` operator behaves when combining multiple `String`s and spaces.",
      "2": "Count all characters, including spaces, in the final concatenated string to determine its length.",
      "3": "Each `System.out.println()` statement produces a separate line of output."
    }
  },
  {
    "id": 97,
    "subtopic_id": 3,
    "type": "output_tracing",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `PotionInventoryTracker` tracks `potionStock` in an array. The count of the second potion is updated. Your task is to trace the code and determine the `Initial Second Potion` count and the `Final Second Potion` count after the update.",
    "story_context": "The PotionInventoryTracker needs to track potion inventory in arrays. Your task is to trace the array modification and predict the outputs.",
    "challenge_data": {
      "code": "public class PotionInventoryTracker {\n    public static void main(String[] args) {\n        int[] potionStock = {5, 10, 15};\n        System.out.println(\"Initial Second Potion: \" + potionStock[1]);\n        \n        potionStock[1] = potionStock[1] - 3;\n        \n        System.out.println(\"Final Second Potion: \" + potionStock[1]);\n    }\n}",
      "expected_output": [
        "Initial Second Potion: 10",
        "Final Second Potion: 7"
      ],
      "choices": [
        "Initial Second Potion: 5",
        "Initial Second Potion: 10",
        "Final Second Potion: 7",
        "Final Second Potion: 10",
        "Initial Second Potion: 100"
      ],
      "explanation": "1. `int[] potionStock = {5, 10, 15};` initializes the array. The second element (`potionStock[1]`) is `10`.\n2. The first `System.out.println()` prints \"Initial Second Potion: 10\".\n3. `potionStock[1] = potionStock[1] - 3;` updates `potionStock[1]` to `10 - 3 = 7`.\n4. The second `System.out.println()` prints \"Final Second Potion: 7\"."
    },
    "hints": {
      "1": "Arrays are zero-indexed: `potionStock[1]` refers to the second element.",
      "2": "Trace the value of `potionStock[1]` through both the initial print and the subsequent calculation.",
      "3": "The `potionStock[1] = potionStock[1] - 3;` line updates the array element directly."
    }
  },
  {
    "id": 98,
    "subtopic_id": 3,
    "type": "output_tracing",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `MirrorSpell` creates `newSpellImage` from an `originalSpell`. Your task is to trace the code and determine if their content and object references are `Identical`.",
    "story_context": "The MirrorSpell needs to create spell images and compare their properties. Your task is to trace the string comparison and predict the outputs.",
    "challenge_data": {
      "code": "public class MirrorSpell {\n    public static void main(String[] args) {\n        String originalSpell = \"Reflect\";\n        String newSpellImage = new String(\"Reflect\");\n        \n        System.out.println(\"Content Match: \" + originalSpell.equals(newSpellImage));\n        System.out.println(\"Object Identical: \" + (originalSpell == newSpellImage));\n    }\n}",
      "expected_output": [
        "Content Match: true",
        "Object Identical: false"
      ],
      "choices": [
        "Content Match: false",
        "Content Match: true",
        "Object Identical: false",
        "Object Identical: true",
        "Content Match: null"
      ],
      "explanation": "1. `String originalSpell = \"Reflect\";` creates a `String` literal.\n2. `String newSpellImage = new String(\"Reflect\");` explicitly creates a *new* `String` object in memory, even though its content is identical to `originalSpell`.\n3. `originalSpell.equals(newSpellImage)` compares the *content* (\"Reflect\" vs. \"Reflect\"), which is `true`. The first `System.out.println()` prints \"Content Match: true\".\n4. `originalSpell == newSpellImage` compares their memory *references*. Since `newSpellImage` was created with `new`, it resides at a different memory location than `originalSpell`. Therefore, this comparison is `false`. The second `System.out.println()` prints \"Object Identical: false\"."
    },
    "hints": {
      "1": "The `.equals()` method compares the *content* of `String` objects.",
      "2": "The `==` operator for non-primitive types compares memory *references* (do they point to the exact same object?).",
      "3": "The `new String(\"Reflect\")` explicitly creates a *new* object in memory."
    }
  },
  {
    "id": 99,
    "subtopic_id": 3,
    "type": "output_tracing",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `CursedItemRegistry` lists `cursedItems` in an array. The first item is destroyed by setting its reference to `null`. Your task is to trace the code and determine the `Third Item` initially and the `First Item After Destruction`.",
    "story_context": "The CursedItemRegistry needs to track cursed items and handle null references. Your task is to trace the array modification and predict the outputs.",
    "challenge_data": {
      "code": "public class CursedItemRegistry {\n    public static void main(String[] args) {\n        String[] cursedItems = {\"Amulet\", \"Orb\", \"Tome\"};\n        System.out.println(\"Third Item: \" + cursedItems[2]);\n        \n        cursedItems[0] = null;\n        \n        System.out.println(\"First Item After Destruction: \" + cursedItems[0]);\n    }\n}",
      "expected_output": [
        "Third Item: Tome",
        "First Item After Destruction: null"
      ],
      "choices": [
        "Third Item: Orb",
        "Third Item: Tome",
        "First Item After Destruction: Amulet",
        "First Item After Destruction: null",
        "Third Item: Tome Orb"
      ],
      "explanation": "1. `String[] cursedItems = {\"Amulet\", \"Orb\", \"Tome\"};` initializes the array.\n2. The first `System.out.println()` prints \"Third Item: \" concatenated with `cursedItems[2]`, which is \"Tome\".\n3. `cursedItems[0] = null;` sets the first element of the array to `null`, meaning it no longer refers to the \"Amulet\" object.\n4. The second `System.out.println()` prints \"First Item After Destruction: \" concatenated with `cursedItems[0]`, which is now `null`."
    },
    "hints": {
      "1": "Arrays are zero-indexed: `cursedItems[2]` refers to the third element.",
      "2": "Assigning `null` to an array element effectively removes its reference to an object, marking that slot as empty.",
      "3": "The `println` statements show the value *at the moment of execution*."
    }
  },
  {
    "id": 100,
    "subtopic_id": 3,
    "type": "output_tracing",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `MagicMessenger` decodes a `cipherMessage`. Your task is to trace the code and determine its `First Letter` and whether it `Starts with 'ARCANE'`.",
    "story_context": "The MagicMessenger needs to decode cipher messages and check their properties. Your task is to trace the string methods and predict the outputs.",
    "challenge_data": {
      "code": "public class MagicMessenger {\n    public static void main(String[] args) {\n        String cipherMessage = \"ARCANE SCROLL\";\n        \n        char firstLetter = cipherMessage.charAt(0);\n        boolean startsWithArcane = cipherMessage.startsWith(\"ARCANE\");\n        \n        System.out.println(\"First Letter: \" + firstLetter);\n        System.out.println(\"Starts with 'ARCANE': \" + startsWithArcane);\n    }\n}",
      "expected_output": [
        "First Letter: A",
        "Starts with 'ARCANE': true"
      ],
      "choices": [
        "First Letter: A",
        "First Letter: R",
        "Starts with 'ARCANE': false",
        "Starts with 'ARCANE': true",
        "First Letter: C"
      ],
      "explanation": "1. `String cipherMessage = \"ARCANE SCROLL\";` initializes the string.\n2. `cipherMessage.charAt(0)` returns the character at index 0, which is `'A'`.\n3. `cipherMessage.startsWith(\"ARCANE\")` checks if \"ARCANE SCROLL\" starts with \"ARCANE\". This is `true`.\n4. The first `System.out.println()` prints \"First Letter: A\".\n5. The second `System.out.println()` prints \"Starts with 'ARCANE': true\"."
    },
    "hints": {
      "1": "`charAt(0)` retrieves the character at the very beginning of a string (index 0).",
      "2": "The `startsWith()` method checks if a string begins with the specified prefix.",
      "3": "String comparisons are case-sensitive."
    }
  },
  {
    "id": 101,
    "subtopic_id": 3,
    "type": "output_tracing",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "An `ElementalSigil` combines parts of a `baseCode` into a `sigilCode`. It also updates an `enchantmentGlyphs` array and checks for a `matchFound` with a `targetGlyph`. Your task is to trace the code and determine the `Final Sigil Code`, `First Enchantment Glyph`, and `Match Found (Reference)` status.",
    "story_context": "The ElementalSigil needs to combine base codes and handle string references. Your task is to trace the string manipulation and reference comparison to predict the outputs.",
    "challenge_data": {
      "code": "public class ElementalSigil {\n    public static void main(String[] args) {\n        String baseCode = \"FIRE-AETHER\";\n        String sigilCode = baseCode.substring(0, 4) + \"!\" + baseCode.substring(5, baseCode.length());\n        \n        String[] enchantmentGlyphs = {\"Alpha\", \"Beta\", \"Gamma\"};\n        String targetGlyph = new String(\"Alpha\");\n        \n        enchantmentGlyphs[0] = enchantmentGlyphs[1].toUpperCase();\n        \n        boolean matchFound = (targetGlyph == enchantmentGlyphs[0]);\n        \n        System.out.println(\"Final Sigil Code: \" + sigilCode);\n        System.out.println(\"First Enchantment Glyph: \" + enchantmentGlyphs[0]);\n        System.out.println(\"Match Found (Reference): \" + matchFound);\n    }\n}",
      "expected_output": [
        "Final Sigil Code: FIRE!AETHER",
        "First Enchantment Glyph: BETA",
        "Match Found (Reference): false"
      ],
      "choices": [
        "Final Sigil Code: FIRE!AETHER",
        "First Enchantment Glyph: Alpha",
        "First Enchantment Glyph: BETA",
        "Match Found (Reference): false",
        "Final Sigil Code: FIRE-AETHER",
        "Match Found (Reference): true"
      ],
      "explanation": "1. `String baseCode = \"FIRE-AETHER\";`\n2. `sigilCode = baseCode.substring(0, 4) + \"!\" + baseCode.substring(5, baseCode.length());` concatenates to \"FIRE!AETHER\". So, `sigilCode` is \"FIRE!AETHER\".\n3. `String[] enchantmentGlyphs = {\"Alpha\", \"Beta\", \"Gamma\"};`\n4. `String targetGlyph = new String(\"Alpha\");` creates a new object.\n5. `enchantmentGlyphs[0] = enchantmentGlyphs[1].toUpperCase();` gets \"Beta\" from `enchantmentGlyphs[1]`, converts to \"BETA\", and assigns to `enchantmentGlyphs[0]`.\n6. `boolean matchFound = (targetGlyph == enchantmentGlyphs[0]);` compares `targetGlyph` (a new \"Alpha\" object) to `enchantmentGlyphs[0]` (\"BETA\" object). These are different objects at different addresses, so `==` is `false`.\n7. The `System.out.println()` statements display the final values."
    },
    "hints": {
      "1": "Trace the `sigilCode` by performing the `substring` and concatenation operations step-by-step.",
      "2": "Follow the modification to `enchantmentGlyphs[0]`, especially the `.toUpperCase()` method.",
      "3": "Remember that `==` for `String` objects compares memory addresses (references), and `new String()` always creates a *new* object."
    }
  },
  {
    "id": 102,
    "subtopic_id": 3,
    "type": "output_tracing",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `LoreProcessor` processes `ancientLore` using various `String` methods, and checks for `loreFound` in an `archiveEntries` array. Your task is to trace the code and determine the `Processed Lore`, `Arcane Fact Length`, and `Lore Found in Archive` status.",
    "story_context": "The LoreProcessor needs to process ancient lore and handle null references. Your task is to trace the string manipulation and null checking to predict the outputs.",
    "challenge_data": {
      "code": "public class LoreProcessor {\n    public static void main(String[] args) {\n        String ancientLore = \"  Whispers of the PAST  \";\n        String arcaneFact = ancientLore.trim().replace(\"PAST\", \"FUTURE\").toLowerCase();\n        \n        String[] archiveEntries = new String[2];\n        archiveEntries[0] = \"First Lore\";\n        archiveEntries[1] = null;\n        \n        boolean loreFound = (archiveEntries[1] != null && archiveEntries[1].equals(\"Second Lore\"));\n        \n        arcaneFact = arcaneFact.substring(0, 8);\n        \n        System.out.println(\"Processed Lore: \" + ancientLore);\n        System.out.println(\"Arcane Fact Length: \" + arcaneFact.length());\n        System.out.println(\"Lore Found in Archive: \" + loreFound);\n    }\n}",
      "expected_output": [
        "Processed Lore:   Whispers of the PAST  ",
        "Arcane Fact Length: 8",
        "Lore Found in Archive: false"
      ],
      "choices": [
        "Processed Lore: Whispers of the PAST",
        "Arcane Fact Length: 8",
        "Lore Found in Archive: true",
        "Arcane Fact Length: 22",
        "Lore Found in Archive: false",
        "Processed Lore: Whispers of the past"
      ],
      "explanation": "1. `String ancientLore = \"  Whispers of the PAST  \";` initializes `ancientLore`. This original value is printed.\n2. `String arcaneFact = ancientLore.trim().replace(\"PAST\", \"FUTURE\").toLowerCase();`\n    * `.trim()`: \"Whispers of the PAST\"\n    * `.replace(\"PAST\", \"FUTURE\")`: \"Whispers of the FUTURE\"\n    * `.toLowerCase()`: \"whispers of the future\"\n    So, `arcaneFact` is \"whispers of the future\".\n3. `arcaneFact = arcaneFact.substring(0, 8);` updates `arcaneFact` to \"whispers\" (first 8 characters).\n4. `archiveEntries[1]` is `null`.\n5. `boolean loreFound = (archiveEntries[1] != null && archiveEntries[1].equals(\"Second Lore\"));`\n    * `archiveEntries[1] != null` evaluates to `null != null`, which is `false`.\n    * Due to short-circuiting of `&&`, the second part (`archiveEntries[1].equals(...)`) is *not* evaluated, preventing a `NullPointerException`. So, `loreFound` is `false`.\n6. `System.out.println(\"Processed Lore: \" + ancientLore);` prints the original value of `ancientLore`.\n7. `System.out.println(\"Arcane Fact Length: \" + arcaneFact.length());` prints \"Arcane Fact Length: 8\" (length of \"whispers\").\n8. The `System.out.println()` statements display the final values."
    },
    "hints": {
      "1": " `ancientLore.trim()` removes leading/trailing spaces, and `.replace()` and `.toLowerCase()` modify the string content.",
      "2": "The `arcaneFact` variable is updated twice (`trim/replace/toLowerCase` then `substring`).",
      "3": "Carefully evaluate the condition `(archiveEntries[1] != null && archiveEntries[1].equals(\\\"Second Lore\\\"))`. What is `archiveEntries[1]`'s value? What does `&&` do if the first part is false?"
    }
  },
  {
    "id": 103,
    "subtopic_id": 3,
    "type": "output_tracing",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `GrandIllusion` spell manipulates `illusionText` and `backupText`, and activates `stageLights` in an array. Your task is to trace the code and determine the `Final Illusion Text`, `Total Active Lights`, and `Text Is Empty` status.",
    "story_context": "The GrandIllusion needs to manipulate text and control stage lights. Your task is to trace the string manipulation and boolean array operations to predict the outputs.",
    "challenge_data": {
      "code": "public class GrandIllusion {\n    public static void main(String[] args) {\n        String illusionText = \"Grand Show\";\n        String backupText = \"Magic\";\n        boolean[] stageLights = new boolean[3];\n\n        illusionText = illusionText.replace(\"Grand\", \"\").trim();\n        backupText = backupText + \"!\";\n\n        stageLights[0] = true;\n        stageLights[2] = true;\n\n        if (illusionText.isEmpty()) {\n            stageLights[1] = true;\n        }\n\n        boolean textIsEmpty = illusionText.isEmpty();\n\n        System.out.println(\"Final Illusion Text: \" + illusionText);\n        System.out.println(\"Total Active Lights: \" + ( (stageLights[0] ? 1 : 0) + (stageLights[1] ? 1 : 0) + (stageLights[2] ? 1 : 0) ) );\n        System.out.println(\"Text Is Empty: \" + textIsEmpty);\n    }\n}",
      "expected_output": [
        "Final Illusion Text: Show",
        "Total Active Lights: 2",
        "Text Is Empty: false"
      ],
      "choices": [
        "Final Illusion Text: Grand Show",
        "Total Active Lights: 2",
        "Text Is Empty: false",
        "Text Is Empty: true",
        "Final Illusion Text: Show",
        "Total Active Lights: 3"
      ],
      "explanation": "1. `illusionText` starts as \"Grand Show\". `illusionText.replace(\"Grand\", \"\").trim()` first becomes \" Show\" (replace), then \"Show\" (trim). So `illusionText` is \"Show\".\n2. `backupText` becomes \"Magic!\".\n3. `stageLights` is `{false, false, false}`. Then `stageLights[0] = true;` makes it `{true, false, false}`. `stageLights[2] = true;` makes it `{true, false, true}`.\n4. `if (illusionText.isEmpty())`: \"Show\".isEmpty() is `false`. So, the `if` block is skipped; `stageLights[1]` remains `false`.\n5. `boolean textIsEmpty = illusionText.isEmpty();` : \"Show\".isEmpty() is `false`. So `textIsEmpty` is `false`.\n6. **Output 1**: `System.out.println(\"Final Illusion Text: \" + illusionText);` prints \"Final Illusion Text: Show\".\n7. **Output 2**: `System.out.println(\"Total Active Lights: \" + (...) );` sums (`1 + 0 + 1 = 2`). Prints \"Total Active Lights: 2\".\n8. **Output 3**: `System.out.println(\"Text Is Empty: \" + textIsEmpty);` prints \"Text Is Empty: false\"."
    },
    "hints": {
      "1": "Trace `illusionText` through its `replace` and `trim` operations.",
      "2": "Evaluate the `if (illusionText.isEmpty())` condition and its impact on `stageLights[1]`.",
      "3": "Sum the boolean states of `stageLights` (true=1, false=0) to find the \"Total Active Lights\"."
    }
  },
  {
    "id": 104,
    "subtopic_id": 3,
    "type": "output_tracing",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "An `OraclePrediction` processes a `prophecy` string, modifying it and checking for a `targetWord`. It also updates an `omens` array. Your task is to trace the code and determine the `Modified Prophecy`, `Omen Char Count (Prophecy)`, and `Condition Met` status.",
    "story_context": "The OraclePrediction needs to process prophecies and handle string transformations. Your task is to trace the string manipulation and conditional logic to predict the outputs.",
    "challenge_data": {
      "code": "public class OraclePrediction {\n    public static void main(String[] args) {\n        String prophecy = \"A NEW ERA BEGINS\";\n        String[] omens = {\"Eclipse\", \"Comet\", \"Starfall\"};\n        boolean conditionMet = false;\n\n        prophecy = prophecy.replace(\" \", \"_\").toLowerCase();\n        \n        omens[1] = \"Celestial\";\n        \n        String targetWord = new String(\"a_new\");\n        if (prophecy.startsWith(targetWord)) {\n            conditionMet = true;\n        }\n\n        System.out.println(\"Modified Prophecy: \" + prophecy);\n        System.out.println(\"Omen Char Count (Prophecy): \" + (prophecy.length() - prophecy.replace(\"o\", \"\").length()));\n        System.out.println(\"Condition Met: \" + conditionMet);\n    }\n}",
      "expected_output": [
        "Modified Prophecy: a_new_era_begins",
        "Omen Char Count (Prophecy): 2",
        "Condition Met: true"
      ],
      "choices": [
        "Modified Prophecy: A NEW ERA BEGINS",
        "Modified Prophecy: a_new_era_begins",
        "Omen Char Count (Prophecy): 2",
        "Condition Met: true",
        "Condition Met: false",
        "Omen Char Count (Prophecy): 0"
      ],
      "explanation": "1. `prophecy` starts as \"A NEW ERA BEGINS\".\n2. `prophecy = prophecy.replace(\" \", \"_\").toLowerCase();` transforms `prophecy` to \"a_new_era_begins\".\n3. `omens[1]` becomes \"Celestial\".\n4. `targetWord` is `new String(\"a_new\")`.\n5. `if (prophecy.startsWith(targetWord))`: `\"a_new_era_begins\".startsWith(\"a_new\")` is `true`.\n    * `conditionMet = true;` updates `conditionMet` to `true`.\n6. `System.out.println(\"Modified Prophecy: \" + prophecy);` prints \"Modified Prophecy: a_new_era_begins\".\n7. `System.out.println(\"Omen Char Count (Prophecy): \" + (prophecy.length() - prophecy.replace(\"o\", \"\").length()));` calculates `16 - 14 = 2` (count of 'o's).\n8. `System.out.println(\"Condition Met: \" + conditionMet);` prints \"Condition Met: true\"."
    },
    "hints": {
      "1": "Trace `prophecy` through `replace` and `toLowerCase` methods.",
      "2": "The \"Omen Char Count\" calculates the number of times a specific character appears (in this case, 'o').",
      "3": "`startsWith()` is case-sensitive, and `new String()` creates a new object, but `startsWith` compares content."
    }
  },
  {
    "id": 105,
    "subtopic_id": 3,
    "type": "output_tracing",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "An `InventoryManager` initializes an array of `artifactNames` and conditionally sets a `masterKey` to `null`. Your task is to trace the code and determine the `Inventory Size`, `Last Artifact`, and `Master Key Status`.",
    "story_context": "The InventoryManager needs to track artifacts and handle conditional null assignments. Your task is to trace the array operations and conditional logic to predict the outputs.",
    "challenge_data": {
      "code": "public class InventoryManager {\n    public static void main(String[] args) {\n        String[] artifactNames = new String[3];\n        artifactNames[0] = \"Sword of Truth\";\n        artifactNames[2] = \"Shield of Light\";\n        \n        String masterKey = \"Ancient Rune\";\n        String searchTarget = \"Sword of Truth\";\n        \n        if (artifactNames[0].equals(searchTarget)) {\n            masterKey = null;\n        }\n        \n        int keyLength = 0;\n        if (masterKey != null) {\n            keyLength = masterKey.length();\n        }\n\n        System.out.println(\"Inventory Size: \" + artifactNames.length);\n        System.out.println(\"Last Artifact: \" + artifactNames[2]);\n        System.out.println(\"Master Key Status: \" + masterKey);\n    }\n}",
      "expected_output": [
        "Last Artifact: Shield of Light",
        "Inventory Size: 3",
        "Master Key Status: null"
      ],
      "choices": [
        "Inventory Size: 2",
        "Last Artifact: Shield of Light",
        "Inventory Size: 3",
        "Master Key Status: null",
        "Master Key Status: Ancient Rune",
        "Last Artifact: Ancient Rune"
      ],
      "explanation": "1. `String[] artifactNames = new String[3];` creates an array of size 3. `artifactNames[0]` is \"Sword of Truth\", `artifactNames[1]` is `null` (default for `String[]`), `artifactNames[2]` is \"Shield of Light\".\n2. `if (artifactNames[0].equals(searchTarget))`: \"Sword of Truth\".equals(\"Sword of Truth\") is `true`.\n    * `masterKey = null;` updates `masterKey` to `null`.\n3. The `keyLength` calculation is skipped because `masterKey` is `null`.\n4. **Output 1**: `System.out.println(\"Inventory Size: \" + artifactNames.length);` prints \"Inventory Size: 3\".\n5. **Output 2**: `System.out.println(\"Last Artifact: \" + artifactNames[2]);` prints \"Last Artifact: Shield of Light\".\n6. **Output 3**: `System.out.println(\"Master Key Status: \" + masterKey);` prints \"Master Key Status: null\"."
    },
    "hints": {
      "1": "An array's `length` property gives its total size, not just the number of filled elements.",
      "2": "`artifactNames[2]` accesses the element at index 2 (the third element).",
      "3": "Trace `masterKey` carefully: it is initially a string, but its value can change to `null` based on a condition."
    }
  },
  {
    "id": 106,
    "subtopic_id": 3,
    "type": "code_fixer",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `SpellScrollComparer` checks if two `spellScroll`s are identical. However, the code incorrectly uses `==` to compare `String` objects, leading to an inaccurate result. Fix the code to correctly compare the content of the spell scrolls.",
    "story_context": "The SpellScrollComparer needs to compare scroll contents accurately. Your task is to fix the string comparison method.",
    "challenge_data": {
      "initial_code": "public class SpellScrollComparer {\n    public static void main(String[] args) {\n        String spellScroll1 = \"Fireball\";\n        String spellScroll2 = new String(\"Fireball\");\n        \n        if (spellScroll1 == spellScroll2) {\n            System.out.println(\"Scrolls are identical.\");\n        } else {\n            System.out.println(\"Scrolls are different.\");\n        }\n    }\n}",
      "expected_output": [
        "Scrolls are identical."
      ],
      "solution_code": "public class SpellScrollComparer {\n    public static void main(String[] args) {\n        String spellScroll1 = \"Fireball\";\n        String spellScroll2 = new String(\"Fireball\");\n        \n        if (spellScroll1.equals(spellScroll2)) {\n            System.out.println(\"Scrolls are identical.\");\n        } else {\n            System.out.println(\"Scrolls are different.\");\n        }\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 6,
          "type": "string_comparison",
          "description": "Using == instead of .equals() for String comparison",
          "fix": "Change == to .equals(): if (spellScroll1.equals(spellScroll2))"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The `==` operator, when used with objects (including `String`s that are not just literals and interned), compares their memory addresses (references). `spellScroll1` points to a `String` literal in the string pool, while `spellScroll2` points to a *new* `String` object created on the heap, even though their content is identical. Therefore, `spellScroll1 == spellScroll2` evaluates to `false`. To compare the actual textual content of `String` objects, the `.equals()` method must be used."
    },
    "hints": {
      "1": "For non-primitive types like `String`, the `==` operator checks if two variables point to the *exact same object* in memory.",
      "2": "If you want to compare what's *inside* the objects (their text content), you need a different method.",
      "3": " `new String(\"...\")` always creates a brand new object."
    }
  },
  {
    "id": 107,
    "subtopic_id": 3,
    "type": "code_fixer",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `PotionShelf` is being set up, but the `potionBottles` array is declared without being initialized, causing a `NullPointerException` when trying to add a potion. Fix the code to correctly initialize the array.",
    "story_context": "The PotionShelf needs to store potion bottles. Your task is to fix the array initialization.",
    "challenge_data": {
      "initial_code": "public class PotionShelf {\n    public static void main(String[] args) {\n        String[] potionBottles;\n        potionBottles[0] = \"Healing Potion\";\n        System.out.println(\"First Potion: \" + potionBottles[0]);\n    }\n}",
      "expected_output": [
        "First Potion: Healing Potion"
      ],
      "solution_code": "public class PotionShelf {\n    public static void main(String[] args) {\n        String[] potionBottles = new String[3];\n        potionBottles[0] = \"Healing Potion\";\n        System.out.println(\"First Potion: \" + potionBottles[0]);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 3,
          "type": "array_initialization",
          "description": "Array not initialized, causing NullPointerException",
          "fix": "Initialize array: String[] potionBottles = new String[3];"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code declares `potionBottles` as an array variable (`String[] potionBottles;`), but it does not actually create the array object in memory. Attempting to access or assign elements (`potionBottles[0]`) on a variable that points to `null` (because it's uninitialized) results in a `NullPointerException` at runtime. The fix is to initialize the array using the `new` keyword and specify its size, for example, `new String[3]`."
    },
    "hints": {
      "1": "Declaring an array variable (e.g., `String[]`) only says \"this variable will point to an array.\" It doesn't actually create the list itself.",
      "2": "You need the `new` keyword to create the actual array object in memory and specify its size.",
      "3": "Imagine having an empty shelf that can hold bottles, but no actual shelf has been built yet."
    }
  },
  {
    "id": 108,
    "subtopic_id": 3,
    "type": "code_fixer",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `ScrollChecker` attempts to determine the length of a `spellScroll` that is initialized as `null`. Calling `.length()` on a `null` variable causes a `NullPointerException`. Fix the code to assign a valid `String` to `spellScroll`.",
    "story_context": "The ScrollChecker needs to analyze spell scrolls. Your task is to fix the null reference issue.",
    "challenge_data": {
      "initial_code": "public class ScrollChecker {\n    public static void main(String[] args) {\n        String spellScroll = null;\n        System.out.println(\"Spell Length: \" + spellScroll.length());\n    }\n}",
      "expected_output": [
        "Spell Length: 8"
      ],
      "solution_code": "public class ScrollChecker {\n    public static void main(String[] args) {\n        String spellScroll = \"Incendio\";\n        System.out.println(\"Spell Length: \" + spellScroll.length());\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 3,
          "type": "null_reference",
          "description": "spellScroll is null, causing NullPointerException",
          "fix": "Assign valid string: String spellScroll = \"Incendio\";"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The `spellScroll` variable is initialized to `null`, meaning it does not refer to any actual `String` object in memory. Attempting to call a method like `.length()` on a `null` reference results in a `NullPointerException` at runtime. The fix is to assign `spellScroll` to an actual `String` object (e.g., `\"Incendio\"`) before calling its methods."
    },
    "hints": {
      "1": "A `NullPointerException` typically means you're trying to do something with a variable that points to \"nothing\" (`null`).",
      "2": "Methods like `.length()` can only be called on actual objects, not on `null`.",
      "3": "Assign a valid `String` literal to `spellScroll` to make it point to a real object."
    }
  },
  {
    "id": 109,
    "subtopic_id": 3,
    "type": "code_fixer",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `PortalJumper` system manages `portalDestinations` in an array. The array is declared with a size of 2, but the code attempts to access an element at index 2, which is out of bounds. Fix the code to access a valid array index.",
    "story_context": "The PortalJumper needs to access portal destinations. Your task is to fix the array bounds issue.",
    "challenge_data": {
      "initial_code": "public class PortalJumper {\n    public static void main(String[] args) {\n        String[] portalDestinations = new String[2];\n        portalDestinations[0] = \"Elysium\";\n        portalDestinations[2] = \"Astral Plane\";\n        System.out.println(\"Next Portal: \" + portalDestinations[2]);\n    }\n}",
      "expected_output": [
        "Next Portal: Astral Plane"
      ],
      "solution_code": "public class PortalJumper {\n    public static void main(String[] args) {\n        String[] portalDestinations = new String[3];\n        portalDestinations[0] = \"Elysium\";\n        portalDestinations[2] = \"Astral Plane\";\n        System.out.println(\"Next Portal: \" + portalDestinations[2]);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 3,
          "type": "array_bounds",
          "description": "Array size too small for index 2",
          "fix": "Increase array size: String[] portalDestinations = new String[3];"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The `portalDestinations` array is initialized with a size of `2`, meaning its valid indices are `0` and `1`. Attempting to access `portalDestinations[2]` (which is the third element) results in an `ArrayIndexOutOfBoundsException` at runtime. The fix is to either increase the array's size to at least `3` (e.g., `new String[3]`) to make index `2` valid, and then assign a value to it, or change the index being accessed to `0` or `1`."
    },
    "hints": {
      "1": "If an array has size `N`, its valid indices range from `0` to `N-1`.",
      "2": "Attempting to access an index outside this range causes an `ArrayIndexOutOfBoundsException`.",
      "3": "Either increase the array's capacity or access an existing index."
    }
  },
  {
    "id": 110,
    "subtopic_id": 3,
    "type": "code_fixer",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `RuneModifier` attempts to change a character within a `runePhrase` directly. However, `String` objects are immutable in Java, so their characters cannot be modified directly. Fix the code to correctly create a modified `String`.",
    "story_context": "The RuneModifier needs to modify rune phrases. Your task is to fix the string immutability issue.",
    "challenge_data": {
      "initial_code": "public class RuneModifier {\n    public static void main(String[] args) {\n        String runePhrase = \"MAGIC\";\n        runePhrase.charAt(0) = 'X';\n        System.out.println(\"Modified Rune: \" + runePhrase);\n    }\n}",
      "expected_output": [
        "Modified Rune: XAGIC"
      ],
      "solution_code": "public class RuneModifier {\n    public static void main(String[] args) {\n        String runePhrase = \"MAGIC\";\n        runePhrase = 'X' + runePhrase.substring(1);\n        System.out.println(\"Modified Rune: \" + runePhrase);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 4,
          "type": "string_immutability",
          "description": "Cannot modify String directly, must create new String",
          "fix": "Create new string: runePhrase = 'X' + runePhrase.substring(1);"
        }
      ],
      "number_of_errors": 1,
      "explanation": " `String` objects in Java are immutable, meaning their content cannot be changed once created. The line `runePhrase.charAt(0) = 'X';` attempts to directly modify a character within the existing `runePhrase` object, which is illegal and causes a compilation error. To achieve the effect of changing a character, a new `String` must be created with the desired modification (e.g., concatenating the new character `'X'` with the rest of the `runePhrase` from index 1 onwards using `substring(1)`), and then `runePhrase` is reassigned to point to this new `String`."
    },
    "hints": {
      "1": " `String` objects in Java are special: once created, their internal sequence of characters cannot be altered.",
      "2": "Methods like `charAt()` return a value, but they don't allow you to change the `String` itself.",
      "3": "To \"change\" a `String`, you actually create a *new* `String` that contains the desired modifications, and then reassign your variable to point to this new `String`."
    }
  },
  {
    "id": 111,
    "subtopic_id": 3,
    "type": "code_fixer",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "An `ArcaneIDGenerator` attempts to `trim` leading/trailing spaces from a `magicWord`. However, `String` methods like `trim()` return a new `String` rather than modifying the original, so the changes are lost. Fix the code to correctly apply the trimming.",
    "story_context": "The ArcaneIDGenerator needs to clean magic words. Your task is to fix the string method assignment.",
    "challenge_data": {
      "initial_code": "public class ArcaneIDGenerator {\n    public static void main(String[] args) {\n        String magicWord = \"  Alakazam  \";\n        magicWord.trim();\n        System.out.println(\"Cleaned Word: '\" + magicWord + \"'\");\n    }\n}",
      "expected_output": [
        "Cleaned Word: 'Alakazam'"
      ],
      "solution_code": "public class ArcaneIDGenerator {\n    public static void main(String[] args) {\n        String magicWord = \"  Alakazam  \";\n        magicWord = magicWord.trim();\n        System.out.println(\"Cleaned Word: '\" + magicWord + \"'\");\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 4,
          "type": "string_method_assignment",
          "description": "trim() result not assigned back to variable",
          "fix": "Assign result: magicWord = magicWord.trim();"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The `String` object `magicWord` is immutable. The `.trim()` method does not modify the `magicWord` object itself; instead, it returns a *new* `String` object with leading and trailing whitespace removed. The original code discards this new, cleaned `String`. The fix is to reassign the `magicWord` variable to the result of `magicWord.trim()`, so it points to the new, cleaned `String` object."
    },
    "hints": {
      "1": "Remember that `String` objects in Java are immutable; their content cannot change.",
      "2": "Methods like `trim()`, `toUpperCase()`, `replace()` *return a new `String`* with the modifications.",
      "3": "To apply the changes, you must reassign the variable to point to this new `String` object."
    }
  },
  {
    "id": 112,
    "subtopic_id": 3,
    "type": "code_fixer",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `SpiritSummoner` attempts to place a spirit in a `summoningCircle` array that has been declared but not initialized, resulting in a `NullPointerException`. Fix the code to correctly initialize the array before use.",
    "story_context": "The SpiritSummoner needs to create a summoning circle. Your task is to fix the array initialization.",
    "challenge_data": {
      "initial_code": "public class SpiritSummoner {\n    public static void main(String[] args) {\n        String[] summoningCircle;\n        summoningCircle[0] = \"Lesser Spirit\";\n        System.out.println(\"Spirit in Circle: \" + summoningCircle[0]);\n    }\n}",
      "expected_output": [
        "Spirit in Circle: Lesser Spirit"
      ],
      "solution_code": "public class SpiritSummoner {\n    public static void main(String[] args) {\n        String[] summoningCircle = new String[5];\n        summoningCircle[0] = \"Lesser Spirit\";\n        System.out.println(\"Spirit in Circle: \" + summoningCircle[0]);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 3,
          "type": "array_initialization",
          "description": "Array declared but not initialized",
          "fix": "Initialize array: String[] summoningCircle = new String[5];"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The `String[] summoningCircle;` line declares the array variable but does not create the actual array object in memory. Without `new String[size]`, `summoningCircle` is `null`. Attempting to access an element (like `summoningCircle[0]`) on a `null` array causes a `NullPointerException` at runtime. The fix is to explicitly create the array object with a size, for example, `new String[5]`."
    },
    "hints": {
      "1": "Declaring an array variable (e.g., `String[]`) only says \"this variable will point to an array.\" It doesn't create the list itself.",
      "2": "You need the `new` keyword followed by the type and size (`new Type[size]`) to create the actual array object.",
      "3": "Attempting to put something into a non-existent container will lead to a `NullPointerException`."
    }
  },
  {
    "id": 113,
    "subtopic_id": 3,
    "type": "code_fixer",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `TomeReader` tries to determine if an `ancientTome` is readable by checking its length. However, `ancientTome` is `null`, causing a `NullPointerException`. Fix the code to safely handle `null` values before attempting to call methods on them.",
    "story_context": "The TomeReader needs to check if a tome is readable. Your task is to fix the null pointer issue.",
    "challenge_data": {
      "initial_code": "public class TomeReader {\n    public static void main(String[] args) {\n        String ancientTome = null;\n        if (ancientTome.length() > 0) {\n            System.out.println(\"Tome is readable.\");\n        } else {\n            System.out.println(\"Tome not found or empty.\");\n        }\n    }\n}",
      "expected_output": [
        "Tome not found or empty."
      ],
      "solution_code": "public class TomeReader {\n    public static void main(String[] args) {\n        String ancientTome = null;\n        if (ancientTome != null && ancientTome.length() > 0) {\n            System.out.println(\"Tome is readable.\");\n        } else {\n            System.out.println(\"Tome not found or empty.\");\n        }\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 4,
          "type": "null_pointer",
          "description": "Calling method on null reference",
          "fix": "Add null check: if (ancientTome != null && ancientTome.length() > 0)"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The `ancientTome` variable is explicitly set to `null`. Attempting to call the `.length()` method on a `null` reference immediately causes a `NullPointerException`. The fix involves adding a `null` check (`ancientTome != null`) before attempting to access `.length()`. By using `&&` (logical AND), Java employs short-circuiting: if `ancientTome != null` is `false`, the second part of the condition (`ancientTome.length() > 0`) is never evaluated, preventing a `NullPointerException`."
    },
    "hints": {
      "1": "A `NullPointerException` means you're trying to perform an action on something that doesn't exist (`null`).",
      "2": "Always check if a non-primitive variable is `null` before trying to use its methods (e.g., `variable != null`).",
      "3": "The `&&` (logical AND) operator is useful for combining conditions, as it \"short-circuits.\""
    }
  },
  {
    "id": 114,
    "subtopic_id": 3,
    "type": "code_fixer",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `SpellAssignment` system compares two spell scrolls. The `spellScroll1` (a literal) and `newSpell` (created with `new String()`) have identical content, but using `==` to compare them incorrectly reports them as different. Fix the code to compare their content correctly.",
    "story_context": "The SpellAssignment needs to compare spell scrolls. Your task is to fix the string comparison.",
    "challenge_data": {
      "initial_code": "public class SpellAssignment {\n    public static void main(String[] args) {\n        String spellScroll1 = \"Incendio\";\n        String newSpell = new String(\"Incendio\");\n        \n        if (spellScroll1 == newSpell) {\n            System.out.println(\"Spells are identical in content.\");\n        } else {\n            System.out.println(\"Spells are different.\");\n        }\n    }\n}",
      "expected_output": [
        "Spells are identical in content."
      ],
      "solution_code": "public class SpellAssignment {\n    public static void main(String[] args) {\n        String spellScroll1 = \"Incendio\";\n        String newSpell = new String(\"Incendio\");\n        \n        if (spellScroll1.equals(newSpell)) {\n            System.out.println(\"Spells are identical in content.\");\n        } else {\n            System.out.println(\"Spells are different.\");\n        }\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 6,
          "type": "string_comparison",
          "description": "Using == instead of .equals() for string content comparison",
          "fix": "Use .equals(): if (spellScroll1.equals(newSpell))"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code attempts to compare the textual content of `spellScroll1` and `newSpell` using the `==` operator. However, `spellScroll1` (a string literal) and `newSpell` (a `String` object created with `new`) typically point to different memory locations, even though their content is identical. Therefore, `spellScroll1 == newSpell` evaluates to `false`. To correctly compare the textual content, the `.equals()` method must be used."
    },
    "hints": {
      "1": "Remember that `==` for non-primitive types (like `String`) compares memory locations (references).",
      "2": "`\"Incendio\"` (literal) and `new String(\"Incendio\")` (object created with `new`) usually reside at different memory locations.",
      "3": "If you want to check if the *text inside* two `String` variables is the same, there's a specific method for that."
    }
  },
  {
    "id": 115,
    "subtopic_id": 3,
    "type": "code_fixer",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `MapRegionsTracker` records `mapRegions` in an array. The code attempts to print the `mapRegions.length` by accessing an out-of-bounds index, causing an `ArrayIndexOutOfBoundsException`. Fix the code to correctly print the total size of the array.",
    "story_context": "The MapRegionsTracker needs to display map regions. Your task is to fix the array length access.",
    "challenge_data": {
      "initial_code": "public class MapRegionsTracker {\n    public static void main(String[] args) {\n        String[] mapRegions = new String[5];\n        mapRegions[0] = \"Forest\";\n        mapRegions[1] = \"Mountain\";\n        \n        System.out.println(\"Total Map Regions: \" + mapRegions[5]);\n    }\n}",
      "expected_output": [
        "Total Map Regions: 5"
      ],
      "solution_code": "public class MapRegionsTracker {\n    public static void main(String[] args) {\n        String[] mapRegions = new String[5];\n        mapRegions[0] = \"Forest\";\n        mapRegions[1] = \"Mountain\";\n        \n        System.out.println(\"Total Map Regions: \" + mapRegions.length);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 7,
          "type": "array_bounds",
          "description": "Accessing out-of-bounds index to get array length",
          "fix": "Use .length property: mapRegions.length"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code attempts to get the total number of map regions by accessing `mapRegions[5]`. However, for an array of size 5, valid indices are from 0 to 4. Accessing index 5 results in an `ArrayIndexOutOfBoundsException`. To get the total size (or length) of an array, its `.length` property should be used (e.g., `mapRegions.length`)."
    },
    "hints": {
      "1": "Arrays have a special property (not a method) that directly tells you their declared size.",
      "2": "Accessing `array[index]` attempts to retrieve an element, not the array's total capacity.",
      "3": "Remember `N-1` for the last valid index."
    }
  },
  {
    "id": 116,
    "subtopic_id": 3,
    "type": "code_fixer",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `SpellParameterProcessor` attempts to process a `param1` string that might become `null`. Calling `String` methods like `substring()` on a `null` variable causes a `NullPointerException`. Fix the code to safely handle `null` values before processing the string.",
    "story_context": "The SpellParameterProcessor needs to handle spell parameters. Your task is to fix the null pointer handling.",
    "challenge_data": {
      "initial_code": "public class SpellParameterProcessor {\n    public static void main(String[] args) {\n        String param1 = \"   Cleanse   \";\n        param1 = param1.trim();\n        param1 = null;\n        \n        String finalParameter = param1.substring(0, 7).toUpperCase();\n        \n        String param2 = \"Purify\";\n        \n        if (finalParameter.equals(param2)) {\n            System.out.println(\"Parameters Match: \" + finalParameter);\n        } else {\n            System.out.println(\"Parameters Mismatch.\");\n        }\n    }\n}",
      "expected_output": [
        "Parameters Mismatch."
      ],
      "solution_code": "public class SpellParameterProcessor {\n    public static void main(String[] args) {\n        String param1 = \"   Cleanse   \";\n        param1 = param1.trim();\n        param1 = null;\n        \n        String finalParameter;\n        if (param1 != null) {\n            finalParameter = param1.substring(0, 7).toUpperCase();\n        } else {\n            finalParameter = \"NULL_PARAM\";\n        }\n        \n        String param2 = \"Purify\";\n        \n        if (finalParameter.equals(param2)) {\n            System.out.println(\"Parameters Match: \" + finalParameter);\n        } else {\n            System.out.println(\"Parameters Mismatch.\");\n        }\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 7,
          "type": "null_pointer",
          "description": "Calling methods on null reference without null check",
          "fix": "Add null check: if (param1 != null) { ... } else { finalParameter = \"NULL_PARAM\"; }"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code explicitly sets `param1` to `null`. Attempting to call `.substring()` or `.toUpperCase()` on a `null` reference (which `param1` becomes) immediately causes a `NullPointerException`. The fix involves adding a `null` check (`if (param1 != null)`) before attempting to use methods on `param1`. If `param1` is `null`, a default value like `\"NULL_PARAM\"` is assigned to `finalParameter`, preventing the crash and allowing the program to continue gracefully."
    },
    "hints": {
      "1": "A `NullPointerException` means a method is called on a variable that points to `null` (nothing).",
      "2": "Always check if a non-primitive variable is `null` before trying to use its methods (e.g., `variable != null`).",
      "3": "Consider a way to assign a safe default value if the variable is indeed `null`."
    }
  },
  {
    "id": 117,
    "subtopic_id": 3,
    "type": "code_fixer",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `RuneProcessor` attempts to `trim` and `replace` parts of `runeText`. However, `String` methods do not modify the original string, causing the final `runeText` to be incorrect. Fix the code to correctly apply these `String` transformations.",
    "story_context": "The RuneProcessor needs to transform rune text. Your task is to fix the string method assignments.",
    "challenge_data": {
      "initial_code": "public class RuneProcessor {\n    public static void main(String[] args) {\n        String runeText = \"  Ancient Power Runes  \";\n        \n        runeText.trim();\n        runeText.replace(\"Power\", \"Magic\");\n        String finalRuneText = runeText.substring(0, 12);\n        \n        System.out.println(\"Final Rune Text: \" + finalRuneText);\n    }\n}",
      "expected_output": [
        "Final Rune Text: Ancient Mag"
      ],
      "solution_code": "public class RuneProcessor {\n    public static void main(String[] args) {\n        String runeText = \"  Ancient Power Runes  \";\n        \n        runeText = runeText.trim();\n        runeText = runeText.replace(\"Power\", \"Magic\");\n        String finalRuneText = runeText.substring(0, 12);\n        \n        System.out.println(\"Final Rune Text: \" + finalRuneText);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 5,
          "type": "string_method_assignment",
          "description": "trim() result not assigned back to variable",
          "fix": "Assign result: runeText = runeText.trim();"
        },
        {
          "id": 2,
          "line": 6,
          "type": "string_method_assignment",
          "description": "replace() result not assigned back to variable",
          "fix": "Assign result: runeText = runeText.replace(\"Power\", \"Magic\");"
        }
      ],
      "number_of_errors": 2,
      "explanation": " `String` objects in Java are immutable. This means methods like `trim()` and `replace()` do not modify the `runeText` object directly. Instead, they return *new* `String` objects with the modifications. The original code discards these new `String` objects because their return values are not assigned back to `runeText`. Consequently, `runeText` remains \"  Ancient Power Runes  \" throughout these operations. The fix is to reassign `runeText` to the result of each method call (`runeText = runeText.trim();` and `runeText = runeText.replace(\"Power\", \"Magic\");`) to chain the transformations correctly."
    },
    "hints": {
      "1": " `String` methods like `trim()`, `replace()`, `substring()`, `toUpperCase()`, `toLowerCase()` *do not change the original `String` object*.",
      "2": "These methods *return a brand new `String` object* that contains the modified sequence of characters.",
      "3": "To apply the changes, you must explicitly reassign the `String` variable to point to this new `String` object returned by the method."
    }
  },
  {
    "id": 118,
    "subtopic_id": 3,
    "type": "code_fixer",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "An `ArtifactInventory` stores `artifactTitles` in an array. By default, `String` array elements are `null`, not empty strings. The code incorrectly checks for empty strings and then attempts to call `.length()` on a `null` element, causing a `NullPointerException`. Fix the code to correctly handle `null` and empty string checks.",
    "story_context": "The ArtifactInventory needs to check artifact titles. Your task is to fix the null handling in arrays.",
    "challenge_data": {
      "initial_code": "public class ArtifactInventory {\n    public static void main(String[] args) {\n        String[] artifactTitles = new String[3];\n        \n        if (artifactTitles[0] == \"\") {\n            System.out.println(\"First slot is null.\");\n        } else {\n            System.out.println(\"First slot is not an empty string or null.\");\n        }\n        \n        System.out.println(\"Second slot length: \" + artifactTitles[1].length());\n    }\n}",
      "expected_output": [
        "First slot is null.",
        "Second slot is null, no length."
      ],
      "solution_code": "public class ArtifactInventory {\n    public static void main(String[] args) {\n        String[] artifactTitles = new String[3];\n        \n        if (artifactTitles[0] == null) {\n            System.out.println(\"First slot is null.\");\n        } else {\n            System.out.println(\"First slot is not null or empty string.\");\n        }\n        \n        if (artifactTitles[1] != null) {\n            System.out.println(\"Second slot length: \" + artifactTitles[1].length());\n        } else {\n            System.out.println(\"Second slot is null, no length.\");\n        }\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 5,
          "type": "null_comparison",
          "description": "Comparing null with empty string instead of checking for null",
          "fix": "Check for null: if (artifactTitles[0] == null)"
        },
        {
          "id": 2,
          "line": 10,
          "type": "null_pointer",
          "description": "Calling method on null array element without null check",
          "fix": "Add null check: if (artifactTitles[1] != null) { ... } else { ... }"
        }
      ],
      "number_of_errors": 2,
      "explanation": "When `new String[3]` is called, the elements of `artifactTitles` are initialized to `null`, not `\"\"` (empty string).\n1. `artifactTitles[0] == \"\"` (null == \"\") evaluates to `false`, so it prints \"First slot is not an empty string or null.\".\n2. `System.out.println(\"Second slot length: \" + artifactTitles[1].length());` attempts to call `.length()` on `artifactTitles[1]`, which is `null`. This results in a `NullPointerException`.\n\nThe fix addresses two issues:\n* Correctly identifies that default `String` array elements are `null`.\n* Adds `null` checks (`artifactTitles[1] != null`) before calling methods like `.length()` on array elements that might be `null`, thus preventing `NullPointerException`s and allowing for proper handling of `null` slots. The `if` condition for `artifactTitles[0]` is expanded to differentiate between `null` and `\"\"`."
    },
    "hints": {
      "1": "When an array of non-primitive types (like `String[]`) is created, its elements are automatically initialized to their default value, which is `null` for object types. They are *not* initialized to empty strings (`\"\"`).",
      "2": "Comparing `null` with `\"\"` using `==` will be `false`. Calling `.equals()` on `null` will cause a `NullPointerException`.",
      "3": "Always check for `null` before trying to use methods on a potentially `null` array element."
    }
  },
  {
    "id": 119,
    "subtopic_id": 3,
    "type": "code_fixer",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `ScrollReplication` system compares `masterScroll` (literal) and `replicaScroll1` (literal) with `replicaScroll2` (new `String` object). The code incorrectly uses `==` for content comparison, leading to `identicalObjects` being `false` when content is the same. Fix the code to correctly compare `String` content across different `String` object types.",
    "story_context": "The ScrollReplication needs to compare scroll content. Your task is to fix the string comparison.",
    "challenge_data": {
      "initial_code": "public class ScrollReplication {\n    public static void main(String[] args) {\n        String masterScroll = \"Ancient Rune\";\n        String replicaScroll1 = \"Ancient Rune\";\n        String replicaScroll2 = new String(\"Ancient Rune\");\n        \n        boolean identicalObjects = (replicaScroll1 == replicaScroll2);\n        boolean contentMatches = (masterScroll == replicaScroll2);\n        \n        System.out.println(\"Are Objects Identical: \" + identicalObjects);\n        System.out.println(\"Does Content Match: \" + contentMatches);\n    }\n}",
      "expected_output": [
        "Are Objects Identical: false",
        "Does Content Match: true"
      ],
      "solution_code": "public class ScrollReplication {\n    public static void main(String[] args) {\n        String masterScroll = \"Ancient Rune\";\n        String replicaScroll1 = \"Ancient Rune\";\n        String replicaScroll2 = new String(\"Ancient Rune\");\n        \n        boolean identicalObjects = (replicaScroll1 == replicaScroll2);\n        boolean contentMatches = masterScroll.equals(replicaScroll2);\n        \n        System.out.println(\"Are Objects Identical: \" + identicalObjects);\n        System.out.println(\"Does Content Match: \" + contentMatches);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 9,
          "type": "string_comparison",
          "description": "Using == instead of .equals() for string content comparison",
          "fix": "Use .equals(): contentMatches = masterScroll.equals(replicaScroll2);"
        }
      ],
      "number_of_errors": 1,
      "explanation": "1. **`identicalObjects`**: `replicaScroll1 == replicaScroll2` correctly uses `==` for reference comparison. `replicaScroll1` (a literal) and `replicaScroll2` (created with `new String()`) point to different memory locations, so `identicalObjects` is `false`.\n2. **`contentMatches`**: The original `masterScroll == replicaScroll1` is `true` due to string interning. However, to correctly illustrate `String` content comparison with `new String()` objects (which is the more complex scenario), the fix changes the comparison to `masterScroll.equals(replicaScroll2)`. This uses the `.equals()` method to compare the actual textual content, resulting in `true`."
    },
    "hints": {
      "1": "For `String` objects, `==` compares whether two variables point to the *exact same memory location*.",
      "2": " `new String(\"...\")` *always* creates a new object in memory, even if the content is the same as an existing literal.",
      "3": "To compare the actual sequence of characters (the content) of `String` objects, you must use a specific method."
    }
  },
  {
    "id": 120,
    "subtopic_id": 3,
    "type": "code_fixer",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `SpellbookManager` tracks `spellbookPages`. Assigning `null` to an element should not change the array's total size, but the code incorrectly calculates the `Remaining Pages` based on this assumption. Fix the code to correctly report the fixed `Total Slots` of the array.",
    "story_context": "The SpellbookManager needs to track spellbook pages. Your task is to fix the array length calculation.",
    "challenge_data": {
      "initial_code": "public class SpellbookManager {\n    public static void main(String[] args) {\n        String[] spellbookPages = {\"Page 1\", \"Page 2\", \"Page 3\"};\n        \n        spellbookPages[1] = null;\n        \n        System.out.println(\"Total Slots (fixed): \" + (spellbookPages.length - 1));\n    }\n}",
      "expected_output": [
        "Total Slots (fixed): 3"
      ],
      "solution_code": "public class SpellbookManager {\n    public static void main(String[] args) {\n        String[] spellbookPages = {\"Page 1\", \"Page 2\", \"Page 3\"};\n        \n        spellbookPages[1] = null;\n        \n        System.out.println(\"Total Slots (fixed): \" + spellbookPages.length);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 7,
          "type": "array_length_calculation",
          "description": "Incorrectly subtracting from array length when setting element to null",
          "fix": "Use array length directly: spellbookPages.length"
        }
      ],
      "number_of_errors": 1,
      "explanation": "Arrays in Java are objects with a fixed size. Assigning `null` to an element (`spellbookPages[1] = null;`) simply means that array slot no longer points to a `String` object; it does *not* change the array's fundamental size or its `.length` property. The original code incorrectly assumes that setting an element to `null` reduces the array's length, leading to an inaccurate output. The fix demonstrates that `spellbookPages.length` will always remain `3`, regardless of individual elements being `null`."
    },
    "hints": {
      "1": "Arrays in Java have a fixed size once they are created.",
      "2": "Assigning `null` to an element in an array simply makes that slot \"empty\" but does not change the array's overall `.length`.",
      "3": "The `.length` property of an array always reflects its initially declared capacity."
    }
  },
  {
    "id": 121,
    "subtopic_id": 3,
    "type": "code_completion",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `GrandSpellcaster` is preparing a grand spell. The `grandSpell` variable needs to be declared to store the text of this mighty incantation. Complete the declaration and initialization.",
    "story_context": "The GrandSpellcaster needs to prepare mighty incantations. Your task is to complete the variable declaration and initialization.",
    "challenge_data": {
      "initial_code": "public class GrandSpellcaster {\n    public static void main(String[] args) {\n        ??? = ???;\n        System.out.println(\"Grand Spell: \" + grandSpell);\n    }\n}",
      "expected_output": [
        "Grand Spell: Mighty Incantation"
      ],
      "solution_code": "public class GrandSpellcaster {\n    public static void main(String[] args) {\n        String grandSpell = \"Mighty Incantation\";\n        System.out.println(\"Grand Spell: \" + grandSpell);\n    }\n}",
      "choices": [
        "'Mighty Incantation'",
        "String grandSpell",
        "char grandSpell",
        "\"Mighty Incantation\""
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 3,
          "type": "variable_declaration",
          "description": "Complete variable declaration for grandSpell",
          "correct_answer": "String grandSpell",
          "explanation": "The variable `grandSpell` is assigned the text `\"Mighty Incantation\"`. In Java, the `String` class is used to represent text."
        },
        {
          "id": "slot_2",
          "line": 3,
          "type": "variable_initialization",
          "description": "String value initialization for grandSpell",
          "correct_answer": "\"Mighty Incantation\"",
          "explanation": "String literals are enclosed in double quotes in Java."
        }
      ],
      "number_of_slots": 2
    },
    "hints": {
      "1": "The variable `grandSpell` is intended to hold a sequence of characters (text).",
      "2": "Recall the non-primitive data type used for storing text in Java.",
      "3": "How are text literal values (strings) typically enclosed in Java?"
    }
  },
  {
    "id": 122,
    "subtopic_id": 3,
    "type": "code_completion",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `PotionRegistry` creates and names different brews. The `brewNames` variable needs to be declared as an array to hold `String` objects. Complete the array declaration.",
    "story_context": "The PotionRegistry needs to manage different brew names. Your task is to complete the array declaration.",
    "challenge_data": {
      "initial_code": "public class PotionRegistry {\n    public static void main(String[] args) {\n        ??? = new String[3];\n        brewNames[0] = \"Healing Brew\";\n        System.out.println(\"First Brew: \" + brewNames[0]);\n    }\n}",
      "expected_output": [
        "First Brew: Healing Brew"
      ],
      "solution_code": "public class PotionRegistry {\n    public static void main(String[] args) {\n        String[] brewNames = new String[3];\n        brewNames[0] = \"Healing Brew\";\n        System.out.println(\"First Brew: \" + brewNames[0]);\n    }\n}",
      "choices": [
        "String[] brewNames",
        "String brewNames",
        "brewNames",
        "int[] brewNames"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 3,
          "type": "variable_declaration",
          "description": "Array declaration for brewNames",
          "correct_answer": "String[] brewNames",
          "explanation": "The variable `brewNames` is intended to be an array that holds `String` objects, as indicated by `new String[3]`. The correct syntax for declaring such an array variable is `String[] brewNames`."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": "The variable `brewNames` is intended to be a collection (list) of strings.",
      "2": "Recall the syntax for declaring an array variable.",
      "3": "The type of elements in the array are `String`."
    }
  },
  {
    "id": 123,
    "subtopic_id": 3,
    "type": "code_completion",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `TomeReader` displays the title of an enchanted tome. The `enchantedTomeTitle` variable holds the title. Complete the print statement to correctly display the value of the variable.",
    "story_context": "The TomeReader needs to display enchanted tome titles. Your task is to complete the print statement.",
    "challenge_data": {
      "initial_code": "public class TomeReader {\n    public static void main(String[] args) {\n        String enchantedTomeTitle = \"Whispers of Eldoria\";\n        System.out.println(\"Tome Title: \" + ???);\n    }\n}",
      "expected_output": [
        "Tome Title: Whispers of Eldoria"
      ],
      "solution_code": "public class TomeReader {\n    public static void main(String[] args) {\n        String enchantedTomeTitle = \"Whispers of Eldoria\";\n        System.out.println(\"Tome Title: \" + enchantedTomeTitle);\n    }\n}",
      "choices": [
        "\"enchantedTomeTitle\"",
        "title",
        "enchantedTome",
        "enchantedTomeTitle"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 4,
          "type": "variable_name",
          "description": "Variable reference in print statement",
          "correct_answer": "enchantedTomeTitle",
          "explanation": "The variable storing the tome's title is named `enchantedTomeTitle`. To print its value, the variable name itself should be used directly in the `System.out.println()` statement."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": "You need to reference the variable itself, not a string literal of its name.",
      "2": "The variable to be printed is already declared and initialized.",
      "3": "The `+` operator will concatenate the literal string with the variable's value."
    }
  },
  {
    "id": 124,
    "subtopic_id": 3,
    "type": "code_completion",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `DungeonMaster` manages `creatureNames` in an array. The array is initialized with specific creature names. Complete the declaration of the `creatureNames` array.",
    "story_context": "The DungeonMaster needs to manage creature names in arrays. Your task is to complete the array declaration.",
    "challenge_data": {
      "initial_code": "public class DungeonMaster {\n    public static void main(String[] args) {\n        ??? = {\"Goblin\", \"Orc\"};\n        System.out.println(\"First Creature: \" + creatureNames[0]);\n    }\n}",
      "expected_output": [
        "First Creature: Goblin"
      ],
      "solution_code": "public class DungeonMaster {\n    public static void main(String[] args) {\n        String[] creatureNames = {\"Goblin\", \"Orc\"};\n        System.out.println(\"First Creature: \" + creatureNames[0]);\n    }\n}",
      "choices": [
        "String creatureNames",
        "int[] creatureNames",
        "String[] creatureNames",
        "creatureNames"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 3,
          "type": "variable_declaration",
          "description": "Array declaration for creatureNames",
          "correct_answer": "String[] creatureNames",
          "explanation": "The values provided (`{\"Goblin\", \"Orc\"}`) are an array initializer for an array of `String` objects. Therefore, `String[] creatureNames` is the correct way to declare and initialize this array variable."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": "The values `{\"Goblin\", \"Orc\"}` clearly indicate an array of strings.",
      "2": "Recall the syntax for declaring an array variable.",
      "3": "The missing part needs both the type and the name of the array."
    }
  },
  {
    "id": 125,
    "subtopic_id": 3,
    "type": "code_completion",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `ProphecyReader` needs to determine the length of `prophecyText`. Complete the method call to correctly get the length of the string.",
    "story_context": "The ProphecyReader needs to determine the length of prophecy text. Your task is to complete the method call.",
    "challenge_data": {
      "initial_code": "public class ProphecyReader {\n    public static void main(String[] args) {\n        String prophecyText = \"The Future is Unwritten.\";\n        System.out.println(\"Prophecy Length: \" + prophecyText.???);\n    }\n}",
      "expected_output": [
        "Prophecy Length: 22"
      ],
      "solution_code": "public class ProphecyReader {\n    public static void main(String[] args) {\n        String prophecyText = \"The Future is Unwritten.\";\n        System.out.println(\"Prophecy Length: \" + prophecyText.length());\n    }\n}",
      "choices": [
        "count()",
        "length",
        "size()",
        "length()"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 4,
          "type": "method_call",
          "description": "String length method call",
          "correct_answer": "length()",
          "explanation": "The `.length()` method is a built-in `String` method that returns the number of characters in the string. It's the correct way to get the length of `prophecyText`."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": " `String` objects have a specific method to determine their length.",
      "2": "This method's name usually reflects \"how long\" something is.",
      "3": "It typically ends with `()`."
    }
  },
  {
    "id": 126,
    "subtopic_id": 3,
    "type": "code_completion",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `SpellScrollComparer` checks if two spell scrolls (`scroll1` and `scroll2`) have identical content. Complete the method call and its argument to perform this content comparison.",
    "story_context": "The SpellScrollComparer needs to compare spell scroll content. Your task is to complete the method call and argument.",
    "challenge_data": {
      "initial_code": "public class SpellScrollComparer {\n    public static void main(String[] args) {\n        String scroll1 = \"Fireball\";\n        String scroll2 = new String(\"Fireball\");\n\n        if (scroll1.???(???)) {\n            System.out.println(\"Spell scrolls have identical content.\");\n        } else {\n            System.out.println(\"Spell scrolls have different content.\");\n        }\n    }\n}",
      "expected_output": [
        "Spell scrolls have identical content."
      ],
      "solution_code": "public class SpellScrollComparer {\n    public static void main(String[] args) {\n        String scroll1 = \"Fireball\";\n        String scroll2 = new String(\"Fireball\");\n\n        if (scroll1.equals(scroll2)) {\n            System.out.println(\"Spell scrolls have identical content.\");\n        } else {\n            System.out.println(\"Spell scrolls have different content.\");\n        }\n    }\n}",
      "choices": [
        "==",
        "isEqual",
        "equals",
        "compareTo",
        "scroll2",
        "scroll1"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 6,
          "type": "method_call",
          "description": "String equals method call",
          "correct_answer": "equals",
          "explanation": "To compare the actual content of two `String` objects, the `.equals()` method must be used."
        },
        {
          "id": "slot_2",
          "line": 6,
          "type": "method_argument",
          "description": "String object argument for equals method",
          "correct_answer": "scroll2",
          "explanation": "The argument to the `equals()` method is the other `String` object being compared, which is `scroll2`."
        }
      ],
      "number_of_slots": 2
    },
    "hints": {
      "1": "For non-primitive types like `String`, `==` compares memory locations, not content.",
      "2": "There's a specific `String` method designed for content comparison.",
      "3": "The blank within the parentheses is the `String` object you want to compare `scroll1` against."
    }
  },
  {
    "id": 127,
    "subtopic_id": 3,
    "type": "code_completion",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `FamiliarRegistry` creates an array `familiarNames` to store names of magical familiars. Complete the array declaration and the keyword to create a new array instance.",
    "story_context": "The FamiliarRegistry needs to create arrays for familiar names. Your task is to complete the array declaration and instantiation.",
    "challenge_data": {
      "initial_code": "public class FamiliarRegistry {\n    public static void main(String[] args) {\n        ??? = ??? String[4];\n        System.out.println(\"Array Size: \" + familiarNames.length);\n        System.out.println(\"First Slot: \" + familiarNames[0]);\n    }\n}",
      "expected_output": [
        "Array Size: 4",
        "First Slot: null"
      ],
      "solution_code": "public class FamiliarRegistry {\n    public static void main(String[] args) {\n        String[] familiarNames = new String[4];\n        System.out.println(\"Array Size: \" + familiarNames.length);\n        System.out.println(\"First Slot: \" + familiarNames[0]);\n    }\n}",
      "choices": [
        "allocate",
        "familiarNames",
        "new",
        "String familiarNames",
        "null",
        "String[] familiarNames"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 3,
          "type": "variable_declaration",
          "description": "Array declaration for familiarNames",
          "correct_answer": "String[] familiarNames",
          "explanation": "The variable `familiarNames` is an array of `String` objects. `String[] familiarNames` correctly declares this array variable."
        },
        {
          "id": "slot_2",
          "line": 3,
          "type": "keyword",
          "description": "New keyword for array instantiation",
          "correct_answer": "new",
          "explanation": "To create the actual array object in memory and specify its size, the `new` keyword is used before `new String[4]`."
        }
      ],
      "number_of_slots": 2
    },
    "hints": {
      "1": "The first blank needs the type and name for an array variable.",
      "2": "The second blank is the keyword used to create a new object instance in Java.",
      "3": "The array is meant to hold `String`s and have a size of 4."
    }
  },
  {
    "id": 128,
    "subtopic_id": 3,
    "type": "code_completion",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `RuneExtractor` retrieves a `middleRune` from a `secretSpell` string at a specific index. Complete the `String` method call and its argument to extract the character at index 3.",
    "story_context": "The RuneExtractor needs to extract runes from secret spells. Your task is to complete the method call and argument.",
    "challenge_data": {
      "initial_code": "public class RuneExtractor {\n    public static void main(String[] args) {\n        String secretSpell = \"ABRACADABRA\";\n        char middleRune = secretSpell.???(???);\n        System.out.println(\"Middle Rune: \" + middleRune);\n    }\n}",
      "expected_output": [
        "Middle Rune: A"
      ],
      "solution_code": "public class RuneExtractor {\n    public static void main(String[] args) {\n        String secretSpell = \"ABRACADABRA\";\n        char middleRune = secretSpell.charAt(3);\n        System.out.println(\"Middle Rune: \" + middleRune);\n    }\n}",
      "choices": [
        "4",
        "3",
        "index",
        "charAt",
        "substring",
        "getChar"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 4,
          "type": "method_call",
          "description": "String charAt method call",
          "correct_answer": "charAt",
          "explanation": "The `charAt()` method is used to retrieve a single character from a `String` at a specified index."
        },
        {
          "id": "slot_2",
          "line": 4,
          "type": "method_argument",
          "description": "Index argument for charAt method",
          "correct_answer": "3",
          "explanation": "To get the character at index 3, the argument `3` should be passed to the method."
        }
      ],
      "number_of_slots": 2
    },
    "hints": {
      "1": "There's a specific `String` method to get a character at a given position.",
      "2": "Remember that `String` indices start from `0`. So, index `3` refers to the fourth character.",
      "3": "The method name usually includes \"char\" and \"at\"."
    }
  },
  {
    "id": 129,
    "subtopic_id": 3,
    "type": "code_completion",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "An `ArtifactMonitor` tracks `artifactStatuses` in an array. The status of the first artifact needs to be updated to \"Inactive\". Complete the array index and the literal value for the assignment.",
    "story_context": "The ArtifactMonitor needs to update artifact statuses in arrays. Your task is to complete the array assignment.",
    "challenge_data": {
      "initial_code": "public class ArtifactMonitor {\n    public static void main(String[] args) {\n        String[] artifactStatuses = {\"Active\", \"Dormant\", \"Broken\"};\n        artifactStatuses[???] = ???;\n        System.out.println(\"First Artifact Status: \" + artifactStatuses[0]);\n    }\n}",
      "expected_output": [
        "First Artifact Status: Inactive"
      ],
      "solution_code": "public class ArtifactMonitor {\n    public static void main(String[] args) {\n        String[] artifactStatuses = {\"Active\", \"Dormant\", \"Broken\"};\n        artifactStatuses[0] = \"Inactive\";\n        System.out.println(\"First Artifact Status: \" + artifactStatuses[0]);\n    }\n}",
      "choices": [
        "\"Inactive\"",
        "artifactStatuses",
        "0",
        "1",
        "null",
        "status"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 4,
          "type": "array_index",
          "description": "Array index for first element",
          "correct_answer": "0",
          "explanation": "Arrays in Java are zero-indexed, so the first element is at index `0`."
        },
        {
          "id": "slot_2",
          "line": 4,
          "type": "variable_assignment",
          "description": "String literal assignment for artifact status",
          "correct_answer": "\"Inactive\"",
          "explanation": "The problem states the status needs to be updated to \"Inactive\", so `\"Inactive\"` is the correct `String` literal to assign to that index."
        }
      ],
      "number_of_slots": 2
    },
    "hints": {
      "1": "The problem states the *first* artifact's status needs to be changed.",
      "2": "Recall the array index for the first element.",
      "3": "The new value is a specific string representing the status."
    }
  },
  {
    "id": 130,
    "subtopic_id": 3,
    "type": "code_completion",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "An `OptionalScrollCheck` evaluates an `optionalScrollName` which might be `null`. Before accessing its length, a `null` check is needed. Complete the `if` condition to safely check if `optionalScrollName` is not `null`.",
    "story_context": "The OptionalScrollCheck needs to safely check for null values. Your task is to complete the null check condition.",
    "challenge_data": {
      "initial_code": "public class OptionalScrollCheck {\n    public static void main(String[] args) {\n        String optionalScrollName = null;\n\n        if (??? != null) {\n            System.out.println(\"Scroll Name Length: \" + optionalScrollName.length());\n        } else {\n            System.out.println(\"No scroll present.\");\n        }\n    }\n}",
      "expected_output": [
        "No scroll present."
      ],
      "solution_code": "public class OptionalScrollCheck {\n    public static void main(String[] args) {\n        String optionalScrollName = null;\n\n        if (optionalScrollName != null) {\n            System.out.println(\"Scroll Name Length: \" + optionalScrollName.length());\n        } else {\n            System.out.println(\"No scroll present.\");\n        }\n    }\n}",
      "choices": [
        "scrollName",
        "optional",
        "length()",
        "optionalScrollName",
        "true",
        "false"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 5,
          "type": "variable_name",
          "description": "Variable name for null check condition",
          "correct_answer": "optionalScrollName",
          "explanation": "To prevent a `NullPointerException` when attempting to call a method like `.length()` on `optionalScrollName`, it's essential to first check if `optionalScrollName` is not `null`."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": "The `if` condition needs to check the variable itself.",
      "2": "The variable to be checked is `optionalScrollName`.",
      "3": "The comparison `!= null` checks if a non-primitive variable points to an object."
    }
  },
  {
    "id": 131,
    "subtopic_id": 3,
    "type": "code_completion",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `SpellTransformer` applies a series of transformations to `masterSpellName` (trimming, replacing, and converting to uppercase). A `derivedSpellName` also needs to be declared. Complete the declaration of `derivedSpellName` and the `String` methods for transformation.",
    "story_context": "The SpellTransformer needs to apply string transformations. Your task is to complete the variable declaration and method calls.",
    "challenge_data": {
      "initial_code": "public class SpellTransformer {\n    public static void main(String[] args) {\n        String masterSpellName = \"  Arcane Blast  \";\n        ??? derivedSpellName = \"Elemental\";\n        \n        masterSpellName = masterSpellName.???();\n        masterSpellName = masterSpellName.???(\"Blast\", \"Force\");\n        masterSpellName = masterSpellName.???();\n        \n        System.out.println(\"Transformed Spell: \" + masterSpellName);\n        System.out.println(\"Derived Spell: \" + derivedSpellName);\n    }\n}",
      "expected_output": [
        "Transformed Spell: ARCANE FORCE",
        "Derived Spell: Elemental"
      ],
      "solution_code": "public class SpellTransformer {\n    public static void main(String[] args) {\n        String masterSpellName = \"  Arcane Blast  \";\n        String derivedSpellName = \"Elemental\";\n        \n        masterSpellName = masterSpellName.trim();\n        masterSpellName = masterSpellName.replace(\"Blast\", \"Force\");\n        masterSpellName = masterSpellName.toUpperCase();\n        \n        System.out.println(\"Transformed Spell: \" + masterSpellName);\n        System.out.println(\"Derived Spell: \" + derivedSpellName);\n    }\n}",
      "choices": [
        "String",
        "trim",
        "toLowerCase",
        "replaceAll",
        "replace",
        "MasterSpellName",
        "substring",
        "toUpperCase"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 4,
          "type": "variable_declaration",
          "description": "Variable type declaration for derivedSpellName",
          "correct_answer": "String",
          "explanation": "`String` is the correct data type for `derivedSpellName`."
        },
        {
          "id": "slot_2",
          "line": 6,
          "type": "method_call",
          "description": "String trim method call",
          "correct_answer": "trim",
          "explanation": "`.trim()` is the `String` method used to remove leading and trailing whitespace."
        },
        {
          "id": "slot_3",
          "line": 7,
          "type": "method_call",
          "description": "String replace method call",
          "correct_answer": "replace",
          "explanation": "`.replace()` is the `String` method used to replace occurrences of a target sequence with a replacement."
        },
        {
          "id": "slot_4",
          "line": 8,
          "type": "method_call",
          "description": "String toUpperCase method call",
          "correct_answer": "toUpperCase",
          "explanation": "`.toUpperCase()` is the `String` method used to convert all characters in a string to uppercase."
        }
      ],
      "number_of_slots": 4
    },
    "hints": {
      "1": "The first blank needs the type for `derivedSpellName`.",
      "2": "The first method call is about removing leading/trailing spaces.",
      "3": "The second method call is about finding and replacing a specific part of the string."
    }
  },
  {
    "id": 132,
    "subtopic_id": 3,
    "type": "code_completion",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "An `ArchiveScanner` processes an `archiveLog` array which contains `String` entries, some of which may be `null`. It determines if a `logEntry` is `valid` (not null). Complete the array declaration, the `isEntryValid` boolean declaration, and the `null` check condition.",
    "story_context": "The ArchiveScanner needs to process archive logs and check for null entries. Your task is to complete the array declaration and null check.",
    "challenge_data": {
      "initial_code": "public class ArchiveScanner {\n    public static void main(String[] args) {\n        ??? archiveLog = {\"Event A\", null, \"Event C\"};\n        \n        String logEntry = archiveLog[1];\n        \n        ??? isEntryValid;\n        \n        if (logEntry ??? ???) {\n            isEntryValid = true;\n        }\n        else {\n            isEntryValid = false;\n        }\n        \n        System.out.println(\"Second Log Entry Length: \" + (isEntryValid ? logEntry.length() : 0));\n        System.out.println(\"Entry Valid: \" + isEntryValid);\n    }\n}",
      "expected_output": [
        "Second Log Entry Length: 0",
        "Entry Valid: false"
      ],
      "solution_code": "public class ArchiveScanner {\n    public static void main(String[] args) {\n        String[] archiveLog = {\"Event A\", null, \"Event C\"};\n        \n        String logEntry = archiveLog[1];\n        \n        boolean isEntryValid;\n        \n        if (logEntry != null) {\n            isEntryValid = true;\n        }\n        else {\n            isEntryValid = false;\n        }\n        \n        System.out.println(\"Second Log Entry Length: \" + (isEntryValid ? logEntry.length() : 0));\n        System.out.println(\"Entry Valid: \" + isEntryValid);\n    }\n}",
      "choices": [
        "isEntryValid",
        "null",
        "String[]",
        "!=",
        "boolean",
        "int[]",
        "logEntry",
        "=="
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 3,
          "type": "variable_declaration",
          "description": "Array declaration for archiveLog",
          "correct_answer": "String[]",
          "explanation": "`String[]` is the correct data type for `archiveLog` as it's an array initialized with `String` literals."
        },
        {
          "id": "slot_2",
          "line": 7,
          "type": "variable_declaration",
          "description": "Boolean variable declaration for isEntryValid",
          "correct_answer": "boolean",
          "explanation": "`boolean` is the correct type for `isEntryValid` as it will hold a `true` or `false` value."
        },
        {
          "id": "slot_3",
          "line": 9,
          "type": "operator",
          "description": "Not equals operator for null check",
          "correct_answer": "!=",
          "explanation": "The condition `logEntry != null` correctly checks if `logEntry` is not pointing to `null`."
        },
        {
          "id": "slot_4",
          "line": 9,
          "type": "keyword",
          "description": "Null keyword for null check",
          "correct_answer": "null",
          "explanation": "The condition `logEntry != null` correctly checks if `logEntry` is not pointing to `null`."
        }
      ],
      "number_of_slots": 4
    },
    "hints": {
      "1": "The first blank needs the type for an array that stores strings.",
      "2": "The third blank requires the type for `isEntryValid`.",
      "3": "The fourth and fifth blanks form the `null` check condition (`logEntry` is or is not `null`)."
    }
  },
  {
    "id": 133,
    "subtopic_id": 3,
    "type": "code_completion",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `SentinelArray` tracks `sentinelPowers`. The array is initialized with integer values, and a `recalibrationNeeded` flag is set based on the power level. Complete the array declaration, the `recalibrationNeeded` boolean declaration, and the assignments in the `if-else` block.",
    "story_context": "The SentinelArray needs to track sentinel powers and determine recalibration status. Your task is to complete the array declaration and boolean assignments.",
    "challenge_data": {
      "initial_code": "public class SentinelArray {\n    public static void main(String[] args) {\n        ??? sentinelPowers = new int[4];\n        \n        sentinelPowers[0] = 50;\n        sentinelPowers[3] = 80;\n        \n        ??? recalibrationNeeded;\n        \n        if (sentinelPowers[3] < 100) { \n            recalibrationNeeded = ???; // Blank 3: Value\n        } else {\n            recalibrationNeeded = ???; // Blank 4: Value\n        }\n        \n        System.out.println(\"Last Sentinel Power: \" + sentinelPowers[3]);\n        System.out.println(\"Recalibration Needed: \" + recalibrationNeeded);\n    }\n}",
      "expected_output": [
        "Last Sentinel Power: 80",
        "Recalibration Needed: true"
      ],
      "solution_code": "public class SentinelArray {\n    public static void main(String[] args) {\n        int[] sentinelPowers = new int[4];\n        \n        sentinelPowers[0] = 50;\n        sentinelPowers[3] = 80;\n        \n        boolean recalibrationNeeded;\n        \n        if (sentinelPowers[3] < 100) { \n            recalibrationNeeded = true; // Blank 3: Value\n        } else {\n            recalibrationNeeded = false; // Blank 4: Value\n        }\n        \n        System.out.println(\"Last Sentinel Power: \" + sentinelPowers[3]);\n        System.out.println(\"Recalibration Needed: \" + recalibrationNeeded);\n    }\n}",
      "choices": [
        "power",
        "int[] sentinelPowers",
        "true",
        "false",
        "boolean recalibrationNeeded",
        "short[]",
        "sentinelPowers",
        "recalibrationNeeded"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 3,
          "type": "variable_declaration",
          "description": "Array declaration for sentinelPowers",
          "correct_answer": "int[] sentinelPowers",
          "explanation": "`int[] sentinelPowers` is the correct declaration for an integer array."
        },
        {
          "id": "slot_2",
          "line": 9,
          "type": "variable_declaration",
          "description": "Boolean variable declaration for recalibrationNeeded",
          "correct_answer": "boolean recalibrationNeeded",
          "explanation": "`boolean recalibrationNeeded` is the correct declaration for a boolean variable."
        },
        {
          "id": "slot_3",
          "line": 12,
          "type": "variable_assignment",
          "description": "Boolean value assignment for if block",
          "correct_answer": "true",
          "explanation": "Since `sentinelPowers[3]` is `80`, the condition `80 < 100` is `true`. Thus, the `if` block executes, and `recalibrationNeeded` should be set to `true`."
        },
        {
          "id": "slot_4",
          "line": 14,
          "type": "variable_assignment",
          "description": "Boolean value assignment for else block",
          "correct_answer": "false",
          "explanation": "The `else` block handles the `false` case for the condition."
        }
      ],
      "number_of_slots": 4
    },
    "hints": {
      "1": "The first blank needs the type and name for an array that stores integer power levels.",
      "2": "The second blank needs the type and name for the `recalibrationNeeded` boolean flag.",
      "3": "Evaluate the `if` condition with `sentinelPowers[3]` to determine which boolean value (`true` or `false`) will be assigned in the `if` and `else` blocks."
    }
  },
  {
    "id": 134,
    "subtopic_id": 3,
    "type": "code_completion",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "An `AncientTomeStatus` tracks whether a `secretChapterFound`, the `pageCount`, and sets `tomeStatus` using a ternary operator. A `lastAccessedPage` is also recorded. Complete the declarations of `tomeStatus` and `lastAccessedPage`, and the final print statements.",
    "story_context": "The AncientTomeStatus needs to track tome information and status. Your task is to complete the variable declarations and print statements.",
    "challenge_data": {
      "initial_code": "public class AncientTomeStatus {\n    public static void main(String[] args) {\n        boolean secretChapterFound = true;\n        int pageCount = 250;\n        \n        ??? = secretChapterFound ? \"Revealed\" : \"Hidden\";\n        \n        ??? = 1492;\n        \n        System.out.println(\"Tome Status: \" + tomeStatus);\n        System.out.println(\"Last Accessed Page: \" + lastAccessedPage);\n        System.out.println(\"Page Count: \" + ???);\n        System.out.println(\"Is Secret Chapter Found: \" + ???);\n    }\n}",
      "expected_output": [
        "Tome Status: Revealed",
        "Last Accessed Page: 1492",
        "Page Count: 250",
        "Is Secret Chapter Found: true"
      ],
      "solution_code": "public class AncientTomeStatus {\n    public static void main(String[] args) {\n        boolean secretChapterFound = true;\n        int pageCount = 250;\n        \n        String tomeStatus = secretChapterFound ? \"Revealed\" : \"Hidden\";\n        \n        int lastAccessedPage = 1492;\n        \n        System.out.println(\"Tome Status: \" + tomeStatus);\n        System.out.println(\"Last Accessed Page: \" + lastAccessedPage);\n        System.out.println(\"Page Count: \" + pageCount);\n        System.out.println(\"Is Secret Chapter Found: \" + secretChapterFound);\n    }\n}",
      "choices": [
        "long lastAccessedPage",
        "String tomeStatus",
        "boolean tomeStatus",
        "pageCount",
        "secretChapterFound",
        "chapter",
        "count",
        "int lastAccessedPage"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 6,
          "type": "variable_declaration",
          "description": "String variable declaration for tomeStatus",
          "correct_answer": "String tomeStatus",
          "explanation": "`String tomeStatus` correctly declares the `String` variable `tomeStatus` that holds the result of the ternary operation."
        },
        {
          "id": "slot_2",
          "line": 8,
          "type": "variable_declaration",
          "description": "Integer variable declaration for lastAccessedPage",
          "correct_answer": "int lastAccessedPage",
          "explanation": "`int lastAccessedPage` correctly declares the integer variable `lastAccessedPage`."
        },
        {
          "id": "slot_3",
          "line": 12,
          "type": "variable_name",
          "description": "Variable name for page count print statement",
          "correct_answer": "pageCount",
          "explanation": "The third blank in the `System.out.println()` statement should print the `pageCount` variable."
        },
        {
          "id": "slot_4",
          "line": 13,
          "type": "variable_name",
          "description": "Variable name for secret chapter found print statement",
          "correct_answer": "secretChapterFound",
          "explanation": "The fourth blank in the `System.out.println()` statement should print the `secretChapterFound` variable."
        }
      ],
      "number_of_slots": 4
    },
    "hints": {
      "1": "The first blank declares a `String` variable and its name, based on a conditional expression.",
      "2": "The second blank declares an `int` variable and its name.",
      "3": "The last two blanks are for variables that should be printed to reveal their values."
    }
  },
  {
    "id": 135,
    "subtopic_id": 3,
    "type": "code_completion",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "An `ArcaneSymbolArray` initializes an array of `char`s. A `isValidSet` flag is determined by checking specific elements. A `finalSymbol` is also extracted from the array. Complete the array declaration, the `isValidSet` boolean declaration, the `finalSymbol` declaration, and the array index for `finalSymbol`.",
    "story_context": "The ArcaneSymbolArray needs to manage arcane symbols and validate sets. Your task is to complete the array declaration and variable assignments.",
    "challenge_data": {
      "initial_code": "public class ArcaneSymbolArray {\n    public static void main(String[] args) {\n        ??? = new char[3];\n        arcaneSymbols[0] = 'X';\n        arcaneSymbols[1] = (char) 70;\n        arcaneSymbols[2] = 'Z';\n        \n        ???;\n        \n        if (arcaneSymbols[0] == 'X' && arcaneSymbols[1] == 'F') {\n            isValidSet = true;\n        } else {\n            isValidSet = false;\n        }\n        \n        ??? = arcaneSymbols[???];\n        \n        System.out.println(\"Final Symbol: \" + finalSymbol);\n        System.out.println(\"Is Valid Set: \" + isValidSet);\n    }\n}",
      "expected_output": [
        "Final Symbol: Z",
        "Is Valid Set: true"
      ],
      "solution_code": "public class ArcaneSymbolArray {\n    public static void main(String[] args) {\n        char[] arcaneSymbols = new char[3];\n        arcaneSymbols[0] = 'X';\n        arcaneSymbols[1] = (char) 70;\n        arcaneSymbols[2] = 'Z';\n        \n        boolean isValidSet;\n        \n        if (arcaneSymbols[0] == 'X' && arcaneSymbols[1] == 'F') {\n            isValidSet = true;\n        } else {\n            isValidSet = false;\n        }\n        \n        char finalSymbol = arcaneSymbols[2];\n        \n        System.out.println(\"Final Symbol: \" + finalSymbol);\n        System.out.println(\"Is Valid Set: \" + isValidSet);\n    }\n}",
      "choices": [
        "boolean isValidSet",
        "char finalSymbol",
        "char[] arcaneSymbols",
        "1",
        "2",
        "0",
        "int[] arcaneSymbols",
        "String finalSymbol"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 3,
          "type": "variable_declaration",
          "description": "Character array declaration for arcaneSymbols",
          "correct_answer": "char[] arcaneSymbols",
          "explanation": "`char[] arcaneSymbols` correctly declares the array of characters."
        },
        {
          "id": "slot_2",
          "line": 8,
          "type": "variable_declaration",
          "description": "Boolean variable declaration for isValidSet",
          "correct_answer": "boolean isValidSet",
          "explanation": "`boolean isValidSet` correctly declares the boolean variable."
        },
        {
          "id": "slot_3",
          "line": 16,
          "type": "variable_declaration",
          "description": "Character variable declaration for finalSymbol",
          "correct_answer": "char finalSymbol",
          "explanation": "`char finalSymbol` declares the `char` variable `finalSymbol`."
        },
        {
          "id": "slot_4",
          "line": 16,
          "type": "array_index",
          "description": "Array index for finalSymbol assignment",
          "correct_answer": "2",
          "explanation": "The last element of a 3-element array (indices 0, 1, 2) is at index `2`."
        }
      ],
      "number_of_slots": 4
    },
    "hints": {
      "1": "The first blank needs the type and name for an array that stores characters.",
      "2": "The second blank declares a boolean variable.",
      "3": "The third blank declares a `char` variable that will hold one of the array elements."
    }
  },
  {
    "id": 136,
    "subtopic_id": 4,
    "type": "output_tracing",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `StolenGoodsReport` system calculates the `totalStolenGoods` by adding values from two separate reports. Your task is to trace the code and determine the final `Total Stolen Goods` that is printed.",
    "story_context": "The StolenGoodsReport system needs to calculate total stolen goods from multiple reports. Your task is to trace the addition operation and predict the output.",
    "challenge_data": {
      "code": "public class StolenGoodsReport {\n    public static void main(String[] args) {\n        int report1Value = 1500;\n        int report2Value = 750;\n        int totalStolenGoods = report1Value + report2Value;\n        System.out.println(\"Total Stolen Goods: $\" + totalStolenGoods);\n    }\n}",
      "expected_output": [
        "Total Stolen Goods: $2250"
      ],
      "choices": [
        "Total Stolen Goods: $1500",
        "Total Stolen Goods: $750",
        "Total Stolen Goods: $2250",
        "Error"
      ],
      "explanation": "The `report1Value` is `1500` and `report2Value` is `750`. The line `int totalStolenGoods = report1Value + report2Value;` adds these two values: `1500 + 750 = 2250`. This result is then assigned to `totalStolenGoods`. Finally, `System.out.println()` prints \"Total Stolen Goods: $2250\"."
    },
    "hints": {
      "1": "Identify the operation being performed on `report1Value` and `report2Value`.",
      "2": "Perform the addition.",
      "3": "The `+` operator combines the string literal with the numerical result."
    }
  },
  {
    "id": 137,
    "subtopic_id": 4,
    "type": "output_tracing",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "An `AlibiChecker` system determines `alibiHoursRemaining` by subtracting `hoursAccountedFor` from `initialAlibiHours`. Your task is to trace the code and determine the final `Alibi Hours Remaining`.",
    "story_context": "The AlibiChecker system needs to determine remaining alibi hours. Your task is to trace the subtraction operation and predict the output.",
    "challenge_data": {
      "code": "public class AlibiChecker {\n    public static void main(String[] args) {\n        int initialAlibiHours = 24;\n        int hoursAccountedFor = 18;\n        int alibiHoursRemaining = initialAlibiHours - hoursAccountedFor;\n        System.out.println(\"Alibi Hours Remaining: \" + alibiHoursRemaining);\n    }\n}",
      "expected_output": [
        "Alibi Hours Remaining: 6"
      ],
      "choices": [
        "Alibi Hours Remaining: 24",
        "Alibi Hours Remaining: 18",
        "Alibi Hours Remaining: 6",
        "Error"
      ],
      "explanation": " `initialAlibiHours` is `24` and `hoursAccountedFor` is `18`. The line `int alibiHoursRemaining = initialAlibiHours - hoursAccountoredFor;` calculates `24 - 18 = 6`. This result is assigned to `alibiHoursRemaining`. Finally, `System.out.println()` prints \"Alibi Hours Remaining: 6\"."
    },
    "hints": {
      "1": "Identify the operation being performed on the two hour variables.",
      "2": "Perform the subtraction.",
      "3": "The `println` statement displays the final calculated value."
    }
  },
  {
    "id": 138,
    "subtopic_id": 4,
    "type": "output_tracing",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `ThreatAssessment` system calculates `threatLevel` by multiplying `suspectsConfirmed` by a `dangerFactor`. Your task is to trace the code and determine the `Current Threat Level`.",
    "story_context": "The ThreatAssessment system needs to calculate threat levels based on suspects and danger factors. Your task is to trace the multiplication operation and predict the output.",
    "challenge_data": {
      "code": "public class ThreatAssessment {\n    public static void main(String[] args) {\n        int suspectsConfirmed = 5;\n        int dangerFactor = 10;\n        int threatLevel = suspectsConfirmed * dangerFactor;\n        System.out.println(\"Current Threat Level: \" + threatLevel);\n    }\n}",
      "expected_output": [
        "Current Threat Level: 50"
      ],
      "choices": [
        "Current Threat Level: 5",
        "Current Threat Level: 10",
        "Current Threat Level: 50",
        "Error"
      ],
      "explanation": " `suspectsConfirmed` is `5` and `dangerFactor` is `10`. The line `int threatLevel = suspectsConfirmed * dangerFactor;` calculates `5 * 10 = 50`. This result is assigned to `threatLevel`. Finally, `System.out.println()` prints \"Current Threat Level: 50\"."
    },
    "hints": {
      "1": "Identify the multiplication operator.",
      "2": "Perform the multiplication.",
      "3": "The final `println` displays the result after the multiplication."
    }
  },
  {
    "id": 139,
    "subtopic_id": 4,
    "type": "output_tracing",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "An `EvidenceDistribution` system calculates `itemsPerDetective` by dividing `totalEvidenceItems` among `detectivesAssigned`. Your task is to trace the code and determine the `Items Per Detective`.",
    "story_context": "The EvidenceDistribution system needs to calculate items per detective. Your task is to trace the division operation and predict the output.",
    "challenge_data": {
      "code": "public class EvidenceDistribution {\n    public static void main(String[] args) {\n        int totalEvidenceItems = 27;\n        int detectivesAssigned = 5;\n        int itemsPerDetective = totalEvidenceItems / detectivesAssigned;\n        System.out.println(\"Items Per Detective: \" + itemsPerDetective);\n    }\n}",
      "expected_output": [
        "Items Per Detective: 5"
      ],
      "choices": [
        "Items Per Detective: 5.4",
        "Items Per Detective: 5",
        "Items Per Detective: 2",
        "Error"
      ],
      "explanation": " `totalEvidenceItems` is `27` and `detectivesAssigned` is `5`. The line `int itemsPerDetective = totalEvidenceItems / detectivesAssigned;` calculates `27 / 5`. Since both are integers, Java performs integer division, which results in `5` (the remainder `2` is discarded). This result is assigned to `itemsPerDetective`. Finally, `System.out.println()` prints \"Items Per Detective: 5\"."
    },
    "hints": {
      "1": "Both `totalEvidenceItems` and `detectivesAssigned` are integers.",
      "2": "Recall that integer division (`/`) truncates (discards) any decimal part.",
      "3": "Calculate the division and then format the output."
    }
  },
  {
    "id": 140,
    "subtopic_id": 4,
    "type": "output_tracing",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `BombSquad` system calculates the `timeRemaining` in a cycle using the modulo operator. Your task is to trace the code and determine the `Time Remaining in Cycle`.",
    "story_context": "The BombSquad system needs to calculate remaining time in cycles. Your task is to trace the modulo operation and predict the output.",
    "challenge_data": {
      "code": "public class BombSquad {\n    public static void main(String[] args) {\n        int totalMinutes = 65;\n        int cycleMinutes = 10;\n        int timeRemaining = totalMinutes % cycleMinutes;\n        System.out.println(\"Time Remaining in Cycle: \" + timeRemaining + \" minutes\");\n    }\n}",
      "expected_output": [
        "Time Remaining in Cycle: 5 minutes"
      ],
      "choices": [
        "Time Remaining in Cycle: 65 minutes",
        "Time Remaining in Cycle: 6 minutes",
        "Time Remaining in Cycle: 5 minutes",
        "Error"
      ],
      "explanation": " `totalMinutes` is `65` and `cycleMinutes` is `10`. The line `int timeRemaining = totalMinutes % cycleMinutes;` calculates the remainder when `65` is divided by `10`. `65 / 10` is `6` with a remainder of `5`. This `5` is assigned to `timeRemaining`. Finally, `System.out.println()` prints \"Time Remaining in Cycle: 5 minutes\"."
    },
    "hints": {
      "1": "The `%` operator calculates the remainder of a division.",
      "2": "Divide `totalMinutes` by `cycleMinutes` and note the remainder.",
      "3": "The `println` statement combines the string with the calculated remainder."
    }
  },
  {
    "id": 141,
    "subtopic_id": 4,
    "type": "output_tracing",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `CrimeSceneAnalyst` calculates `expectedRounds` and `casingsPerCrimeScene` using multiple arithmetic operations. Your task is to trace the code and determine the `Expected Rounds` and `Casings Per Crime Scene`.",
    "story_context": "The CrimeSceneAnalyst needs to calculate expected rounds and casings per crime scene. Your task is to trace the arithmetic operations and predict the outputs.",
    "challenge_data": {
      "code": "public class CrimeSceneAnalyst {\n    public static void main(String[] args) {\n        int bulletCasings = 5;\n        int magazineCapacity = 10;\n        int crimeScenes = 2;\n\n        int expectedRounds = magazineCapacity * crimeScenes + bulletCasings;\n        int casingsPerCrimeScene = bulletCasings / crimeScenes;\n        \n        System.out.println(\"Expected Rounds: \" + expectedRounds);\n        System.out.println(\"Casings Per Crime Scene: \" + casingsPerCrimeScene);\n    }\n}",
      "expected_output": [
        "Expected Rounds: 25",
        "Casings Per Crime Scene: 2"
      ],
      "choices": [
        "Expected Rounds: 20",
        "Expected Rounds: 25",
        "Casings Per Crime Scene: 2.5",
        "Casings Per Crime Scene: 2",
        "Expected Rounds: 0.25"
      ],
      "explanation": "1. `bulletCasings` is `5`, `magazineCapacity` is `10`, `crimeScenes` is `2`.\n2. `expectedRounds = magazineCapacity * crimeScenes + bulletCasings;` first calculates `10 * 2 = 20` (multiplication), then `20 + 5 = 25` (addition). So, `expectedRounds` is `25`.\n3. `casingsPerCrimeScene = bulletCasings / crimeScenes;` calculates `5 / 2`. Since both are integers, it performs integer division, which results in `2` (the remainder is discarded).\n4. The first `System.out.println()` prints \"Expected Rounds: 25\".\n5. The second `System.out.println()` prints \"Casings Per Crime Scene: 2\"."
    },
    "hints": {
      "1": "Remember the order of operations: multiplication and division happen before addition and subtraction.",
      "2": "Pay attention to the data types for division. If both operands are integers, the result will also be an integer.",
      "3": "Each `System.out.println()` statement produces a distinct output."
    }
  },
  {
    "id": 142,
    "subtopic_id": 4,
    "type": "output_tracing",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "An `EvidenceProcessor` calculates `analyzedWeight` and `samplesLeft` using division and modulo operators with mixed data types. Your task is to trace the code and determine the `Analyzed Weight` and `Samples Left`.",
    "story_context": "The EvidenceProcessor needs to calculate analyzed weight and samples left. Your task is to trace the division and modulo operations and predict the outputs.",
    "challenge_data": {
      "code": "public class EvidenceProcessor {\n    public static void main(String[] args) {\n        int totalWeight = 50;\n        double samplingFactor = 2.5;\n        int sampleSize = 7;\n\n        double analyzedWeight = totalWeight / samplingFactor;\n        int samplesLeft = totalWeight % sampleSize;\n        \n        System.out.println(\"Analyzed Weight: \" + analyzedWeight);\n        System.out.println(\"Samples Left: \" + samplesLeft);\n    }\n}",
      "expected_output": [
        "Analyzed Weight: 20.0",
        "Samples Left: 1"
      ],
      "choices": [
        "Analyzed Weight: 20",
        "Analyzed Weight: 20.0",
        "Samples Left: 1",
        "Samples Left: 7",
        "Analyzed Weight: 20.01"
      ],
      "explanation": "1. `totalWeight` is `50`, `samplingFactor` is `2.5`, `sampleSize` is `7`.\n2. `analyzedWeight = totalWeight / samplingFactor;` calculates `50 / 2.5`. The `int` `totalWeight` is promoted to `double`, so `50.0 / 2.5 = 20.0`. `analyzedWeight` is `20.0`.\n3. `samplesLeft = totalWeight % sampleSize;` calculates the remainder of `50 / 7`. `50 / 7` is `7` with a remainder of `1`. So, `samplesLeft` is `1`.\n4. The first `System.out.println()` prints \"Analyzed Weight: 20.0\".\n5. The second `System.out.println()` prints \"Samples Left: 1\"."
    },
    "hints": {
      "1": "When an `int` is divided by a `double`, the `int` promotes to `double`, and the result is a `double`.",
      "2": "The modulo operator (`%`) gives the remainder of a division.",
      "3": "Trace each calculation independently to avoid mixing results."
    }
  },
  {
    "id": 143,
    "subtopic_id": 4,
    "type": "output_tracing",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `FinancialAudit` tracks `initialFunds` and `totalTransactions`. Funds are adjusted by `expense` and `incomeAdded`, and transactions are incremented. Your task is to trace the code and determine the final `Funds` and `Total Transactions`.",
    "story_context": "The FinancialAudit needs to track funds and transactions. Your task is to trace the arithmetic operations and predict the outputs.",
    "challenge_data": {
      "code": "public class FinancialAudit {\n    public static void main(String[] args) {\n        int initialFunds = 1000;\n        int expense = 200;\n        int incomeAdded = 150;\n        int totalTransactions = 0;\n\n        initialFunds -= expense;\n        initialFunds += incomeAdded;\n        totalTransactions++;\n        totalTransactions++;\n        \n        System.out.println(\"Final Funds: $\" + initialFunds);\n        System.out.println(\"Total Transactions: \" + totalTransactions);\n    }\n}",
      "expected_output": [
        "Final Funds: $950",
        "Total Transactions: 2"
      ],
      "choices": [
        "Final Funds: $800",
        "Final Funds: $950",
        "Total Transactions: 1",
        "Total Transactions: 2",
        "Final Funds: $900"
      ],
      "explanation": "1. `initialFunds` starts at `1000`, `totalTransactions` at `0`.\n2. `initialFunds -= expense;` becomes `1000 - 200 = 800`. `initialFunds` is now `800`.\n3. `initialFunds += incomeAdded;` becomes `800 + 150 = 950`. `initialFunds` is now `950`.\n4. `totalTransactions++;` increments `totalTransactions` to `1`.\n5. `totalTransactions++;` increments `totalTransactions` to `2`.\n6. The first `System.out.println()` prints \"Final Funds: $950\".\n7. The second `System.out.println()` prints \"Total Transactions: 2\"."
    },
    "hints": {
      "1": " `x -= y` is a shorthand for `x = x - y`.",
      "2": " `x += y` is a shorthand for `x = x + y`.",
      "3": " `x++` is a shorthand for `x = x + 1`."
    }
  },
  {
    "id": 144,
    "subtopic_id": 4,
    "type": "output_tracing",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `ProfilerReport` calculates `firstScore` using a complex expression with casting, then determines a `remainderCheck`. Your task is to trace the code and determine the `First Score After Ops` and `Remainder Check`.",
    "story_context": "The ProfilerReport needs to calculate scores and remainder checks. Your task is to trace the casting and modulo operations and predict the outputs.",
    "challenge_data": {
      "code": "public class ProfilerReport {\n    public static void main(String[] args) {\n        int firstScore = 15;\n        double multiplier = 2.5;\n        int divisor = 4;\n\n        firstScore = (int) ((firstScore + 5) * multiplier);\n        int remainderCheck = firstScore % divisor;\n        \n        System.out.println(\"First Score After Ops: \" + firstScore);\n        System.out.println(\"Remainder Check: \" + remainderCheck);\n    }\n}",
      "expected_output": [
        "First Score After Ops: 50",
        "Remainder Check: 2"
      ],
      "choices": [
        "First Score After Ops: 15",
        "First Score After Ops: 50",
        "Remainder Check: 0",
        "Remainder Check: 2",
        "First Score After Ops: 55"
      ],
      "explanation": "1. `firstScore` is `15`, `multiplier` is `2.5`, `divisor` is `4`.\n2. `firstScore = (int) ((firstScore + 5) * multiplier);`\n    * `(firstScore + 5)` calculates `15 + 5 = 20`.\n    * `20 * multiplier` calculates `20 * 2.5 = 50.0`.\n    * `(int)50.0` casts to `50`. So `firstScore` is `50`.\n3. `remainderCheck = firstScore % divisor;` calculates `50 % 4`. `50 / 4` is `12` with a remainder of `2`. So, `remainderCheck` is `2`.\n4. The first `System.out.println()` prints \"First Score After Ops: 50\".\n5. The second `System.out.println()` prints \"Remainder Check: 2\"."
    },
    "hints": {
      "1": "Parentheses dictate the order of operations before multiplication.",
      "2": "Multiplying an `int` by a `double` results in a `double`; the `(int)` cast truncates.",
      "3": "The modulo operator (`%`) calculates the remainder."
    }
  },
  {
    "id": 145,
    "subtopic_id": 4,
    "type": "output_tracing",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `PhotoAnalyst` calculates `exposureSettings` and then reassigns `aperture`. Your task is to trace the code and determine the `Final Exposure Settings` and `Aperture After Reassignment`.",
    "story_context": "The PhotoAnalyst needs to calculate exposure settings and handle aperture reassignment. Your task is to trace the division and reassignment operations and predict the outputs.",
    "challenge_data": {
      "code": "public class PhotoAnalyst {\n    public static void main(String[] args) {\n        double lightConditions = 100.0;\n        int aperture = 5;\n        \n        double exposureSettings = lightConditions / aperture - 10;\n        \n        System.out.println(\"Final Exposure Settings: \" + exposureSettings);\n        \n        aperture = 7;\n        \n        System.out.println(\"Aperture After Reassignment: \" + aperture);\n    }\n}",
      "expected_output": [
        "Final Exposure Settings: 10.0",
        "Aperture After Reassignment: 7"
      ],
      "choices": [
        "Final Exposure Settings: 10.0",
        "Final Exposure Settings: 20.0",
        "Aperture After Reassignment: 5",
        "Aperture After Reassignment: 7",
        "Final Exposure Settings: 10.5"
      ],
      "explanation": "1. `lightConditions` is `100.0`, `aperture` is `5`.\n2. `exposureSettings = lightConditions / aperture - 10;`\n    * `lightConditions / aperture` calculates `100.0 / 5.0` (aperture promotes to double), resulting in `20.0`.\n    * `20.0 - 10` calculates `10.0`. So, `exposureSettings` is `10.0`.\n3. The first `System.out.println()` prints \"Final Exposure Settings: 10.0\".\n4. `aperture = 7;` reassigns `aperture` to `7`.\n5. The second `System.out.println()` prints \"Aperture After Reassignment: 7\"."
    },
    "hints": {
      "1": "Division happens before subtraction.",
      "2": "An integer (`aperture`) will promote to a `double` when used with a `double` (`lightConditions`).",
      "3": "The variable `aperture` is reassigned *after* it's used to calculate `exposureSettings`. Track its value for the second `println`."
    }
  },
  {
    "id": 146,
    "subtopic_id": 4,
    "type": "output_tracing",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `SurveillanceLog` calculates `totalTimeAnalyzed`, `timeDifference`, and `cycleCount` using a mix of integer and floating-point arithmetic with various operators. Your task is to trace the code and determine the `Total Time Analyzed`, `Time Difference`, and `Cycle Count`.",
    "story_context": "The SurveillanceLog needs to calculate time analysis, differences, and cycle counts. Your task is to trace the complex arithmetic operations and predict the outputs.",
    "challenge_data": {
      "code": "public class SurveillanceLog {\n    public static void main(String[] args) {\n        int initialHours = 100;\n        double footageMultiplier = 0.5;\n        byte agentsInField = 3;\n        \n        double totalTimeAnalyzed = (initialHours / agentsInField) * footageMultiplier + 5.0;\n        \n        int timeDifference = (int) (initialHours - (agentsInField * 10.0));\n        \n        int cycleCount = (int) totalTimeAnalyzed % 10;\n        \n        System.out.println(\"Total Time Analyzed: \" + totalTimeAnalyzed);\n        System.out.println(\"Time Difference: \" + timeDifference);\n        System.out.println(\"Cycle Count: \" + cycleCount);\n    }\n}",
      "expected_output": [
        "Total Time Analyzed: 21.5",
        "Time Difference: 70",
        "Cycle Count: 1"
      ],
      "choices": [
        "Total Time Analyzed: 21.5",
        "Time Difference: 70",
        "Cycle Count: 1",
        "Total Time Analyzed: 16.5",
        "Time Difference: 70.5",
        "Cycle Count: 10"
      ],
      "explanation": "1. `initialHours = 100`, `footageMultiplier = 0.5`, `agentsInField = 3`.\n2. `totalTimeAnalyzed = (initialHours / agentsInField) * footageMultiplier + 5.0;`\n    * `initialHours / agentsInField`: `100 / 3` (integer division) = `33`.\n    * `33 * footageMultiplier`: `33 * 0.5` (int promotes to double) = `16.5`.\n    * `16.5 + 5.0` = `21.5`. So, `totalTimeAnalyzed` is `21.5`.\n3. `timeDifference = (int) (initialHours - (agentsInField * 10.0));`\n    * `agentsInField * 10.0`: `3 * 10.0` (int promotes to double) = `30.0`.\n    * `initialHours - 30.0`: `100 - 30.0` (int promotes to double) = `70.0`.\n    * `(int)70.0`: casts to `70`. So, `timeDifference` is `70`.\n4. `cycleCount = (int) totalTimeAnalyzed % 10;`\n    * `(int) totalTimeAnalyzed`: `(int)21.5` = `21`.\n    * `21 % 10`: `21 / 10` is 2 with remainder `1`. So, `cycleCount` is `1`.\n5. All three `System.out.println()` statements display the final values."
    },
    "hints": {
      "1": "Remember integer division: `100 / 3` will discard the decimal.",
      "2": "Follow the type promotion rules: when an `int` interacts with a `double`, the result is a `double`.",
      "3": "Parentheses dictate precedence. Perform operations inside them first."
    }
  },
  {
    "id": 147,
    "subtopic_id": 4,
    "type": "output_tracing",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `BombCalibrator` calculates `detonationTiming`, `fuseStatus`, and `signalLossFactor` using various arithmetic operations with different primitive types, including a `byte` that may overflow. Your task is to trace the code and determine the `Final Detonation Timing`, `Fuse Status`, and `Signal Loss Factor`.",
    "story_context": "The BombCalibrator needs to calculate detonation timing, fuse status, and signal loss factors. Your task is to trace the complex arithmetic operations and predict the outputs.",
    "challenge_data": {
      "code": "public class BombCalibrator {\n    public static void main(String[] args) {\n        float wireLength1 = 10.5f;\n        double wireLength2 = 2.5;\n        int pulseFrequency = 3;\n        byte safetyOverride = 5;\n\n        double detonationTiming = (wireLength1 + wireLength2) * pulseFrequency;\n        \n        int fuseStatus = (int) (detonationTiming % safetyOverride);\n        \n        safetyOverride = (byte) (safetyOverride + 125);\n        \n        float signalLossFactor = wireLength1 / safetyOverride;\n        \n        System.out.println(\"Final Detonation Timing: \" + detonationTiming);\n        System.out.println(\"Fuse Status: \" + fuseStatus);\n        System.out.println(\"Signal Loss Factor: \" + signalLossFactor);\n    }\n}",
      "expected_output": [
        "Final Detonation Timing: 39.0",
        "Fuse Status: 4",
        "Signal Loss Factor: -0.083333336"
      ],
      "choices": [
        "Final Detonation Timing: 39.0",
        "Fuse Status: 4",
        "Signal Loss Factor: -0.083333336",
        "Signal Loss Factor: 0.083333336",
        "Final Detonation Timing: 39.9",
        "Fuse Status: 4.2"
      ],
      "explanation": "1. `wireLength1 = 10.5f`, `wireLength2 = 2.5`, `pulseFrequency = 3`, `safetyOverride = 5`.\n2. `detonationTiming = (wireLength1 + wireLength2) * pulseFrequency;`\n    * `wireLength1 + wireLength2`: `10.5f + 2.5d` (float promotes to double) = `13.0d`.\n    * `13.0d * 3` (int promotes to double) = `39.0d`. So, `detonationTiming` is `39.0`.\n3. `fuseStatus = (int) (detonationTiming % safetyOverride);`\n    * `(int)detonationTiming`: `(int)39.0` = `39`.\n    * `39 % 5` = `4`. So, `fuseStatus` is `4`.\n4. `safetyOverride = (byte) (safetyOverride + 125);`\n    * `5 + 125 = 130`.\n    * `(byte)130` causes a **byte overflow** (130 > 127). `130` wraps around to `-126`. So, `safetyOverride` is `-126`.\n5. `float signalLossFactor = wireLength1 / safetyOverride;`\n    * `wireLength1` is `10.5f`. `safetyOverride` (`-126`) promotes to `float`.\n    * `10.5f / -126.0f` = approximately `-0.083333336`. So, `signalLossFactor` is `-0.083333336`.\n6. All three `System.out.println()` statements display the final values."
    },
    "hints": {
      "1": "Adding a `float` and `double` results in a `double`.",
      "2": "The modulo operator (`%`) works on integer operands; ensure the `detonationTiming` is cast before the modulo.",
      "3": "Watch out for `byte` overflow: `5 + 125` will exceed `byte`'s max value."
    }
  },
  {
    "id": 148,
    "subtopic_id": 4,
    "type": "output_tracing",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `FinancialAuditSystem` calculates `netProfit`, `taxLiability`, and `refundRemainder` from large `long` and `int` values, involving potential overflows and type promotions. Your task is to trace the code and determine these final values.",
    "story_context": "The FinancialAuditSystem needs to calculate net profit, tax liability, and refund remainder. Your task is to trace the complex arithmetic operations and predict the outputs.",
    "challenge_data": {
      "code": "public class FinancialAuditSystem {\n    public static void main(String[] args) {\n        long period1Profit = 950000000L;\n        long period2Profit = 500000000L;\n        int expenses = 200000000;\n        \n        long netProfit = period1Profit + period2Profit - expenses;\n        \n        int taxRate = 20;\n        int taxLiability = (int) (netProfit * taxRate / 100);\n        \n        int totalCustomers = 3;\n        int refundRemainder = taxLiability % totalCustomers;\n        \n        System.out.println(\"Net Profit: \" + netProfit);\n        System.out.println(\"Tax Liability: \" + taxLiability);\n        System.out.println(\"Refund Remainder: \" + refundRemainder);\n    }\n}",
      "expected_output": [
        "Tax Liability: 250000000",
        "Refund Remainder: 1",
        "Net Profit: 1250000000"
      ],
      "choices": [
        "Net Profit: 1500000000",
        "Tax Liability: 2500000000",
        "Refund Remainder: 1",
        "Net Profit: 1250000000",
        "Tax Liability: 250000000",
        "Refund Remainder: 100"
      ],
      "explanation": "1. `period1Profit = 950000000L`, `period2Profit = 500000000L`, `expenses = 200000000`.\n2. `long netProfit = period1Profit + period2Profit - expenses;`\n    * `950000000L + 500000000L = 1450000000L`.\n    * `1450000000L - 200000000` (int promotes to long) = `1250000000L`. So, `netProfit` is `1250000000L`.\n3. `int taxLiability = (int) (netProfit * taxRate / 100);`\n    * `netProfit * taxRate`: `1250000000L * 20` (int promotes to long) = `25000000000L`.\n    * `25000000000L / 100` (int promotes to long) = `250000000L`.\n    * `(int)250000000L`: casts to `250000000`. This value fits in `int`. So, `taxLiability` is `250000000`.\n4. `int refundRemainder = taxLiability % totalCustomers;`\n    * `250000000 % 3`. The sum of digits of `250000000` is `7`. `7 % 3 = 1`. So, `refundRemainder` is `1`.\n5. All three `System.out.println()` statements display the final values."
    },
    "hints": {
      "1": "Perform `long` arithmetic first; the result will also be a `long`.",
      "2": "Be careful when casting the result of a `long` calculation to an `int` (`taxLiability`); ensure the value fits within `int`'s range.",
      "3": "The modulo operator (`%`) calculates the remainder after integer division."
    }
  },
  {
    "id": 149,
    "subtopic_id": 4,
    "type": "output_tracing",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `BallisticsAnalyst` calculates `adjustedVelocity`, `targetAdjustedDistance`, and `hitChancePercentage` using a mix of float, double, and int operations with various type promotions. Your task is to trace the code and determine these final values.",
    "story_context": "The BallisticsAnalyst needs to calculate adjusted velocity, target distance, and hit chance percentage. Your task is to trace the complex arithmetic operations and predict the outputs.",
    "challenge_data": {
      "code": "public class BallisticsAnalyst {\n    public static void main(String[] args) {\n        float bulletVelocity = 350.5f;\n        double windDeflection = 0.05;\n        int targetDistance = 1000;\n        \n        double adjustedVelocity = bulletVelocity - (windDeflection * 10.0f);\n        \n        int targetAdjustedDistance = targetDistance / 300 * 10;\n        \n        double hitChancePercentage = (adjustedVelocity / bulletVelocity) * 100.0;\n        \n        System.out.println(\"Final Bullet Velocity: \" + adjustedVelocity);\n        System.out.println(\"Target Adjusted Distance: \" + targetAdjustedDistance);\n        System.out.println(\"Hit Chance Percentage: \" + hitChancePercentage);\n    }\n}",
      "expected_output": [
        "Final Bullet Velocity: 350.0",
        "Target Adjusted Distance: 30",
        "Hit Chance Percentage: 99.85734664764622"
      ],
      "choices": [
        "Final Bullet Velocity: 350.0",
        "Target Adjusted Distance: 308",
        "Hit Chance Percentage: 100.0",
        "Hit Chance Percentage: 99.85748",
        "Final Bullet Velocity: 350.5",
        "Target Adjusted Distance: 30"
      ],
      "explanation": "1. `bulletVelocity = 350.5f`, `windDeflection = 0.05`, `targetDistance = 1000`.\n2. `double adjustedVelocity = bulletVelocity - (windDeflection * 10.0f);`\n    * `windDeflection * 10.0f`: `0.05d * 10.0f` (float promotes to double) = `0.5d`.\n    * `bulletVelocity - 0.5d`: `350.5f - 0.5d` (float promotes to double) = `350.0d`. So, `adjustedVelocity` is `350.0`.\n3. `int targetAdjustedDistance = targetDistance / 300 * 10;`\n    * `targetDistance / 300`: `1000 / 300` (integer division) = `3`.\n    * `3 * 10` = `30`. So, `targetAdjustedDistance` is `30`.\n4. `double hitChancePercentage = (adjustedVelocity / bulletVelocity) * 100.0;`\n    * `adjustedVelocity / bulletVelocity`: `350.0d / 350.5f` (float promotes to double) = `0.9985734664764622`.\n    * `0.9985734664764622 * 100.0` = `99.85734664764622`. So, `hitChancePercentage` is `99.85734664764622`.\n5. All three `System.out.println()` statements display the final values."
    },
    "hints": {
      "1": "Trace `adjustedVelocity` remembering that `float` promotes to `double` when operating with a `double`.",
      "2": "Perform the integer division for `targetAdjustedDistance` carefully before multiplication.",
      "3": "Calculate `hitChancePercentage` with full `double` precision, then consider the expected decimal output."
    }
  },
  {
    "id": 150,
    "subtopic_id": 4,
    "type": "output_tracing",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `CovertRouteTracker` determines `routeDistance`, `elapsedTime`, and `deviationFactor` from various integer and floating-point values, including operations that cause a `byte` overflow. Your task is to trace the code and determine these final values.",
    "story_context": "The CovertRouteTracker needs to calculate route distances, elapsed times, and deviation factors. Your task is to trace the complex arithmetic operations and predict the outputs.",
    "challenge_data": {
      "code": "public class CovertRouteTracker {\n    public static void main(String[] args) {\n        int startPoint = 100;\n        int endPoint = -20;\n        float speedFactor = 2.5f;\n        byte checkpoints = 7;\n\n        int routeDistance = (startPoint - endPoint) / checkpoints;\n        \n        double elapsedTime = routeDistance * speedFactor + (startPoint % checkpoints);\n        \n        byte deviationFactor = (byte) (checkpoints * speedFactor);\n        deviationFactor += (byte) (endPoint / 5);\n        \n        System.out.println(\"Final Route Distance: \" + routeDistance);\n        System.out.println(\"Elapsed Time: \" + elapsedTime);\n        System.out.println(\"Deviation Factor: \" + deviationFactor);\n    }\n}",
      "expected_output": [
        "Final Route Distance: 17",
        "Elapsed Time: 44.5",
        "Deviation Factor: 13"
      ],
      "choices": [
        "Final Route Distance: 17",
        "Elapsed Time: 44.55",
        "Deviation Factor: 13",
        "Deviation Factor: 17",
        "Final Route Distance: 175",
        "Elapsed Time: 44.5"
      ],
      "explanation": "1. `startPoint = 100`, `endPoint = -20`, `speedFactor = 2.5f`, `checkpoints = 7`.\n2. `int routeDistance = (startPoint - endPoint) / checkpoints;`\n    * `(100 - (-20))` = `120`.\n    * `120 / 7` (integer division) = `17`. So, `routeDistance` is `17`.\n3. `double elapsedTime = routeDistance * speedFactor + (startPoint % checkpoints);`\n    * `routeDistance * speedFactor`: `17 * 2.5f` (int promotes to float) = `42.5f`.\n    * `startPoint % checkpoints`: `100 % 7` = `2` (100 / 7 is 14 with remainder 2).\n    * `42.5f + 2` (int promotes to float) = `44.5f`. So, `elapsedTime` is `44.5`.\n4. `byte deviationFactor = (byte) (checkpoints * speedFactor);`\n    * `checkpoints * speedFactor`: `7 * 2.5f` (int promotes to float) = `17.5f`.\n    * `(byte)17.5f`: casts to `17` (truncates). So, `deviationFactor` is `17`.\n5. `deviationFactor += (byte) (endPoint / 5);`\n    * `endPoint / 5`: `-20 / 5` (integer division) = `-4`.\n    * `(byte)-4` is `-4`.\n    * `deviationFactor += -4`: `17 + (-4)` = `13`. So, `deviationFactor` is `13`.\n6. All three `System.out.println()` statements display the final values."
    },
    "hints": {
      "1": "Subtraction of a negative number becomes addition (e.g., `100 - (-20)`).",
      "2": "Follow type promotion: `int * float` results in `float`, then `float + int` results in `float`.",
      "3": "Carefully trace the `byte` variable and its updates, including the cast and potential final overflow."
    }
  },
  {
    "id": 151,
    "subtopic_id": 4,
    "type": "code_fixer",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `StakeoutLogger` tracks `totalStakeoutHours` by combining `shift1Hours` and `shift2Hours`. However, the code incorrectly uses subtraction instead of addition. Fix the code to calculate the correct total hours.",
    "story_context": "The StakeoutLogger needs to calculate total stakeout hours. Your task is to fix the arithmetic operation.",
    "challenge_data": {
      "initial_code": "public class StakeoutLogger {\n    public static void main(String[] args) {\n        int shift1Hours = 8;\n        int shift2Hours = 4;\n        int totalStakeoutHours = shift1Hours - shift2Hours;\n        System.out.println(\"Total Stakeout Hours: \" + totalStakeoutHours);\n    }\n}",
      "expected_output": [
        "Total Stakeout Hours: 12"
      ],
      "solution_code": "public class StakeoutLogger {\n    public static void main(String[] args) {\n        int shift1Hours = 8;\n        int shift2Hours = 4;\n        int totalStakeoutHours = shift1Hours + shift2Hours;\n        System.out.println(\"Total Stakeout Hours: \" + totalStakeoutHours);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 5,
          "type": "arithmetic_operator",
          "description": "Using subtraction instead of addition for total calculation",
          "fix": "Change - to +: shift1Hours + shift2Hours"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code used the subtraction operator (`-`) instead of the addition operator (`+`). To find the total hours, the two values need to be added together. Replacing `-` with `+` correctly calculates `8 + 4 = 12`."
    },
    "hints": {
      "1": "The goal is to find the *total* hours.",
      "2": "Which arithmetic operator performs addition?",
      "3": "Look for the operation symbol between `shift1Hours` and `shift2Hours`."
    }
  },
  {
    "id": 152,
    "subtopic_id": 4,
    "type": "code_fixer",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `SuspectTracker` determines `activeSuspects` by reducing `initialSuspects` by `clearedSuspects`. However, the code incorrectly uses multiplication instead of subtraction. Fix the code to calculate the correct number of active suspects.",
    "story_context": "The SuspectTracker needs to calculate active suspects. Your task is to fix the arithmetic operation.",
    "challenge_data": {
      "initial_code": "public class SuspectTracker {\n    public static void main(String[] args) {\n        int initialSuspects = 10;\n        int clearedSuspects = 3;\n        int activeSuspects = initialSuspects * clearedSuspects;\n        System.out.println(\"Active Suspects: \" + activeSuspects);\n    }\n}",
      "expected_output": [
        "Active Suspects: 7"
      ],
      "solution_code": "public class SuspectTracker {\n    public static void main(String[] args) {\n        int initialSuspects = 10;\n        int clearedSuspects = 3;\n        int activeSuspects = initialSuspects - clearedSuspects;\n        System.out.println(\"Active Suspects: \" + activeSuspects);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 5,
          "type": "arithmetic_operator",
          "description": "Using multiplication instead of subtraction for remaining calculation",
          "fix": "Change * to -: initialSuspects - clearedSuspects"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code used the multiplication operator (`*`) instead of the subtraction operator (`-`). To find the remaining suspects, the `clearedSuspects` need to be subtracted from `initialSuspects`. Replacing `*` with `-` correctly calculates `10 - 3 = 7`."
    },
    "hints": {
      "1": "The goal is to find the number of suspects *remaining* after some are cleared.",
      "2": "Which arithmetic operator reduces a quantity?",
      "3": "Look at the symbol between `initialSuspects` and `clearedSuspects`."
    }
  },
  {
    "id": 153,
    "subtopic_id": 4,
    "type": "code_fixer",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "An `EvidenceDistributor` calculates `itemsPerContainer` by dividing `evidenceItems` among `containers`. However, the code performs integer division, losing decimal precision. Fix the code to obtain a floating-point result for `itemsPerContainer`.",
    "story_context": "The EvidenceDistributor needs to calculate items per container. Your task is to fix the division precision.",
    "challenge_data": {
      "initial_code": "public class EvidenceDistributor {\n    public static void main(String[] args) {\n        int evidenceItems = 15;\n        int containers = 4;\n        double itemsPerContainer = evidenceItems / containers;\n        System.out.println(\"Items Per Container: \" + itemsPerContainer);\n    }\n}",
      "expected_output": [
        "Items Per Container: 3.75"
      ],
      "solution_code": "public class EvidenceDistributor {\n    public static void main(String[] args) {\n        int evidenceItems = 15;\n        int containers = 4;\n        double itemsPerContainer = (double) evidenceItems / containers;\n        System.out.println(\"Items Per Container: \" + itemsPerContainer);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 5,
          "type": "integer_division",
          "description": "Integer division loses decimal precision",
          "fix": "Cast to double: (double) evidenceItems / containers"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code performs integer division (`15 / 4 = 3`) because both `evidenceItems` and `containers` are `int`s. This causes the decimal part (`.75`) to be lost. To achieve floating-point division and retain precision, at least one of the operands must be cast to a floating-point type (`double` or `float`). Casting `evidenceItems` to `double` (`(double)evidenceItems`) before division forces the entire operation to be floating-point. The result `3.75` can then be correctly stored in a `double` variable."
    },
    "hints": {
      "1": "Division between two integers will always result in an integer (any decimal part is truncated).",
      "2": "To get a floating-point result from division, at least one of the operands must be a floating-point type (`double` or `float`).",
      "3": "Consider explicitly converting one of the numbers to a decimal type before division."
    }
  },
  {
    "id": 154,
    "subtopic_id": 4,
    "type": "code_fixer",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `FingerprintAnalyzer` calculates `fingerprintRemainder` from `totalPrints` and `labCapacity`. However, the code incorrectly uses multiplication instead of the modulo operator. Fix the code to calculate the correct remainder.",
    "story_context": "The FingerprintAnalyzer needs to calculate fingerprint remainder. Your task is to fix the arithmetic operator.",
    "challenge_data": {
      "initial_code": "public class FingerprintAnalyzer {\n    public static void main(String[] args) {\n        int totalPrints = 22;\n        int labCapacity = 5;\n        int fingerprintRemainder = totalPrints * labCapacity;\n        System.out.println(\"Fingerprint Remainder: \" + fingerprintRemainder);\n    }\n}",
      "expected_output": [
        "Fingerprint Remainder: 2"
      ],
      "solution_code": "public class FingerprintAnalyzer {\n    public static void main(String[] args) {\n        int totalPrints = 22;\n        int labCapacity = 5;\n        int fingerprintRemainder = totalPrints % labCapacity;\n        System.out.println(\"Fingerprint Remainder: \" + fingerprintRemainder);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 5,
          "type": "arithmetic_operator",
          "description": "Using multiplication instead of modulo for remainder calculation",
          "fix": "Change * to %: totalPrints % labCapacity"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code used the multiplication operator (`*`) instead of the modulo operator (`%`). The modulo operator (`%`) is used to find the remainder of a division (`22 / 5` is `4` with a remainder of `2`). Replacing `*` with `%` correctly calculates `22 % 5 = 2`."
    },
    "hints": {
      "1": "The goal is to find what's left over after one number is divided by another, not their product.",
      "2": "Which arithmetic operator gives you the remainder?",
      "3": "Look for the operation symbol between `totalPrints` and `labCapacity`."
    }
  },
  {
    "id": 155,
    "subtopic_id": 4,
    "type": "code_fixer",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "An `ExpenseReport` calculates `netExpenses` by combining `itemsPurchased` and `serviceFees`. However, the code incorrectly uses addition instead of subtraction. Fix the code to calculate the correct net expenses.",
    "story_context": "The ExpenseReport needs to calculate net expenses. Your task is to fix the arithmetic operation.",
    "challenge_data": {
      "initial_code": "public class ExpenseReport {\n    public static void main(String[] args) {\n        double itemsPurchased = 500.0;\n        double serviceFees = 75.5;\n        double netExpenses = itemsPurchased + serviceFees;\n        System.out.println(\"Net Expenses: $\" + netExpenses);\n    }\n}",
      "expected_output": [
        "Net Expenses: $424.5"
      ],
      "solution_code": "public class ExpenseReport {\n    public static void main(String[] args) {\n        double itemsPurchased = 500.0;\n        double serviceFees = 75.5;\n        double netExpenses = itemsPurchased - serviceFees;\n        System.out.println(\"Net Expenses: $\" + netExpenses);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 5,
          "type": "arithmetic_operator",
          "description": "Using addition instead of subtraction for net calculation",
          "fix": "Change + to -: itemsPurchased - serviceFees"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code used the addition operator (`+`) instead of the subtraction operator (`-`). To find the net expenses, the `serviceFees` need to be subtracted from `itemsPurchased`. Replacing `+` with `-` correctly calculates `500.0 - 75.5 = 424.5`."
    },
    "hints": {
      "1": "The goal is to find the *net* expenses, which implies a reduction.",
      "2": "Which arithmetic operator calculates a difference?",
      "3": "Look for the operation symbol between `itemsPurchased` and `serviceFees`."
    }
  },
  {
    "id": 156,
    "subtopic_id": 4,
    "type": "code_fixer",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `ForensicCalculator` determines `evidenceScore` from `cluesFound`, `witnessStatements`, and `importanceFactor`. The code has an operator precedence issue, leading to an incorrect score. Fix the code to correctly calculate the `evidenceScore` by summing `cluesFound` and `witnessStatements` first.",
    "story_context": "The ForensicCalculator needs to calculate evidence score. Your task is to fix the operator precedence.",
    "challenge_data": {
      "initial_code": "public class ForensicCalculator {\n    public static void main(String[] args) {\n        int cluesFound = 10;\n        int witnessStatements = 2;\n        int importanceFactor = 5;\n        int evidenceScore = cluesFound + witnessStatements * importanceFactor;\n        System.out.println(\"Evidence Score: \" + evidenceScore);\n    }\n}",
      "expected_output": [
        "Evidence Score: 60"
      ],
      "solution_code": "public class ForensicCalculator {\n    public static void main(String[] args) {\n        int cluesFound = 10;\n        int witnessStatements = 2;\n        int importanceFactor = 5;\n        int evidenceScore = (cluesFound + witnessStatements) * importanceFactor;\n        System.out.println(\"Evidence Score: \" + evidenceScore);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 6,
          "type": "operator_precedence",
          "description": "Missing parentheses for correct operator precedence",
          "fix": "Add parentheses: (cluesFound + witnessStatements) * importanceFactor"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code `cluesFound + witnessStatements * importanceFactor` evaluates `witnessStatements * importanceFactor` first (`2 * 5 = 10`), then adds `cluesFound` (`10 + 10 = 20`). The intended order was to sum `cluesFound` and `witnessStatements` first. To override Java's default operator precedence and force the addition to occur first, parentheses `()` must be used around `cluesFound + witnessStatements`. This makes the calculation `(10 + 2) * 5 = 12 * 5 = 60`."
    },
    "hints": {
      "1": "In arithmetic operations, multiplication (`*`) and division (`/`) generally take precedence over addition (`+`) and subtraction (`-`).",
      "2": "If you want addition to happen first, you need a way to group those operations.",
      "3": "Think about how you'd explicitly define the order of calculations in mathematics."
    }
  },
  {
    "id": 157,
    "subtopic_id": 4,
    "type": "code_fixer",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "An `InterrogationEvaluator` calculates `interrogationScore` by dividing `totalConfessions` by `suspectsQuestioned`. The code performs integer division, losing decimal precision. Fix the code to obtain a floating-point result for `interrogationScore`.",
    "story_context": "The InterrogationEvaluator needs to calculate interrogation score. Your task is to fix the division precision.",
    "challenge_data": {
      "initial_code": "public class InterrogationEvaluator {\n    public static void main(String[] args) {\n        int totalConfessions = 7;\n        int suspectsQuestioned = 3;\n        double interrogationScore = totalConfessions / suspectsQuestioned;\n        System.out.println(\"Interrogation Score: \" + interrogationScore);\n    }\n}",
      "expected_output": [
        "Interrogation Score: 2.3333333333333335"
      ],
      "solution_code": "public class InterrogationEvaluator {\n    public static void main(String[] args) {\n        int totalConfessions = 7;\n        int suspectsQuestioned = 3;\n        double interrogationScore = (double) totalConfessions / suspectsQuestioned;\n        System.out.println(\"Interrogation Score: \" + interrogationScore);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 5,
          "type": "integer_division",
          "description": "Integer division loses decimal precision",
          "fix": "Cast to double: (double) totalConfessions / suspectsQuestioned"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code performs integer division (`7 / 3 = 2`) because both `totalConfessions` and `suspectsQuestioned` are `int`s. This loses the decimal precision. To get a floating-point result, at least one of the operands must be a `double` or `float`. Casting `totalConfessions` to `double` (`(double)totalConfessions`) before division forces the operation to be floating-point, and the result is stored in a `double` variable (`interrogationScore`), retaining its decimal value."
    },
    "hints": {
      "1": "Division between two integers will result in a whole number, discarding any fractional part.",
      "2": "To obtain a decimal result from a division, at least one of the numbers involved must be a floating-point type (`double` or `float`).",
      "3": "Consider explicitly converting one of the integer variables to a `double` before performing the division."
    }
  },
  {
    "id": 158,
    "subtopic_id": 4,
    "type": "code_fixer",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `CaseAssigner` updates `caseID` using a compound multiplication assignment. However, operator precedence causes the addition `2 + 1` to happen first, leading to an incorrect `caseID` value. Fix the code to ensure the multiplication `* 2` happens before the `+ 1`.",
    "story_context": "The CaseAssigner needs to update case ID. Your task is to fix the compound assignment operator precedence.",
    "challenge_data": {
      "initial_code": "public class CaseAssigner {\n    public static void main(String[] args) {\n        int caseID = 10;\n        caseID *= 2 + 1;\n        System.out.println(\"Final Case ID: \" + caseID);\n    }\n}",
      "expected_output": [
        "Final Case ID: 21"
      ],
      "solution_code": "public class CaseAssigner {\n    public static void main(String[] args) {\n        int caseID = 10;\n        caseID = caseID * 2 + 1;\n        System.out.println(\"Final Case ID: \" + caseID);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 4,
          "type": "compound_assignment_precedence",
          "description": "Compound assignment evaluates right side first, causing wrong order",
          "fix": "Use explicit arithmetic: caseID = caseID * 2 + 1;"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code `caseID *= 2 + 1;` is equivalent to `caseID = caseID * (2 + 1);`. This means `2 + 1` is evaluated first (`3`), and then `caseID` is multiplied by `3` (`10 * 3 = 30`). The intended calculation was `(caseID * 2) + 1`. The fix is to explicitly write out the arithmetic expression `caseID = caseID * 2 + 1;`, which correctly follows the precedence (multiplication first, then addition), resulting in `10 * 2 + 1 = 20 + 1 = 21`."
    },
    "hints": {
      "1": "Compound assignment operators like `*=`, `/=`, `+=`, `-=` have specific rules about what happens on the right-hand side.",
      "2": "The expression `2 + 1` on the right-hand side of `*=` will be evaluated as `3` *before* multiplication.",
      "3": "To ensure the desired order of operations (`* 2` then `+ 1`), you might need to break down the compound assignment or use parentheses."
    }
  },
  {
    "id": 159,
    "subtopic_id": 4,
    "type": "code_fixer",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `CoordinateLogger` calculates `averageCoord` from `xCoord` and `yCoord`. However, the current code performs integer division before casting to `double`, losing precision. Fix the code to ensure floating-point division for an accurate `averageCoord`.",
    "story_context": "The CoordinateLogger needs to calculate average coordinate. Your task is to fix the division precision.",
    "challenge_data": {
      "initial_code": "public class CoordinateLogger {\n    public static void main(String[] args) {\n        int xCoord = 10;\n        int yCoord = 3;\n        double averageCoord = (double) (xCoord / yCoord);\n        System.out.println(\"Average Coordinate: \" + averageCoord);\n    }\n}",
      "expected_output": [
        "Average Coordinate: 3.3333333333333335"
      ],
      "solution_code": "public class CoordinateLogger {\n    public static void main(String[] args) {\n        int xCoord = 10;\n        int yCoord = 3;\n        double averageCoord = (double) xCoord / yCoord;\n        System.out.println(\"Average Coordinate: \" + averageCoord);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 5,
          "type": "cast_precedence",
          "description": "Casting after division loses decimal precision",
          "fix": "Cast before division: (double) xCoord / yCoord"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code `(double) (xCoord / yCoord)` first performs integer division `xCoord / yCoord` (`10 / 3 = 3`), truncating the decimal part. Only *then* is the integer result `3` cast to `double` (`3.0`), leading to a loss of precision. To ensure floating-point division, the cast to `double` must be applied to at least one of the operands *before* the division occurs. `(double) xCoord / yCoord` correctly promotes `xCoord` to `double` before division, making the entire division operation floating-point and retaining the decimals."
    },
    "hints": {
      "1": "The `()` around `xCoord / yCoord` mean that division is completed *before* the cast to `double`.",
      "2": "If both operands in a division are integers, the result of that division is always an integer.",
      "3": "To ensure floating-point division, the cast to `double` needs to affect at least one operand *before* the division happens."
    }
  },
  {
    "id": 160,
    "subtopic_id": 4,
    "type": "code_fixer",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `CrimeSceneChecker` determines if an `evidenceID` is even. The code incorrectly uses the division operator (`/`) instead of the modulo operator (`%`), leading to an inaccurate check. Fix the code to correctly identify if `evidenceID` is even.",
    "story_context": "The CrimeSceneChecker needs to check if evidence ID is even. Your task is to fix the arithmetic operator.",
    "challenge_data": {
      "initial_code": "public class CrimeSceneChecker {\n    public static void main(String[] args) {\n        int evidenceID = 14;\n        if (evidenceID / 2 == 0) {\n            System.out.println(\"Evidence ID is even.\");\n        } else {\n            System.out.println(\"Evidence ID is odd.\");\n        }\n    }\n}",
      "expected_output": [
        "Evidence ID is even."
      ],
      "solution_code": "public class CrimeSceneChecker {\n    public static void main(String[] args) {\n        int evidenceID = 14;\n        if (evidenceID % 2 == 0) {\n            System.out.println(\"Evidence ID is even.\");\n        } else {\n            System.out.println(\"Evidence ID is odd.\");\n        }\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 4,
          "type": "arithmetic_operator",
          "description": "Using division instead of modulo for remainder check",
          "fix": "Use modulo: evidenceID % 2 == 0"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code uses the division operator (`/`) to try and determine if `evidenceID` is even. `evidenceID / 2` calculates `14 / 2 = 7`. `7 == 0` is `false`, so it would incorrectly print \"Evidence ID is odd.\" The correct operator for finding the remainder of a division is the modulo operator (`%`). `14 % 2` correctly evaluates to `0`, so `0 == 0` is `true`, and it prints \"Evidence ID is even.\""
    },
    "hints": {
      "1": "The standard division operator (`/`) performs division, not remainder calculation.",
      "2": "An even number has a remainder of `0` when divided by `2`.",
      "3": "Which specific arithmetic operator is designed to return the remainder of a division?"
    }
  },
  {
    "id": 161,
    "subtopic_id": 4,
    "type": "code_fixer",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `CaseFileGenerator` calculates a `caseFileNumber` from `incidentCount` and `districtID`. The sum of these `int` values exceeds the `int`'s maximum capacity, causing an integer overflow. Fix the code to correctly store this large `caseFileNumber`.",
    "story_context": "The CaseFileGenerator needs to calculate case file number. Your task is to fix the integer overflow.",
    "challenge_data": {
      "initial_code": "public class CaseFileGenerator {\n    public static void main(String[] args) {\n        int incidentCount = 2000000000;\n        int districtID = 500000000;\n        int caseFileNumber = incidentCount + districtID;\n        System.out.println(\"Case File Number: \" + caseFileNumber);\n    }\n}",
      "expected_output": [
        "Case File Number: 2500000000"
      ],
      "solution_code": "public class CaseFileGenerator {\n    public static void main(String[] args) {\n        int incidentCount = 2000000000;\n        int districtID = 500000000;\n        long caseFileNumber = (long)incidentCount + districtID;\n        System.out.println(\"Case File Number: \" + caseFileNumber);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 5,
          "type": "integer_overflow",
          "description": "Sum exceeds int maximum capacity",
          "fix": "Cast to long and change variable type: long caseFileNumber = (long)incidentCount + districtID;"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The sum of `incidentCount` (`2,000,000,000`) and `districtID` (`500,000,000`) is `2,500,000,000`. This value exceeds the maximum capacity of an `int` (which is `2,147,483,647`). When this sum is assigned to an `int` variable, it causes an **integer overflow**, resulting in an incorrect negative value. To correctly store such a large number, the `long` data type (which can hold values up to approximately 9.2 x 10^18) must be used for both the literals (by adding `L` suffix) and the `caseFileNumber` variable."
    },
    "hints": {
      "1": "Recall the maximum positive value an `int` can store (approximately 2.1 billion).",
      "2": "Adding two large `int`s can result in a sum that exceeds this limit, causing an \"overflow\" where the number wraps around to a negative value.",
      "3": "Consider the primitive integer type that has a much larger capacity for whole numbers."
    }
  },
  {
    "id": 162,
    "subtopic_id": 4,
    "type": "code_fixer",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `BallisticsCalculator` calculates `projectileImpactPoint` using `float` variables. Due to the limited precision of `float`, the final calculation is inaccurate. Fix the code to ensure maximum precision for `projectileImpactPoint`.",
    "story_context": "The BallisticsCalculator needs to calculate projectile impact point. Your task is to fix the precision issue.",
    "challenge_data": {
      "initial_code": "public class BallisticsCalculator {\n    public static void main(String[] args) {\n        float launchAngle = 45.0f;\n        float gravityEffect = 9.8f;\n        float windCorrection = 0.000123f;\n        \n        float projectileImpactPoint = launchAngle / gravityEffect - windCorrection;\n        System.out.println(\"Projectile Impact Point: \" + projectileImpactPoint);\n    }\n}",
      "expected_output": [
        "Projectile Impact Point: 4.588049693877551"
      ],
      "solution_code": "public class BallisticsCalculator {\n    public static void main(String[] args) {\n        double launchAngle = 45.0;\n        double gravityEffect = 9.8;\n        double windCorrection = 0.000123;\n        \n        double projectileImpactPoint = launchAngle / gravityEffect - windCorrection;\n        System.out.println(\"Projectile Impact Point: \" + projectileImpactPoint);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 3,
          "type": "precision_loss",
          "description": "Using float instead of double for precision calculations",
          "fix": "Change to double: double launchAngle = 45.0;"
        },
        {
          "id": 2,
          "line": 4,
          "type": "precision_loss",
          "description": "Using float instead of double for precision calculations",
          "fix": "Change to double: double gravityEffect = 9.8;"
        },
        {
          "id": 3,
          "line": 5,
          "type": "precision_loss",
          "description": "Using float instead of double for precision calculations",
          "fix": "Change to double: double windCorrection = 0.000123;"
        },
        {
          "id": 4,
          "line": 7,
          "type": "precision_loss",
          "description": "Using float instead of double for precision calculations",
          "fix": "Change to double: double projectileImpactPoint = launchAngle / gravityEffect - windCorrection;"
        }
      ],
      "number_of_errors": 4,
      "explanation": "The `float` data type offers less precision (32-bit) compared to `double` (64-bit). In calculations involving multiple floating-point operations, using `float` can lead to cumulative precision loss, resulting in an inaccurate final value. To ensure maximum precision for `projectileImpactPoint`, all variables and literals involved in its calculation should be of the `double` type. This forces all intermediate calculations to use double precision, preserving accuracy."
    },
    "hints": {
      "1": "The `float` data type provides single precision, which can lead to inaccuracies in complex or sensitive calculations.",
      "2": "The `double` data type offers double precision, providing much higher accuracy for decimal numbers.",
      "3": "To ensure full precision, all floating-point literals and variables involved in the calculation should be of the higher precision type."
    }
  },
  {
    "id": 163,
    "subtopic_id": 4,
    "type": "code_fixer",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "An `AlibiTimer` calculates `criticalTimeOffset` using division that results in a decimal, but the code performs integer division before multiplication, losing precision. Fix the code to ensure floating-point precision in the division.",
    "story_context": "The AlibiTimer needs to calculate critical time offset. Your task is to fix the division precision.",
    "challenge_data": {
      "initial_code": "public class AlibiTimer {\n    public static void main(String[] args) {\n        int crimeHour = 10;\n        int alibiWindow = 3;\n        double offsetMultiplier = 0.75;\n        \n        double criticalTimeOffset = (alibiWindow / 2) * offsetMultiplier;\n        System.out.println(\"Critical Time Offset: \" + criticalTimeOffset);\n    }\n}",
      "expected_output": [
        "Critical Time Offset: 1.125"
      ],
      "solution_code": "public class AlibiTimer {\n    public static void main(String[] args) {\n        int crimeHour = 10;\n        int alibiWindow = 3;\n        double offsetMultiplier = 0.75;\n        \n        double criticalTimeOffset = ((double) alibiWindow / 2) * offsetMultiplier;\n        System.out.println(\"Critical Time Offset: \" + criticalTimeOffset);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 7,
          "type": "integer_division",
          "description": "Integer division loses decimal precision",
          "fix": "Cast to double: ((double) alibiWindow / 2) * offsetMultiplier"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code `(alibiWindow / 2)` performs integer division (`3 / 2 = 1`), truncating the decimal part. This integer result `1` is then multiplied by `offsetMultiplier` (`1 * 0.75 = 0.75`), leading to an incorrect final value. To ensure floating-point precision in the division, one of the operands in `alibiWindow / 2` must be explicitly cast to `double` (e.g., `(double)alibiWindow`). This forces floating-point division (`3.0 / 2 = 1.5`), and the subsequent multiplication maintains that precision."
    },
    "hints": {
      "1": "The expression `alibiWindow / 2` will perform integer division because both `alibiWindow` and `2` are integers.",
      "2": "This integer division (e.g., `3 / 2 = 1`) happens *before* the result is multiplied by `offsetMultiplier`.",
      "3": "To get a floating-point result for the division, at least one operand must be a floating-point type *before* the division occurs."
    }
  },
  {
    "id": 164,
    "subtopic_id": 4,
    "type": "code_fixer",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "An `InterrogationFeedback` system calculates `feedbackRemainder` using the modulo operator on a negative `feedbackCode`. In Java, the result of modulo with a negative dividend is negative, leading to an unexpected remainder. Fix the code to always yield a non-negative remainder.",
    "story_context": "The InterrogationFeedback needs to calculate feedback remainder. Your task is to fix the negative modulo issue.",
    "challenge_data": {
      "initial_code": "public class InterrogationFeedback {\n    public static void main(String[] args) {\n        int feedbackCode = -7;\n        int divisor = 3;\n        int feedbackRemainder = feedbackCode % divisor;\n        System.out.println(\"Feedback Remainder: \" + feedbackRemainder);\n    }\n}",
      "expected_output": [
        "Feedback Remainder: 2"
      ],
      "solution_code": "public class InterrogationFeedback {\n    public static void main(String[] args) {\n        int feedbackCode = -7;\n        int divisor = 3;\n        int feedbackRemainder = (feedbackCode % divisor + divisor) % divisor;\n        System.out.println(\"Feedback Remainder: \" + feedbackRemainder);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 5,
          "type": "negative_modulo",
          "description": "Modulo with negative dividend yields negative result",
          "fix": "Adjust for non-negative: (feedbackCode % divisor + divisor) % divisor"
        }
      ],
      "number_of_errors": 1,
      "explanation": "In Java, the result of the modulo operator (`%`) takes the sign of the dividend (the left operand). So, `-7 % 3` evaluates to `-1` (because `-7 = -3 * 2 - 1`). If the goal is to always have a non-negative remainder (as in standard mathematical modular arithmetic), an adjustment is needed for negative results. The common fix is `(feedbackCode % divisor + divisor) % divisor`. This ensures that even if `feedbackCode % divisor` is negative, adding `divisor` makes it positive before the final modulo operation, resulting in a non-negative remainder (e.g., `(-1 + 3) % 3 = 2 % 3 = 2`)."
    },
    "hints": {
      "1": "In Java, the sign of the result of the modulo operator (`%`) is the same as the sign of the *dividend* (the left-hand operand).",
      "2": "For a negative `feedbackCode` like `-7`, `-7 % 3` will be `-1`.",
      "3": "If you need a strictly non-negative remainder (like in true mathematical modulo), an extra step is required for negative results."
    }
  },
  {
    "id": 165,
    "subtopic_id": 4,
    "type": "code_fixer",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `ProgressTracker` updates `caseProgress` using a compound multiplication assignment. However, operator precedence causes the addition `5 + 1` to occur before the multiplication with `caseProgress`, leading to an incorrect final value. Fix the code to ensure `caseProgress` is multiplied by `2` and then `1` is added.",
    "story_context": "The ProgressTracker needs to update case progress. Your task is to fix the compound assignment operator precedence.",
    "challenge_data": {
      "initial_code": "public class ProgressTracker {\n    public static void main(String[] args) {\n        int caseProgress = 10;\n        caseProgress *= 5 + 1;\n        System.out.println(\"Final Case Progress: \" + caseProgress);\n    }\n}",
      "expected_output": [
        "Final Case Progress: 21"
      ],
      "solution_code": "public class ProgressTracker {\n    public static void main(String[] args) {\n        int caseProgress = 10;\n        caseProgress = caseProgress * 2 + 1;\n        System.out.println(\"Final Case Progress: \" + caseProgress);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 4,
          "type": "compound_assignment_precedence",
          "description": "Compound assignment evaluates right side first, causing wrong order",
          "fix": "Use explicit arithmetic: caseProgress = caseProgress * 2 + 1;"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code `caseProgress *= 5 + 1;` is equivalent to `caseProgress = caseProgress * (5 + 1);`. This means `5 + 1` is evaluated first (resulting in `6`), and then `caseProgress` is multiplied by `6` (`10 * 6 = 60`). The intended calculation was `(caseProgress * 2) + 1`. The fix is to explicitly write out the arithmetic expression `caseProgress = caseProgress * 2 + 1;`, which correctly follows the precedence (multiplication first, then addition), resulting in `10 * 2 + 1 = 20 + 1 = 21`."
    },
    "hints": {
      "1": "Compound assignment operators like `*= X + Y` are shorthand for `variable = variable * (X + Y)`.",
      "2": "The entire expression on the right side of the compound operator is evaluated *first*, based on its own precedence rules.",
      "3": "To ensure the desired order of operations (`* 2` then `+ 1`), you might need to break down the compound assignment or use parentheses."
    }
  },
  {
    "id": 166,
    "subtopic_id": 4,
    "type": "code_completion",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `LeadAggregator` combines `informantA` and `informantB` leads to get `activeLeads`. Complete the arithmetic operator to correctly sum these leads.",
    "story_context": "The LeadAggregator needs to combine leads from different informants. Your task is to complete the arithmetic operator.",
    "challenge_data": {
      "initial_code": "public class LeadAggregator {\n    public static void main(String[] args) {\n        int informantA = 7;\n        int informantB = 5;\n        int activeLeads = informantA ??? informantB;\n        System.out.println(\"Active Leads: \" + activeLeads);\n    }\n}",
      "expected_output": [
        "Active Leads: 12"
      ],
      "solution_code": "public class LeadAggregator {\n    public static void main(String[] args) {\n        int informantA = 7;\n        int informantB = 5;\n        int activeLeads = informantA + informantB;\n        System.out.println(\"Active Leads: \" + activeLeads);\n    }\n}",
      "choices": [
        "+",
        "-",
        "/",
        "*"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 5,
          "type": "operator",
          "description": "Arithmetic operator for addition",
          "correct_answer": "+",
          "explanation": "To find the total sum of `informantA` and `informantB`, the addition operator `+` is required. `7 + 5` correctly calculates `12`."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": "The goal is to `total` the leads.",
      "2": "Which arithmetic operator performs addition?",
      "3": "The blank needs a single operation symbol."
    }
  },
  {
    "id": 167,
    "subtopic_id": 4,
    "type": "code_completion",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `CaseTracker` determines `openCases` by subtracting `closedCases` from `totalCases`. Complete the arithmetic operator to correctly find the number of `openCases`.",
    "story_context": "The CaseTracker needs to determine open cases by subtracting closed cases. Your task is to complete the arithmetic operator.",
    "challenge_data": {
      "initial_code": "public class CaseTracker {\n    public static void main(String[] args) {\n        int totalCases = 20;\n        int closedCases = 8;\n        int openCases = totalCases ??? closedCases;\n        System.out.println(\"Open Cases: \" + openCases);\n    }\n}",
      "expected_output": [
        "Open Cases: 12"
      ],
      "solution_code": "public class CaseTracker {\n    public static void main(String[] args) {\n        int totalCases = 20;\n        int closedCases = 8;\n        int openCases = totalCases - closedCases;\n        System.out.println(\"Open Cases: \" + openCases);\n    }\n}",
      "choices": [
        "+",
        "-",
        "/",
        "*"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 5,
          "type": "operator",
          "description": "Arithmetic operator for subtraction",
          "correct_answer": "-",
          "explanation": "To find the number of `openCases`, the `closedCases` need to be subtracted from `totalCases`. The subtraction operator `-` is used for this purpose. `20 - 8` correctly calculates `12`."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": "The goal is to find the number of cases that are still `open`.",
      "2": "Which arithmetic operator performs subtraction?",
      "3": "The blank needs a single operation symbol."
    }
  },
  {
    "id": 168,
    "subtopic_id": 4,
    "type": "code_completion",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `ProfileMultiplier` estimates `totalProfiles` by multiplying `suspectProfiles` by a `duplicateFactor`. Complete the arithmetic operator to correctly scale the profiles.",
    "story_context": "The ProfileMultiplier needs to estimate total profiles by accounting for duplicates. Your task is to complete the arithmetic operator.",
    "challenge_data": {
      "initial_code": "public class ProfileMultiplier {\n    public static void main(String[] args) {\n        int suspectProfiles = 6;\n        int duplicateFactor = 3;\n        int totalProfiles = suspectProfiles ??? duplicateFactor;\n        System.out.println(\"Total Profiles: \" + totalProfiles);\n    }\n}",
      "expected_output": [
        "Total Profiles: 18"
      ],
      "solution_code": "public class ProfileMultiplier {\n    public static void main(String[] args) {\n        int suspectProfiles = 6;\n        int duplicateFactor = 3;\n        int totalProfiles = suspectProfiles * duplicateFactor;\n        System.out.println(\"Total Profiles: \" + totalProfiles);\n    }\n}",
      "choices": [
        "+",
        "-",
        "/",
        "*"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 5,
          "type": "operator",
          "description": "Arithmetic operator for multiplication",
          "correct_answer": "*",
          "explanation": "To find the `totalProfiles` by accounting for duplicates, `suspectProfiles` and `duplicateFactor` need to be multiplied. The multiplication operator `*` is used for this purpose. `6 * 3` correctly calculates `18`."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": "The goal is to find the `total` number of profiles when accounting for duplicates.",
      "2": "Which arithmetic operator performs multiplication?",
      "3": "The blank needs a single operation symbol."
    }
  },
  {
    "id": 169,
    "subtopic_id": 4,
    "type": "code_completion",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `ResourceAllocator` distributes `sharedResources` among `teamMembers`. Complete the arithmetic operator to correctly calculate `resourcesPerMember`.",
    "story_context": "The ResourceAllocator needs to distribute resources among team members. Your task is to complete the arithmetic operator.",
    "challenge_data": {
      "initial_code": "public class ResourceAllocator {\n    public static void main(String[] args) {\n        int sharedResources = 25;\n        int teamMembers = 5;\n        int resourcesPerMember = sharedResources ??? teamMembers;\n        System.out.println(\"Resources Per Member: \" + resourcesPerMember);\n    }\n}",
      "expected_output": [
        "Resources Per Member: 5"
      ],
      "solution_code": "public class ResourceAllocator {\n    public static void main(String[] args) {\n        int sharedResources = 25;\n        int teamMembers = 5;\n        int resourcesPerMember = sharedResources / teamMembers;\n        System.out.println(\"Resources Per Member: \" + resourcesPerMember);\n    }\n}",
      "choices": [
        "+",
        "-",
        "/",
        "*"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 5,
          "type": "operator",
          "description": "Arithmetic operator for division",
          "correct_answer": "/",
          "explanation": "To find `resourcesPerMember`, `sharedResources` need to be divided by `teamMembers`. The division operator `/` is used for this purpose. `25 / 5` correctly calculates `5`."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": "The goal is to distribute resources `per member`.",
      "2": "Which arithmetic operator performs division?",
      "3": "The blank needs a single operation symbol."
    }
  },
  {
    "id": 170,
    "subtopic_id": 4,
    "type": "code_completion",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `TaggingSystem` calculates `remainingTags` after `evidenceCount` is divided into sheets, each holding `tagsPerSheet`. Complete the arithmetic operator to correctly find the remainder.",
    "story_context": "The TaggingSystem needs to calculate remaining tags after division. Your task is to complete the arithmetic operator.",
    "challenge_data": {
      "initial_code": "public class TaggingSystem {\n    public static void main(String[] args) {\n        int evidenceCount = 17;\n        int tagsPerSheet = 5;\n        int remainingTags = evidenceCount ??? tagsPerSheet;\n        System.out.println(\"Remaining Tags: \" + remainingTags);\n    }\n}",
      "expected_output": [
        "Remaining Tags: 2"
      ],
      "solution_code": "public class TaggingSystem {\n    public static void main(String[] args) {\n        int evidenceCount = 17;\n        int tagsPerSheet = 5;\n        int remainingTags = evidenceCount % tagsPerSheet;\n        System.out.println(\"Remaining Tags: \" + remainingTags);\n    }\n}",
      "choices": [
        "+",
        "-",
        "%",
        "*"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 5,
          "type": "operator",
          "description": "Arithmetic operator for modulo",
          "correct_answer": "%",
          "explanation": "To find the `remainingTags` after dividing `evidenceCount` by `tagsPerSheet`, the modulo operator `%` is used. `17 % 5` correctly calculates `2` (17 divided by 5 is 3 with a remainder of 2)."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": "The goal is to find what's \"left over\" or the `remainder` after division.",
      "2": "Which arithmetic operator specifically gives you the remainder?",
      "3": "The blank needs a single operation symbol."
    }
  },
  {
    "id": 171,
    "subtopic_id": 4,
    "type": "code_completion",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "An `ActivityProfiler` calculates an `activityScore` by multiplying `incidents` by `days`, then adding a `bonus`. Complete the arithmetic operators to correctly calculate the `activityScore`.",
    "story_context": "The ActivityProfiler needs to calculate activity scores using multiplication and addition. Your task is to complete the arithmetic operators.",
    "challenge_data": {
      "initial_code": "public class ActivityProfiler {\n    public static void main(String[] args) {\n        int incidents = 5;\n        int days = 10;\n        int bonus = 20;\n        int activityScore = incidents ??? days ??? bonus;\n        System.out.println(\"Activity Score: \" + activityScore);\n    }\n}",
      "expected_output": [
        "Activity Score: 70"
      ],
      "solution_code": "public class ActivityProfiler {\n    public static void main(String[] args) {\n        int incidents = 5;\n        int days = 10;\n        int bonus = 20;\n        int activityScore = incidents * days + bonus;\n        System.out.println(\"Activity Score: \" + activityScore);\n    }\n}",
      "choices": [
        "-",
        "/",
        "*",
        "%",
        "+",
        "( )"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 7,
          "type": "operator",
          "description": "Arithmetic operator for multiplication",
          "correct_answer": "*",
          "explanation": "To calculate `activityScore`, `incidents` should be multiplied by `days`. The multiplication operator `*` performs the multiplication."
        },
        {
          "id": "slot_2",
          "line": 7,
          "type": "operator",
          "description": "Arithmetic operator for addition",
          "correct_answer": "+",
          "explanation": "After multiplying `incidents` by `days`, the `bonus` should be added. The addition operator `+` performs the addition."
        }
      ],
      "number_of_slots": 2
    },
    "hints": {
      "1": "The calculation involves both multiplication and addition.",
      "2": "Recall the default order of operations (precedence) for arithmetic operators.",
      "3": "Consider how numbers and operators combine to form a score."
    }
  },
  {
    "id": 172,
    "subtopic_id": 4,
    "type": "code_completion",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `CrimeRateCalculator` determines `averageCrimeRate` by dividing `totalCrimes` by `reportingPeriods`. Complete the type cast and the arithmetic operator to ensure a floating-point result for the average.",
    "story_context": "The CrimeRateCalculator needs to calculate average crime rates with decimal precision. Your task is to complete the type cast and arithmetic operator.",
    "challenge_data": {
      "initial_code": "public class CrimeRateCalculator {\n    public static void main(String[] args) {\n        int totalCrimes = 17;\n        int reportingPeriods = 5;\n        double averageCrimeRate = (??? totalCrimes) ??? reportingPeriods;\n        System.out.println(\"Average Crime Rate: \" + averageCrimeRate);\n    }\n}",
      "expected_output": [
        "Average Crime Rate: 3.4"
      ],
      "solution_code": "public class CrimeRateCalculator {\n    public static void main(String[] args) {\n        int totalCrimes = 17;\n        int reportingPeriods = 5;\n        double averageCrimeRate = (double totalCrimes) / reportingPeriods;\n        System.out.println(\"Average Crime Rate: \" + averageCrimeRate);\n    }\n}",
      "choices": [
        "/",
        "%",
        "*",
        "+",
        "double",
        "int"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 5,
          "type": "type_casting",
          "description": "Type cast for floating-point division",
          "correct_answer": "double",
          "explanation": "To ensure floating-point division and retain decimal precision, `totalCrimes` must be explicitly cast to `double` using `(double)` before the division."
        },
        {
          "id": "slot_2",
          "line": 5,
          "type": "operator",
          "description": "Arithmetic operator for division",
          "correct_answer": "/",
          "explanation": "The division operator `/` is used to perform the division. This results in `(double)17 / 5` calculating `3.4`."
        }
      ],
      "number_of_slots": 2
    },
    "hints": {
      "1": "To get a decimal result from division involving integers, at least one operand must be converted to a floating-point type.",
      "2": "The blank before `totalCrimes` needs a type conversion operator.",
      "3": "The blank after `totalCrimes` needs the division operator."
    }
  },
  {
    "id": 173,
    "subtopic_id": 4,
    "type": "code_completion",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `BudgetTracker` adjusts `caseBudget` by subtracting `investigationCosts` and adding `reimbursement`. Complete the compound assignment operators to reflect these changes efficiently.",
    "story_context": "The BudgetTracker needs to adjust case budgets using compound assignment operators. Your task is to complete the compound assignment operators.",
    "challenge_data": {
      "initial_code": "public class BudgetTracker {\n    public static void main(String[] args) {\n        int caseBudget = 500;\n        int investigationCosts = 150;\n        int reimbursement = 75;\n\n        caseBudget ??? investigationCosts;\n        caseBudget ??? reimbursement;\n        System.out.println(\"Remaining Budget: $\" + caseBudget);\n    }\n}",
      "expected_output": [
        "Remaining Budget: $425"
      ],
      "solution_code": "public class BudgetTracker {\n    public static void main(String[] args) {\n        int caseBudget = 500;\n        int investigationCosts = 150;\n        int reimbursement = 75;\n\n        caseBudget -= investigationCosts;\n        caseBudget += reimbursement;\n        System.out.println(\"Remaining Budget: $\" + caseBudget);\n    }\n}",
      "choices": [
        "/=",
        "-",
        "+=",
        "-=",
        "*",
        "+"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 8,
          "type": "compound_assignment",
          "description": "Compound subtraction assignment operator",
          "correct_answer": "-=",
          "explanation": "To subtract `investigationCosts` from `caseBudget` and reassign the result, the compound subtraction assignment operator `-=` is used."
        },
        {
          "id": "slot_2",
          "line": 9,
          "type": "compound_assignment",
          "description": "Compound addition assignment operator",
          "correct_answer": "+=",
          "explanation": "To add `reimbursement` to `caseBudget` and reassign the result, the compound addition assignment operator `+=` is used."
        }
      ],
      "number_of_slots": 2
    },
    "hints": {
      "1": "The `investigationCosts` are `subtracted` from the budget. Which compound operator performs subtraction and assignment?",
      "2": "The `reimbursement` is `added` to the budget. Which compound operator performs addition and assignment?",
      "3": "Each blank requires a compound assignment operator."
    }
  },
  {
    "id": 174,
    "subtopic_id": 4,
    "type": "code_completion",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `CipherAnalyzer` determines a `patternRemainder` by finding the remainder of `cipherSequence` divided by `segmentSize`. Complete the arithmetic operator to correctly calculate the remainder.",
    "story_context": "The CipherAnalyzer needs to determine pattern remainders using modulo operations. Your task is to complete the arithmetic operator.",
    "challenge_data": {
      "initial_code": "public class CipherAnalyzer {\n    public static void main(String[] args) {\n        int cipherSequence = 47;\n        int segmentSize = 10;\n        int patternRemainder = cipherSequence ??? segmentSize;\n        System.out.println(\"Pattern Remainder: \" + patternRemainder);\n    }\n}",
      "expected_output": [
        "Pattern Remainder: 7"
      ],
      "solution_code": "public class CipherAnalyzer {\n    public static void main(String[] args) {\n        int cipherSequence = 47;\n        int segmentSize = 10;\n        int patternRemainder = cipherSequence % segmentSize;\n        System.out.println(\"Pattern Remainder: \" + patternRemainder);\n    }\n}",
      "choices": [
        "-",
        "/",
        "%",
        "*",
        "+",
        "=="
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 5,
          "type": "operator",
          "description": "Arithmetic operator for modulo",
          "correct_answer": "%",
          "explanation": "To find the `patternRemainder` when `cipherSequence` is divided by `segmentSize`, the modulo operator `%` is used. `47 % 10` calculates `7` (47 divided by 10 is 4 with a remainder of 7)."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": "The goal is to find the `remainder` of a division.",
      "2": "Which arithmetic operator specifically returns the remainder?",
      "3": "The blank requires a single operation symbol."
    }
  },
  {
    "id": 175,
    "subtopic_id": 4,
    "type": "code_completion",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `ProfileCombiner` calculates `totalProfiles` by summing `knownProfiles` and `newProfiles`, then multiplying by `securityMultiplier`. Complete the arithmetic operators to correctly combine these values.",
    "story_context": "The ProfileCombiner needs to calculate total profiles by combining and scaling values. Your task is to complete the arithmetic operators.",
    "challenge_data": {
      "initial_code": "public class ProfileCombiner {\n    public static void main(String[] args) {\n        int knownProfiles = 12;\n        int newProfiles = 3;\n        int securityMultiplier = 2;\n        int totalProfiles = (knownProfiles ??? newProfiles) ??? securityMultiplier;\n        System.out.println(\"Total Profiles: \" + totalProfiles);\n    }\n}",
      "expected_output": [
        "Total Profiles: 30"
      ],
      "solution_code": "public class ProfileCombiner {\n    public static void main(String[] args) {\n        int knownProfiles = 12;\n        int newProfiles = 3;\n        int securityMultiplier = 2;\n        int totalProfiles = (knownProfiles + newProfiles) * securityMultiplier;\n        System.out.println(\"Total Profiles: \" + totalProfiles);\n    }\n}",
      "choices": [
        "-",
        "/",
        "*",
        "+",
        "%=",
        "( )"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 6,
          "type": "operator",
          "description": "Arithmetic operator for addition",
          "correct_answer": "+",
          "explanation": "To calculate `totalProfiles`, `knownProfiles` and `newProfiles` are first added using the `+` operator."
        },
        {
          "id": "slot_2",
          "line": 6,
          "type": "operator",
          "description": "Arithmetic operator for multiplication",
          "correct_answer": "*",
          "explanation": "Then their sum is multiplied by `securityMultiplier` using the `*` operator. The parentheses correctly enforce the order of operations."
        }
      ],
      "number_of_slots": 2
    },
    "hints": {
      "1": "First, `knownProfiles` and `newProfiles` should be summed.",
      "2": "Then, that sum should be multiplied by `securityMultiplier`.",
      "3": "Consider the operators needed for addition and multiplication."
    }
  },
  {
    "id": 176,
    "subtopic_id": 4,
    "type": "code_completion",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `SafeCracker` processes `cipherPart1`, `cipherPart2`, and a `modifier` to determine a `combinationValueRemainder` and a `finalCalc`. Complete the declarations and operators for these complex arithmetic operations.",
    "story_context": "The SafeCracker needs to process cipher parts and modifiers for complex calculations. Your task is to complete the variable declarations and arithmetic operators.",
    "challenge_data": {
      "initial_code": "public class SafeCracker {\n    public static void main(String[] args) {\n        int cipherPart1 = 10;\n        int cipherPart2 = 5;\n        int modifier = 3;\n        \n        ??? combinationValueRemainder;\n        \n        int intermediateResult = (cipherPart1 + cipherPart2) ??? 2;\n        \n        combinationValueRemainder = intermediateResult ??? modifier;\n        \n        int finalCalc = (intermediateResult + modifier) ??? (cipherPart1 - cipherPart2);\n        \n        System.out.println(\"Combination Value Remainder: \" + combinationValueRemainder);\n        System.out.println(\"Final Calculation: \" + finalCalc);\n    }\n}",
      "expected_output": [
        "Combination Value Remainder: 0",
        "Final Calculation: 45"
      ],
      "solution_code": "public class SafeCracker {\n    public static void main(String[] args) {\n        int cipherPart1 = 10;\n        int cipherPart2 = 5;\n        int modifier = 3;\n        \n        int combinationValueRemainder;\n        \n        int intermediateResult = (cipherPart1 + cipherPart2) / 2;\n        \n        combinationValueRemainder = intermediateResult % modifier;\n        \n        int finalCalc = (intermediateResult + modifier) * (cipherPart1 - cipherPart2);\n        \n        System.out.println(\"Combination Value Remainder: \" + combinationValueRemainder);\n        System.out.println(\"Final Calculation: \" + finalCalc);\n    }\n}",
      "choices": [
        "-",
        "int combinationValueRemainder",
        "long combinationValueRemainder",
        "/",
        "%",
        "*",
        "+",
        "value"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 7,
          "type": "variable_declaration",
          "description": "Integer variable declaration for combinationValueRemainder",
          "correct_answer": "int combinationValueRemainder",
          "explanation": "`int combinationValueRemainder` declares the integer variable for the remainder."
        },
        {
          "id": "slot_2",
          "line": 9,
          "type": "operator",
          "description": "Arithmetic operator for division",
          "correct_answer": "/",
          "explanation": "The blank after `(cipherPart1 + cipherPart2)` needs the division operator `/` to divide the sum by 2."
        },
        {
          "id": "slot_3",
          "line": 11,
          "type": "operator",
          "description": "Arithmetic operator for modulo",
          "correct_answer": "%",
          "explanation": "The blank for the `combinationValueRemainder` assignment needs the modulo operator `%` to find the remainder of `intermediateResult` divided by `modifier`."
        },
        {
          "id": "slot_4",
          "line": 13,
          "type": "operator",
          "description": "Arithmetic operator for multiplication",
          "correct_answer": "*",
          "explanation": "The blank for `finalCalc` needs the multiplication operator `*` to multiply the sum of `intermediateResult` and `modifier` by the difference of `cipherPart1` and `cipherPart2`."
        }
      ],
      "number_of_slots": 4
    },
    "hints": {
      "1": "The first blank declares the result variable for a remainder.",
      "2": "The expression involves dividing a sum by `2` and then performing a modulo operation with `modifier`.",
      "3": "The last blank involves a multiplication (`*`) to get the `finalCalc`."
    }
  },
  {
    "id": 177,
    "subtopic_id": 4,
    "type": "code_completion",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "An `AuditReport` calculates `netBalance` and updates `totalRevenue` based on `feesIncurred` and `periods`. An `auditCode` is also determined. Complete the declarations and various arithmetic and compound assignment operators.",
    "story_context": "The AuditReport needs to calculate net balances and update revenue using various operators. Your task is to complete the variable declarations and operators.",
    "challenge_data": {
      "initial_code": "public class AuditReport {\n    public static void main(String[] args) {\n        long totalRevenue = 1000000000L;\n        int feesIncurred = 50000000;\n        int periods = 5;\n        \n        ??? netBalance = totalRevenue ??? feesIncurred;\n        \n        totalRevenue ???= feesIncurred / periods;\n        \n        int auditCode = (int) (netBalance ??? feesIncurred);\n        \n        auditCode ???= 200;\n        \n        System.out.println(\"Final Net Balance: \" + netBalance);\n        System.out.println(\"Total Revenue After Adjust: \" + totalRevenue);\n        System.out.println(\"Final Audit Code: \" + auditCode);\n    }\n}",
      "expected_output": [
        "Final Net Balance: 950000000",
        "Total Revenue After Adjust: 900000000",
        "Final Audit Code: 4750000200"
      ],
      "solution_code": "public class AuditReport {\n    public static void main(String[] args) {\n        long totalRevenue = 1000000000L;\n        int feesIncurred = 50000000;\n        int periods = 5;\n        \n        long netBalance = totalRevenue - feesIncurred;\n        \n        totalRevenue /= feesIncurred / periods;\n        \n        int auditCode = (int) (netBalance * feesIncurred);\n        \n        auditCode += 200;\n        \n        System.out.println(\"Final Net Balance: \" + netBalance);\n        System.out.println(\"Total Revenue After Adjust: \" + totalRevenue);\n        System.out.println(\"Final Audit Code: \" + auditCode);\n    }\n}",
      "choices": [
        "/=",
        "long",
        "+=",
        "-",
        "double",
        "*",
        "+",
        "%="
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 7,
          "type": "variable_declaration",
          "description": "Data type declaration for netBalance",
          "correct_answer": "long",
          "explanation": "`long` is the correct type for `netBalance` to hold large values."
        },
        {
          "id": "slot_2",
          "line": 7,
          "type": "operator",
          "description": "Arithmetic operator for subtraction",
          "correct_answer": "-",
          "explanation": "`-` is used for subtraction between `totalRevenue` and `feesIncurred`."
        },
        {
          "id": "slot_3",
          "line": 9,
          "type": "compound_assignment",
          "description": "Compound division assignment operator",
          "correct_answer": "/=",
          "explanation": "`/=` is the compound division assignment operator."
        },
        {
          "id": "slot_4",
          "line": 11,
          "type": "operator",
          "description": "Arithmetic operator for multiplication",
          "correct_answer": "*",
          "explanation": "`*` is the multiplication operator for `auditCode` calculation."
        },
        {
          "id": "slot_5",
          "line": 13,
          "type": "compound_assignment",
          "description": "Compound addition assignment operator",
          "correct_answer": "+=",
          "explanation": "`+=` is the compound addition assignment operator."
        }
      ],
      "number_of_slots": 5
    },
    "hints": {
      "1": "`netBalance` needs to store a large integer value, found by subtracting `feesIncurred` from `totalRevenue`.",
      "2": "`totalRevenue` is being adjusted by a division of `feesIncurred` by `periods`. Which compound assignment performs division and assignment?",
      "3": "The `auditCode` calculation needs an operator that performs multiplication."
    }
  },
  {
    "id": 178,
    "subtopic_id": 4,
    "type": "code_completion",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `FieldAgentLog` tracks `timeOnTarget` and `distanceCovered`. `timeOnTarget` is calculated with division and multiplication, and `distanceCovered` is adjusted using compound assignments. Complete the declarations and operators for these calculations.",
    "story_context": "The FieldAgentLog needs to track time on target and distance covered using various calculations. Your task is to complete the variable declarations and operators.",
    "challenge_data": {
      "initial_code": "public class FieldAgentLog {\n    public static void main(String[] args) {\n        int initialTime = 10;\n        int observationPeriods = 3;\n        float accuracyFactor = 0.5f;\n        \n        ??? timeOnTarget = ( (float)initialTime / observationPeriods) ??? accuracyFactor;\n        \n        int distanceCovered = 500;\n        \n        distanceCovered ???= 100;\n        distanceCovered ???= 2;\n        \n        System.out.println(\"Time On Target: \" + timeOnTarget);\n        System.out.println(\"Distance Covered: \" + distanceCovered);\n    }\n}",
      "expected_output": [
        "Time On Target: 1.6666666",
        "Distance Covered: 200"
      ],
      "solution_code": "public class FieldAgentLog {\n    public static void main(String[] args) {\n        int initialTime = 10;\n        int observationPeriods = 3;\n        float accuracyFactor = 0.5f;\n        \n        float timeOnTarget = ( (float)initialTime / observationPeriods) * accuracyFactor;\n        \n        int distanceCovered = 500;\n        \n        distanceCovered -= 100;\n        distanceCovered /= 2;\n        \n        System.out.println(\"Time On Target: \" + timeOnTarget);\n        System.out.println(\"Distance Covered: \" + distanceCovered);\n    }\n}",
      "choices": [
        "/=",
        "+=",
        "-=",
        "*=",
        "/",
        "double",
        "*",
        "float"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 7,
          "type": "variable_declaration",
          "description": "Floating-point type declaration for timeOnTarget",
          "correct_answer": "float",
          "explanation": "`float` is the correct type for `timeOnTarget` since it's derived from `(float)initialTime / observationPeriods` which promotes to `float`, and then multiplied by a `float`."
        },
        {
          "id": "slot_2",
          "line": 7,
          "type": "operator",
          "description": "Arithmetic operator for multiplication",
          "correct_answer": "*",
          "explanation": "`*` is the multiplication operator for `timeOnTarget` calculation."
        },
        {
          "id": "slot_3",
          "line": 11,
          "type": "compound_assignment",
          "description": "Compound subtraction assignment operator",
          "correct_answer": "-=",
          "explanation": "`-=` is the compound subtraction assignment operator for `distanceCovered`."
        },
        {
          "id": "slot_4",
          "line": 12,
          "type": "compound_assignment",
          "description": "Compound division assignment operator",
          "correct_answer": "/=",
          "explanation": "`/=` is the compound division assignment operator for `distanceCovered`."
        }
      ],
      "number_of_slots": 4
    },
    "hints": {
      "1": " `timeOnTarget` needs to be a floating-point type, and the result of the division is multiplied by `accuracyFactor`.",
      "2": "The first blank needs the type for `timeOnTarget`.",
      "3": " `distanceCovered` is first reduced by `100`, then divided by `2` using compound assignments."
    }
  },
  {
    "id": 179,
    "subtopic_id": 4,
    "type": "code_completion",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `SecurityProtocol` calculates `protocolCode` and `alertLevel` from base values, modifiers, and modulo operations, involving compound assignments. Complete the declaration and various arithmetic and compound assignment operators.",
    "story_context": "The SecurityProtocol needs to calculate protocol codes and alert levels using various operations. Your task is to complete the operators.",
    "challenge_data": {
      "initial_code": "public class SecurityProtocol {\n    public static void main(String[] args) {\n        int baseCode = 2100000000;\n        int modifier = 100000000;\n        int moduloValue = 7;\n        \n        ??? protocolCode = (int) ( (long)baseCode ??? modifier );\n        \n        int alertLevel = protocolCode % moduloValue;\n        \n        alertLevel ???= 10;\n        alertLevel = (alertLevel ??? 5) % 3;\n        \n        System.out.println(\"Protocol Code: \" + protocolCode);\n        System.out.println(\"Alert Level: \" + alertLevel);\n    }\n}",
      "expected_output": [
        "Protocol Code: 2200000000",
        "Alert Level: 1"
      ],
      "solution_code": "public class SecurityProtocol {\n    public static void main(String[] args) {\n        int baseCode = 2100000000;\n        int modifier = 100000000;\n        int moduloValue = 7;\n        \n        int protocolCode = (int) ( (long)baseCode + modifier );\n        \n        int alertLevel = protocolCode % moduloValue;\n        \n        alertLevel += 10;\n        alertLevel = (alertLevel - 5) % 3;\n        \n        System.out.println(\"Protocol Code: \" + protocolCode);\n        System.out.println(\"Alert Level: \" + alertLevel);\n    }\n}",
      "choices": [
        "-",
        "long",
        "+=",
        "/",
        "%",
        "*",
        "+",
        "protocol"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 7,
          "type": "operator",
          "description": "Arithmetic operator for addition",
          "correct_answer": "+",
          "explanation": "The blank for `protocolCode` calculation needs the addition operator `+` to sum `baseCode` and `modifier`."
        },
        {
          "id": "slot_2",
          "line": 11,
          "type": "compound_assignment",
          "description": "Compound addition assignment operator",
          "correct_answer": "+=",
          "explanation": "The blank for `alertLevel += 10;` needs the compound addition assignment operator `+=`."
        },
        {
          "id": "slot_3",
          "line": 12,
          "type": "operator",
          "description": "Arithmetic operator for subtraction",
          "correct_answer": "-",
          "explanation": "The blank in `(alertLevel ??? 5)` needs the subtraction operator `-` to subtract 5."
        },
        {
          "id": "slot_4",
          "line": 12,
          "type": "operator",
          "description": "Arithmetic operator for modulo",
          "correct_answer": "%",
          "explanation": "The final blank in `(alertLevel - 5) ??? 3` needs the modulo operator `%` to find the remainder."
        }
      ],
      "number_of_slots": 4
    },
    "hints": {
      "1": "The `protocolCode` calculation needs an operator to sum `baseCode` and `modifier`.",
      "2": "The `alertLevel` is first increased by `10` using a compound assignment.",
      "3": "Then, `alertLevel` is further adjusted by subtracting `5` and finding the remainder when divided by `3`."
    }
  },
  {
    "id": 180,
    "subtopic_id": 4,
    "type": "code_completion",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `ForensicReport` calculates `evidenceWeight`, `sampleCount`, and `reportID` using a mix of primitive types, operators, and compound assignments, involving potential overflow for `reportID`. Complete the declarations and various arithmetic and compound assignment operators.",
    "story_context": "The ForensicReport needs to calculate evidence weights and update various values using different operators. Your task is to complete the variable declarations and operators.",
    "challenge_data": {
      "initial_code": "public class ForensicReport {\n    public static void main(String[] args) {\n        double initialWeight = 50.0;\n        float density = 0.75f;\n        int analysisRuns = 10;\n        \n        ??? evidenceWeight = (float) (initialWeight ??? density);\n        \n        int sampleCount = 20;\n        sampleCount ???= analysisRuns;\n        \n        byte reportID = 120;\n        reportID ???= analysisRuns;\n        \n        reportID = (byte) (reportID ??? 2);\n        \n        System.out.println(\"Evidence Weight: \" + evidenceWeight);\n        System.out.println(\"Sample Count: \" + sampleCount);\n        System.out.println(\"Report ID: \" + reportID);\n    }\n}",
      "expected_output": [
        "Evidence Weight: 37.5",
        "Sample Count: 2",
        "Report ID: -126"
      ],
      "solution_code": "public class ForensicReport {\n    public static void main(String[] args) {\n        double initialWeight = 50.0;\n        float density = 0.75f;\n        int analysisRuns = 10;\n        \n        float evidenceWeight = (float) (initialWeight * density);\n        \n        int sampleCount = 20;\n        sampleCount /= analysisRuns;\n        \n        byte reportID = 120;\n        reportID += analysisRuns;\n        \n        reportID = (byte) (reportID % 2);\n        \n        System.out.println(\"Evidence Weight: \" + evidenceWeight);\n        System.out.println(\"Sample Count: \" + sampleCount);\n        System.out.println(\"Report ID: \" + reportID);\n    }\n}",
      "choices": [
        "/=",
        "-",
        "+=",
        "report",
        "*",
        "+",
        "%=",
        "float"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 7,
          "type": "variable_declaration",
          "description": "Floating-point type declaration for evidenceWeight",
          "correct_answer": "float",
          "explanation": "`float` is the correct type for `evidenceWeight` since it's cast from a double calculation."
        },
        {
          "id": "slot_2",
          "line": 7,
          "type": "operator",
          "description": "Arithmetic operator for multiplication",
          "correct_answer": "*",
          "explanation": "The blank for `evidenceWeight` needs the multiplication operator `*` to calculate `initialWeight * density`."
        },
        {
          "id": "slot_3",
          "line": 11,
          "type": "compound_assignment",
          "description": "Compound division assignment operator",
          "correct_answer": "/=",
          "explanation": "The blank for `sampleCount` needs the compound division assignment operator `/=` to divide `sampleCount` by `analysisRuns`."
        },
        {
          "id": "slot_4",
          "line": 14,
          "type": "compound_assignment",
          "description": "Compound addition assignment operator",
          "correct_answer": "+=",
          "explanation": "The first blank for `reportID` needs the compound addition assignment operator `+=` to add `analysisRuns` to `reportID`. This will cause an overflow."
        },
        {
          "id": "slot_5",
          "line": 16,
          "type": "operator",
          "description": "Arithmetic operator for modulo",
          "correct_answer": "%",
          "explanation": "The final blank for `reportID` needs the modulo operator `%` to find the remainder of `reportID` divided by `2`."
        }
      ],
      "number_of_slots": 5
    },
    "hints": {
      "1": "The `evidenceWeight` is calculated by multiplying `initialWeight` and `density`.",
      "2": "`sampleCount` is updated by dividing by `analysisRuns` using a compound assignment.",
      "3": "`reportID` is first increased by `analysisRuns` using a compound assignment, and then a modulo operation is performed on it."
    }
  },
  {
    "id": 181,
    "subtopic_id": 5,
    "type": "output_tracing",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `CaseFileOpener` initializes a `caseID`. Your task is to trace the code and determine the `New Case ID` that is printed.",
    "story_context": "The CaseFileOpener needs to initialize case IDs. Your task is to trace the variable initialization and predict the output.",
    "challenge_data": {
      "code": "public class CaseFileOpener {\n    public static void main(String[] args) {\n        int caseID = 101;\n        System.out.println(\"New Case ID: \" + caseID);\n    }\n}",
      "expected_output": [
        "New Case ID: 101"
      ],
      "choices": [
        "New Case ID: 0",
        "New Case ID: 101",
        "caseID",
        "Error"
      ],
      "explanation": "The line `int caseID = 101;` uses the simple assignment operator `=` to give the `caseID` variable an initial value of `101`. The `System.out.println()` then prints this value."
    },
    "hints": {
      "1": "The `=` operator assigns the value on the right to the variable on the left.",
      "2": "The `caseID` variable is directly initialized with a value.",
      "3": "The `println` statement displays the current value of the variable."
    }
  },
  {
    "id": 182,
    "subtopic_id": 5,
    "type": "output_tracing",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `LeadTracker` system updates `leadsCount` by adding a value using a compound assignment. Your task is to trace the code and determine the final `Current Leads` count.",
    "story_context": "The LeadTracker needs to update lead counts using compound assignments. Your task is to trace the compound assignment operation and predict the output.",
    "challenge_data": {
      "code": "public class LeadTracker {\n    public static void main(String[] args) {\n        int leadsCount = 5;\n        leadsCount += 3;\n        System.out.println(\"Current Leads: \" + leadsCount);\n    }\n}",
      "expected_output": [
        "Current Leads: 8"
      ],
      "choices": [
        "Current Leads: 5",
        "Current Leads: 3",
        "Current Leads: 8",
        "Error"
      ],
      "explanation": "The `leadsCount` variable starts at `5`. The line `leadsCount += 3;` is equivalent to `leadsCount = leadsCount + 3;`, which calculates `5 + 3 = 8`. This new value is assigned back to `leadsCount`. Finally, `System.out.println()` prints \"Current Leads: 8\"."
    },
    "hints": {
      "1": "The `+=` operator is a shorthand for adding a value to a variable and then assigning the result back to that variable.",
      "2": "Perform the addition: `leadsCount` + 3.",
      "3": "The `println` statement displays the final value."
    }
  },
  {
    "id": 183,
    "subtopic_id": 5,
    "type": "output_tracing",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `BudgetMonitor` tracks `investigationBudget`. Travel expenses are deducted using a compound assignment. Your task is to trace the code and determine the `Remaining Budget`.",
    "story_context": "The BudgetMonitor needs to track investigation budgets and deduct expenses. Your task is to trace the compound assignment operation and predict the output.",
    "challenge_data": {
      "code": "public class BudgetMonitor {\n    public static void main(String[] args) {\n        double investigationBudget = 500.0;\n        double travelExpense = 75.5;\n        investigationBudget -= travelExpense;\n        System.out.println(\"Remaining Budget: $\" + investigationBudget);\n    }\n}",
      "expected_output": [
        "Remaining Budget: $424.5"
      ],
      "choices": [
        "Remaining Budget: $500.0",
        "Remaining Budget: $75.5",
        "Remaining Budget: $424.5",
        "Error"
      ],
      "explanation": "The `investigationBudget` starts at `500.0`. The line `investigationBudget -= travelExpense;` is equivalent to `investigationBudget = investigationBudget - travelExpense;`, which calculates `500.0 - 75.5 = 424.5`. This new value is assigned back to `investigationBudget`. Finally, `System.out.println()` prints \"Remaining Budget: $424.5\"."
    },
    "hints": {
      "1": "The `-=` operator is a shorthand for subtracting a value from a variable and then assigning the result back to that variable.",
      "2": "Perform the subtraction: `investigationBudget` - `travelExpense`.",
      "3": "The `println` statement displays the final value."
    }
  },
  {
    "id": 184,
    "subtopic_id": 5,
    "type": "output_tracing",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `PopulationEstimator` scales `suspectPopulation` using a compound multiplication assignment. Your task is to trace the code and determine the `Estimated Suspect Population`.",
    "story_context": "The PopulationEstimator needs to scale suspect population. Your task is to trace the compound multiplication operation and predict the output.",
    "challenge_data": {
      "code": "public class PopulationEstimator {\n    public static void main(String[] args) {\n        int suspectPopulation = 10;\n        suspectPopulation *= 2;\n        System.out.println(\"Estimated Suspect Population: \" + suspectPopulation);\n    }\n}",
      "expected_output": [
        "Estimated Suspect Population: 20"
      ],
      "choices": [
        "Estimated Suspect Population: 10",
        "Estimated Suspect Population: 2",
        "Estimated Suspect Population: 20",
        "Error"
      ],
      "explanation": "The `suspectPopulation` variable starts at `10`. The line `suspectPopulation *= 2;` is equivalent to `suspectPopulation = suspectPopulation * 2;`, which calculates `10 * 2 = 20`. This new value is assigned back to `suspectPopulation`. Finally, `System.out.println()` prints \"Estimated Suspect Population: 20\"."
    },
    "hints": {
      "1": "The `*=` operator is a shorthand for multiplying a variable by a value and then assigning the result back.",
      "2": "Perform the multiplication: `suspectPopulation` * 2.",
      "3": "The `println` statement displays the final value."
    }
  },
  {
    "id": 185,
    "subtopic_id": 5,
    "type": "output_tracing",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `PhotoAllocator` distributes `evidencePhotos` among `analysts` using a compound division assignment. Your task is to trace the code and determine the `Photos Per Analyst`.",
    "story_context": "The PhotoAllocator needs to distribute evidence photos among analysts. Your task is to trace the compound division operation and predict the output.",
    "challenge_data": {
      "code": "public class PhotoAllocator {\n    public static void main(String[] args) {\n        int evidencePhotos = 15;\n        int analysts = 3;\n        evidencePhotos /= analysts;\n        System.out.println(\"Photos Per Analyst: \" + evidencePhotos);\n    }\n}",
      "expected_output": [
        "Photos Per Analyst: 5"
      ],
      "choices": [
        "Photos Per Analyst: 15",
        "Photos Per Analyst: 3",
        "Photos Per Analyst: 5",
        "Error"
      ],
      "explanation": "The `evidencePhotos` variable starts at `15`. The line `evidencePhotos /= analysts;` is equivalent to `evidencePhotos = evidencePhotos / analysts;`, which calculates `15 / 3 = 5`. This new value is assigned back to `evidencePhotos`. Finally, `System.out.println()` prints \"Photos Per Analyst: 5\"."
    },
    "hints": {
      "1": "The `/=` operator is a shorthand for dividing a variable by a value and then assigning the result back.",
      "2": "Perform the division: `evidencePhotos` / `analysts`.",
      "3": "The `println` statement displays the final value."
    }
  },
  {
    "id": 186,
    "subtopic_id": 5,
    "type": "output_tracing",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `BudgetAuditor` tracks `caseBudget` and `totalExpenses`. Funds are adjusted by `cost` and `reimbursement`, and expenses are tallied using compound assignments. Your task is to trace the code and determine the final `Budget` and `Total Expenses`.",
    "story_context": "The BudgetAuditor needs to track case budgets and total expenses. Your task is to trace the compound assignment operations and predict the outputs.",
    "challenge_data": {
      "code": "public class BudgetAuditor {\n    public static void main(String[] args) {\n        double caseBudget = 1000.0;\n        double cost = 150.0;\n        double reimbursement = 75.0;\n        double totalExpenses = 0.0;\n\n        caseBudget -= cost;\n        totalExpenses += cost;\n        caseBudget += reimbursement;\n        \n        System.out.println(\"Final Budget: $\" + caseBudget);\n        System.out.println(\"Total Expenses: $\" + totalExpenses);\n    }\n}",
      "expected_output": [
        "Final Budget: $925.0",
        "Total Expenses: $150.0"
      ],
      "choices": [
        "Final Budget: $850.0",
        "Final Budget: $925.5",
        "Total Expenses: $75.0",
        "Total Expenses: $150.0",
        "Final Budget: $925.0"
      ],
      "explanation": "1. `caseBudget` starts at `1000.0`, `totalExpenses` at `0.0`.\n2. `caseBudget -= cost;` updates `caseBudget` to `1000.0 - 150.0 = 850.0`.\n3. `totalExpenses += cost;` updates `totalExpenses` to `0.0 + 150.0 = 150.0`.\n4. `caseBudget += reimbursement;` updates `caseBudget` to `850.0 + 75.0 = 925.0`.\n5. The first `System.out.println()` prints \"Final Budget: $925.0\".\n6. The second `System.out.println()` prints \"Total Expenses: $150.0\"."
    },
    "hints": {
      "1": "Trace `caseBudget` and `totalExpenses` independently through each assignment line.",
      "2": " `x -= y` means `x = x - y`.",
      "3": " `x += y` means `x = x + y`."
    }
  },
  {
    "id": 187,
    "subtopic_id": 5,
    "type": "output_tracing",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `CrimeSeverityProfiler` calculates `crimeSeverityIndex` and `investigatorBonus` using compound assignments and arithmetic operations. Your task is to trace the code and determine the `Final Crime Severity Index` and `Investigator Bonus`.",
    "story_context": "The CrimeSeverityProfiler needs to calculate crime severity indices and investigator bonuses. Your task is to trace the compound assignments and arithmetic operations to predict the outputs.",
    "challenge_data": {
      "code": "public class CrimeSeverityProfiler {\n    public static void main(String[] args) {\n        int criminalHistory = 7;\n        double baseSeverity = 1.5;\n        double investigatorBonus = 100.0;\n\n        baseSeverity *= criminalHistory;\n        double crimeSeverityIndex = baseSeverity;\n\n        investigatorBonus /= (criminalHistory % 3 + 1);\n        \n        System.out.println(\"Final Crime Severity Index: \" + crimeSeverityIndex);\n        System.out.println(\"Investigator Bonus: $\" + investigatorBonus);\n    }\n}",
      "expected_output": [
        "Final Crime Severity Index: 10.5",
        "Investigator Bonus: $50.0"
      ],
      "choices": [
        "Final Crime Severity Index: 10",
        "Final Crime Severity Index: 10.55",
        "Investigator Bonus: $33.333333333333336",
        "Investigator Bonus: $50.0",
        "Final Crime Severity Index: 10.5"
      ],
      "explanation": "1. `criminalHistory` is `7`, `baseSeverity` is `1.5`, `investigatorBonus` is `100.0`.\n2. `baseSeverity *= criminalHistory;` updates `baseSeverity` to `1.5 * 7 = 10.5`.\n3. `double crimeSeverityIndex = baseSeverity;` assigns the current value of `baseSeverity` (`10.5`) to `crimeSeverityIndex`.\n4. `investigatorBonus /= (criminalHistory % 3 + 1);`\n    * `criminalHistory % 3`: `7 % 3 = 1`.\n    * `1 + 1 = 2`.\n    * `investigatorBonus /= 2`: `100.0 / 2 = 50.0`. So, `investigatorBonus` is `50.0`.\n5. The first `System.out.println()` prints \"Final Crime Severity Index: 10.5\".\n6. The second `System.out.println()` prints \"Investigator Bonus: $50.0\"."
    },
    "hints": {
      "1": " `x *= y` is a shorthand for `x = x * y`.",
      "2": " `x /= y` is a shorthand for `x = x / y`.",
      "3": "Remember operator precedence: parentheses first, then modulo, then addition, then division."
    }
  },
  {
    "id": 188,
    "subtopic_id": 5,
    "type": "output_tracing",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `MissionAllocator` manages `squadVehicles` and tracks `missionProgress`. Vehicles are deployed, and progress is incremented and adjusted based on remaining vehicles. Your task is to trace the code and determine the `Remaining Vehicles` and `Current Mission Progress`.",
    "story_context": "The MissionAllocator needs to manage squad vehicles and track mission progress. Your task is to trace the compound assignments and increment operations to predict the outputs.",
    "challenge_data": {
      "code": "public class MissionAllocator {\n    public static void main(String[] args) {\n        int squadVehicles = 10;\n        int vehiclesDeployed = 3;\n        int missionProgress = 0;\n\n        squadVehicles -= vehiclesDeployed;\n        missionProgress++;\n        missionProgress += (squadVehicles - 5);\n        \n        System.out.println(\"Remaining Vehicles: \" + squadVehicles);\n        System.out.println(\"Current Mission Progress: \" + missionProgress);\n    }\n}",
      "expected_output": [
        "Remaining Vehicles: 7",
        "Current Mission Progress: 3"
      ],
      "choices": [
        "Remaining Vehicles: 77",
        "Remaining Vehicles: 10",
        "Current Mission Progress: 1",
        "Current Mission Progress: 3",
        "Remaining Vehicles: 7"
      ],
      "explanation": "1. `squadVehicles` starts at `10`, `missionProgress` at `0`.\n2. `squadVehicles -= vehiclesDeployed;` updates `squadVehicles` to `10 - 3 = 7`.\n3. `missionProgress++;` increments `missionProgress` to `1`.\n4. `missionProgress += (squadVehicles - 5);`\n    * `squadVehicles - 5`: `7 - 5 = 2`.\n    * `missionProgress += 2`: `1 + 2 = 3`. So, `missionProgress` is `3`.\n5. The first `System.out.println()` prints \"Remaining Vehicles: 7\".\n6. The second `System.out.println()` prints \"Current Mission Progress: 3\"."
    },
    "hints": {
      "1": "Trace `squadVehicles` through its subtraction assignment.",
      "2": "Trace `missionProgress` through its increment (`++`) and then the compound addition (`+=`).",
      "3": "Evaluate the expression inside the parentheses for `missionProgress += ...` first."
    }
  },
  {
    "id": 189,
    "subtopic_id": 5,
    "type": "output_tracing",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "An `EvidenceLabeler` applies a `batchSize` multiplier and then a `divisor` modulo to a `baseID`. Your task is to trace the code and determine the final `ID` and `Remainder Status`.",
    "story_context": "The EvidenceLabeler needs to apply batch size multipliers and modulo operations to base IDs. Your task is to trace the compound assignments and predict the outputs.",
    "challenge_data": {
      "code": "public class EvidenceLabeler {\n    public static void main(String[] args) {\n        int baseID = 50;\n        int batchSize = 3;\n        int divisor = 7;\n        \n        baseID *= batchSize;\n        int finalID = baseID;\n        \n        baseID %= divisor;\n        int remainderStatus = baseID;\n        \n        System.out.println(\"Final ID: \" + finalID);\n        System.out.println(\"Remainder Status: \" + remainderStatus);\n    }\n}",
      "expected_output": [
        "Final ID: 150",
        "Remainder Status: 3"
      ],
      "choices": [
        "Final ID: 150",
        "Final ID: 50",
        "Remainder Status: 1",
        "Remainder Status: 3",
        "Final ID: 155"
      ],
      "explanation": "1. `baseID` starts at `50`.\n2. `baseID *= batchSize;` updates `baseID` to `50 * 3 = 150`.\n3. `int finalID = baseID;` assigns the current value of `baseID` (`150`) to `finalID`.\n4. `baseID %= divisor;` updates `baseID` to `150 % 7 = 3`.\n5. `int remainderStatus = baseID;` assigns the current value of `baseID` (`3`) to `remainderStatus`.\n6. The first `System.out.println()` prints \"Final ID: 150\".\n7. The second `System.out.println()` prints \"Remainder Status: 3\"."
    },
    "hints": {
      "1": " `x *= y` updates `x` by multiplying it with `y`.",
      "2": " `x %= y` updates `x` by assigning the remainder of `x / y`.",
      "3": "Note that `finalID` takes its value *before* `baseID` undergoes the modulo operation."
    }
  },
  {
    "id": 190,
    "subtopic_id": 5,
    "type": "output_tracing",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `SecretBudgetAdjuster` manages `secretOperationBudget` by applying a `multiplier` and deducting a `fixedExpense`. Your task is to trace the code and determine the `Adjusted Budget` (before final expense) and the `Final Budget`.",
    "story_context": "The SecretBudgetAdjuster needs to manage secret operation budgets with multipliers and expenses. Your task is to trace the compound assignments and predict the outputs.",
    "challenge_data": {
      "code": "public class SecretBudgetAdjuster {\n    public static void main(String[] args) {\n        double secretOperationBudget = 5000.0;\n        double multiplier = 0.5;\n        double fixedExpense = 100.0;\n\n        secretOperationBudget *= multiplier;\n        double adjustedBudget = secretOperationBudget;\n\n        secretOperationBudget -= fixedExpense;\n        double finalBudget = secretOperationBudget;\n        \n        System.out.println(\"Adjusted Budget (Before Final Expense): $\" + adjustedBudget);\n        System.out.println(\"Final Budget: $\" + finalBudget);\n    }\n}",
      "expected_output": [
        "Adjusted Budget (Before Final Expense): $2500.0",
        "Final Budget: $2400.0"
      ],
      "choices": [
        "Adjusted Budget (Before Final Expense): $2500.0",
        "Adjusted Budget (Before Final Expense): $5000.0",
        "Final Budget: $2400.0",
        "Final Budget: $2600.0",
        "Adjusted Budget (Before Final Expense): $2505.0"
      ],
      "explanation": "1. `secretOperationBudget` starts at `5000.0`.\n2. `secretOperationBudget *= multiplier;` updates `secretOperationBudget` to `5000.0 * 0.5 = 2500.0`.\n3. `double adjustedBudget = secretOperationBudget;` assigns `2500.0` to `adjustedBudget`.\n4. `secretOperationBudget -= fixedExpense;` updates `secretOperationBudget` to `2500.0 - 100.0 = 2400.0`.\n5. `double finalBudget = secretOperationBudget;` assigns `2400.0` to `finalBudget`.\n6. The first `System.out.println()` prints \"Adjusted Budget (Before Final Expense): $2500.0\".\n7. The second `System.out.println()` prints \"Final Budget: $2400.0\"."
    },
    "hints": {
      "1": " `secretOperationBudget` is updated multiple times; trace its value precisely.",
      "2": " `adjustedBudget` captures `secretOperationBudget`'s value *after* the multiplication but *before* the subtraction.",
      "3": " `finalBudget` captures `secretOperationBudget`'s value *after all* operations."
    }
  },
  {
    "id": 191,
    "subtopic_id": 5,
    "type": "output_tracing",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `SuspectProfiler` adjusts `initialRating` and `offenseScore` using pre/post-increment/decrement and compound assignments, then determines a `riskIndicator`. Your task is to trace the code and determine the `Final Rating`, `Offense Threshold`, and `Risk Indicator`.",
    "story_context": "The SuspectProfiler needs to adjust ratings and scores using increment/decrement operations. Your task is to trace the compound assignments and conditional logic to predict the outputs.",
    "challenge_data": {
      "code": "public class SuspectProfiler {\n    public static void main(String[] args) {\n        int initialRating = 100;\n        int offenseScore = 20;\n        byte profileIterations = 3;\n        boolean riskIndicator = false;\n\n        initialRating /= profileIterations++;\n        \n        int finalRating = initialRating;\n        \n        offenseScore %= --profileIterations;\n        \n        int offenseThreshold = offenseScore;\n        \n        finalRating -= offenseScore * 2;\n        \n        if (finalRating % 2 != 0) {\n            riskIndicator = true;\n        }\n        \n        System.out.println(\"Final Rating: \" + finalRating);\n        System.out.println(\"Offense Threshold: \" + offenseThreshold);\n        System.out.println(\"Risk Indicator: \" + riskIndicator);\n    }\n}",
      "expected_output": [
        "Final Rating: 29",
        "Offense Threshold: 2",
        "Risk Indicator: true"
      ],
      "choices": [
        "Final Rating: 29",
        "Offense Threshold: 2",
        "Risk Indicator: true",
        "Final Rating: 33",
        "Final Rating: 30"
      ],
      "explanation": "1. `initialRating = 100`, `offenseScore = 20`, `profileIterations = 3`.\n2. `initialRating /= profileIterations++;`\n    * `initialRating /= 3` (`100 / 3` integer division) = `33`. `initialRating` is `33`.\n    * `profileIterations++` increments `profileIterations` to `4` (after use).\n3. `int finalRating = initialRating;` `finalRating` is `33`.\n4. `offenseScore %= --profileIterations;`\n    * `--profileIterations` decrements `profileIterations` to `3` (before use).\n    * `offenseScore %= 3`: `20 % 3 = 2`. `offenseScore` is `2`.\n5. `int offenseThreshold = offenseScore;` `offenseThreshold` is `2`.\n6. `finalRating -= offenseScore * 2;`\n    * `offenseScore * 2`: `2 * 2 = 4`.\n    * `finalRating -= 4`: `33 - 4 = 29`. `finalRating` is `29`.\n7. `if (finalRating % 2 != 0)`: `29 % 2 = 1`. `1 != 0` is `true`.\n    * `riskIndicator = true;` `riskIndicator` is `true`.\n8. All three `System.out.println()` statements display the final values."
    },
    "hints": {
      "1": "Distinguish between pre-increment/decrement (`++x`, `--x`) and post-increment/decrement (`x++`, `x--`). Pre-operations change the value *before* use, post-operations *after*.",
      "2": "Trace `profileIterations` carefully as it affects multiple calculations.",
      "3": "Compound assignments and modulo operations should be done sequentially."
    }
  },
  {
    "id": 192,
    "subtopic_id": 5,
    "type": "output_tracing",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `ForensicAccountant` audits `suspiciousAccount` funds, calculating `auditFlag` and `balanceStatus`. The calculations involve compound assignments, modulo operations, and conditional logic. Your task is to trace the code and determine the `Final Balance`, `Audit Alert`, and `Balance Status`.",
    "story_context": "The ForensicAccountant needs to audit suspicious account funds and calculate audit flags. Your task is to trace the compound assignments and conditional logic to predict the outputs.",
    "challenge_data": {
      "code": "public class ForensicAccountant {\n    public static void main(String[] args) {\n        double suspiciousAccount = 1000.75;\n        double transactionFee = 25.50;\n        int auditFlag = 0;\n        boolean balanceStatus = false;\n\n        suspiciousAccount -= transactionFee;\n        suspiciousAccount /= 2.0;\n\n        auditFlag += (int) (suspiciousAccount % 100);\n        \n        String auditAlert = (auditFlag > 50) ? \"HIGH\" : \"LOW\";\n        \n        if (suspiciousAccount < 500.0 && auditAlert.equals(\"HIGH\")) {\n            balanceStatus = true;\n        }\n        \n        System.out.println(\"Final Balance: \" + suspiciousAccount);\n        System.out.println(\"Audit Alert: \" + auditAlert);\n        System.out.println(\"Balance Status: \" + balanceStatus);\n    }\n}",
      "expected_output": [
        "Final Balance: 487.625",
        "Audit Alert: HIGH",
        "Balance Status: true"
      ],
      "choices": [
        "Final Balance: 487.625",
        "Audit Alert: HIGH",
        "Balance Status: true",
        "Final Balance: 975.25",
        "Balance Status: false",
        "Audit Alert: LOW"
      ],
      "explanation": "1. `suspiciousAccount = 1000.75`, `transactionFee = 25.50`, `auditFlag = 0`.\n2. `suspiciousAccount -= transactionFee;` updates `suspiciousAccount` to `1000.75 - 25.50 = 975.25`.\n3. `suspiciousAccount /= 2.0;` updates `suspiciousAccount` to `975.25 / 2.0 = 487.625`. \n4. `auditFlag += (int) (suspiciousAccount % 100);`\n    * `suspiciousAccount % 100`: `487.625 % 100` (double converted to int for modulo, truncating to 487) = `487 % 100 = 87`.\n    * `auditFlag += 87`: `0 + 87 = 87`. `auditFlag` is `87`.\n5. `String auditAlert = (auditFlag > 50) ? \"HIGH\" : \"LOW\";` `87 > 50` is `true`. `auditAlert` is \"HIGH\". \n6. `if (suspiciousAccount < 500.0 && auditAlert.equals(\"HIGH\"))`\n    * `487.625 < 500.0` is `true`.\n    * `auditAlert.equals(\"HIGH\")` is `\"HIGH\".equals(\"HIGH\")`, which is `true`.\n    * `true && true` is `true`.\n    * `balanceStatus = true;` `balanceStatus` is `true`. \n7. All three `System.out.println()` statements display the final values."
    },
    "hints": {
      "1": "Trace `suspiciousAccount` through its compound subtraction and division, retaining decimal precision.",
      "2": "`auditFlag` uses a compound addition with a modulo result, requiring `(int)` cast.",
      "3": "The ternary operator determines `auditAlert`."
    }
  },
  {
    "id": 193,
    "subtopic_id": 5,
    "type": "output_tracing",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `CrossReferenceSystem` calculates `reportCode`, `finalReportID`, `confidenceRating`, and `statusMessage` using various compound assignments, pre/post-increments, and conditional logic. Your task is to trace the code and determine the `Final Report ID`, `Confidence Rating`, and `Status Message`.",
    "story_context": "The CrossReferenceSystem needs to calculate report codes and confidence ratings. Your task is to trace the compound assignments and conditional logic to predict the outputs.",
    "challenge_data": {
      "code": "public class CrossReferenceSystem {\n    public static void main(String[] args) {\n        int reportCode = 200;\n        float evidenceLevel = 0.5f;\n        int baseConfidence = 10;\n        String statusMessage = \"PENDING\";\n\n        reportCode /= --baseConfidence;\n        \n        float finalReportID = reportCode;\n        \n        int confidenceRating = (int) (finalReportID * (baseConfidence++));\n        \n        confidenceRating %= 50;\n        \n        if (confidenceRating > 45) {\n            statusMessage += \" VERIFIED\";\n        } else {\n            statusMessage += \" UNVERIFIED\";\n        }\n\n        System.out.println(\"Final Report ID: \" + finalReportID);\n        System.out.println(\"Confidence Rating: \" + confidenceRating);\n        System.out.println(\"Status Message: \" + statusMessage);\n    }\n}",
      "expected_output": [
        "Final Report ID: 22.0",
        "Confidence Rating: 48",
        "Status Message: PENDING VERIFIED"
      ],
      "choices": [
        "Final Report ID: 22.0",
        "Confidence Rating: 198",
        "Confidence Rating: 48",
        "Status Message: PENDING VERIFIED",
        "Final Report ID: 22.0",
        "Status Message: PENDING UNVERIFIED"
      ],
      "explanation": "1. `reportCode = 200`, `baseConfidence = 10`, `statusMessage = \"PENDING\"`.\n2. `reportCode /= --baseConfidence;`\n    * `--baseConfidence` decrements `baseConfidence` to `9` (before use).\n    * `reportCode /= 9`: `200 / 9` (integer division) = `22`. `reportCode` is `22`.\n3. `float finalReportID = reportCode;` `finalReportID` is `22.0f`. \n4. `int confidenceRating = (int) (finalReportID * (baseConfidence++));`\n    * `baseConfidence++`: `9` (used then incremented to `10`).\n    * `finalReportID * 9`: `22.0f * 9` = `198.0f`.\n    * `(int)198.0f`: `198`. `confidenceRating` is `198`.\n5. `confidenceRating %= 50;` `198 % 50` = `48`. `confidenceRating` is `48`. \n6. `if (confidenceRating > 45)`: `48 > 45` is `true`.\n    * `statusMessage += \" VERIFIED\";` appends, so `statusMessage` is \"PENDING VERIFIED\". \n7. All three `System.out.println()` statements display the final values."
    },
    "hints": {
      "1": "Trace `reportCode` through division by a pre-decremented value.",
      "2": "Follow `confidenceRating` through multiplication by a post-incremented value, and then a modulo operation.",
      "3": "The `if` condition determines the final appended string to `statusMessage`."
    }
  },
  {
    "id": 194,
    "subtopic_id": 5,
    "type": "output_tracing",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `VeteranDetectiveEvaluator` calculates `finalRiskFactor` and `complexScoreAudit`, then sets a `caseStatusIndicator` based on potential `byte` and `int` overflows. Your task is to trace the code and determine the `Final Risk Factor`, `Complex Score Audit`, and `Case Status Indicator`.",
    "story_context": "The VeteranDetectiveEvaluator needs to calculate risk factors and complex scores. Your task is to trace the overflow operations and conditional logic to predict the outputs.",
    "challenge_data": {
      "code": "public class VeteranDetectiveEvaluator {\n    public static void main(String[] args) {\n        byte suspectRiskFactor = 120;\n        int baseComplexity = 2000000000;\n        float adjustmentValue = 0.5f;\n        boolean caseStatusIndicator = false;\n\n        suspectRiskFactor += 10;\n        \n        int finalRiskFactor = suspectRiskFactor;\n        \n        baseComplexity += (int) (baseComplexity * adjustmentValue);\n        \n        double complexScoreAudit = baseComplexity;\n        \n        if (finalRiskFactor < 0 && complexScoreAudit < 0) {\n            caseStatusIndicator = true;\n        }\n        \n        System.out.println(\"Final Risk Factor: \" + finalRiskFactor);\n        System.out.println(\"Complex Score Audit: \" + complexScoreAudit);\n        System.out.println(\"Case Status Indicator: \" + caseStatusIndicator);\n    }\n}",
      "expected_output": [
        "Final Risk Factor: -126",
        "Complex Score Audit: -1294967296.0",
        "Case Status Indicator: true"
      ],
      "choices": [
        "Final Risk Factor: 130",
        "Final Risk Factor: -126",
        "Case Status Indicator: false",
        "Complex Score Audit: -1294967296.0",
        "Case Status Indicator: true",
        "Complex Score Audit: -1294967296.1"
      ],
      "explanation": "1. `suspectRiskFactor = 120`, `baseComplexity = 2000000000`.\n2. `suspectRiskFactor += 10;` calculates `120 + 10 = 130`. This causes **byte overflow** (130 > 127), so `suspectRiskFactor` becomes `-126`.\n3. `int finalRiskFactor = suspectRiskFactor;` `finalRiskFactor` is `-126`.\n4. `baseComplexity += (int) (baseComplexity * adjustmentValue);`\n    * `baseComplexity * adjustmentValue`: `2000000000 * 0.5f` (int promotes to float, then to double due to assignment to double result which is cast back to int) = `1000000000.0d`.\n    * `baseComplexity += 1000000000`: `2000000000 + 1000000000 = 3000000000`. This causes **int overflow**, so `baseComplexity` becomes `-1294967296`.\n5. `double complexScoreAudit = baseComplexity;` `complexScoreAudit` is `-1294967296.0`.\n6. `if (finalRiskFactor < 0 && complexScoreAudit < 0)`: `-126 < 0` is `true`, AND `-1294967296.0 < 0` is `true`. Condition is `true`.\n    * `caseStatusIndicator = true;` `caseStatusIndicator` is `true`.\n7. All three `System.out.println()` statements display the final values."
    },
    "hints": {
      "1": "Pay close attention to `suspectRiskFactor += 10` and its potential `byte` overflow.",
      "2": "The `baseComplexity += ...` involves `int` multiplication by `float`, which can lead to `int` overflow when `int`s are added and then assigned back.",
      "3": "Evaluate the `if` condition with both negative results to determine `caseStatusIndicator`."
    }
  },
  {
    "id": 195,
    "subtopic_id": 5,
    "type": "output_tracing",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `ForensicAccountant` audits `suspiciousAccount` funds, calculating `auditFlag` and `balanceStatus`. The calculations involve compound assignments, modulo operations, and conditional logic. Your task is to trace the code and determine the `Final Balance`, `Audit Alert`, and `Balance Status`.",
    "story_context": "The ForensicAccountant needs to audit suspicious account funds and calculate audit flags. Your task is to trace the compound assignments and conditional logic to predict the outputs.",
    "challenge_data": {
      "code": "public class ForensicAccountant {\n    public static void main(String[] args) {\n        double suspiciousAccount = 1000.75;\n        double transactionFee = 25.50;\n        int auditFlag = 0;\n        boolean balanceStatus = false;\n\n        suspiciousAccount -= transactionFee;\n        suspiciousAccount /= 2.0;\n\n        auditFlag += (int) (suspiciousAccount % 100);\n        \n        String auditAlert = (auditFlag > 50) ? \"HIGH\" : \"LOW\";\n        \n        if (suspiciousAccount < 500.0 && auditAlert.equals(\"HIGH\")) {\n            balanceStatus = true;\n        }\n        \n        System.out.println(\"Final Balance: \" + suspiciousAccount);\n        System.out.println(\"Audit Alert: \" + auditAlert);\n        System.out.println(\"Balance Status: \" + balanceStatus);\n    }\n}",
      "expected_output": [
        "Final Balance: 487.625",
        "Audit Alert: HIGH",
        "Balance Status: true"
      ],
      "choices": [
        "Final Balance: 487.625",
        "Audit Alert: HIGH",
        "Balance Status: true",
        "Final Balance: 975.25",
        "Audit Alert: LOW",
        "Balance Status: false"
      ],
      "explanation": "1. `suspiciousAccount = 1000.75`, `transactionFee = 25.50`, `auditFlag = 0`.\n2. `suspiciousAccount -= transactionFee;` updates `suspiciousAccount` to `1000.75 - 25.50 = 975.25`.\n3. `suspiciousAccount /= 2.0;` updates `suspiciousAccount` to `975.25 / 2.0 = 487.625`. \n4. `auditFlag += (int) (suspiciousAccount % 100);`\n    * `suspiciousAccount % 100`: `487.625 % 100` (double converted to int for modulo, truncating to 487) = `487 % 100 = 87`.\n    * `auditFlag += 87`: `0 + 87 = 87`. `auditFlag` is `87`.\n5. `String auditAlert = (auditFlag > 50) ? \"HIGH\" : \"LOW\";` `87 > 50` is `true`. `auditAlert` is \"HIGH\". \n6. `if (suspiciousAccount < 500.0 && auditAlert.equals(\"HIGH\"))`\n    * `487.625 < 500.0` is `true`.\n    * `auditAlert.equals(\"HIGH\")` is `\"HIGH\".equals(\"HIGH\")`, which is `true`.\n    * `true && true` is `true`.\n    * `balanceStatus = true;` `balanceStatus` is `true`. \n7. All three `System.out.println()` statements display the final values."
    },
    "hints": {
      "1": "Trace `suspiciousAccount` through its compound subtraction and division, retaining decimal precision.",
      "2": "`auditFlag` uses a compound addition with a modulo result, requiring `(int)` cast.",
      "3": "The ternary operator determines `auditAlert`."
    }
  },
  {
    "id": 196,
    "subtopic_id": 5,
    "type": "code_fixer",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `StakeoutLogger` tracks `totalStakeoutHours` by combining `shift1Hours` and `shift2Hours`. However, the code incorrectly uses subtraction instead of addition. Fix the code to calculate the correct total hours.",
    "story_context": "The StakeoutLogger needs to calculate total stakeout hours. Your task is to fix the arithmetic operation.",
    "challenge_data": {
      "initial_code": "public class StakeoutLogger {\n    public static void main(String[] args) {\n        int shift1Hours = 8;\n        int shift2Hours = 4;\n        int totalStakeoutHours = shift1Hours - shift2Hours;\n        System.out.println(\"Total Stakeout Hours: \" + totalStakeoutHours);\n    }\n}",
      "expected_output": [
        "Total Stakeout Hours: 12"
      ],
      "solution_code": "public class StakeoutLogger {\n    public static void main(String[] args) {\n        int shift1Hours = 8;\n        int shift2Hours = 4;\n        int totalStakeoutHours = shift1Hours + shift2Hours;\n        System.out.println(\"Total Stakeout Hours: \" + totalStakeoutHours);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 5,
          "type": "arithmetic_operator",
          "description": "Using subtraction instead of addition for total calculation",
          "fix": "Change - to +: shift1Hours + shift2Hours"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code used the subtraction operator (`-`) instead of the addition operator (`+`). To find the total hours, the two values need to be added together. Replacing `-` with `+` correctly calculates `8 + 4 = 12`."
    },
    "hints": {
      "1": "The goal is to find the *total* hours.",
      "2": "Which arithmetic operator performs addition?",
      "3": "Look for the operation symbol between `shift1Hours` and `shift2Hours`."
    }
  },
  {
    "id": 197,
    "subtopic_id": 5,
    "type": "code_fixer",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `SuspectTracker` determines `activeSuspects` by reducing `initialSuspects` by `clearedSuspects`. However, the code incorrectly uses multiplication instead of subtraction. Fix the code to calculate the correct number of active suspects.",
    "story_context": "The SuspectTracker needs to calculate active suspects. Your task is to fix the arithmetic operation.",
    "challenge_data": {
      "initial_code": "public class SuspectTracker {\n    public static void main(String[] args) {\n        int initialSuspects = 10;\n        int clearedSuspects = 3;\n        int activeSuspects = initialSuspects * clearedSuspects;\n        System.out.println(\"Active Suspects: \" + activeSuspects);\n    }\n}",
      "expected_output": [
        "Active Suspects: 7"
      ],
      "solution_code": "public class SuspectTracker {\n    public static void main(String[] args) {\n        int initialSuspects = 10;\n        int clearedSuspects = 3;\n        int activeSuspects = initialSuspects - clearedSuspects;\n        System.out.println(\"Active Suspects: \" + activeSuspects);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 5,
          "type": "arithmetic_operator",
          "description": "Using multiplication instead of subtraction for remaining calculation",
          "fix": "Change * to -: initialSuspects - clearedSuspects"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code used the multiplication operator (`*`) instead of the subtraction operator (`-`). To find the remaining suspects, the `clearedSuspects` need to be subtracted from `initialSuspects`. Replacing `*` with `-` correctly calculates `10 - 3 = 7`."
    },
    "hints": {
      "1": "The goal is to find the number of suspects *remaining* after some are cleared.",
      "2": "Which arithmetic operator reduces a quantity?",
      "3": "Look at the symbol between `initialSuspects` and `clearedSuspects`."
    }
  },
  {
    "id": 198,
    "subtopic_id": 5,
    "type": "code_fixer",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "An `EvidenceDistributor` calculates `itemsPerContainer` by dividing `evidenceItems` among `containers`. However, the code performs integer division, losing decimal precision. Fix the code to obtain a floating-point result for `itemsPerContainer`.",
    "story_context": "The EvidenceDistributor needs to calculate items per container. Your task is to fix the division precision.",
    "challenge_data": {
      "initial_code": "public class EvidenceDistributor {\n    public static void main(String[] args) {\n        int evidenceItems = 15;\n        int containers = 4;\n        double itemsPerContainer = evidenceItems / containers;\n        System.out.println(\"Items Per Container: \" + itemsPerContainer);\n    }\n}",
      "expected_output": [
        "Items Per Container: 3.75"
      ],
      "solution_code": "public class EvidenceDistributor {\n    public static void main(String[] args) {\n        int evidenceItems = 15;\n        int containers = 4;\n        double itemsPerContainer = (double) evidenceItems / containers;\n        System.out.println(\"Items Per Container: \" + itemsPerContainer);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 5,
          "type": "integer_division",
          "description": "Integer division loses decimal precision",
          "fix": "Cast to double: (double) evidenceItems / containers"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code performs integer division (`15 / 4 = 3`) because both `evidenceItems` and `containers` are `int`s. This causes the decimal part (`.75`) to be lost. To achieve floating-point division and retain precision, at least one of the operands must be cast to a floating-point type (`double` or `float`). Casting `evidenceItems` to `double` (`(double)evidenceItems`) before division forces the entire operation to be floating-point. The result `3.75` can then be correctly stored in a `double` variable."
    },
    "hints": {
      "1": "Division between two integers will always result in an integer (any decimal part is truncated).",
      "2": "To get a floating-point result from division, at least one of the operands must be a floating-point type (`double` or `float`).",
      "3": "Consider explicitly converting one of the numbers to a decimal type before division."
    }
  },
  {
    "id": 199,
    "subtopic_id": 5,
    "type": "code_fixer",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `FingerprintAnalyzer` calculates `fingerprintRemainder` from `totalPrints` and `labCapacity`. However, the code incorrectly uses multiplication instead of the modulo operator. Fix the code to calculate the correct remainder.",
    "story_context": "The FingerprintAnalyzer needs to calculate fingerprint remainder. Your task is to fix the arithmetic operator.",
    "challenge_data": {
      "initial_code": "public class FingerprintAnalyzer {\n    public static void main(String[] args) {\n        int totalPrints = 22;\n        int labCapacity = 5;\n        int fingerprintRemainder = totalPrints * labCapacity;\n        System.out.println(\"Fingerprint Remainder: \" + fingerprintRemainder);\n    }\n}",
      "expected_output": [
        "Fingerprint Remainder: 2"
      ],
      "solution_code": "public class FingerprintAnalyzer {\n    public static void main(String[] args) {\n        int totalPrints = 22;\n        int labCapacity = 5;\n        int fingerprintRemainder = totalPrints % labCapacity;\n        System.out.println(\"Fingerprint Remainder: \" + fingerprintRemainder);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 5,
          "type": "arithmetic_operator",
          "description": "Using multiplication instead of modulo for remainder calculation",
          "fix": "Change * to %: totalPrints % labCapacity"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code used the multiplication operator (`*`) instead of the modulo operator (`%`). The modulo operator (`%`) is used to find the remainder of a division (`22 / 5` is `4` with a remainder of `2`). Replacing `*` with `%` correctly calculates `22 % 5 = 2`."
    },
    "hints": {
      "1": "The goal is to find what's left over after one number is divided by another, not their product.",
      "2": "Which arithmetic operator gives you the remainder?",
      "3": "Look for the operation symbol between `totalPrints` and `labCapacity`."
    }
  },
  {
    "id": 200,
    "subtopic_id": 5,
    "type": "code_fixer",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `CodeAnalyzer` attempts to calculate a remainder from `serialCode` using the modulo operator, but the result is discarded, and `serialCode` remains unchanged. Fix the code to correctly update `serialCode` with the remainder.",
    "story_context": "The CodeAnalyzer needs to update serial code. Your task is to fix the compound assignment.",
    "challenge_data": {
      "initial_code": "public class CodeAnalyzer {\n    public static void main(String[] args) {\n        int serialCode = 37;\n        serialCode % 10;\n        System.out.println(\"Pattern Check: \" + serialCode);\n    }\n}",
      "expected_output": [
        "Pattern Check: 7"
      ],
      "solution_code": "public class CodeAnalyzer {\n    public static void main(String[] args) {\n        int serialCode = 37;\n        serialCode %= 10;\n        System.out.println(\"Pattern Check: \" + serialCode);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 4,
          "type": "compound_assignment",
          "description": "Modulo result is calculated but not assigned",
          "fix": "Use compound assignment: serialCode %= 10;"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code `serialCode % 10;` calculates `37 % 10 = 7` but discards this result. `serialCode` remains `37`. To find the remainder of `serialCode` divided by `10` and reassign the updated value back to it, the compound modulo assignment operator `%=` is required (`serialCode %= 10;` is equivalent to `serialCode = serialCode % 10;`)."
    },
    "hints": {
      "1": "The expression `serialCode % 10` computes a value, but that value needs to be stored.",
      "2": "To find the remainder of a division and update a variable simultaneously, a compound assignment operator is needed.",
      "3": "Look for the shorthand operator that combines modulo and assignment."
    }
  },
  {
    "id": 201,
    "subtopic_id": 5,
    "type": "code_fixer",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `BudgetReducer` updates `surveillanceBudget` by subtracting `dailyRate` multiplied by `daysWatched`. The code causes a compilation error due to implicit casting from `double` to `int` in the compound assignment. Fix the code to correctly update the budget.",
    "story_context": "The BudgetReducer needs to update surveillance budget. Your task is to fix the type casting issue.",
    "challenge_data": {
      "initial_code": "public class BudgetReducer {\n    public static void main(String[] args) {\n        int surveillanceBudget = 1000;\n        double dailyRate = 50.5;\n        int daysWatched = 3;\n        surveillanceBudget -= dailyRate * daysWatched;\n        System.out.println(\"Remaining Budget: $\" + surveillanceBudget);\n    }\n}",
      "expected_output": [
        "Remaining Budget: $848"
      ],
      "solution_code": "public class BudgetReducer {\n    public static void main(String[] args) {\n        int surveillanceBudget = 1000;\n        double dailyRate = 50.5;\n        int daysWatched = 3;\n        surveillanceBudget = (int)(surveillanceBudget - (dailyRate * daysWatched));\n        System.out.println(\"Remaining Budget: $\" + surveillanceBudget);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 6,
          "type": "type_casting",
          "description": "Implicit casting from double to int causes compilation error",
          "fix": "Explicitly cast result: surveillanceBudget = (int)(surveillanceBudget - (dailyRate * daysWatched));"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code attempts to subtract `dailyRate * daysWatched` (which is `50.5 * 3 = 151.5`, a `double`) from `surveillanceBudget` (an `int`) using the compound assignment `-=`. Java's rules for compound assignments perform the operation and then an implicit cast to the variable's type. However, for a `double` to `int` conversion, this implicit cast is not allowed without potential data loss, causing a compilation error. The fix explicitly performs the subtraction and then casts the *entire result* to an `int` (`(int)(surveillanceBudget - (dailyRate * daysWatched))`), effectively truncating `151.5` to `151` (when it's subtracted, this gives `1000-151.5 = 848.5`) and so `848` when cast back to int. The calculation is `1000 - (50.5 * 3) = 1000 - 151.5 = 848.5`. Casting `848.5` to `int` truncates it to `848`."
    },
    "hints": {
      "1": "Compound assignment operators (like `-=`) implicitly perform an operation and then an assignment.",
      "2": "If the result of the arithmetic operation is of a wider type (e.g., `double`) than the variable (e.g., `int`), it's a \"possible lossy conversion.\"",
      "3": "You need to explicitly tell Java to convert the result to the narrower type, accepting any precision loss."
    }
  },
  {
    "id": 202,
    "subtopic_id": 5,
    "type": "code_fixer",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "An `Interrogator` tracks `interrogationRounds`. The code attempts to use a post-increment (`++`) in an assignment that causes `interrogationRounds` to not update as expected. Fix the code to ensure `interrogationRounds` correctly increments.",
    "story_context": "The Interrogator needs to track interrogation rounds. Your task is to fix the increment operator.",
    "challenge_data": {
      "initial_code": "public class Interrogator {\n    public static void main(String[] args) {\n        int interrogationRounds = 5;\n        interrogationRounds = interrogationRounds++;\n        System.out.println(\"Current Rounds: \" + interrogationRounds);\n    }\n}",
      "expected_output": [
        "Current Rounds: 6"
      ],
      "solution_code": "public class Interrogator {\n    public static void main(String[] args) {\n        int interrogationRounds = 5;\n        interrogationRounds = ++interrogationRounds;\n        System.out.println(\"Current Rounds: \" + interrogationRounds);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 4,
          "type": "increment_operator",
          "description": "Post-increment in assignment overwrites the increment",
          "fix": "Use pre-increment: interrogationRounds = ++interrogationRounds;"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code `interrogationRounds = interrogationRounds++;` creates a subtle logical flaw. The `interrogationRounds++` (post-increment) operation first uses the *current value* of `interrogationRounds` (`5`) for the right-hand side of the assignment. So, `interrogationRounds` is assigned `5`. *Then*, `interrogationRounds` is incremented to `6`. Effectively, the assignment overwrites the increment. The fix is to use `++interrogationRounds` (pre-increment), which increments `interrogationRounds` *before* its value is used in the assignment, ensuring the updated `6` is assigned. Alternatively, `interrogationRounds += 1;` or simply `interrogationRounds++;` (without reassigning from itself) are clearer and more common solutions."
    },
    "hints": {
      "1": "The `x++` (post-increment) operator means \"use `x`'s current value *then* increment `x`.\"",
      "2": "In an assignment like `x = x++`, `x`'s original value is used for the right-hand side of the assignment *before* `x` itself is incremented.",
      "3": "To ensure the variable is incremented *and* its new value is assigned, consider pre-increment (`++x`) or the compound assignment `+= 1`."
    }
  },
  {
    "id": 203,
    "subtopic_id": 5,
    "type": "code_fixer",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `MissionBudgeter` calculates `missionFunds`. The compound assignment operator has an incorrect space, causing a syntax error. Fix the code to correctly multiply and assign `missionFunds`.",
    "story_context": "The MissionBudgeter needs to calculate mission funds. Your task is to fix the compound assignment operator syntax.",
    "challenge_data": {
      "initial_code": "public class MissionBudgeter {\n    public static void main(String[] args) {\n        double missionFunds = 500.0;\n        double resourceFactor = 1.5;\n        missionFunds * = resourceFactor;\n        System.out.println(\"Allocated Funds: $\" + missionFunds);\n    }\n}",
      "expected_output": [
        "Allocated Funds: $750.0"
      ],
      "solution_code": "public class MissionBudgeter {\n    public static void main(String[] args) {\n        double missionFunds = 500.0;\n        double resourceFactor = 1.5;\n        missionFunds *= resourceFactor;\n        System.out.println(\"Allocated Funds: $\" + missionFunds);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 5,
          "type": "compound_assignment_syntax",
          "description": "Space between * and = in compound assignment operator",
          "fix": "Remove space: missionFunds *= resourceFactor;"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code `missionFunds * = resourceFactor;` has an incorrect space between the `*` and `=` symbols. Compound assignment operators like `*=`, `+=`, `-=`, `/=`, `%=` must be written as a single token without any space. Removing the space (`missionFunds *= resourceFactor;`) correctly forms the compound multiplication assignment operator, allowing the code to compile and perform the intended calculation (`500.0 * 1.5 = 750.0`)."
    },
    "hints": {
      "1": "The `*` and `=` symbols, when used together for multiplication and assignment, should not have a space between them.",
      "2": "This form is a single compound assignment operator.",
      "3": "Look for the shorthand operator that combines multiplication and assignment."
    }
  },
  {
    "id": 204,
    "subtopic_id": 5,
    "type": "code_fixer",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "An `EvidenceWeightUpdater` updates `evidenceWeight` by adding `newSampleWeight`. The code causes a compilation error because adding a `double` to an `int` and implicitly casting back to `int` is not allowed. Fix the code to correctly update `evidenceWeight`.",
    "story_context": "The EvidenceWeightUpdater needs to update evidence weight. Your task is to fix the type casting issue.",
    "challenge_data": {
      "initial_code": "public class EvidenceWeightUpdater {\n    public static void main(String[] args) {\n        int evidenceWeight = 100;\n        double newSampleWeight = 5.75;\n        evidenceWeight += newSampleWeight;\n        System.out.println(\"Updated Weight: \" + evidenceWeight);\n    }\n}",
      "expected_output": [
        "Updated Weight: 105"
      ],
      "solution_code": "public class EvidenceWeightUpdater {\n    public static void main(String[] args) {\n        int evidenceWeight = 100;\n        double newSampleWeight = 5.75;\n        evidenceWeight = (int)(evidenceWeight + newSampleWeight);\n        System.out.println(\"Updated Weight: \" + evidenceWeight);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 5,
          "type": "type_casting",
          "description": "Implicit casting from double to int causes compilation error",
          "fix": "Explicitly cast result: evidenceWeight = (int)(evidenceWeight + newSampleWeight);"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The compound assignment `evidenceWeight += newSampleWeight;` is equivalent to `evidenceWeight = evidenceWeight + newSampleWeight;`. In the expression `evidenceWeight + newSampleWeight` (`100 + 5.75`), `evidenceWeight` (int) is promoted to `double`, resulting in `105.75` (double). Attempting to assign this `double` back to `evidenceWeight` (int) implicitly results in a \"possible lossy conversion\" error. The fix requires explicitly casting the `double` result back to `int`: `evidenceWeight = (int) (evidenceWeight + newSampleWeight);`, which truncates `105.75` to `105`."
    },
    "hints": {
      "1": "Compound assignment operators like `+=` implicitly perform an operation and then a cast back to the variable's type.",
      "2": "An implicit cast from a `double` to an `int` (which discards decimals) is not allowed by Java without explicit instruction.",
      "3": "You need to manually perform the addition and then explicitly cast the result to an `int`."
    }
  },
  {
    "id": 205,
    "subtopic_id": 5,
    "type": "code_fixer",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `ReportFinalizer` sets `reportStatus` based on `finalApproval`. The code attempts to assign a boolean value (`finalApproval`) directly to a `String` variable, causing a type mismatch. Fix the code to correctly update `reportStatus`.",
    "story_context": "The ReportFinalizer needs to set report status. Your task is to fix the type mismatch.",
    "challenge_data": {
      "initial_code": "public class ReportFinalizer {\n    public static void main(String[] args) {\n        boolean finalApproval = true;\n        String reportStatus = \"Draft\";\n        \n        if (finalApproval == true) {\n            reportStatus = finalApproval;\n        }\n        \n        System.out.println(\"Report Status: \" + reportStatus);\n    }\n}",
      "expected_output": [
        "Report Status: Finalized"
      ],
      "solution_code": "public class ReportFinalizer {\n    public static void main(String[] args) {\n        boolean finalApproval = true;\n        String reportStatus = \"Draft\";\n        \n        if (finalApproval == true) {\n            reportStatus = \"Finalized\";\n        }\n        \n        System.out.println(\"Report Status: \" + reportStatus);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 7,
          "type": "type_mismatch",
          "description": "Assigning boolean to String variable",
          "fix": "Assign String literal: reportStatus = \"Finalized\";"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code attempts to assign the boolean variable `finalApproval` (which is `true`) directly to the `String` variable `reportStatus`. This results in a type mismatch compilation error because a `boolean` cannot be assigned directly to a `String`. The fix is to assign the `String` literal `\"Finalized\"` (enclosed in double quotes) to `reportStatus` when the condition is met."
    },
    "hints": {
      "1": "The `reportStatus` variable is a `String`.",
      "2": "You are trying to assign a boolean value (`finalApproval`) directly to a `String` variable inside the `if` block.",
      "3": "Remember that `true` or `false` are boolean literals, not `String` literals. `String` literals are enclosed in double quotes."
    }
  },
  {
    "id": 206,
    "subtopic_id": 5,
    "type": "code_fixer",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "An `EvidenceAggregator` calculates `fragmentCount` by adding `collectionRate` and multiplying by `labFactor`. However, operator precedence in the compound assignment leads to an incorrect sum. Fix the code to ensure `fragmentCount` is correctly calculated.",
    "story_context": "The EvidenceAggregator needs to calculate fragment count. Your task is to fix the operator precedence.",
    "challenge_data": {
      "initial_code": "public class EvidenceAggregator {\n    public static void main(String[] args) {\n        int fragmentCount = 10;\n        int collectionRate = 2;\n        int labFactor = 5;\n        fragmentCount += collectionRate * labFactor;\n        System.out.println(\"Total Fragments: \" + fragmentCount);\n    }\n}",
      "expected_output": [
        "Total Fragments: 60"
      ],
      "solution_code": "public class EvidenceAggregator {\n    public static void main(String[] args) {\n        int fragmentCount = 10;\n        int collectionRate = 2;\n        int labFactor = 5;\n        fragmentCount = (fragmentCount + collectionRate) * labFactor;\n        System.out.println(\"Total Fragments: \" + fragmentCount);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 6,
          "type": "operator_precedence",
          "description": "Compound assignment evaluates multiplication before addition",
          "fix": "Use explicit assignment with parentheses: fragmentCount = (fragmentCount + collectionRate) * labFactor;"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code `fragmentCount += collectionRate * labFactor;` is equivalent to `fragmentCount = fragmentCount + (collectionRate * labFactor);`. This evaluates `collectionRate * labFactor` first (`2 * 5 = 10`), then adds it to `fragmentCount` (`10 + 10 = 20`). The intended calculation was `(fragmentCount + collectionRate) * labFactor`. To achieve this, the addition `(fragmentCount + collectionRate)` must be grouped with parentheses, and the multiplication must be applied to that sum. This requires breaking down the compound assignment into a full assignment `fragmentCount = (fragmentCount + collectionRate) * labFactor;`, which yields `(10 + 2) * 5 = 12 * 5 = 60`."
    },
    "hints": {
      "1": "Remember that `X += A * B` is equivalent to `X = X + (A * B)`. Multiplication (`*`) inside the expression on the right-hand side has higher precedence.",
      "2": "If you want an addition (e.g., `fragmentCount + collectionRate`) to occur *before* multiplication by `labFactor`, you need to explicitly group those operations.",
      "3": "Compound assignment operators are shorthands, but sometimes you need to break them down into full assignments with explicit parentheses to control precedence."
    }
  },
  {
    "id": 207,
    "subtopic_id": 5,
    "type": "code_fixer",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "An `AssetAuditor` updates `currentAssets` by adding `newInvestments`. The code causes a compilation error because implicitly casting the `double` result of the addition back to an `int` is not allowed. Fix the code to correctly update `currentAssets`.",
    "story_context": "The AssetAuditor needs to update current assets. Your task is to fix the type casting issue.",
    "challenge_data": {
      "initial_code": "public class AssetAuditor {\n    public static void main(String[] args) {\n        int currentAssets = 1000;\n        double newInvestments = 150.75;\n        currentAssets += newInvestments;\n        System.out.println(\"Total Assets: $\" + currentAssets);\n    }\n}",
      "expected_output": [
        "Total Assets: $1150"
      ],
      "solution_code": "public class AssetAuditor {\n    public static void main(String[] args) {\n        int currentAssets = 1000;\n        double newInvestments = 150.75;\n        currentAssets = (int)(currentAssets + newInvestments);\n        System.out.println(\"Total Assets: $\" + currentAssets);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 5,
          "type": "type_casting",
          "description": "Implicit casting from double to int causes compilation error",
          "fix": "Explicitly cast result: currentAssets = (int)(currentAssets + newInvestments);"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code `currentAssets += newInvestments;` is equivalent to `currentAssets = currentAssets + newInvestments;`. In the expression `currentAssets + newInvestments` (`1000 + 150.75`), `currentAssets` (int) is promoted to `double`, resulting in `1150.75` (double). Attempting to assign this `double` back to `currentAssets` (int) implicitly results in a \"possible lossy conversion\" compilation error. The fix requires explicitly casting the `double` result back to `int`: `currentAssets = (int) (currentAssets + newInvestments);`, which truncates `1150.75` to `1150`."
    },
    "hints": {
      "1": "Compound assignment operators like `+=` implicitly perform an operation and then a cast back to the variable's type.",
      "2": "Java does not allow an implicit (automatic) conversion from `double` to `int` if it means losing decimal places.",
      "3": "To proceed, you must explicitly tell Java to truncate the decimal by casting the entire arithmetic result to an `int`."
    }
  },
  {
    "id": 208,
    "subtopic_id": 5,
    "type": "code_fixer",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "An `InterrogationRounds` counter is updated using a post-increment (`roundCount++`) within an assignment that causes the variable to not reflect the increment immediately for the comparison. Fix the code to ensure `roundCount` is incremented *before* the comparison.",
    "story_context": "The InterrogationRounds needs to check round count. Your task is to fix the increment operator.",
    "challenge_data": {
      "initial_code": "public class InterrogationRounds {\n    public static void main(String[] args) {\n        int roundCount = 5;\n        if (roundCount++ < 6) {\n            System.out.println(\"Round still in progress: \" + roundCount);\n        } else {\n            System.out.println(\"Round completed: \" + roundCount);\n        }\n    }\n}",
      "expected_output": [
        "Round completed: 6"
      ],
      "solution_code": "public class InterrogationRounds {\n    public static void main(String[] args) {\n        int roundCount = 5;\n        if (++roundCount < 6) {\n            System.out.println(\"Round still in progress: \" + roundCount);\n        } else {\n            System.out.println(\"Round completed: \" + roundCount);\n        }\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 4,
          "type": "increment_operator",
          "description": "Post-increment used instead of pre-increment",
          "fix": "Use pre-increment: if (++roundCount < 6)"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code `if (roundCount++ < 6)` uses the post-increment operator. This means `roundCount`'s original value (`5`) is used in the comparison (`5 < 6`) first, which is `true`. *Then*, `roundCount` increments to `6`. So, it prints \"Round still in progress: 6\". The intended behavior is for the increment to happen *before* the comparison. The fix is to use the pre-increment operator `++roundCount`. This increments `roundCount` to `6` first, then uses `6` in the comparison (`6 < 6`), which is `false`. This leads to the `else` block being executed, printing \"Round completed: 6\"."
    },
    "hints": {
      "1": "The `x++` (post-increment) operator means \"use `x`'s current value *then* increment `x`.\"",
      "2": "In an assignment like `x = x++`, `x`'s original value is used for the right-hand side of the assignment *before* `x` itself is incremented.",
      "3": "To ensure the variable is incremented *and* its new value is assigned, consider pre-increment (`++x`) or the compound assignment `+= 1`."
    }
  },
  {
    "id": 209,
    "subtopic_id": 5,
    "type": "code_fixer",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "An `InvestigationBudget` updates `totalBudget` using a compound multiplication assignment followed by division. However, operator precedence leads to an incorrect calculation. Fix the code to ensure `totalBudget` is correctly multiplied by `factor` and then divided by `days`.",
    "story_context": "The InvestigationBudget needs to calculate final budget. Your task is to fix the operator precedence.",
    "challenge_data": {
      "initial_code": "public class InvestigationBudget {\n    public static void main(String[] args) {\n        double totalBudget = 1000.0;\n        double factor = 1.2;\n        int days = 5;\n        double bonus = 50.0;\n        \n        totalBudget *= factor / days;\n        totalBudget += bonus;\n        System.out.println(\"Final Budget: $\" + totalBudget);\n    }\n}",
      "expected_output": [
        "Final Budget: $290.0"
      ],
      "solution_code": "public class InvestigationBudget {\n    public static void main(String[] args) {\n        double totalBudget = 1000.0;\n        double factor = 1.2;\n        int days = 5;\n        double bonus = 50.0;\n        \n        totalBudget = totalBudget * factor;\n        totalBudget /= days;\n        totalBudget += bonus;\n        System.out.println(\"Final Budget: $\" + totalBudget);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 8,
          "type": "operator_precedence",
          "description": "Compound assignment evaluates division before multiplication",
          "fix": "Break into separate operations: totalBudget = totalBudget * factor; totalBudget /= days;"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code `totalBudget *= factor / days;` is equivalent to `totalBudget = totalBudget * (factor / days);`. This first calculates `factor / days` (`1.2 / 5 = 0.24`), then multiplies `totalBudget` by this result (`1000.0 * 0.24 = 240.0`). The intended order was to multiply `totalBudget` by `factor` *before* dividing by `days`. The fix requires breaking down the compound assignment into separate operations (`totalBudget = totalBudget * factor;` and then `totalBudget /= days;`), which correctly performs the calculation `(1000.0 * 1.2) / 5 + 50.0 = 1200.0 / 5 + 50.0 = 240.0 + 50.0 = 290.0`."
    },
    "hints": {
      "1": "Remember that `X op= Y / Z` is equivalent to `X = X op (Y / Z)`. The division `Y / Z` is evaluated *before* the `op` with `X`.",
      "2": "If you intend for multiplication to happen before division, you might need to break down compound assignments or use explicit parentheses in the full expression.",
      "3": "The intended calculation is `(totalBudget * factor) / days + bonus`."
    }
  },
  {
    "id": 210,
    "subtopic_id": 5,
    "type": "code_fixer",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "An `AuditCodeUpdater` calculates `finalAuditCode` from `transactionCount` and `auditFactor`. The compound assignment has an operator precedence issue, causing subtraction `transactionCount - auditFactor` to occur before multiplication. Fix the code to ensure multiplication happens first.",
    "story_context": "The AuditCodeUpdater needs to calculate final audit code. Your task is to fix the operator precedence.",
    "challenge_data": {
      "initial_code": "public class AuditCodeUpdater {\n    public static void main(String[] args) {\n        int finalAuditCode = 100;\n        int transactionCount = 20;\n        int auditFactor = 5;\n        \n        finalAuditCode *= transactionCount - auditFactor;\n        \n        System.out.println(\"Final Audit Code: \" + finalAuditCode);\n    }\n}",
      "expected_output": [
        "Final Audit Code: 1995"
      ],
      "solution_code": "public class AuditCodeUpdater {\n    public static void main(String[] args) {\n        int finalAuditCode = 100;\n        int transactionCount = 20;\n        int auditFactor = 5;\n        \n        finalAuditCode = (finalAuditCode * transactionCount) - auditFactor;\n        \n        System.out.println(\"Final Audit Code: \" + finalAuditCode);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 7,
          "type": "operator_precedence",
          "description": "Compound assignment evaluates subtraction before multiplication",
          "fix": "Use explicit assignment with parentheses: finalAuditCode = (finalAuditCode * transactionCount) - auditFactor;"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code `finalAuditCode *= transactionCount - auditFactor;` is equivalent to `finalAuditCode = finalAuditCode * (transactionCount - auditFactor);`. This means `transactionCount - auditFactor` (`20 - 5 = 15`) is evaluated first. Then, `finalAuditCode` is multiplied by `15` (`100 * 15 = 1500`). The intended calculation was `(finalAuditCode * transactionCount) - auditFactor`. The fix involves breaking down the compound assignment into a full assignment: `finalAuditCode = (finalAuditCode * transactionCount) - auditFactor;`, which correctly performs `(100 * 20) - 5 = 2000 - 5 = 1995`."
    },
    "hints": {
      "1": "Compound assignment operators (e.g., `*=`) evaluate the entire expression on their right-hand side first, then apply the compound operation.",
      "2": " `X *= A - B` is equivalent to `X = X * (A - B)`. The subtraction `A - B` happens before the multiplication.",
      "3": "If you want multiplication to happen before subtraction, you need to explicitly group operations."
    }
  },
  {
    "id": 211,
    "subtopic_id": 5,
    "type": "code_completion",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `ReportInitializer` sets the initial `reportStatus`. Complete the simple assignment operator to correctly initialize `reportStatus` to \"Pending\".",
    "story_context": "The ReportInitializer needs to set the initial status of a report. Your task is to complete the assignment operator.",
    "challenge_data": {
      "initial_code": "public class ReportInitializer {\n    public static void main(String[] args) {\n        String reportStatus ??? \"Pending\";\n        System.out.println(\"Report Status: \" + reportStatus);\n    }\n}",
      "expected_output": [
        "Report Status: Pending"
      ],
      "solution_code": "public class ReportInitializer {\n    public static void main(String[] args) {\n        String reportStatus = \"Pending\";\n        System.out.println(\"Report Status: \" + reportStatus);\n    }\n}",
      "choices": [
        "-",
        "+=",
        "=",
        "=="
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 3,
          "type": "operator",
          "description": "Simple assignment operator",
          "correct_answer": "=",
          "explanation": "The simple assignment operator `=` is used to initialize or assign a value to a variable. In this case, it correctly sets `reportStatus` to \"Pending\"."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": "The goal is to give a variable its very first value.",
      "2": "Which operator is used for simple assignment?",
      "3": "The blank needs a single operation symbol."
    }
  },
  {
    "id": 212,
    "subtopic_id": 5,
    "type": "code_completion",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `ClueLogger` updates `cluesFound` by adding `5` to its current value. Complete the compound assignment operator to correctly add and assign the new total to `cluesFound`.",
    "story_context": "The ClueLogger needs to update the count of clues found using compound assignment. Your task is to complete the compound assignment operator.",
    "challenge_data": {
      "initial_code": "public class ClueLogger {\n    public static void main(String[] args) {\n        int cluesFound = 10;\n        cluesFound ??? 5;\n        System.out.println(\"Total Clues: \" + cluesFound);\n    }\n}",
      "expected_output": [
        "Total Clues: 15"
      ],
      "solution_code": "public class ClueLogger {\n    public static void main(String[] args) {\n        int cluesFound = 10;\n        cluesFound += 5;\n        System.out.println(\"Total Clues: \" + cluesFound);\n    }\n}",
      "choices": [
        "+",
        "-",
        "*=",
        "+="
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 4,
          "type": "compound_assignment",
          "description": "Compound addition assignment operator",
          "correct_answer": "+=",
          "explanation": "The `+=` operator is a compound assignment operator that adds the value on the right to the variable on the left and assigns the result back. So, `cluesFound += 5;` correctly updates `cluesFound` from `10` to `15`."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": "The goal is to add a value to `cluesFound` and immediately update `cluesFound` itself.",
      "2": "Which compound assignment operator combines addition and assignment?",
      "3": "The blank needs a single operation symbol."
    }
  },
  {
    "id": 213,
    "subtopic_id": 5,
    "type": "code_completion",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `BudgetReducer` adjusts `investigationBudget` by deducting `travelCost`. Complete the compound assignment operator to correctly subtract and assign the remaining budget.",
    "story_context": "The BudgetReducer needs to adjust the investigation budget by deducting travel costs. Your task is to complete the compound assignment operator.",
    "challenge_data": {
      "initial_code": "public class BudgetReducer {\n    public static void main(String[] args) {\n        double investigationBudget = 1000.0;\n        double travelCost = 75.0;\n        investigationBudget ??? travelCost;\n        System.out.println(\"Remaining Budget: $\" + investigationBudget);\n    }\n}",
      "expected_output": [
        "Remaining Budget: $925.0"
      ],
      "solution_code": "public class BudgetReducer {\n    public static void main(String[] args) {\n        double investigationBudget = 1000.0;\n        double travelCost = 75.0;\n        investigationBudget -= travelCost;\n        System.out.println(\"Remaining Budget: $\" + investigationBudget);\n    }\n}",
      "choices": [
        "+",
        "/=",
        "-=",
        "-"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 5,
          "type": "compound_assignment",
          "description": "Compound subtraction assignment operator",
          "correct_answer": "-=",
          "explanation": "The `-=` operator is a compound assignment operator that subtracts the value on the right from the variable on the left and assigns the result back. So, `investigationBudget -= travelCost;` correctly updates `investigationBudget` from `1000.0` to `925.0`."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": "The goal is to subtract a value from `investigationBudget` and immediately update `investigationBudget` itself.",
      "2": "Which compound assignment operator combines subtraction and assignment?",
      "3": "The blank needs a single operation symbol."
    }
  },
  {
    "id": 214,
    "subtopic_id": 5,
    "type": "code_completion",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `ThreatScaler` adjusts `threatLevel` by multiplying it by a `factor`. Complete the compound assignment operator to correctly scale the `threatLevel`.",
    "story_context": "The ThreatScaler needs to adjust threat levels by scaling them with a factor. Your task is to complete the compound assignment operator.",
    "challenge_data": {
      "initial_code": "public class ThreatScaler {\n    public static void main(String[] args) {\n        int threatLevel = 10;\n        int factor = 2;\n        threatLevel ??? factor;\n        System.out.println(\"Scaled Threat: \" + threatLevel);\n    }\n}",
      "expected_output": [
        "Scaled Threat: 20"
      ],
      "solution_code": "public class ThreatScaler {\n    public static void main(String[] args) {\n        int threatLevel = 10;\n        int factor = 2;\n        threatLevel *= factor;\n        System.out.println(\"Scaled Threat: \" + threatLevel);\n    }\n}",
      "choices": [
        "+",
        "-",
        "*=",
        "*"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 5,
          "type": "compound_assignment",
          "description": "Compound multiplication assignment operator",
          "correct_answer": "*=",
          "explanation": "The `*=` operator is a compound assignment operator that multiplies the variable on the left by the value on the right and assigns the result back. So, `threatLevel *= factor;` correctly updates `threatLevel` from `10` to `20`."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": "The goal is to multiply `threatLevel` by `factor` and immediately update `threatLevel` itself.",
      "2": "Which compound assignment operator combines multiplication and assignment?",
      "3": "The blank needs a single operation symbol."
    }
  },
  {
    "id": 215,
    "subtopic_id": 5,
    "type": "code_completion",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `PhotoAllocator` distributes `totalPhotos` among `numAnalysts`. Complete the compound assignment operator to correctly divide and assign the photos per analyst.",
    "story_context": "The PhotoAllocator needs to distribute photos among analysts using compound assignment. Your task is to complete the compound assignment operator.",
    "challenge_data": {
      "initial_code": "public class PhotoAllocator {\n    public static void main(String[] args) {\n        int totalPhotos = 18;\n        int numAnalysts = 3;\n        totalPhotos ??? numAnalysts;\n        System.out.println(\"Photos per Analyst: \" + totalPhotos);\n    }\n}",
      "expected_output": [
        "Photos per Analyst: 6"
      ],
      "solution_code": "public class PhotoAllocator {\n    public static void main(String[] args) {\n        int totalPhotos = 18;\n        int numAnalysts = 3;\n        totalPhotos /= numAnalysts;\n        System.out.println(\"Photos per Analyst: \" + totalPhotos);\n    }\n}",
      "choices": [
        "+",
        "/=",
        "/",
        "-"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 5,
          "type": "compound_assignment",
          "description": "Compound division assignment operator",
          "correct_answer": "/=",
          "explanation": "The `/=` operator is a compound assignment operator that divides the variable on the left by the value on the right and assigns the result back. So, `totalPhotos /= numAnalysts;` correctly updates `totalPhotos` from `18` to `6`."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": "The goal is to divide `totalPhotos` by `numAnalysts` and immediately update `totalPhotos` itself.",
      "2": "Which compound assignment operator combines division and assignment?",
      "3": "The blank needs a single operation symbol."
    }
  },
  {
    "id": 216,
    "subtopic_id": 5,
    "type": "code_completion",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `BudgetAdjuster` manages `investigationBudget` by adding a `grantFund` and subtracting a `travelCost`. Complete the compound assignment operators to reflect these changes efficiently.",
    "story_context": "The BudgetAdjuster needs to manage investigation budget by adding grants and subtracting costs. Your task is to complete the compound assignment operators.",
    "challenge_data": {
      "initial_code": "public class BudgetAdjuster {\n    public static void main(String[] args) {\n        double investigationBudget = 1000.0;\n        double grantFund = 250.0;\n        double travelCost = 120.0;\n\n        investigationBudget ??? grantFund;\n        investigationBudget ??? travelCost;\n        System.out.println(\"Adjusted Budget: $\" + investigationBudget);\n    }\n}",
      "expected_output": [
        "Adjusted Budget: $1130.0"
      ],
      "solution_code": "public class BudgetAdjuster {\n    public static void main(String[] args) {\n        double investigationBudget = 1000.0;\n        double grantFund = 250.0;\n        double travelCost = 120.0;\n\n        investigationBudget += grantFund;\n        investigationBudget -= travelCost;\n        System.out.println(\"Adjusted Budget: $\" + investigationBudget);\n    }\n}",
      "choices": [
        "/=",
        "-",
        "+=",
        "-=",
        "*",
        "+"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 8,
          "type": "compound_assignment",
          "description": "Compound addition assignment operator",
          "correct_answer": "+=",
          "explanation": "To add `grantFund` to `investigationBudget` and reassign, the `+=` operator is used."
        },
        {
          "id": "slot_2",
          "line": 9,
          "type": "compound_assignment",
          "description": "Compound subtraction assignment operator",
          "correct_answer": "-=",
          "explanation": "To subtract `travelCost` from `investigationBudget` and reassign, the `-=` operator is used."
        }
      ],
      "number_of_slots": 2
    },
    "hints": {
      "1": "The `grantFund` is `added` to the budget, requiring a compound addition operator.",
      "2": "The `travelCost` is `subtracted` from the budget, requiring a compound subtraction operator.",
      "3": "Each blank needs a compound assignment operator."
    }
  },
  {
    "id": 217,
    "subtopic_id": 5,
    "type": "code_completion",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "An `EvidenceScaler` adjusts `evidenceMultiplier` by first multiplying by a `factor` and then dividing by a `divisor`. Complete the compound assignment operators for these sequential updates.",
    "story_context": "The EvidenceScaler needs to adjust evidence multipliers using sequential operations. Your task is to complete the compound assignment operators.",
    "challenge_data": {
      "initial_code": "public class EvidenceScaler {\n    public static void main(String[] args) {\n        double evidenceMultiplier = 2.0;\n        double factor = 1.5;\n        int divisor = 3;\n\n        evidenceMultiplier ??? factor;\n        evidenceMultiplier ??? divisor;\n        System.out.println(\"Scaled Multiplier: \" + evidenceMultiplier);\n    }\n}",
      "expected_output": [
        "Scaled Multiplier: 1.0"
      ],
      "solution_code": "public class EvidenceScaler {\n    public static void main(String[] args) {\n        double evidenceMultiplier = 2.0;\n        double factor = 1.5;\n        int divisor = 3;\n\n        evidenceMultiplier *= factor;\n        evidenceMultiplier /= divisor;\n        System.out.println(\"Scaled Multiplier: \" + evidenceMultiplier);\n    }\n}",
      "choices": [
        "/=",
        "*=",
        "/",
        "*",
        "+",
        "%="
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 8,
          "type": "compound_assignment",
          "description": "Compound multiplication assignment operator",
          "correct_answer": "*=",
          "explanation": "To multiply `evidenceMultiplier` by `factor` and reassign, the `*=` operator is used."
        },
        {
          "id": "slot_2",
          "line": 9,
          "type": "compound_assignment",
          "description": "Compound division assignment operator",
          "correct_answer": "/=",
          "explanation": "To divide `evidenceMultiplier` by `divisor` and reassign, the `/=` operator is used."
        }
      ],
      "number_of_slots": 2
    },
    "hints": {
      "1": "The `evidenceMultiplier` is first `increased by a factor` (multiplication).",
      "2": "Then, it's `divided by a divisor`.",
      "3": "Each blank needs a compound assignment operator."
    }
  },
  {
    "id": 218,
    "subtopic_id": 5,
    "type": "code_completion",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `SampleProcessor` processes `totalSamples` in batches. The remaining samples after a batch are determined using the modulo operator and updated in `totalSamples`. Complete the compound assignment operator.",
    "story_context": "The SampleProcessor needs to process samples in batches and track remaining samples. Your task is to complete the compound assignment operator.",
    "challenge_data": {
      "initial_code": "public class SampleProcessor {\n    public static void main(String[] args) {\n        int totalSamples = 37;\n        int batchSize = 10;\n\n        totalSamples ??? batchSize;\n        System.out.println(\"Remaining Samples: \" + totalSamples);\n    }\n}",
      "expected_output": [
        "Remaining Samples: 7"
      ],
      "solution_code": "public class SampleProcessor {\n    public static void main(String[] args) {\n        int totalSamples = 37;\n        int batchSize = 10;\n\n        totalSamples %= batchSize;\n        System.out.println(\"Remaining Samples: \" + totalSamples);\n    }\n}",
      "choices": [
        "-",
        "/",
        "*",
        "%",
        "+",
        "%="
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 6,
          "type": "compound_assignment",
          "description": "Compound modulo assignment operator",
          "correct_answer": "%=",
          "explanation": "To find the remainder of `totalSamples` divided by `batchSize` and reassign the result, the `%=` operator is used. `37 % 10` calculates `7`, and `totalSamples` becomes `7`."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": "The goal is to find the `remainder` of a division and update `totalSamples`.",
      "2": "Which compound assignment operator combines modulo and assignment?",
      "3": "The blank needs a single compound assignment operator."
    }
  },
  {
    "id": 219,
    "subtopic_id": 5,
    "type": "code_completion",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `DailyReportLogger` tracks `dailyReports` filed. The `dailyReports` count is incremented by 1. Complete the compound assignment operator to efficiently update `dailyReports`.",
    "story_context": "The DailyReportLogger needs to track daily reports by incrementing the count. Your task is to complete the compound assignment operator.",
    "challenge_data": {
      "initial_code": "public class DailyReportLogger {\n    public static void main(String[] args) {\n        int dailyReports = 5;\n        dailyReports ??? 1;\n        System.out.println(\"Daily Reports Filed: \" + dailyReports);\n    }\n}",
      "expected_output": [
        "Daily Reports Filed: 6"
      ],
      "solution_code": "public class DailyReportLogger {\n    public static void main(String[] args) {\n        int dailyReports = 5;\n        dailyReports += 1;\n        System.out.println(\"Daily Reports Filed: \" + dailyReports);\n    }\n}",
      "choices": [
        "-",
        "+=",
        "++",
        "*",
        "+",
        "--"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 4,
          "type": "compound_assignment",
          "description": "Compound addition assignment operator",
          "correct_answer": "+=",
          "explanation": "The `+=` operator is a compound assignment operator that adds the value on the right to the variable on the left and assigns the result back. It's the most concise way to add 1 and reassign within the category of compound assignment operators."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": "The goal is to increase the variable by `1` and update it.",
      "2": "The blank requires a `compound assignment` operator, which combines an arithmetic operation with assignment.",
      "3": "Consider the operator that adds a value to a variable and assigns the new sum back."
    }
  },
  {
    "id": 220,
    "subtopic_id": 5,
    "type": "code_completion",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "An `AuditSystem` sets `reportStatus` based on `auditComplete`. Complete the declaration of `auditStatus` and its initial value, and the simple assignment operator to update it based on `auditComplete`.",
    "story_context": "The AuditSystem needs to track audit status with proper variable declaration and assignment. Your task is to complete the variable declaration and assignment operator.",
    "challenge_data": {
      "initial_code": "public class AuditSystem {\n    public static void main(String[] args) {\n        boolean auditComplete = true;\n        ??? = ???;\n        \n        if (auditComplete) {\n            auditStatus ??? \"Approved\";\n        }\n        System.out.println(\"Audit Status: \" + auditStatus);\n    }\n}",
      "expected_output": [
        "Audit Status: Approved"
      ],
      "solution_code": "public class AuditSystem {\n    public static void main(String[] args) {\n        boolean auditComplete = true;\n        String auditStatus = \"Pending\";\n        \n        if (auditComplete) {\n            auditStatus = \"Approved\";\n        }\n        System.out.println(\"Audit Status: \" + auditStatus);\n    }\n}",
      "choices": [
        "auditStatus",
        "=",
        "String auditStatus",
        "\"Pending\"",
        "==",
        "boolean auditStatus"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 4,
          "type": "variable_declaration",
          "description": "String variable declaration",
          "correct_answer": "String auditStatus",
          "explanation": "`String auditStatus` correctly declares the `String` variable to store the audit status."
        },
        {
          "id": "slot_2",
          "line": 4,
          "type": "variable_initialization",
          "description": "String literal initialization",
          "correct_answer": "\"Pending\"",
          "explanation": "`\"Pending\"` is the `String` literal used to initialize `auditStatus`."
        },
        {
          "id": "slot_3",
          "line": 7,
          "type": "variable_assignment",
          "description": "Simple assignment operator",
          "correct_answer": "=",
          "explanation": "The simple assignment operator `=` is used to update `auditStatus` to \"Approved\" inside the `if` block."
        }
      ],
      "number_of_slots": 3
    },
    "hints": {
      "1": "The first blank needs the type and name for the `auditStatus` variable, which stores text.",
      "2": "The second blank initializes `auditStatus` to a specific string literal.",
      "3": "The third blank needs the operator for simple assignment (setting the new value)."
    }
  },
  {
    "id": 221,
    "subtopic_id": 5,
    "type": "code_completion",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "An `AuditTrail` tracks `transactionVolume` and determines `auditCompliance`. `transactionVolume` is updated using compound assignments, and `auditCompliance` is set based on a modulo check. Complete the `auditCompliance` declaration and the compound assignment operators.",
    "story_context": "The AuditTrail needs to track transaction volume and determine audit compliance using compound assignments and modulo operations. Your task is to complete the variable declaration and operators.",
    "challenge_data": {
      "initial_code": "public class AuditTrail {\n    public static void main(String[] args) {\n        int transactionVolume = 1000;\n        int newBatch = 250;\n        int auditors = 3;\n        ??? auditCompliance;\n\n        transactionVolume ??? newBatch;\n        transactionVolume ??? auditors;\n\n        auditCompliance = (transactionVolume ??? 2 == 0);\n        \n        System.out.println(\"Final Transaction Volume: \" + transactionVolume);\n        System.out.println(\"Audit Compliance: \" + auditCompliance);\n    }\n}",
      "expected_output": [
        "Final Transaction Volume: 416",
        "Audit Compliance: true"
      ],
      "solution_code": "public class AuditTrail {\n    public static void main(String[] args) {\n        int transactionVolume = 1000;\n        int newBatch = 250;\n        int auditors = 3;\n        boolean auditCompliance;\n\n        transactionVolume += newBatch;\n        transactionVolume /= auditors;\n\n        auditCompliance = (transactionVolume % 2 == 0);\n        \n        System.out.println(\"Final Transaction Volume: \" + transactionVolume);\n        System.out.println(\"Audit Compliance: \" + auditCompliance);\n    }\n}",
      "choices": [
        "/=",
        "-",
        "+=",
        "boolean",
        "/",
        "%",
        "*",
        "+"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 6,
          "type": "variable_declaration",
          "description": "Boolean variable declaration",
          "correct_answer": "boolean",
          "explanation": "`boolean` is the correct type for `auditCompliance` since it stores a true/false value."
        },
        {
          "id": "slot_2",
          "line": 9,
          "type": "compound_assignment",
          "description": "Compound addition assignment operator",
          "correct_answer": "+=",
          "explanation": "`+=` performs compound addition to add `newBatch` to `transactionVolume`."
        },
        {
          "id": "slot_3",
          "line": 10,
          "type": "compound_assignment",
          "description": "Compound division assignment operator",
          "correct_answer": "/=",
          "explanation": "`/=` performs compound division to divide `transactionVolume` by `auditors`."
        },
        {
          "id": "slot_4",
          "line": 12,
          "type": "operator",
          "description": "Modulo operator",
          "correct_answer": "%",
          "explanation": "`%` is the modulo operator, used to check if `transactionVolume` is even (`transactionVolume % 2 == 0`)."
        }
      ],
      "number_of_slots": 4
    },
    "hints": {
      "1": "The first blank declares a `boolean` variable.",
      "2": " `transactionVolume` first `adds` a `newBatch`, then `divides` by `auditors`. Use the correct compound assignment operators.",
      "3": "The last blank needs the arithmetic operator to check for an even number (remainder is 0)."
    }
  },
  {
    "id": 222,
    "subtopic_id": 5,
    "type": "code_completion",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "An `EvidenceFluctuation` system tracks `evidenceWeight` and determines `sampleStatus`. `evidenceWeight` is updated using compound assignments, and `sampleStatus` is set using a ternary operator. Complete the `sampleStatus` declaration, compound assignments, and the ternary operator symbol.",
    "story_context": "The EvidenceFluctuation system needs to track evidence weight and determine sample status using compound assignments and ternary operators. Your task is to complete the variable declaration and operators.",
    "challenge_data": {
      "initial_code": "public class EvidenceFluctuation {\n    public static void main(String[] args) {\n        float evidenceWeight = 100.0f;\n        double purityFactor = 0.85;\n        int contaminantAmount = 5;\n        ??? sampleStatus;\n\n        evidenceWeight ??? purityFactor;\n        evidenceWeight ??? contaminantAmount;\n\n        sampleStatus = (evidenceWeight > 70.0f) ??? 'A' : 'F';\n        \n        System.out.println(\"Final Evidence Weight: \" + evidenceWeight);\n        System.out.println(\"Sample Status: \" + sampleStatus);\n    }\n}",
      "expected_output": [
        "Final Evidence Weight: 80.0",
        "Sample Status: A"
      ],
      "solution_code": "public class EvidenceFluctuation {\n    public static void main(String[] args) {\n        float evidenceWeight = 100.0f;\n        double purityFactor = 0.85;\n        int contaminantAmount = 5;\n        char sampleStatus;\n\n        evidenceWeight *= purityFactor;\n        evidenceWeight -= contaminantAmount;\n\n        sampleStatus = (evidenceWeight > 70.0f) ? 'A' : 'F';\n        \n        System.out.println(\"Final Evidence Weight: \" + evidenceWeight);\n        System.out.println(\"Sample Status: \" + sampleStatus);\n    }\n}",
      "choices": [
        "/=",
        "-=",
        "weight",
        "sampleStatus",
        "char",
        "*=",
        "+",
        "?"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 6,
          "type": "variable_declaration",
          "description": "Character variable declaration",
          "correct_answer": "char",
          "explanation": "`char` is the correct type for `sampleStatus` since it stores a single character ('A' or 'F')."
        },
        {
          "id": "slot_2",
          "line": 9,
          "type": "compound_assignment",
          "description": "Compound multiplication assignment operator",
          "correct_answer": "*=",
          "explanation": "`*=` performs compound multiplication (100.0f * 0.85 = 85.0f)."
        },
        {
          "id": "slot_3",
          "line": 10,
          "type": "compound_assignment",
          "description": "Compound subtraction assignment operator",
          "correct_answer": "-=",
          "explanation": "`-=` performs compound subtraction (85.0f - 5 = 80.0f)."
        },
        {
          "id": "slot_4",
          "line": 12,
          "type": "operator",
          "description": "Ternary operator symbol",
          "correct_answer": "?",
          "explanation": "`?` is the ternary operator symbol, completing the conditional assignment."
        }
      ],
      "number_of_slots": 4
    },
    "hints": {
      "1": "The first blank declares a `char` variable.",
      "2": " `evidenceWeight` is first multiplied by `purityFactor`, then `contaminantAmount` is subtracted. Use compound assignment operators.",
      "3": "The last blank completes a ternary (conditional) assignment."
    }
  },
  {
    "id": 223,
    "subtopic_id": 5,
    "type": "code_completion",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `SuspectProfiler` tracks `suspectConfidence` and sets `profileStatus`. `suspectConfidence` is adjusted using compound assignments, and `profileStatus` is set using a ternary operator. Complete the declarations and various compound assignments.",
    "story_context": "The SuspectProfiler needs to track suspect confidence and set profile status using compound assignments and ternary operators. Your task is to complete the variable declarations and operators.",
    "challenge_data": {
      "initial_code": "public class SuspectProfiler {\n    public static void main(String[] args) {\n        int suspectConfidence = 100;\n        int penalty = 25;\n        int maxScale = 10;\n        ??? profileStatus;\n        \n        suspectConfidence ???= penalty;\n        suspectConfidence ???= maxScale;\n        \n        ??? = (suspectConfidence > 5) ? \"HIGH RISK\" : \"LOW RISK\";\n        \n        System.out.println(\"Final Confidence: \" + suspectConfidence);\n        System.out.println(\"Profile Status: \" + profileStatus);\n    }\n}",
      "expected_output": [
        "Final Confidence: 5",
        "Profile Status: LOW RISK"
      ],
      "solution_code": "public class SuspectProfiler {\n    public static void main(String[] args) {\n        int suspectConfidence = 100;\n        int penalty = 25;\n        int maxScale = 10;\n        String profileStatus;\n        \n        suspectConfidence -= penalty;\n        suspectConfidence %= maxScale;\n        \n        profileStatus = (suspectConfidence > 5) ? \"HIGH RISK\" : \"LOW RISK\";\n        \n        System.out.println(\"Final Confidence: \" + suspectConfidence);\n        System.out.println(\"Profile Status: \" + profileStatus);\n    }\n}",
      "choices": [
        "/=",
        "-=",
        "String",
        "profileStatus",
        "+",
        "%=",
        "int",
        "status"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 6,
          "type": "variable_declaration",
          "description": "String variable declaration",
          "correct_answer": "String",
          "explanation": "`String` is the correct type for `profileStatus` since it stores text values like \"HIGH RISK\" or \"LOW RISK\"."
        },
        {
          "id": "slot_2",
          "line": 9,
          "type": "compound_assignment",
          "description": "Compound subtraction assignment operator",
          "correct_answer": "-=",
          "explanation": "`-=` performs compound subtraction to reduce `suspectConfidence` by `penalty`."
        },
        {
          "id": "slot_3",
          "line": 10,
          "type": "compound_assignment",
          "description": "Compound modulo assignment operator",
          "correct_answer": "%=",
          "explanation": "`%=` performs compound modulo to find the remainder when `suspectConfidence` is divided by `maxScale`."
        },
        {
          "id": "slot_4",
          "line": 12,
          "type": "variable_name",
          "description": "Variable name for ternary assignment",
          "correct_answer": "profileStatus",
          "explanation": "`profileStatus` is the variable being assigned the result of the ternary operation."
        }
      ],
      "number_of_slots": 4
    },
    "hints": {
      "1": "The first blank declares a `String` variable.",
      "2": " `suspectConfidence` is first `reduced by penalty`, then its `remainder when divided by maxScale` is found. Use compound assignment operators.",
      "3": "The last blank is the name of the variable being assigned the ternary result."
    }
  },
  {
    "id": 224,
    "subtopic_id": 5,
    "type": "code_completion",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `SecuritySystem` calculates `securityCode` and sets `securityStatus`. `securityCode` is derived from `baseValue`, `keyModifier`, and `shiftAmount`, involving type casting and arithmetic operations. `securityStatus` is determined by a modulo check. Complete the declarations and arithmetic operators.",
    "story_context": "The SecuritySystem needs to calculate security codes using type casting and arithmetic operations. Your task is to complete the variable declarations and operators.",
    "challenge_data": {
      "initial_code": "public class SecuritySystem {\n    public static void main(String[] args) {\n        int baseValue = 100000;\n        int keyModifier = 50000;\n        int shiftAmount = 10000;\n        ??? securityCode;\n        ??? securityStatus;\n\n        securityCode = (int) ((long)baseValue ??? keyModifier ??? shiftAmount);\n        \n        securityStatus = (securityCode % 2 == 0) ? true : false;\n        \n        System.out.println(\"Final Security Code: \" + securityCode);\n        System.out.println(\"Security Status: \" + securityStatus);\n    }\n}",
      "expected_output": [
        "Final Security Code: 5010000000",
        "Security Status: true"
      ],
      "solution_code": "public class SecuritySystem {\n    public static void main(String[] args) {\n        int baseValue = 100000;\n        int keyModifier = 50000;\n        int shiftAmount = 10000;\n        int securityCode;\n        boolean securityStatus;\n\n        securityCode = (int) ((long)baseValue * keyModifier + shiftAmount);\n        \n        securityStatus = (securityCode % 2 == 0) ? true : false;\n        \n        System.out.println(\"Final Security Code: \" + securityCode);\n        System.out.println(\"Security Status: \" + securityStatus);\n    }\n}",
      "choices": [
        "-",
        "securityCode",
        "boolean",
        "/",
        "*",
        "+",
        "int",
        "status"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 6,
          "type": "variable_declaration",
          "description": "Integer variable declaration",
          "correct_answer": "int",
          "explanation": "`int` is the correct data type for `securityCode` since it holds a whole number."
        },
        {
          "id": "slot_2",
          "line": 7,
          "type": "variable_declaration",
          "description": "Boolean variable declaration",
          "correct_answer": "boolean",
          "explanation": "`boolean` is the correct data type for `securityStatus` since it holds a true/false value."
        },
        {
          "id": "slot_3",
          "line": 9,
          "type": "operator",
          "description": "Multiplication operator",
          "correct_answer": "*",
          "explanation": "The calculation `(long)baseValue * keyModifier` needs multiplication to multiply the base value by the key modifier."
        },
        {
          "id": "slot_4",
          "line": 9,
          "type": "operator",
          "description": "Addition operator",
          "correct_answer": "+",
          "explanation": "The calculation `(long)baseValue * keyModifier + shiftAmount` needs addition to add the shift amount to the result."
        }
      ],
      "number_of_slots": 4
    },
    "hints": {
      "1": "The `securityCode` holds a whole number.",
      "2": "The `securityStatus` holds a `true`/`false` value.",
      "3": " `securityCode` is derived from `baseValue` multiplied by `keyModifier`, then `shiftAmount` is added. The order `*` then `+` is critical."
    }
  },
  {
    "id": 225,
    "subtopic_id": 5,
    "type": "code_completion",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `PacketAllocator` determines `finalAllocation` and `allocationStatus`. `packetCount` is adjusted using compound assignments, and `allocationStatus` is determined by a modulo check. Complete the declarations and various compound assignment operators.",
    "story_context": "The PacketAllocator needs to determine final allocation and status using compound assignments. Your task is to complete the variable declarations and compound assignment operators.",
    "challenge_data": {
      "initial_code": "public class PacketAllocator {\n    public static void main(String[] args) {\n        int packetCount = 150;\n        double distributionFactor = 0.5;\n        int safetyMargin = 10;\n        int dailyQuota = 7;\n        \n        ??? finalAllocation;\n        ??? allocationStatus;\n\n        packetCount ???= distributionFactor;\n        packetCount ???= safetyMargin;\n        \n        finalAllocation = packetCount;\n        allocationStatus = (finalAllocation % dailyQuota == 0);\n        \n        System.out.println(\"Final Allocation: \" + finalAllocation);\n        System.out.println(\"Allocation Status: \" + allocationStatus);\n    }\n}",
      "expected_output": [
        "Final Allocation: 65",
        "Allocation Status: false"
      ],
      "solution_code": "public class PacketAllocator {\n    public static void main(String[] args) {\n        int packetCount = 150;\n        double distributionFactor = 0.5;\n        int safetyMargin = 10;\n        int dailyQuota = 7;\n        \n        int finalAllocation;\n        boolean allocationStatus;\n\n        packetCount *= distributionFactor;\n        packetCount -= safetyMargin;\n        \n        finalAllocation = packetCount;\n        allocationStatus = (finalAllocation % dailyQuota == 0);\n        \n        System.out.println(\"Final Allocation: \" + finalAllocation);\n        System.out.println(\"Allocation Status: \" + allocationStatus);\n    }\n}",
      "choices": [
        "/=",
        "-=",
        "*=",
        "boolean",
        "finalAllocation",
        "%=",
        "int",
        "status"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 8,
          "type": "variable_declaration",
          "description": "Integer variable declaration",
          "correct_answer": "int",
          "explanation": "`int` is the correct type for `finalAllocation` since it stores a whole number."
        },
        {
          "id": "slot_2",
          "line": 9,
          "type": "variable_declaration",
          "description": "Boolean variable declaration",
          "correct_answer": "boolean",
          "explanation": "`boolean` is the correct type for `allocationStatus` since it stores a true/false value."
        },
        {
          "id": "slot_3",
          "line": 12,
          "type": "compound_assignment",
          "description": "Compound multiplication assignment operator",
          "correct_answer": "*=",
          "explanation": "`*=` is the compound multiplication assignment operator. `packetCount` (int) is promoted to `double` for the calculation with `distributionFactor` (double), and the result is implicitly cast back to `int` for assignment."
        },
        {
          "id": "slot_4",
          "line": 13,
          "type": "compound_assignment",
          "description": "Compound subtraction assignment operator",
          "correct_answer": "-=",
          "explanation": "`-=` is the compound subtraction assignment operator. This subtracts the safety margin from the packet count."
        }
      ],
      "number_of_slots": 4
    },
    "hints": {
      "1": "The first blank declares an `int` variable for `finalAllocation`.",
      "2": "The second blank declares a `boolean` variable for `allocationStatus`.",
      "3": " `packetCount` is first multiplied by `distributionFactor`. Use the compound assignment for multiplication."
    }
  },
  {
    "id": 226,
    "subtopic_id": 6,
    "type": "output_tracing",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `FingerprintMatch` system compares `fingerprintCount` and `expectedPrints`. Your task is to trace the code and determine if the `Fingerprint Counts Match`.",
    "story_context": "The FingerprintMatch system needs to compare fingerprint counts with expected prints. Your task is to trace the comparison operation and predict the output.",
    "challenge_data": {
      "code": "public class FingerprintMatch {\n    public static void main(String[] args) {\n        int fingerprintCount = 10;\n        int expectedPrints = 10;\n        boolean countsMatch = (fingerprintCount == expectedPrints);\n        System.out.println(\"Fingerprint Counts Match: \" + countsMatch);\n    }\n}",
      "expected_output": [
        "Fingerprint Counts Match: true"
      ],
      "choices": [
        "Fingerprint Counts Match: true",
        "Fingerprint Counts Match: false",
        "Error",
        "10"
      ],
      "explanation": "The `fingerprintCount` (`10`) is compared to `expectedPrints` (`10`) using the `==` operator. Since both values are the same, `fingerprintCount == expectedPrints` evaluates to `true`. The `System.out.println()` then displays \"Fingerprint Counts Match: true\"."
    },
    "hints": {
      "1": "The `==` operator checks if the values on both sides are identical.",
      "2": "Compare `fingerprintCount` to `expectedPrints`.",
      "3": "The result of a comparison operation is always `true` or `false`."
    }
  },
  {
    "id": 227,
    "subtopic_id": 6,
    "type": "output_tracing",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "An `AgeChecker` determines if a `suspectAge` is `underage` compared to `legalDrinkingAge`. Your task is to trace the code and determine if the `Suspect is Underage`.",
    "story_context": "The AgeChecker needs to determine if a suspect is underage compared to the legal drinking age. Your task is to trace the comparison operation and predict the output.",
    "challenge_data": {
      "code": "public class AgeChecker {\n    public static void main(String[] args) {\n        int suspectAge = 20;\n        int legalDrinkingAge = 21;\n        boolean isUnderage = (suspectAge < legalDrinkingAge);\n        System.out.println(\"Suspect is Underage: \" + isUnderage);\n    }\n}",
      "expected_output": [
        "Suspect is Underage: true"
      ],
      "choices": [
        "Suspect is Underage: true",
        "Suspect is Underage: false",
        "Error",
        "20"
      ],
      "explanation": "The `suspectAge` (`20`) is compared to `legalDrinkingAge` (`21`) using the `<` operator. Since `20` is less than `21`, `suspectAge < legalDrinkingAge` evaluates to `true`. The `System.out.println()` then displays \"Suspect is Underage: true\"."
    },
    "hints": {
      "1": "The `<` operator checks if the left value is strictly less than the right value.",
      "2": "Compare `suspectAge` to `legalDrinkingAge`.",
      "3": "The result of a comparison operation is always `true` or `false`."
    }
  },
  {
    "id": 228,
    "subtopic_id": 6,
    "type": "output_tracing",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `DispatchEvaluator` determines if a `crimeSceneDistance` is `tooFar` based on a `responseThreshold`. Your task is to trace the code and determine if the `Crime Scene Too Far` status.",
    "story_context": "The DispatchEvaluator needs to determine if a crime scene distance is too far based on a response threshold. Your task is to trace the comparison operation and predict the output.",
    "challenge_data": {
      "code": "public class DispatchEvaluator {\n    public static void main(String[] args) {\n        double crimeSceneDistance = 15.5;\n        double responseThreshold = 15.0;\n        boolean tooFar = (crimeSceneDistance > responseThreshold);\n        System.out.println(\"Crime Scene Too Far: \" + tooFar);\n    }\n}",
      "expected_output": [
        "Crime Scene Too Far: true"
      ],
      "choices": [
        "Crime Scene Too Far: true",
        "Crime Scene Too Far: false",
        "Error",
        "15.5"
      ],
      "explanation": "The `crimeSceneDistance` (`15.5`) is compared to `responseThreshold` (`15.0`) using the `>` operator. Since `15.5` is greater than `15.0`, `crimeSceneDistance > responseThreshold` evaluates to `true`. The `System.out.println()` then displays \"Crime Scene Too Far: true\"."
    },
    "hints": {
      "1": "The `>` operator checks if the left value is strictly greater than the right value.",
      "2": "Compare `crimeSceneDistance` to `responseThreshold`.",
      "3": "The result of a comparison is always `true` or `false`."
    }
  },
  {
    "id": 229,
    "subtopic_id": 6,
    "type": "output_tracing",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `SuspectStatusChecker` determines if a `suspectStatus` is `notArrested` compared to \"Arrested\". Your task is to trace the code and determine if the `Suspect Not Arrested` status.",
    "story_context": "The SuspectStatusChecker needs to determine if a suspect is not arrested based on their status. Your task is to trace the string comparison operation and predict the output.",
    "challenge_data": {
      "code": "public class SuspectStatusChecker {\n    public static void main(String[] args) {\n        String suspectStatus = \"Detained\";\n        boolean notArrested = (suspectStatus != \"Arrested\");\n        System.out.println(\"Suspect Not Arrested: \" + notArrested);\n    }\n}",
      "expected_output": [
        "Suspect Not Arrested: true"
      ],
      "choices": [
        "Suspect Not Arrested: true",
        "Suspect Not Arrested: false",
        "Error",
        "Detained"
      ],
      "explanation": "The `suspectStatus` (`\"Detained\"`) is compared to `\"Arrested\"` using the `!=` operator. Since `\"Detained\"` is indeed not equal to `\"Arrested\"`, `suspectStatus != \"Arrested\"` evaluates to `true`. The `System.out.println()` then displays \"Suspect Not Arrested: true\"."
    },
    "hints": {
      "1": "The `!=` operator checks if the values on both sides are *not* identical.",
      "2": "Compare `suspectStatus` to the literal \"Arrested\".",
      "3": "Remember that `String` literals are compared by content for `!=` and `==` due to interning."
    }
  },
  {
    "id": 230,
    "subtopic_id": 6,
    "type": "output_tracing",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "An `EvidenceReliabilityChecker` determines if `evidenceReliability` meets a `minimumStandard`. Your task is to trace the code and determine if the `Evidence is Reliable`.",
    "story_context": "The EvidenceReliabilityChecker needs to determine if evidence reliability meets the minimum standard. Your task is to trace the comparison operation and predict the output.",
    "challenge_data": {
      "code": "public class EvidenceReliabilityChecker {\n    public static void main(String[] args) {\n        int evidenceReliability = 7;\n        int minimumStandard = 7;\n        boolean isReliable = (evidenceReliability >= minimumStandard);\n        System.out.println(\"Evidence is Reliable: \" + isReliable);\n    }\n}",
      "expected_output": [
        "Evidence is Reliable: true"
      ],
      "choices": [
        "Evidence is Reliable: true",
        "Evidence is Reliable: false",
        "Error",
        "7"
      ],
      "explanation": "The `evidenceReliability` (`7`) is compared to `minimumStandard` (`7`) using the `>=` operator. Since `7` is greater than or equal to `7`, `evidenceReliability >= minimumStandard` evaluates to `true`. The `System.out.println()` then displays \"Evidence is Reliable: true\"."
    },
    "hints": {
      "1": "The `>=` operator checks if the left value is greater than or equal to the right value.",
      "2": "Compare `evidenceReliability` to `minimumStandard`.",
      "3": "The result of a comparison is always `true` or `false`."
    }
  },
  {
    "id": 231,
    "subtopic_id": 6,
    "type": "output_tracing",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `ProfilerComparator` evaluates `suspectAge` against a `riskThreshold` and `knownAlias` against `profileName`. Your task is to trace the code and determine if `Age Meets Risk` and if `Alias is Exact Object Match`.",
    "story_context": "The ProfilerComparator needs to evaluate suspect age against risk thresholds and compare aliases with profile names. Your task is to trace the comparison operations and predict the outputs.",
    "challenge_data": {
      "code": "public class ProfilerComparator {\n    public static void main(String[] args) {\n        int suspectAge = 30;\n        double riskThreshold = 29.5;\n        String knownAlias = \"Shadow\";\n        String profileName = \"Shadow\";\n\n        boolean ageRiskMatch = (suspectAge > riskThreshold);\n        boolean aliasMatchesProfile = (knownAlias == profileName);\n        \n        System.out.println(\"Age Meets Risk: \" + ageRiskMatch);\n        System.out.println(\"Alias is Exact Object Match: \" + aliasMatchesProfile);\n    }\n}",
      "expected_output": [
        "Age Meets Risk: true",
        "Alias is Exact Object Match: true"
      ],
      "choices": [
        "Age Meets Risk: false",
        "Age Meets Risk: true",
        "Alias is Exact Object Match: false",
        "Alias is Exact Object Match: true",
        "Age Meets Risk: null"
      ],
      "explanation": "1. `suspectAge` is `30`, `riskThreshold` is `29.5`. `suspectAge > riskThreshold` compares `30` (promoted to `30.0`) to `29.5`. `30.0 > 29.5` is `true`. So, `ageRiskMatch` is `true`.\n2. `knownAlias` is `\"Shadow\"`, `profileName` is `\"Shadow\"`. Since both are `String` literals with identical content, Java performs string interning, making both variables point to the *same* `String` object in memory. Therefore, `knownAlias == profileName` evaluates to `true`.\n3. The first `System.out.println()` prints \"Age Meets Risk: true\".\n4. The second `System.out.println()` prints \"Alias is Exact Object Match: true\"."
    },
    "hints": {
      "1": "When comparing an `int` and a `double`, the `int` is promoted to `double` for the comparison.",
      "2": "For `String` literals that are identical, Java often makes them refer to the same object in memory.",
      "3": "The `==` operator for non-primitive types compares memory addresses."
    }
  },
  {
    "id": 232,
    "subtopic_id": 6,
    "type": "output_tracing",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `SuspectVerification` system checks `suspectHeight` against a `profileHeight` and `alibiDetails1` against `alibiDetails2`. Your task is to trace the code and determine if `Height Matches Profile` and if `Alibi Content Matches`.",
    "story_context": "The SuspectVerification system needs to check suspect height against profile height and compare alibi details. Your task is to trace the comparison operations and predict the outputs.",
    "challenge_data": {
      "code": "public class SuspectVerification {\n    public static void main(String[] args) {\n        double suspectHeight = 6.2;\n        double profileHeight = 6.0;\n        String alibiDetails1 = \"At the club.\";\n        String alibiDetails2 = new String(\"At the club.\");\n\n        boolean heightMatches = (suspectHeight >= profileHeight);\n        boolean alibiContentMatch = (alibiDetails1.equals(alibiDetails2));\n        \n        System.out.println(\"Height Matches Profile: \" + heightMatches);\n        System.out.println(\"Alibi Content Matches: \" + alibiContentMatch);\n    }\n}",
      "expected_output": [
        "Height Matches Profile: true",
        "Alibi Content Matches: true"
      ],
      "choices": [
        "Height Matches Profile: false",
        "Height Matches Profile: true",
        "Alibi Content Matches: false",
        "Alibi Content Matches: true",
        "Error"
      ],
      "explanation": "1. `suspectHeight` is `6.2`, `profileHeight` is `6.0`. `suspectHeight >= profileHeight` compares `6.2` to `6.0`. `6.2 >= 6.0` is `true`. So, `heightMatches` is `true`.\n2. `alibiDetails1` is `\"At the club.\"`, `alibiDetails2` is `new String(\"At the club.\")`. Even though they are different objects in memory (due to `new String()`), their content is identical. The `.equals()` method compares content, so `alibiDetails1.equals(alibiDetails2)` evaluates to `true`.\n3. The first `System.out.println()` prints \"Height Matches Profile: true\".\n4. The second `System.out.println()` prints \"Alibi Content Matches: true\"."
    },
    "hints": {
      "1": "The `>=` operator checks if the left value is greater than or equal to the right value.",
      "2": "The `.equals()` method for `String` objects compares their actual content.",
      "3": "Even if `alibiDetails2` is a new object, `equals()` will still return true if the text is the same."
    }
  },
  {
    "id": 233,
    "subtopic_id": 6,
    "type": "output_tracing",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `CaseStatusEvaluator` checks `clueCount` against `minimumRequired` and `caseID` against `0`. Your task is to trace the code and determine if `Enough Clues Found` and if the `Case ID is Valid`.",
    "story_context": "The CaseStatusEvaluator needs to check clue count against minimum requirements and validate case IDs. Your task is to trace the comparison operations and predict the outputs.",
    "challenge_data": {
      "code": "public class CaseStatusEvaluator {\n    public static void main(String[] args) {\n        int clueCount = 8;\n        int minimumRequired = 10;\n        int caseID = 101;\n\n        boolean enoughClues = (clueCount >= minimumRequired);\n        boolean isIDValid = (caseID != 0);\n        \n        System.out.println(\"Enough Clues Found: \" + enoughClues);\n        System.out.println(\"Is Case ID Valid: \" + isIDValid);\n    }\n}",
      "expected_output": [
        "Enough Clues Found: false",
        "Is Case ID Valid: true"
      ],
      "choices": [
        "Enough Clues Found: true",
        "Enough Clues Found: false",
        "Is Case ID Valid: true",
        "Is Case ID Valid: false",
        "Enough Clues Found: null"
      ],
      "explanation": "1. `clueCount` is `8`, `minimumRequired` is `10`. `clueCount >= minimumRequired` compares `8` to `10`. `8 >= 10` is `false`. So, `enoughClues` is `false`.\n2. `caseID` is `101`. `caseID != 0` compares `101` to `0`. `101 != 0` is `true`. So, `isIDValid` is `true`.\n3. The first `System.out.println()` prints \"Enough Clues Found: false\".\n4. The second `System.out.println()` prints \"Is Case ID Valid: true\"."
    },
    "hints": {
      "1": "The `>=` operator checks for \"greater than or equal to.\"",
      "2": "The `!=` operator checks for \"not equal to.\"",
      "3": "Evaluate both comparisons based on the given values."
    }
  },
  {
    "id": 234,
    "subtopic_id": 6,
    "type": "output_tracing",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `DispatchPriority` system checks `callPriority` and `responseTime`. Your task is to trace the code and determine if the `Call is High Priority` and if the `Response is Fast`.",
    "story_context": "The DispatchPriority system needs to check call priority and response time. Your task is to trace the comparison operations and predict the outputs.",
    "challenge_data": {
      "code": "public class DispatchPriority {\n    public static void main(String[] args) {\n        int callPriority = 5;\n        double responseTime = 1.8;\n\n        boolean isHighPriority = (callPriority == 5);\n        boolean isFastResponse = (responseTime < 2.0);\n        \n        System.out.println(\"Call is High Priority: \" + isHighPriority);\n        System.out.println(\"Response is Fast: \" + isFastResponse);\n    }\n}",
      "expected_output": [
        "Call is High Priority: true",
        "Response is Fast: true"
      ],
      "choices": [
        "Call is High Priority: true",
        "Call is High Priority: false",
        "Response is Fast: true",
        "Response is Fast: false",
        "true"
      ],
      "explanation": "1. `callPriority` is `5`. `callPriority == 5` compares `5` to `5`. This is `true`. So, `isHighPriority` is `true`.\n2. `responseTime` is `1.8`. `responseTime < 2.0` compares `1.8` to `2.0`. `1.8 < 2.0` is `true`. So, `isFastResponse` is `true`.\n3. The first `System.out.println()` prints \"Call is High Priority: true\".\n4. The second `System.out.println()` prints \"Response is Fast: true\"."
    },
    "hints": {
      "1": "The `==` operator checks for exact equality.",
      "2": "The `<` operator checks for strictly less than.",
      "3": "Evaluate both comparisons based on the values provided."
    }
  },
  {
    "id": 235,
    "subtopic_id": 6,
    "type": "output_tracing",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "An `EvidenceValidator` checks `evidenceWeight` against `minWeightRequired` and `suspectID` against `0`. Your task is to trace the code and determine if `Weight Meets Standard` and if the `Suspect ID is Valid`.",
    "story_context": "The EvidenceValidator needs to check evidence weight against minimum requirements and validate suspect IDs. Your task is to trace the comparison operations and predict the outputs.",
    "challenge_data": {
      "code": "public class EvidenceValidator {\n    public static void main(String[] args) {\n        double evidenceWeight = 1.0;\n        double minWeightRequired = 1.0;\n        int suspectID = 0;\n        \n        boolean weightMeetsStandard = (evidenceWeight >= minWeightRequired);\n        boolean isSuspectIDValid = (suspectID != 0);\n        \n        System.out.println(\"Weight Meets Standard: \" + weightMeetsStandard);\n        System.out.println(\"Suspect ID is Valid: \" + isSuspectIDValid);\n    }\n}",
      "expected_output": [
        "Weight Meets Standard: true",
        "Suspect ID is Valid: false"
      ],
      "choices": [
        "Weight Meets Standard: false",
        "Weight Meets Standard: true",
        "Suspect ID is Valid: false",
        "Suspect ID is Valid: true",
        "Weight Meets Standard: null"
      ],
      "explanation": "1. `evidenceWeight` is `1.0`, `minWeightRequired` is `1.0`. `evidenceWeight >= minWeightRequired` compares `1.0` to `1.0`. This is `true`. So, `weightMeetsStandard` is `true`.\n2. `suspectID` is `0`. `suspectID != 0` compares `0` to `0`. This is `false`. So, `isSuspectIDValid` is `false`.\n3. The first `System.out.println()` prints \"Weight Meets Standard: true\".\n4. The second `System.out.println()` prints \"Suspect ID is Valid: false\"."
    },
    "hints": {
      "1": "The `>=` operator checks for \"greater than or equal to.\"",
      "2": "The `!=` operator checks for \"not equal to.\"",
      "3": "Evaluate both comparisons based on the values provided."
    }
  },
  {
    "id": 236,
    "subtopic_id": 6,
    "type": "output_tracing",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `ForensicCrossReference` compares `dnaSampleID`s and `fingerprintMatchPercentage` to determine `exactIDMatch`, `highConfidenceMatch`, and `auditRequired`. Your task is to trace the code and determine these boolean statuses.",
    "story_context": "The ForensicCrossReference needs to compare DNA sample IDs and fingerprint match percentages. Your task is to trace the comparison operations and predict the outputs.",
    "challenge_data": {
      "code": "public class ForensicCrossReference {\n    public static void main(String[] args) {\n        long dnaSampleID1 = 123456789123L;\n        long dnaSampleID2 = 123456789123L;\n        double fingerprintMatchPercentage = 99.99999999999999;\n        double threshold = 100.0;\n\n        boolean exactIDMatch = (dnaSampleID1 == dnaSampleID2);\n        \n        boolean highConfidenceMatch = (fingerprintMatchPercentage >= threshold);\n        \n        boolean auditRequired = (exactIDMatch || fingerprintMatchPercentage != threshold);\n        \n        System.out.println(\"Exact ID Match: \" + exactIDMatch);\n        System.out.println(\"High Confidence Match: \" + highConfidenceMatch);\n        System.out.println(\"Audit Required: \" + auditRequired);\n    }\n}",
      "expected_output": [
        "Exact ID Match: true",
        "High Confidence Match: false",
        "Audit Required: true"
      ],
      "choices": [
        "Exact ID Match: true",
        "High Confidence Match: true",
        "High Confidence Match: false",
        "Audit Required: true",
        "Exact ID Match: null",
        "Audit Required: false"
      ],
      "explanation": "1. `dnaSampleID1` and `dnaSampleID2` are identical `long` values. `exactIDMatch = (dnaSampleID1 == dnaSampleID2)` is `true`.\n2. `fingerprintMatchPercentage` is `99.99999999999999`, `threshold` is `100.0`. Due to inherent floating-point precision, `99.99999999999999` is not exactly `100.0`. `fingerprintMatchPercentage >= threshold` is `false`.\n3. `auditRequired = (exactIDMatch || fingerprintMatchPercentage != threshold);` evaluates `(true || (99.99999999999999 != 100.0))`. `99.99999999999999 != 100.0` is `true`. So `true || true` is `true`.\n4. **Outputs:** `Exact ID Match: true`, `High Confidence Match: false`, `Audit Required: true`."
    },
    "hints": {
      "1": "Comparing `long` values with `==` is straightforward. The `fingerprintMatchPercentage` is a `double` and comparison with `threshold` is tricky due to precision.",
      "2": "Floating-point numbers (like `double`) can have tiny internal inaccuracies, making direct `==` or `>=` comparisons with seemingly equal values unreliable.",
      "3": "Evaluate the logical `OR` (`||`) operator. If the first operand is `true`, the second one isn't even checked."
    }
  },
  {
    "id": 237,
    "subtopic_id": 6,
    "type": "output_tracing",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `SuspectInterview` evaluates `responseTime` and `alibiEvidence` to determine `responseTimely`, `strongEvidence`, and `finalVerdict`. The code involves floating-point comparison and `null` checks for strings. Your task is to trace the code and determine these boolean statuses.",
    "story_context": "The SuspectInterview needs to evaluate response times and alibi evidence. Your task is to trace the comparison operations and predict the outputs.",
    "challenge_data": {
      "code": "public class SuspectInterview {\n    public static void main(String[] args) {\n        int interviewMinutes = 15;\n        float preparationFactor = 0.5f;\n        double strictDeadline = 7.5;\n        String alibiEvidence = null;\n        \n        float suspectResponseTime = interviewMinutes / preparationFactor;\n        \n        boolean responseTimely = (suspectResponseTime <= strictDeadline);\n        \n        boolean strongEvidence = (alibiEvidence != null && alibiEvidence.length() > 0);\n        \n        boolean finalVerdict = (responseTimely || strongEvidence);\n        \n        System.out.println(\"Response Timely: \" + responseTimely);\n        System.out.println(\"Strong Evidence: \" + strongEvidence);\n        System.out.println(\"Final Verdict: \" + finalVerdict);\n    }\n}",
      "expected_output": [
        "Response Timely: false",
        "Strong Evidence: false",
        "Final Verdict: false"
      ],
      "choices": [
        "Response Timely: true",
        "Response Timely: false",
        "Strong Evidence: false",
        "Strong Evidence: true",
        "Final Verdict: false",
        "Final Verdict: true"
      ],
      "explanation": "1. `interviewMinutes = 15`, `preparationFactor = 0.5f`, `strictDeadline = 7.5`, `alibiEvidence = null`.\n2. `float suspectResponseTime = interviewMinutes / preparationFactor;` calculates `15 / 0.5f = 30.0f`.\n3. `boolean responseTimely = (suspectResponseTime <= strictDeadline);` compares `30.0f` (promoted to `double`) to `7.5d`. `30.0d <= 7.5d` is `false`. `responseTimely` is `false`.\n4. `boolean strongEvidence = (alibiEvidence != null && alibiEvidence.length() > 0);`\n    * `alibiEvidence != null` is `null != null`, which is `false`.\n    * Due to short-circuiting of `&&`, `alibiEvidence.length()` is *not* evaluated. `strongEvidence` is `false`.\n5. `boolean finalVerdict = (responseTimely || strongEvidence);` evaluates `false || false`, which is `false`. `finalVerdict` is `false`.\n6. **Outputs:** `Response Timely: false`, `Strong Evidence: false`, `Final Verdict: false`."
    },
    "hints": {
      "1": "Perform the division for `suspectResponseTime`, noting `int` divided by `float` results in a `float`.",
      "2": "When comparing a `float` to a `double`, the `float` promotes to `double` for the comparison.",
      "3": "The `null` check `!= null` for `alibiEvidence` is critical before the `length()` call. Understand `&&` short-circuiting."
    }
  },
  {
    "id": 238,
    "subtopic_id": 6,
    "type": "output_tracing",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `DispatchPrioritySystem` determines `isUrgentCall`, `requiresBackup`, and `dispatchDecision` based on `emergencyCallRank`, `callerProfile`, and `incidentSeverity` using logical operators with precedence. Your task is to trace the code and determine these boolean statuses.",
    "story_context": "The DispatchPrioritySystem needs to determine urgent calls and backup requirements. Your task is to trace the logical operations and predict the outputs.",
    "challenge_data": {
      "code": "public class DispatchPrioritySystem {\n    public static void main(String[] args) {\n        int emergencyCallRank = 8;\n        int callerProfile = 5;\n        int incidentSeverity = 7;\n        \n        boolean isUrgentCall = (emergencyCallRank >= 8 || incidentSeverity >= 9);\n        \n        boolean requiresBackup = (isUrgentCall && callerProfile >= 5 || incidentSeverity == 10);\n        \n        boolean dispatchDecision = (isUrgentCall && requiresBackup && callerProfile > 3);\n        \n        System.out.println(\"Is Urgent Call: \" + isUrgentCall);\n        System.out.println(\"Requires Backup: \" + requiresBackup);\n        System.out.println(\"Dispatch Decision: \" + dispatchDecision);\n    }\n}",
      "expected_output": [
        "Is Urgent Call: true",
        "Requires Backup: true",
        "Dispatch Decision: true"
      ],
      "choices": [
        "Is Urgent Call: true",
        "Requires Backup: false",
        "Dispatch Decision: true",
        "Requires Backup: true",
        "Dispatch Decision: false",
        "Is Urgent Call: false"
      ],
      "explanation": "1. `emergencyCallRank = 8`, `callerProfile = 5`, `incidentSeverity = 7`.\n2. `boolean isUrgentCall = (emergencyCallRank >= 8 || incidentSeverity >= 9);`\n    * `8 >= 8` is `true`.\n    * `7 >= 9` is `false`.\n    * `true || false` is `true`. `isUrgentCall` is `true`.\n3. `boolean requiresBackup = (isUrgentCall && callerProfile >= 5 || incidentSeverity == 10);`\n    * `isUrgentCall && callerProfile >= 5`: `true && (5 >= 5)` (`true && true`) is `true`.\n    * `incidentSeverity == 10`: `7 == 10` is `false`.\n    * `true || false` is `true`. `requiresBackup` is `true`.\n4. `boolean dispatchDecision = (isUrgentCall && requiresBackup && callerProfile > 3);`\n    * `isUrgentCall && requiresBackup`: `true && true` is `true`.\n    * `callerProfile > 3`: `5 > 3` is `true`.\n    * `true && true` is `true`. `dispatchDecision` is `true`.\n5. All three `System.out.println()` statements display the final values."
    },
    "hints": {
      "1": "Evaluate `isUrgentCall` first: `emergencyCallRank >= 8 || incidentSeverity >= 9`.",
      "2": "Evaluate `requiresBackup`: remember `&&` has higher precedence than `||`. This means `(isUrgentCall && callerProfile >= 5)` is evaluated first, then `|| incidentSeverity == 10`.",
      "3": "Finally, evaluate `dispatchDecision` which uses `&&` exclusively."
    }
  },
  {
    "id": 239,
    "subtopic_id": 6,
    "type": "output_tracing",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `CipherKeyValidator` processes `cipherKey1` and `cipherKey2` (derived from `cipherKey1` using string methods), and checks `keyStrength` against a `highStrengthThreshold`. Your task is to trace the code and determine if `Are Keys Identical (Ref)`, `Are Keys Same Content`, and `Is Strength High`.",
    "story_context": "The CipherKeyValidator needs to process cipher keys and validate key strength. Your task is to trace the string operations and comparisons to predict the outputs.",
    "challenge_data": {
      "code": "public class CipherKeyValidator {\n    public static void main(String[] args) {\n        String cipherKey1 = \"SECURE_ALPHA\";\n        String cipherKey2 = cipherKey1.substring(0, 6).toLowerCase() + \"_beta\";\n        float keyStrength = 99.9999f;\n        float highStrengthThreshold = 100.0f;\n\n        boolean areKeysIdentical = (cipherKey1 == cipherKey2);\n        boolean areKeysSameContent = (cipherKey1.equals(cipherKey2));\n        boolean isStrengthHigh = (keyStrength > highStrengthThreshold);\n        \n        System.out.println(\"Are Keys Identical (Ref): \" + areKeysIdentical);\n        System.out.println(\"Are Keys Same Content: \" + areKeysSameContent);\n        System.out.println(\"Is Strength High: \" + isStrengthHigh);\n    }\n}\n",
      "expected_output": [
        "Are Keys Identical (Ref): false",
        "Are Keys Same Content: false",
        "Is Strength High: false"
      ],
      "choices": [
        "Are Keys Identical (Ref): false",
        "Are Keys Same Content: true",
        "Are Keys Same Content: false",
        "Is Strength High: false",
        "Are Keys Identical (Ref): true",
        "Is Strength High: true"
      ],
      "explanation": "1. `cipherKey1 = \"SECURE_ALPHA\"`.\n2. `cipherKey2 = cipherKey1.substring(0, 6).toLowerCase() + \"_beta\";`\n    * `substring(0, 6)`: \"SECURE\".\n    * `toLowerCase()`: \"secure\".\n    * `\"secure\" + \"_beta\"`: \"secure_beta\". So `cipherKey2` is \"secure_beta\".\n3. `boolean areKeysIdentical = (cipherKey1 == cipherKey2);` compares `\"SECURE_ALPHA\"` to `\"secure_beta\"`. They are different `String` objects and different content, so `false`.\n4. `boolean areKeysSameContent = (cipherKey1.equals(cipherKey2));` compares `\"SECURE_ALPHA\"` to `\"secure_beta\"`. Content is different, so `false`.\n5. `float keyStrength = 99.9999f`, `highStrengthThreshold = 100.0f`. `keyStrength > highStrengthThreshold` is `99.9999f > 100.0f`, which is `false`.\n6. **Outputs:** `Are Keys Identical (Ref): false`, `Are Keys Same Content: false`, `Is Strength High: false`."
    },
    "hints": {
      "1": "Trace the creation of `cipherKey2` through its string methods.",
      "2": "Distinguish between `==` (reference comparison) and `.equals()` (content comparison) for `String` objects.",
      "3": "Evaluate the float comparison precisely: `99.9999f` vs `100.0f`."
    }
  },
  {
    "id": 240,
    "subtopic_id": 6,
    "type": "output_tracing",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `SceneReconstruction` system determines `accuracyMeetsStandard`, `alibiConsistency`, and `finalVerdict` based on floating-point accuracy and time range checks. Your task is to trace the code and determine these boolean statuses.",
    "story_context": "The SceneReconstruction needs to determine accuracy standards and alibi consistency. Your task is to trace the floating-point comparisons and logical operations to predict the outputs.",
    "challenge_data": {
      "code": "public class SceneReconstruction {\n    public static void main(String[] args) {\n        double reconstructionAccuracy = 99.9999999;\n        float idealPrecision = 100.0f;\n        int alibiStartTime = 1000;\n        int alibiEndTime = 1100;\n        int crimeTime = 1030;\n\n        boolean accuracyMeetsStandard = (reconstructionAccuracy >= idealPrecision);\n        \n        boolean alibiConsistency = (crimeTime >= alibiStartTime && crimeTime <= alibiEndTime);\n        \n        boolean finalVerdict = (accuracyMeetsStandard && alibiConsistency);\n        \n        System.out.println(\"Accuracy Meets Standard: \" + accuracyMeetsStandard);\n        System.out.println(\"Alibi Consistency: \" + alibiConsistency);\n        System.out.println(\"Final Verdict: \" + finalVerdict);\n    }\n}",
      "expected_output": [
        "Accuracy Meets Standard: false",
        "Alibi Consistency: true",
        "Final Verdict: false"
      ],
      "choices": [
        "Accuracy Meets Standard: true",
        "Accuracy Meets Standard: false",
        "Alibi Consistency: true",
        "Final Verdict: false",
        "Final Verdict: true",
        "Alibi Consistency: false"
      ],
      "explanation": "1. `reconstructionAccuracy = 99.9999999`, `idealPrecision = 100.0f`.\n2. `boolean accuracyMeetsStandard = (reconstructionAccuracy >= idealPrecision);` compares `99.9999999` (double) to `100.0f` (float, promoted to double). Due to precision differences, `99.9999999` is *not* greater than or equal to `100.0`. So, `accuracyMeetsStandard` is `false`.\n3. `boolean alibiConsistency = (crimeTime >= alibiStartTime && crimeTime <= alibiEndTime);`\n    * `crimeTime >= alibiStartTime`: `1030 >= 1000` is `true`.\n    * `crimeTime <= alibiEndTime`: `1030 <= 1100` is `true`.\n    * `true && true` is `true`. So, `alibiConsistency` is `true`.\n4. `boolean finalVerdict = (accuracyMeetsStandard && alibiConsistency);` evaluates `false && true`, which is `false`. So, `finalVerdict` is `false`.\n5. **Outputs:** `Accuracy Meets Standard: false`, `Alibi Consistency: true`, `Final Verdict: false`."
    },
    "hints": {
      "1": "Compare `reconstructionAccuracy` (double) to `idealPrecision` (float, which promotes to double). Be aware of floating-point precision issues.",
      "2": "Evaluate the `alibiConsistency` condition: it combines two comparisons with `&&`.",
      "3": "The `finalVerdict` is an `AND` of the first two boolean results."
    }
  },
  {
    "id": 241,
    "subtopic_id": 6,
    "type": "code_fixer",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `SuspectMatcher` compares `suspectAlias` to `\"Phantom\"`. The code incorrectly uses the assignment operator `=` within the `if` condition, leading to a compilation error. Fix the code to correctly compare the content of the strings.",
    "story_context": "The SuspectMatcher needs to compare suspect alias. Your task is to fix the comparison operator.",
    "challenge_data": {
      "initial_code": "public class SuspectMatcher {\n    public static void main(String[] args) {\n        String suspectAlias = \"Shadow\";\n        if (suspectAlias = \"Phantom\") {\n            System.out.println(\"Suspect is Phantom.\");\n        } else {\n            System.out.println(\"Suspect is not Phantom.\");\n        }\n    }\n}",
      "expected_output": [
        "Suspect is not Phantom."
      ],
      "solution_code": "public class SuspectMatcher {\n    public static void main(String[] args) {\n        String suspectAlias = \"Shadow\";\n        if (suspectAlias.equals(\"Phantom\")) {\n            System.out.println(\"Suspect is Phantom.\");\n        } else {\n            System.out.println(\"Suspect is not Phantom.\");\n        }\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 4,
          "type": "comparison_operator",
          "description": "Using assignment operator instead of equals method",
          "fix": "Use .equals() method: if (suspectAlias.equals(\"Phantom\"))"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code `if (suspectAlias = \"Phantom\")` attempts to use the assignment operator `=` within the `if` condition. This is a common mistake; it actually tries to assign \"Phantom\" to `suspectAlias` (which would compile but often not work as intended for a String comparison inside an if) and then evaluate the result of that assignment. For content comparison of `String` objects, the `.equals()` method is required. The fix replaces `=` with `.equals()` to correctly check if the content of `suspectAlias` is \"Phantom\"."
    },
    "hints": {
      "1": "The `=` operator assigns a value, it doesn't check for equality.",
      "2": "An `if` statement needs a condition that evaluates to `true` or `false`.",
      "3": "For `String` content comparison, a specific method is usually preferred over `==`."
    }
  },
  {
    "id": 242,
    "subtopic_id": 6,
    "type": "code_fixer",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `WitnessAgeChecker` determines if `witnessAge` is `exactly 25`. However, the code uses `>` operator, making it check for strictly greater than 25, leading to an incorrect output. Fix the code to correctly check for exact age.",
    "story_context": "The WitnessAgeChecker needs to verify witness age. Your task is to fix the comparison operator.",
    "challenge_data": {
      "initial_code": "public class WitnessAgeChecker {\n    public static void main(String[] args) {\n        int witnessAge = 25;\n        if (witnessAge > 25) {\n            System.out.println(\"Witness is exactly 25.\");\n        } else {\n            System.out.println(\"Witness is not 25.\");\n        }\n    }\n}",
      "expected_output": [
        "Witness is exactly 25."
      ],
      "solution_code": "public class WitnessAgeChecker {\n    public static void main(String[] args) {\n        int witnessAge = 25;\n        if (witnessAge == 25) {\n            System.out.println(\"Witness is exactly 25.\");\n        } else {\n            System.out.println(\"Witness is not 25.\");\n        }\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 4,
          "type": "comparison_operator",
          "description": "Using greater than instead of equality operator",
          "fix": "Use equality operator: if (witnessAge == 25)"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code `if (witnessAge > 25)` checks if `witnessAge` is strictly greater than `25`. Since `witnessAge` is `25`, this condition is `false`, leading to the `else` block. The intent was to check for exact equality. The fix is to use the `==` operator, which correctly evaluates `25 == 25` as `true`, leading to the desired output."
    },
    "hints": {
      "1": "The `>` operator means \"strictly greater than.\"",
      "2": "The goal is to check for an *exact* match.",
      "3": "Which comparison operator checks if two values are precisely the same?"
    }
  },
  {
    "id": 243,
    "subtopic_id": 6,
    "type": "code_fixer",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `CrimeRadiusChecker` determines if `crimeRadius` is `very close` (less than or equal to 5.0 miles). However, the code uses `<` operator, making it check for strictly less than 5.0, leading to an incorrect output. Fix the code to correctly include 5.0 miles in the \"very close\" category.",
    "story_context": "The CrimeRadiusChecker needs to check crime radius. Your task is to fix the comparison operator.",
    "challenge_data": {
      "initial_code": "public class CrimeRadiusChecker {\n    public static void main(String[] args) {\n        double crimeRadius = 5.0;\n        if (crimeRadius < 5.0) {\n            System.out.println(\"Crime scene is very close.\");\n        } else {\n            System.out.println(\"Crime scene is farther.\");\n        }\n    }\n}",
      "expected_output": [
        "Crime scene is very close."
      ],
      "solution_code": "public class CrimeRadiusChecker {\n    public static void main(String[] args) {\n        double crimeRadius = 5.0;\n        if (crimeRadius <= 5.0) {\n            System.out.println(\"Crime scene is very close.\");\n        } else {\n            System.out.println(\"Crime scene is farther.\");\n        }\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 4,
          "type": "comparison_operator",
          "description": "Using less than instead of less than or equal to",
          "fix": "Use less than or equal to: if (crimeRadius <= 5.0)"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code `if (crimeRadius < 5.0)` checks if `crimeRadius` is strictly less than `5.0`. Since `crimeRadius` is exactly `5.0`, this condition is `false`, leading to the `else` block. The intent was to include `5.0` as \"very close.\" The fix is to use the `<=` operator, which correctly evaluates `5.0 <= 5.0` as `true`, leading to the desired output."
    },
    "hints": {
      "1": "The `<` operator means \"strictly less than.\"",
      "2": "The goal is to include the boundary value (`5.0`) in the \"close\" category.",
      "3": "Which comparison operator means \"less than or equal to\"?"
    }
  },
  {
    "id": 244,
    "subtopic_id": 6,
    "type": "code_fixer",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "An `AlibiVerification` system checks if `alibiTime` is `at or after` a `startTime`. However, the code uses `>` operator, making it check for strictly after start time, leading to an incorrect output. Fix the code to correctly include the `startTime` in the verification.",
    "story_context": "The AlibiVerification needs to check alibi time. Your task is to fix the comparison operator.",
    "challenge_data": {
      "initial_code": "public class AlibiVerification {\n    public static void main(String[] args) {\n        int alibiTime = 1000;\n        int startTime = 1000;\n        if (alibiTime > startTime) {\n            System.out.println(\"Alibi is at or after start time.\");\n        }\n        else {\n            System.out.println(\"Alibi is before start time.\");\n        }\n    }\n}",
      "expected_output": [
        "Alibi is at or after start time."
      ],
      "solution_code": "public class AlibiVerification {\n    public static void main(String[] args) {\n        int alibiTime = 1000;\n        int startTime = 1000;\n        if (alibiTime >= startTime) {\n            System.out.println(\"Alibi is at or after start time.\");\n        }\n        else {\n            System.out.println(\"Alibi is before start time.\");\n        }\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 5,
          "type": "comparison_operator",
          "description": "Using greater than instead of greater than or equal to",
          "fix": "Use greater than or equal to: if (alibiTime >= startTime)"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code `if (alibiTime > startTime)` checks if `alibiTime` is strictly greater than `startTime`. Since `alibiTime` is exactly `startTime` (`1000`), this condition is `false`, leading to the `else` block. The intent was to include `startTime` in the true condition. The fix is to use the `>=` operator, which correctly evaluates `1000 >= 1000` as `true`, leading to the desired output."
    },
    "hints": {
      "1": "The `>` operator means \"strictly greater than.\"",
      "2": "The goal is to include the `startTime` itself in the \"at or after\" category.",
      "3": "Which comparison operator means \"greater than or equal to\"?"
    }
  },
  {
    "id": 245,
    "subtopic_id": 6,
    "type": "code_fixer",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `ReportIDValidator` checks if a `reportID` is `valid` (not equal to 0). However, the code incorrectly checks for equality to 0, leading to an incorrect output. Fix the code to correctly validate the `reportID`.",
    "story_context": "The ReportIDValidator needs to validate report ID. Your task is to fix the comparison operator.",
    "challenge_data": {
      "initial_code": "public class ReportIDValidator {\n    public static void main(String[] args) {\n        int reportID = 123;\n        if (reportID == 0) {\n            System.out.println(\"Report ID is valid.\");\n        } else {\n            System.out.println(\"Report ID is invalid.\");\n        }\n    }\n}",
      "expected_output": [
        "Report ID is valid."
      ],
      "solution_code": "public class ReportIDValidator {\n    public static void main(String[] args) {\n        int reportID = 123;\n        if (reportID != 0) {\n            System.out.println(\"Report ID is valid.\");\n        } else {\n            System.out.println(\"Report ID is invalid.\");\n        }\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 4,
          "type": "comparison_operator",
          "description": "Using equality instead of inequality operator",
          "fix": "Use inequality operator: if (reportID != 0)"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code `if (reportID == 0)` checks if `reportID` is exactly `0`. Since `reportID` is `123`, this condition is `false`, leading to the `else` block, incorrectly printing \"Report ID is invalid.\" The intent was to check if the ID is *not* `0`. The fix is to use the `!=` operator, which correctly evaluates `123 != 0` as `true`, leading to the desired output."
    },
    "hints": {
      "1": "The `==` operator checks if two values are identical.",
      "2": "The goal is to verify if the `reportID` is *not* `0`.",
      "3": "Which comparison operator means \"not equal to\"?"
    }
  },
  {
    "id": 246,
    "subtopic_id": 6,
    "type": "code_fixer",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "An `AlibiVerifier` compares `suspectAlibi` (literal) and `clubRecord` (new `String` object). The code incorrectly uses `==` for comparison, leading to an `Alibi is suspicious` output when content is identical. Fix the code to correctly compare the textual content.",
    "story_context": "The AlibiVerifier needs to verify alibi. Your task is to fix the string comparison.",
    "challenge_data": {
      "initial_code": "public class AlibiVerifier {\n    public static void main(String[] args) {\n        String suspectAlibi = \"At the Club\";\n        String clubRecord = new String(\"At the Club\");\n        \n        if (suspectAlibi == clubRecord) {\n            System.out.println(\"Alibi is verified.\");\n        } else {\n            System.out.println(\"Alibi is suspicious.\");\n        }\n    }\n}",
      "expected_output": [
        "Alibi is verified."
      ],
      "solution_code": "public class AlibiVerifier {\n    public static void main(String[] args) {\n        String suspectAlibi = \"At the Club\";\n        String clubRecord = new String(\"At the Club\");\n        \n        if (suspectAlibi.equals(clubRecord)) {\n            System.out.println(\"Alibi is verified.\");\n        } else {\n            System.out.println(\"Alibi is suspicious.\");\n        }\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 6,
          "type": "string_comparison",
          "description": "Using == instead of .equals() for String content comparison",
          "fix": "Use .equals() method: if (suspectAlibi.equals(clubRecord))"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code uses `==` to compare `suspectAlibi` and `clubRecord`. While `suspectAlibi` points to a string literal, `clubRecord` (created with `new String()`) points to a *different* object in memory, even though their contents are the same. Therefore, `suspectAlibi == clubRecord` evaluates to `false`. To correctly compare the textual content, the `.equals()` method is required, which returns `true` because \"At the Club\" is equal to \"At the Club\"."
    },
    "hints": {
      "1": "For non-primitive types like `String`, the `==` operator compares memory *references* (do they point to the exact same object?).",
      "2": " `new String(\"...\")` *always* creates a new object in memory, even if its content is identical to another string.",
      "3": "To compare the *actual text* inside two `String` objects, a specific method must be used."
    }
  },
  {
    "id": 247,
    "subtopic_id": 6,
    "type": "code_fixer",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `CollectionRateChecker` calculates `collectionRate` and attempts to check for exact equality with `0.3f`. Due to floating-point precision, this direct comparison may fail. Fix the code to robustly compare the `collectionRate` for practical equality.",
    "story_context": "The CollectionRateChecker needs to check collection rate. Your task is to fix the floating-point comparison.",
    "challenge_data": {
      "initial_code": "public class CollectionRateChecker {\n    public static void main(String[] args) {\n        float totalItems = 3.0f;\n        float totalDays = 10.0f;\n        float collectionRate = totalItems / totalDays;\n        \n        if (collectionRate == 0.3f) {\n            System.out.println(\"Collection rate is precise.\");\n        } else {\n            System.out.println(\"Collection rate has minor deviation.\");\n        }\n    }\n}",
      "expected_output": [
        "Collection rate is precise."
      ],
      "solution_code": "public class CollectionRateChecker {\n    public static void main(String[] args) {\n        float totalItems = 3.0f;\n        float totalDays = 10.0f;\n        float collectionRate = totalItems / totalDays;\n        \n        if (Math.abs(collectionRate - 0.3f) < 0.000001f) {\n            System.out.println(\"Collection rate is precise.\");\n        } else {\n            System.out.println(\"Collection rate has minor deviation.\");\n        }\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 7,
          "type": "floating_point_comparison",
          "description": "Using exact equality for floating-point comparison",
          "fix": "Use epsilon comparison: if (Math.abs(collectionRate - 0.3f) < 0.000001f)"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The calculation `3.0f / 10.0f` results in `0.3f`. However, due to the nature of floating-point representation, `0.3` often cannot be perfectly represented in binary, leading to a tiny precision error when stored. Therefore, `collectionRate == 0.3f` might evaluate to `false` even if mathematically they should be equal. The fix involves comparing `collectionRate` to `0.3f` within a small acceptable margin (epsilon) using `Math.abs(difference) < epsilon`, which robustly handles these precision issues."
    },
    "hints": {
      "1": "Floating-point numbers (`float` and `double`) cannot always perfectly represent decimal values in binary, leading to tiny inaccuracies.",
      "2": "Direct equality (`==`) comparison with `float` or `double` is often unreliable for values that are results of calculations.",
      "3": "A common way to compare floating-point numbers for \"equality\" is to check if their difference is smaller than a very small acceptable margin (epsilon)."
    }
  },
  {
    "id": 248,
    "subtopic_id": 6,
    "type": "code_fixer",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `WitnessEligibility` system checks if `witnessAge` is `18 or older`. However, the code uses `>` operator, leading to an incorrect output for a witness exactly 18. Fix the code to correctly include the age 18 in the eligible category.",
    "story_context": "The WitnessEligibility needs to check witness age. Your task is to fix the comparison operator.",
    "challenge_data": {
      "initial_code": "public class WitnessEligibility {\n    public static void main(String[] args) {\n        int witnessAge = 18;\n        if (witnessAge > 18) {\n            System.out.println(\"Witness is eligible.\");\n        } else {\n            System.out.println(\"Witness is not eligible.\");\n        }\n    }\n}",
      "expected_output": [
        "Witness is eligible."
      ],
      "solution_code": "public class WitnessEligibility {\n    public static void main(String[] args) {\n        int witnessAge = 18;\n        if (witnessAge >= 18) {\n            System.out.println(\"Witness is eligible.\");\n        } else {\n            System.out.println(\"Witness is not eligible.\");\n        }\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 4,
          "type": "comparison_operator",
          "description": "Using greater than instead of greater than or equal to",
          "fix": "Use greater than or equal to: if (witnessAge >= 18)"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code `if (witnessAge > 18)` checks if `witnessAge` is strictly greater than `18`. Since `witnessAge` is `18`, this condition is `false`, leading to the `else` block. The intent was to include `18` as eligible. The fix is to use the `>=` operator, which correctly evaluates `18 >= 18` as `true`, leading to the desired output."
    },
    "hints": {
      "1": "The `>` operator only checks if a value is strictly larger.",
      "2": "The phrase \"18 or older\" implies including the number `18` itself.",
      "3": "Which comparison operator means \"greater than or equal to\"?"
    }
  },
  {
    "id": 249,
    "subtopic_id": 6,
    "type": "code_fixer",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "An `EvidenceTagSorter` compares `tagID1` and `tagID2`. The code uses `<` operator, making it check for strictly less than, leading to an incorrect output when IDs are the same. Fix the code to correctly categorize tags as `same as or before` another.",
    "story_context": "The EvidenceTagSorter needs to sort evidence tags. Your task is to fix the comparison operator.",
    "challenge_data": {
      "initial_code": "public class EvidenceTagSorter {\n    public static void main(String[] args) {\n        int tagID1 = 50;\n        int tagID2 = 50;\n        if (tagID1 < tagID2) {\n            System.out.println(\"Tag 1 comes before or is same as Tag 2.\");\n        } else {\n            System.out.println(\"Tag 1 comes after Tag 2.\");\n        }\n    }\n}",
      "expected_output": [
        "Tag 1 comes before or is same as Tag 2."
      ],
      "solution_code": "public class EvidenceTagSorter {\n    public static void main(String[] args) {\n        int tagID1 = 50;\n        int tagID2 = 50;\n        if (tagID1 <= tagID2) {\n            System.out.println(\"Tag 1 comes before or is same as Tag 2.\");\n        } else {\n            System.out.println(\"Tag 1 comes after Tag 2.\");\n        }\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 5,
          "type": "comparison_operator",
          "description": "Using less than instead of less than or equal to",
          "fix": "Use less than or equal to: if (tagID1 <= tagID2)"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code `if (tagID1 < tagID2)` checks if `tagID1` is strictly less than `tagID2`. Since both IDs are `50`, this condition is `false`, leading to the `else` block. The intent was to include equality as part of the true condition (\"Tag 1 comes before or is same as Tag 2\"). The fix is to use the `<=` operator, which correctly evaluates `50 <= 50` as `true`, leading to the desired output."
    },
    "hints": {
      "1": "The `<` operator means \"strictly less than.\"",
      "2": "The phrase \"less than or equal to\" implies including the case where values are identical.",
      "3": "Which comparison operator specifically includes equality in a \"less than\" check?"
    }
  },
  {
    "id": 250,
    "subtopic_id": 6,
    "type": "code_fixer",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `SceneTemperatureChecker` calculates `sceneTemperature` and checks for exact equality with `25.0`. Due to potential floating-point inaccuracies, direct comparison might fail. Fix the code to robustly compare `sceneTemperature` for practical equality.",
    "story_context": "The SceneTemperatureChecker needs to check scene temperature. Your task is to fix the floating-point comparison.",
    "challenge_data": {
      "initial_code": "public class SceneTemperatureChecker {\n    public static void main(String[] args) {\n        double sceneTemperature = 200.0 / 8.0;\n        if (sceneTemperature == 25.0) {\n            System.out.println(\"Temperature is exact.\");\n        } else {\n            System.out.println(\"Temperature has slight deviation.\");\n        }\n    }\n}",
      "expected_output": [
        "Temperature is exact."
      ],
      "solution_code": "public class SceneTemperatureChecker {\n    public static void main(String[] args) {\n        double sceneTemperature = 200.0 / 8.0;\n        if (Math.abs(sceneTemperature - 25.0) < 0.0000001) {\n            System.out.println(\"Temperature is exact.\");\n        } else {\n            System.out.println(\"Temperature has slight deviation.\");\n        }\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 4,
          "type": "floating_point_comparison",
          "description": "Using exact equality for floating-point comparison",
          "fix": "Use epsilon comparison: if (Math.abs(sceneTemperature - 25.0) < 0.0000001)"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The calculation `200.0 / 8.0` is mathematically `25.0`. However, due to how `double` (and `float`) numbers are represented in binary, direct equality (`==`) comparisons can fail if there are tiny, imperceptible precision differences. While `25.0` *is* perfectly representable in binary, this challenge tests the general rule. The robust way to compare floating-point numbers for practical equality is to check if their absolute difference is smaller than a very small positive number (epsilon, like `0.0000001`). The fix uses `Math.abs(sceneTemperature - 25.0) < 0.0000001`."
    },
    "hints": {
      "1": "While `200.0 / 8.0` is mathematically `25.0`, internal binary floating-point representation can sometimes introduce tiny, invisible inaccuracies.",
      "2": "Direct equality (`==`) comparison of `double` values is generally unreliable if the values are results of calculations.",
      "3": "Use the `Math.abs()` method to check if the absolute difference between two numbers is less than a very small \"epsilon\" value."
    }
  },
  {
    "id": 251,
    "subtopic_id": 6,
    "type": "code_fixer",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `TransactionVerifier` compares `transactionAmount` (float) and `expectedAmount` (double). Due to different precision, a direct `==` comparison fails. Fix the code to robustly compare these floating-point amounts for practical equality.",
    "story_context": "The TransactionVerifier needs to verify transaction amounts. Your task is to fix the floating-point comparison.",
    "challenge_data": {
      "initial_code": "public class TransactionVerifier {\n    public static void main(String[] args) {\n        float transactionAmount = 100.0f / 3.0f;\n        double expectedAmount = 100.0 / 3.0;\n        \n        if (transactionAmount == expectedAmount) {\n            System.out.println(\"Amounts are an exact match.\");\n        } else {\n            System.out.println(\"Amounts have a slight discrepancy.\");\n        }\n    }\n}",
      "expected_output": [
        "Amounts are an exact match."
      ],
      "solution_code": "public class TransactionVerifier {\n    public static void main(String[] args) {\n        float transactionAmount = 100.0f / 3.0f;\n        double expectedAmount = 100.0 / 3.0;\n        \n        if (Math.abs(transactionAmount - expectedAmount) < 0.000001) {\n            System.out.println(\"Amounts are an exact match.\");\n        } else {\n            System.out.println(\"Amounts have a slight discrepancy.\");\n        }\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 7,
          "type": "floating_point_comparison",
          "description": "Using exact equality for different precision types",
          "fix": "Use epsilon comparison: if (Math.abs(transactionAmount - expectedAmount) < 0.000001)"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The calculation `100.0f / 3.0f` results in a `float` value (`33.333332f`), while `100.0 / 3.0` results in a more precise `double` value (`33.333333333333336d`). Even though they are conceptually the same number, their internal binary representations differ. Directly comparing them with `==` will return `false`. The fix involves using `Math.abs()` to check if the absolute difference between `transactionAmount` and `expectedAmount` is less than a very small \"epsilon\" value (e.g., `0.000001`), which correctly identifies them as practically equal."
    },
    "hints": {
      "1": "`float` provides less precision than `double`. Calculations involving `float`s can lead to different results than the same calculation with `double`s, even if mathematically identical.",
      "2": "Direct equality (`==`) comparisons between `float` and `double` values are highly unreliable due to these precision differences.",
      "3": "To accurately compare two floating-point numbers for practical equality, you should check if their absolute difference is extremely small."
    }
  },
  {
    "id": 252,
    "subtopic_id": 6,
    "type": "code_fixer",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `SuspectIdentityVerifier` compares `suspectName` (literal) and `profileName` (created with `toUpperCase()`). The code uses `==` for String comparison and assigns `true` to `discrepancyFound` inside the `if` condition. Fix the code to correctly compare String content and ensure `discrepancyFound` is initialized and updated properly.",
    "story_context": "The SuspectIdentityVerifier needs to verify suspect identity. Your task is to fix the string comparison and variable initialization.",
    "challenge_data": {
      "initial_code": "public class SuspectIdentityVerifier {\n    public static void main(String[] args) {\n        String suspectName = \"JOHN DOE\";\n        String profileName = \"John Doe\".toUpperCase();\n        \n        if (suspectName == profileName) {\n            System.out.println(\"Identity verified.\");\n            boolean discrepancyFound = false;\n        } else {\n            System.out.println(\"Identity suspicious.\");\n            boolean discrepancyFound = true;\n        }\n        System.out.println(\"Discrepancy Found: \" + discrepancyFound);\n    }\n}",
      "expected_output": [
        "Identity verified.",
        "Discrepancy Found: false"
      ],
      "solution_code": "public class SuspectIdentityVerifier {\n    public static void main(String[] args) {\n        String suspectName = \"JOHN DOE\";\n        String profileName = \"John Doe\".toUpperCase();\n        boolean discrepancyFound;\n        \n        if (suspectName.equals(profileName)) {\n            System.out.println(\"Identity verified.\");\n            discrepancyFound = false;\n        } else {\n            System.out.println(\"Identity suspicious.\");\n            discrepancyFound = true;\n        }\n        System.out.println(\"Discrepancy Found: \" + discrepancyFound);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 6,
          "type": "string_comparison",
          "description": "Using == instead of .equals() for String content comparison",
          "fix": "Use .equals() method: if (suspectName.equals(profileName))"
        },
        {
          "id": 2,
          "line": 8,
          "type": "variable_scope",
          "description": "Variable declared inside if block, not accessible outside",
          "fix": "Declare discrepancyFound outside if-else block"
        }
      ],
      "number_of_errors": 2,
      "explanation": "The original code has two problems:\n1.  **String comparison:** `suspectName` is a literal `\"JOHN DOE\"`, while `profileName` (`\"John Doe\".toUpperCase()`) creates a *new* `String` object, even though its content also becomes `\"JOHN DOE\"`. Using `==` compares their memory addresses, so `suspectName == profileName` evaluates to `false`. The fix is to use `.equals()` for content comparison.\n2.  **Uninitialized local variable:** `discrepancyFound` is declared *inside* the `if` and `else` blocks. This makes it a local variable within those blocks, and it's not accessible outside. Even if it were declared outside, Java's compiler requires it to be *definitely assigned* in all branches before use. The fix declares `discrepancyFound` outside the `if-else` block and assigns it in both branches, ensuring it's always initialized."
    },
    "hints": {
      "1": "For `String` objects, the `==` operator compares memory addresses, not the actual text content.",
      "2": "Methods like `.toUpperCase()` on a `String` often return a *new* `String` object.",
      "3": "To compare `String` content, always use the `.equals()` method."
    }
  },
  {
    "id": 253,
    "subtopic_id": 6,
    "type": "code_fixer",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "An `EvidenceRangeChecker` verifies if `rawEvidenceLevel` is `between 50 and 100` (inclusive). The code incorrectly uses logical `OR` (`||`), making the range check too permissive. Fix the code to use the correct logical operator for a strict range check.",
    "story_context": "The EvidenceRangeChecker needs to check evidence level range. Your task is to fix the logical operator.",
    "challenge_data": {
      "initial_code": "public class EvidenceRangeChecker {\n    public static void main(String[] args) {\n        int rawEvidenceLevel = 75;\n        int minLevel = 50;\n        int maxLevel = 100;\n        \n        if (rawEvidenceLevel >= minLevel || rawEvidenceLevel <= maxLevel) {\n            System.out.println(\"Evidence level is valid.\");\n        } else {\n            System.out.println(\"Evidence level is invalid.\");\n        }\n    }\n}",
      "expected_output": [
        "Evidence level is valid."
      ],
      "solution_code": "public class EvidenceRangeChecker {\n    public static void main(String[] args) {\n        int rawEvidenceLevel = 75;\n        int minLevel = 50;\n        int maxLevel = 100;\n        \n        if (rawEvidenceLevel >= minLevel && rawEvidenceLevel <= maxLevel) {\n            System.out.println(\"Evidence level is valid.\");\n        } else {\n            System.out.println(\"Evidence level is invalid.\");\n        }\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 7,
          "type": "logical_operator",
          "description": "Using OR instead of AND for range check",
          "fix": "Use logical AND: if (rawEvidenceLevel >= minLevel && rawEvidenceLevel <= maxLevel)"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code uses the logical `OR` (`||`) operator: `rawEvidenceLevel >= minLevel || rawEvidenceLevel <= maxLevel`. An `OR` condition is `true` if *any* of its parts are `true`. Since `rawEvidenceLevel` (`75`) is `true` for `75 >= 50`, the whole `OR` condition is `true`. However, for a range check \"between X and Y\", both conditions (`>= min` AND `<= max`) must hold simultaneously. The fix is to use the logical `AND` (`&&`) operator instead of `||`. `75 >= 50 && 75 <= 100` evaluates to `true && true`, which is `true`."
    },
    "hints": {
      "1": "To check if a value is *between* two limits (inclusive), both conditions (`>= min` and `<= max`) must be true.",
      "2": "The logical `OR` (`||`) operator means \"if at least one condition is true.\"",
      "3": "The logical `AND` (`&&`) operator means \"if both conditions are true.\""
    }
  },
  {
    "id": 254,
    "subtopic_id": 6,
    "type": "code_fixer",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "An `InterrogationResponseEvaluator` checks `responseTime` and `accuracyScore` for reliability. The code has issues with floating-point comparison and logical operator precedence, leading to an incorrect reliability assessment. Fix the code to ensure a precise and logically correct reliability check.",
    "story_context": "The InterrogationResponseEvaluator needs to evaluate response reliability. Your task is to fix the floating-point comparison and logical operators.",
    "challenge_data": {
      "initial_code": "public class InterrogationResponseEvaluator {\n    public static void main(String[] args) {\n        float responseTime = 10.0f / 10.0f;\n        int accuracyScore = 90;\n        \n        if (responseTime == 1.0f || accuracyScore > 80 && accuracyScore <= 90) {\n            System.out.println(\"Response is reliable.\");\n        } else {\n            System.out.println(\"Response is unreliable.\");\n        }\n    }\n}",
      "expected_output": [
        "Response is reliable."
      ],
      "solution_code": "public class InterrogationResponseEvaluator {\n    public static void main(String[] args) {\n        float responseTime = 10.0f / 10.0f;\n        int accuracyScore = 90;\n        \n        if (Math.abs(responseTime - 1.0f) < 0.000001f && accuracyScore > 80 && accuracyScore <= 90) {\n            System.out.println(\"Response is reliable.\");\n        } else {\n            System.out.println(\"Response is unreliable.\");\n        }\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 6,
          "type": "floating_point_comparison",
          "description": "Using exact equality for floating-point comparison",
          "fix": "Use epsilon comparison: Math.abs(responseTime - 1.0f) < 0.000001f"
        },
        {
          "id": 2,
          "line": 6,
          "type": "logical_operator",
          "description": "Using OR instead of AND for all conditions",
          "fix": "Use logical AND: && for all conditions"
        }
      ],
      "number_of_errors": 2,
      "explanation": "The original code has two problems:\n1.  **Floating-point comparison:** `responseTime == 1.0f` might fail due to subtle `float` precision issues, even though mathematically it's `1.0`. The fix uses an epsilon comparison `Math.abs(responseTime - 1.0f) < 0.000001f` for robustness.\n2.  **Logical precedence:** The condition `responseTime == 1.0f || accuracyScore > 80 && accuracyScore <= 90` is interpreted as `(responseTime == 1.0f) || (accuracyScore > 80 && accuracyScore <= 90)` due to `&&` having higher precedence than `||`. If `responseTime == 1.0f` is `true`, the rest of the condition isn't checked. The intended logic is that *all three* conditions (response time is effectively 1.0, and accuracy is within range) must be true. The fix uses `&&` as the primary connector and adds parentheses where necessary for clarity."
    },
    "hints": {
      "1": "Direct equality (`==`) for `float` numbers (especially results of calculations) is often problematic. Use an epsilon comparison (`Math.abs(diff) < epsilon`).",
      "2": "The logical `||` (OR) has lower precedence than `&&` (AND). Without parentheses, `A || B && C` means `A || (B && C)`.",
      "3": "To ensure all parts of a complex reliability check are true, the main connecting operator should be logical `AND`."
    }
  },
  {
    "id": 255,
    "subtopic_id": 6,
    "type": "code_fixer",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `SuspectDossierMatcher` compares three `dossierID` strings. The code incorrectly uses `==` for `String` comparisons, leading to inaccurate results for string content that is identical but references are different. Fix the code to correctly compare the textual content of the dossier IDs.",
    "story_context": "The SuspectDossierMatcher needs to match suspect dossiers. Your task is to fix the string comparisons.",
    "challenge_data": {
      "initial_code": "public class SuspectDossierMatcher {\n    public static void main(String[] args) {\n        String dossierID1 = \"CASE-XYZ\";\n        String dossierID2 = new String(\"CASE-XYZ\");\n        String dossierID3 = \"CASE\" + \"-XYZ\";\n        \n        boolean isConfirmedSuspect = false;\n        \n        if (dossierID1 == dossierID2 || dossierID2 == dossierID3 || dossierID1 == dossierID3) {\n            isConfirmedSuspect = true;\n        }\n        \n        System.out.println(\"Is Confirmed Suspect: \" + isConfirmedSuspect);\n    }\n}",
      "expected_output": [
        "Is Confirmed Suspect: true"
      ],
      "solution_code": "public class SuspectDossierMatcher {\n    public static void main(String[] args) {\n        String dossierID1 = \"CASE-XYZ\";\n        String dossierID2 = new String(\"CASE-XYZ\");\n        String dossierID3 = \"CASE\" + \"-XYZ\";\n        \n        boolean isConfirmedSuspect = false;\n        \n        if (dossierID1.equals(dossierID2) || dossierID2.equals(dossierID3) || dossierID1.equals(dossierID3)) {\n            isConfirmedSuspect = true;\n        }\n        \n        System.out.println(\"Is Confirmed Suspect: \" + isConfirmedSuspect);\n    }\n}",
      "errors": [
        {
          "id": 1,
          "line": 10,
          "type": "string_comparison",
          "description": "Using == instead of .equals() for String content comparison",
          "fix": "Use .equals() method: dossierID1.equals(dossierID2) || dossierID2.equals(dossierID3) || dossierID1.equals(dossierID3)"
        }
      ],
      "number_of_errors": 1,
      "explanation": "The original code uses `==` for String comparisons.\n1. `dossierID1 == dossierID2`: `false` (literal vs. new object).\n2. `dossierID2 == dossierID3`: `false` (new object vs. concatenated literal, which gets interned).\n3. `dossierID1 == dossierID3`: `true` (both are string literals/interned constants, so they point to the same object).\n\nBecause `dossierID1 == dossierID3` is `true` in the `else if` (or because `dossierID1 == dossierID2` or `dossierID2 == dossierID3` are checked first), `isConfirmedSuspect` eventually becomes `true` anyway, but the logic is misleading if content comparison is the intent.\n\nThe fix emphasizes using `.equals()` for content comparison, which is the robust way to check if strings are textually identical regardless of how they were created or where they reside in memory. The corrected code combines all necessary content comparisons with `||` in a single `if` statement, ensuring `isConfirmedSuspect` is `true` if any pair has matching content."
    },
    "hints": {
      "1": "The `==` operator for `String`s compares memory addresses. String literals (`\"abc\"`) often get interned (point to the same object), but `new String(\"abc\")` always creates a *new* object. Concatenated literals (`\"A\" + \"B\"`) might also be interned.",
      "2": "The `.equals()` method compares the actual *content* of `String` objects, regardless of where they are in memory.",
      "3": "To confirm a suspect based on *any* matching ID, use logical `OR` (`||`)."
    }
  },
  {
    "id": 256,
    "subtopic_id": 6,
    "type": "code_completion",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `CaseIDChecker` verifies if `currentCaseID` matches a specific value. Complete the comparison operator to correctly check for an exact match.",
    "story_context": "The CaseIDChecker needs to verify if a case ID matches a specific value. Your task is to complete the comparison operator.",
    "challenge_data": {
      "initial_code": "public class CaseIDChecker {\n    public static void main(String[] args) {\n        int currentCaseID = 101;\n        if (currentCaseID ??? 101) {\n            System.out.println(\"Case ID matches.\");\n        } else {\n            System.out.println(\"Case ID does not match.\");\n        }\n    }\n}",
      "expected_output": [
        "Case ID matches."
      ],
      "solution_code": "public class CaseIDChecker {\n    public static void main(String[] args) {\n        int currentCaseID = 101;\n        if (currentCaseID == 101) {\n            System.out.println(\"Case ID matches.\");\n        } else {\n            System.out.println(\"Case ID does not match.\");\n        }\n    }\n}",
      "choices": [
        "<",
        ">",
        "==",
        "="
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 4,
          "type": "operator",
          "description": "Equality comparison operator",
          "correct_answer": "==",
          "explanation": "To check if `currentCaseID` is exactly equal to `101`, the `==` operator is used. The condition `currentCaseID == 101` evaluates to `true`."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": "The goal is to check for `exact equality`.",
      "2": "Which comparison operator explicitly checks if two values are the same?",
      "3": "The blank needs a single operation symbol."
    }
  },
  {
    "id": 257,
    "subtopic_id": 6,
    "type": "code_completion",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "An `AgeEligibility` system checks if a `suspectAge` is `an adult` (strictly greater than 18). Complete the comparison operator to correctly determine adult status.",
    "story_context": "The AgeEligibility system needs to check if a suspect is an adult. Your task is to complete the comparison operator.",
    "challenge_data": {
      "initial_code": "public class AgeEligibility {\n    public static void main(String[] args) {\n        int suspectAge = 20;\n        if (suspectAge ??? 18) {\n            System.out.println(\"Suspect is an adult.\");\n        } else {\n            System.out.println(\"Suspect is not an adult.\");\n        }\n    }\n}",
      "expected_output": [
        "Suspect is an adult."
      ],
      "solution_code": "public class AgeEligibility {\n    public static void main(String[] args) {\n        int suspectAge = 20;\n        if (suspectAge > 18) {\n            System.out.println(\"Suspect is an adult.\");\n        } else {\n            System.out.println(\"Suspect is not an adult.\");\n        }\n    }\n}",
      "choices": [
        "<",
        ">",
        "==",
        "="
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 4,
          "type": "operator",
          "description": "Greater than comparison operator",
          "correct_answer": ">",
          "explanation": "To check if `suspectAge` is strictly greater than `18`, the `>` operator is used. The condition `suspectAge > 18` evaluates to `true`."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": "The goal is to check if the age is `strictly more than` 18.",
      "2": "Which comparison operator means \"greater than\"?",
      "3": "The blank needs a single operation symbol."
    }
  },
  {
    "id": 258,
    "subtopic_id": 6,
    "type": "code_completion",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `PriorityChecker` assigns `high priority` if `casePriority` is `less than or equal to 3`. Complete the comparison operator to correctly classify case priority.",
    "story_context": "The PriorityChecker needs to assign priority based on case priority values. Your task is to complete the comparison operator.",
    "challenge_data": {
      "initial_code": "public class PriorityChecker {\n    public static void main(String[] args) {\n        int casePriority = 3;\n        if (casePriority ??? 3) {\n            System.out.println(\"Case has high priority.\");\n        }\n        else {\n            System.out.println(\"Case has standard priority.\");\n        }\n    }\n}",
      "expected_output": [
        "Case has high priority."
      ],
      "solution_code": "public class PriorityChecker {\n    public static void main(String[] args) {\n        int casePriority = 3;\n        if (casePriority <= 3) {\n            System.out.println(\"Case has high priority.\");\n        }\n        else {\n            System.out.println(\"Case has standard priority.\");\n        }\n    }\n}",
      "choices": [
        ">",
        "<=",
        "=",
        "=="
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 4,
          "type": "operator",
          "description": "Less than or equal to comparison operator",
          "correct_answer": "<=",
          "explanation": "To check if `casePriority` is less than or equal to `3`, the `<=` operator is used. The condition `casePriority <= 3` evaluates to `true` (since `3` is equal to `3`)."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": "The goal is to include the value `3` itself in the \"high priority\" category.",
      "2": "Which comparison operator means \"less than or equal to\"?",
      "3": "The blank needs a single operation symbol."
    }
  },
  {
    "id": 259,
    "subtopic_id": 6,
    "type": "code_completion",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "An `IDValidator` checks if a `reportedCaseID` is `valid` (not equal to 0). Complete the comparison operator to correctly validate the case ID.",
    "story_context": "The IDValidator needs to check if a reported case ID is valid. Your task is to complete the comparison operator.",
    "challenge_data": {
      "initial_code": "public class IDValidator {\n    public static void main(String[] args) {\n        int reportedCaseID = 123;\n        if (reportedCaseID ??? 0) {\n            System.out.println(\"Valid Case ID.\");\n        } else {\n            System.out.println(\"Invalid Case ID.\");\n        }\n    }\n}",
      "expected_output": [
        "Valid Case ID."
      ],
      "solution_code": "public class IDValidator {\n    public static void main(String[] args) {\n        int reportedCaseID = 123;\n        if (reportedCaseID != 0) {\n            System.out.println(\"Valid Case ID.\");\n        } else {\n            System.out.println(\"Invalid Case ID.\");\n        }\n    }\n}",
      "choices": [
        "!=",
        "<",
        "=",
        "=="
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 4,
          "type": "operator",
          "description": "Not equal to comparison operator",
          "correct_answer": "!=",
          "explanation": "To check if `reportedCaseID` is not equal to `0`, the `!=` operator is used. The condition `reportedCaseID != 0` evaluates to `true` (since `123` is not equal to `0`)."
        }
      ],
      "number_of_slots": 1
    },
    "hints": {
      "1": "The goal is to check if the `reportedCaseID` is `different from` zero.",
      "2": "Which comparison operator means \"not equal to\"?",
      "3": "The blank needs a single operation symbol."
    }
  },
  {
    "id": 260,
    "subtopic_id": 6,
    "type": "code_completion",
    "difficulty": "easy",
    "timer": 300,
    "points": 10,
    "scenario": "A `StatementComparer` checks if two `String` statements have identical content. Complete the `String` method call and its argument to correctly compare the statements.",
    "story_context": "The StatementComparer needs to check if two String statements have identical content. Your task is to complete the String method call and argument.",
    "challenge_data": {
      "initial_code": "public class StatementComparer {\n    public static void main(String[] args) {\n        String statement1 = \"I saw nothing.\";\n        String statement2 = \"I saw nothing.\";\n        if (statement1.???(???)) {\n            System.out.println(\"Statements match.\");\n        } else {\n            System.out.println(\"Statements differ.\");\n        }\n    }\n}",
      "expected_output": [
        "Statements match."
      ],
      "solution_code": "public class StatementComparer {\n    public static void main(String[] args) {\n        String statement1 = \"I saw nothing.\";\n        String statement2 = \"I saw nothing.\";\n        if (statement1.equals(statement2)) {\n            System.out.println(\"Statements match.\");\n        } else {\n            System.out.println(\"Statements differ.\");\n        }\n    }\n}",
      "choices": [
        "equals",
        "statement2",
        "==",
        "statement1"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 5,
          "type": "method_call",
          "description": "String equals method",
          "correct_answer": "equals",
          "explanation": "To check if the *content* of two `String` objects is identical, the `.equals()` method is used."
        },
        {
          "id": "slot_2",
          "line": 5,
          "type": "method_argument",
          "description": "String variable argument",
          "correct_answer": "statement2",
          "explanation": "The method is called on `statement1`, and `statement2` is passed as its argument."
        }
      ],
      "number_of_slots": 2
    },
    "hints": {
      "1": "For non-primitive types like `String`, `==` compares memory locations, not content.",
      "2": "There's a specific `String` method designed for comparing the actual text.",
      "3": "The first blank is the method name, and the second blank is the variable to compare against."
    }
  },
  {
    "id": 261,
    "subtopic_id": 6,
    "type": "code_completion",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `FootageEvaluator` assesses `footageDuration`. If `footageDuration` is `at least 30` minutes AND `less than 60` minutes, it's within acceptable range. Complete the comparison operator and logical operator for this range check.",
    "story_context": "The FootageEvaluator needs to assess if footage duration is within acceptable range. Your task is to complete the comparison and logical operators.",
    "challenge_data": {
      "initial_code": "public class FootageEvaluator {\n    public static void main(String[] args) {\n        int footageDuration = 45;\n\n        if (footageDuration ??? 30 ??? footageDuration < 60) {\n            System.out.println(\"Footage duration is within acceptable range.\");\n        } else {\n            System.out.println(\"Footage duration is outside acceptable range.\");\n        }\n    }\n}",
      "expected_output": [
        "Footage duration is within acceptable range."
      ],
      "solution_code": "public class FootageEvaluator {\n    public static void main(String[] args) {\n        int footageDuration = 45;\n\n        if (footageDuration >= 30 && footageDuration < 60) {\n            System.out.println(\"Footage duration is within acceptable range.\");\n        } else {\n            System.out.println(\"Footage duration is outside acceptable range.\");\n        }\n    }\n}",
      "choices": [
        "<",
        "&&",
        ">",
        "||",
        ">=",
        "=="
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 5,
          "type": "operator",
          "description": "Greater than or equal to comparison operator",
          "correct_answer": ">=",
          "explanation": "To check for \"at least 30 minutes,\" the `>=` operator is used."
        },
        {
          "id": "slot_2",
          "line": 5,
          "type": "operator",
          "description": "Logical AND operator",
          "correct_answer": "&&",
          "explanation": "To combine the two conditions (`footageDuration >= 30` AND `footageDuration < 60`), the logical `AND` operator `&&` is used. This ensures both parts of the range check are true."
        }
      ],
      "number_of_slots": 2
    },
    "hints": {
      "1": "The phrase \"at least 30 minutes\" implies a specific comparison operator.",
      "2": "To check if a value falls `between` two limits, both conditions must be true simultaneously.",
      "3": "Which logical operator means \"both sides must be true\"?"
    }
  },
  {
    "id": 262,
    "subtopic_id": 6,
    "type": "code_completion",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "An `EvidenceStatusChecker` determines if `evidenceStatus` is `in active phase` if it's `\"Collected\"` OR `\"Processed\"`. Complete the `String` comparison method and the logical operator.",
    "story_context": "The EvidenceStatusChecker needs to determine if evidence status is in active phase. Your task is to complete the String comparison method and logical operator.",
    "challenge_data": {
      "initial_code": "public class EvidenceStatusChecker {\n    public static void main(String[] args) {\n        String evidenceStatus = \"Collected\";\n\n        if (evidenceStatus.???(\"Collected\") ??? evidenceStatus.equals(\"Processed\")) {\n            System.out.println(\"Evidence is in active phase.\");\n        } else {\n            System.out.println(\"Evidence is in inactive phase.\");\n        }\n    }\n}",
      "expected_output": [
        "Evidence is in active phase."
      ],
      "solution_code": "public class EvidenceStatusChecker {\n    public static void main(String[] args) {\n        String evidenceStatus = \"Collected\";\n\n        if (evidenceStatus.equals(\"Collected\") || evidenceStatus.equals(\"Processed\")) {\n            System.out.println(\"Evidence is in active phase.\");\n        } else {\n            System.out.println(\"Evidence is in inactive phase.\");\n        }\n    }\n}",
      "choices": [
        "!=",
        "&&",
        "||",
        "equals",
        "compareTo",
        "=="
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 5,
          "type": "method_call",
          "description": "String equals method",
          "correct_answer": "equals",
          "explanation": "To compare the `String` `evidenceStatus` with \"Collected\" and \"Processed\" by content, the `.equals()` method is used."
        },
        {
          "id": "slot_2",
          "line": 5,
          "type": "operator",
          "description": "Logical OR operator",
          "correct_answer": "||",
          "explanation": "To combine these two possibilities (`equals(\"Collected\")` OR `equals(\"Processed\")`), the logical `OR` operator `||` is used. This means the condition is `true` if `evidenceStatus` matches either \"Collected\" or \"Processed\"."
        }
      ],
      "number_of_slots": 2
    },
    "hints": {
      "1": "To compare the *content* of `String` objects, you need a specific method.",
      "2": "The word \"either... or\" in the scenario implies a particular logical operator.",
      "3": "Which logical operator means \"if at least one condition is true\"?"
    }
  },
  {
    "id": 263,
    "subtopic_id": 6,
    "type": "code_completion",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `WitnessCredibilityChecker` evaluates `witnessCredibility` and `witnessStatement`. A witness is `highly credible` if `credibility is above 7.5` AND the `statement is NOT \"Retracted\"`. Complete the comparison operator, logical AND, and logical NOT.",
    "story_context": "The WitnessCredibilityChecker needs to evaluate witness credibility and statement. Your task is to complete the comparison operator, logical AND, and logical NOT.",
    "challenge_data": {
      "initial_code": "public class WitnessCredibilityChecker {\n    public static void main(String[] args) {\n        double witnessCredibility = 8.0;\n        String witnessStatement = \"Consistent\";\n\n        if (witnessCredibility ??? 7.5 ??? (witnessStatement.equals(\"Retracted\"))) {\n            System.out.println(\"Witness is highly credible.\");\n        } else {\n            System.out.println(\"Witness credibility is questionable.\");\n        }\n    }\n}",
      "expected_output": [
        "Witness is highly credible."
      ],
      "solution_code": "public class WitnessCredibilityChecker {\n    public static void main(String[] args) {\n        double witnessCredibility = 8.0;\n        String witnessStatement = \"Consistent\";\n\n        if (witnessCredibility > 7.5 && !(witnessStatement.equals(\"Retracted\"))) {\n            System.out.println(\"Witness is highly credible.\");\n        } else {\n            System.out.println(\"Witness credibility is questionable.\");\n        }\n    }\n}",
      "choices": [
        "!=",
        "&&",
        ">",
        "||",
        ">=",
        "!"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 5,
          "type": "operator",
          "description": "Greater than comparison operator",
          "correct_answer": ">",
          "explanation": "To check for \"above 7.5,\" the `>` operator is used."
        },
        {
          "id": "slot_2",
          "line": 5,
          "type": "operator",
          "description": "Logical AND operator",
          "correct_answer": "&&",
          "explanation": "To combine the conditions with \"AND,\" the logical `&&` operator is used."
        },
        {
          "id": "slot_3",
          "line": 5,
          "type": "operator",
          "description": "Logical NOT operator",
          "correct_answer": "!",
          "explanation": "To check for \"not Retracted,\" the `!` (NOT) operator is used before the `equals()` method call, making the full comparison `!witnessStatement.equals(\"Retracted\")`."
        }
      ],
      "number_of_slots": 3
    },
    "hints": {
      "1": "The phrase \"above 7.5\" implies a specific comparison operator.",
      "2": "The problem states \"AND\" to combine the conditions.",
      "3": "The last part of the condition needs a way to say \"NOT equal to\" without modifying the `equals()` method itself."
    }
  },
  {
    "id": 264,
    "subtopic_id": 6,
    "type": "code_completion",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `DispatchPriority` system determines dispatch urgency based on `callTime` and `incidentType`. An `urgent dispatch` is initiated if `callTime is earlier than 0900` OR `incidentType is \"Critical\"`. Complete the comparison operator and logical OR.",
    "story_context": "The DispatchPriority system needs to determine dispatch urgency based on call time and incident type. Your task is to complete the comparison operator and logical OR.",
    "challenge_data": {
      "initial_code": "public class DispatchPriority {\n    public static void main(String[] args) {\n        int callTime = 830;\n        String incidentType = \"Standard\";\n\n        if (callTime ??? 900 ??? incidentType.equals(\"Critical\")) {\n            System.out.println(\"Urgent dispatch initiated.\");\n        } else {\n            System.out.println(\"Standard dispatch queue.\");\n        }\n    }\n}",
      "expected_output": [
        "Urgent dispatch initiated."
      ],
      "solution_code": "public class DispatchPriority {\n    public static void main(String[] args) {\n        int callTime = 830;\n        String incidentType = \"Standard\";\n\n        if (callTime < 900 || incidentType.equals(\"Critical\")) {\n            System.out.println(\"Urgent dispatch initiated.\");\n        } else {\n            System.out.println(\"Standard dispatch queue.\");\n        }\n    }\n}",
      "choices": [
        "<",
        "&&",
        "<=",
        ">",
        "||",
        "=="
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 5,
          "type": "operator",
          "description": "Less than comparison operator",
          "correct_answer": "<",
          "explanation": "To check for \"earlier than 0900,\" the `<` operator is used."
        },
        {
          "id": "slot_2",
          "line": 5,
          "type": "operator",
          "description": "Logical OR operator",
          "correct_answer": "||",
          "explanation": "To combine the two conditions (call time OR incident type), the logical `OR` operator `||` is used. This means the condition is `true` if either `callTime` is less than `900` or `incidentType` is \"Critical\"."
        }
      ],
      "number_of_slots": 2
    },
    "hints": {
      "1": "The phrase \"earlier than 0900\" implies a specific comparison operator.",
      "2": "The word \"OR\" in the scenario implies a particular logical operator.",
      "3": "Which logical operator means \"if at least one condition is true\"?"
    }
  },
  {
    "id": 265,
    "subtopic_id": 6,
    "type": "code_completion",
    "difficulty": "medium",
    "timer": 450,
    "points": 15,
    "scenario": "A `ReportApprovalChecker` approves a report if its `reportVersion` is `at least 3` AND `approvalStatus` is `true`. Complete the comparison operator and logical AND.",
    "story_context": "The ReportApprovalChecker needs to approve reports based on version and approval status. Your task is to complete the comparison operator and logical AND.",
    "challenge_data": {
      "initial_code": "public class ReportApprovalChecker {\n    public static void main(String[] args) {\n        int reportVersion = 4;\n        boolean approvalStatus = true;\n\n        if (reportVersion ??? 3 ??? approvalStatus) {\n            System.out.println(\"Report is approved for final submission.\");\n        } else {\n            System.out.println(\"Report needs further review.\");\n        }\n    }\n}",
      "expected_output": [
        "Report is approved for final submission."
      ],
      "solution_code": "public class ReportApprovalChecker {\n    public static void main(String[] args) {\n        int reportVersion = 4;\n        boolean approvalStatus = true;\n\n        if (reportVersion >= 3 && approvalStatus) {\n            System.out.println(\"Report is approved for final submission.\");\n        } else {\n            System.out.println(\"Report needs further review.\");\n        }\n    }\n}",
      "choices": [
        "!=",
        "&&",
        ">",
        "||",
        ">=",
        "=="
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 6,
          "type": "operator",
          "description": "Greater than or equal to comparison operator",
          "correct_answer": ">=",
          "explanation": "To check for \"at least 3,\" the `>=` operator is used."
        },
        {
          "id": "slot_2",
          "line": 6,
          "type": "operator",
          "description": "Logical AND operator",
          "correct_answer": "&&",
          "explanation": "To combine the two conditions (version AND approval status), the logical `AND` operator `&&` is used. This ensures both parts of the condition are true."
        }
      ],
      "number_of_slots": 2
    },
    "hints": {
      "1": "The phrase \"at least 3\" implies a specific comparison operator.",
      "2": "The word \"AND\" in the scenario implies a particular logical operator.",
      "3": "For a boolean variable like `approvalStatus`, you can use it directly in a condition without `== true`."
    }
  },
  {
    "id": 266,
    "subtopic_id": 6,
    "type": "code_completion",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `SuspectProfilerAdvanced` checks `suspectAge` (between 30 and 50 inclusive), `caseInvolvementScore` (above 75), OR `criminalRecordType` is \"Violent\". Complete the operators for this complex logical condition.",
    "story_context": "The SuspectProfilerAdvanced needs to check suspect criteria with complex logical conditions. Your task is to complete the operators.",
    "challenge_data": {
      "initial_code": "public class SuspectProfilerAdvanced {\n    public static void main(String[] args) {\n        int suspectAge = 40;\n        int caseInvolvementScore = 80;\n        String criminalRecordType = \"Non-Violent\";\n\n        if (suspectAge ??? 30 ??? suspectAge <= 50 ??? caseInvolvementScore > 75 ??? criminalRecordType.equals(\"Violent\")) {\n            System.out.println(\"Suspect meets high-priority criteria.\");\n        } else {\n            System.out.println(\"Suspect meets standard criteria.\");\n        }\n    }\n}",
      "expected_output": [
        "Suspect meets high-priority criteria."
      ],
      "solution_code": "public class SuspectProfilerAdvanced {\n    public static void main(String[] args) {\n        int suspectAge = 40;\n        int caseInvolvementScore = 80;\n        String criminalRecordType = \"Non-Violent\";\n\n        if (suspectAge >= 30 && suspectAge <= 50 && caseInvolvementScore > 75 || criminalRecordType.equals(\"Violent\")) {\n            System.out.println(\"Suspect meets high-priority criteria.\");\n        } else {\n            System.out.println(\"Suspect meets standard criteria.\");\n        }\n    }\n}",
      "choices": [
        "<",
        ">=",
        "!=",
        "&&",
        "<=",
        ">",
        "||",
        "=="
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 7,
          "type": "operator",
          "description": "Greater than or equal to comparison operator",
          "correct_answer": ">=",
          "explanation": "`>=` for `suspectAge >= 30` (inclusive lower bound)."
        },
        {
          "id": "slot_2",
          "line": 7,
          "type": "operator",
          "description": "Logical AND operator for age range",
          "correct_answer": "&&",
          "explanation": "`&&` to combine the age range (`suspectAge >= 30 && suspectAge <= 50`)."
        },
        {
          "id": "slot_3",
          "line": 7,
          "type": "operator",
          "description": "Logical AND operator for combined criteria",
          "correct_answer": "&&",
          "explanation": "`&&` to combine the age criteria with `caseInvolvementScore > 75`."
        },
        {
          "id": "slot_4",
          "line": 7,
          "type": "operator",
          "description": "Logical OR operator for criminal record",
          "correct_answer": "||",
          "explanation": "`||` to connect the combined conditions with `criminalRecordType.equals(\"Violent\")` (since `&&` has higher precedence, this correctly forms `((age_range && involvement_score) || criminal_record_type)`)."
        }
      ],
      "number_of_slots": 4
    },
    "hints": {
      "1": "The age range needs an inclusive lower bound operator.",
      "2": "A range check (like 'between X and Y') always uses a logical `AND`.",
      "3": "The combined criteria use `AND` for the age and score, but an `OR` for the `criminalRecordType`."
    }
  },
  {
    "id": 267,
    "subtopic_id": 6,
    "type": "code_completion",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `CipherValidator` checks if a cipher key is `valid` if its `keyLength` is `exactly 12` AND `securityLevel is at least 5`, OR if `specialCharacter` is `true`. Complete the operators for this complex logical condition.",
    "story_context": "The CipherValidator needs to check cipher key validity with complex logical conditions. Your task is to complete the operators.",
    "challenge_data": {
      "initial_code": "public class CipherValidator {\n    public static void main(String[] args) {\n        int keyLength = 12;\n        int securityLevel = 6;\n        boolean specialCharacter = false;\n\n        if (keyLength ??? 12 ??? securityLevel >= 5 ??? specialCharacter) {\n            System.out.println(\"Cipher key is valid.\");\n        } else {\n            System.out.println(\"Cipher key is invalid.\");\n        }\n    }\n}",
      "expected_output": [
        "Cipher key is valid."
      ],
      "solution_code": "public class CipherValidator {\n    public static void main(String[] args) {\n        int keyLength = 12;\n        int securityLevel = 6;\n        boolean specialCharacter = false;\n\n        if (keyLength == 12 && securityLevel >= 5 || specialCharacter) {\n            System.out.println(\"Cipher key is valid.\");\n        } else {\n            System.out.println(\"Cipher key is invalid.\");\n        }\n    }\n}",
      "choices": [
        "<",
        ">=",
        "!=",
        "&&",
        "<=",
        ">",
        "||",
        "=="
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 7,
          "type": "operator",
          "description": "Equality comparison operator",
          "correct_answer": "==",
          "explanation": "`==` is used for `keyLength == 12` (exact match)."
        },
        {
          "id": "slot_2",
          "line": 7,
          "type": "operator",
          "description": "Logical AND operator",
          "correct_answer": "&&",
          "explanation": "`&&` is used to combine `keyLength == 12` AND `securityLevel >= 5`."
        },
        {
          "id": "slot_3",
          "line": 7,
          "type": "operator",
          "description": "Logical OR operator",
          "correct_answer": "||",
          "explanation": "`||` is used to combine the first combined condition OR `specialCharacter`. This results in `(keyLength == 12 && securityLevel >= 5 || specialCharacter)`."
        }
      ],
      "number_of_slots": 3
    },
    "hints": {
      "1": "Checking for \"exactly 12\" requires a specific comparison operator.",
      "2": "The phrase \"at least 5\" requires another specific comparison operator.",
      "3": "The overall logic combines `(exact length AND min security)` OR `special character`."
    }
  },
  {
    "id": 268,
    "subtopic_id": 6,
    "type": "code_completion",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `TravelRecordVerifier` validates a `travelDistance` (double) against `maxDistanceAllowed` (float) and `isInternationalTravel` (boolean). The record is `valid` if distance is approximately equal AND it's NOT international travel. Complete the operators for this precise logical condition.",
    "story_context": "The TravelRecordVerifier needs to validate travel records with precise floating-point comparison. Your task is to complete the operators for the logical condition.",
    "challenge_data": {
      "initial_code": "public class TravelRecordVerifier {\n    public static void main(String[] args) {\n        double travelDistance = 150.0;\n        float maxDistanceAllowed = 150.0f;\n        boolean isInternationalTravel = false;\n\n        if (Math.abs(travelDistance ??? maxDistanceAllowed) < 0.00001 ??? isInternationalTravel) {\n            System.out.println(\"Travel record is valid.\");\n        } else {\n            System.out.println(\"Travel record is invalid.\");\n        }\n    }\n}",
      "expected_output": [
        "Travel record is valid."
      ],
      "solution_code": "public class TravelRecordVerifier {\n    public static void main(String[] args) {\n        double travelDistance = 150.0;\n        float maxDistanceAllowed = 150.0f;\n        boolean isInternationalTravel = false;\n\n        if (Math.abs(travelDistance - maxDistanceAllowed) < 0.00001 && !isInternationalTravel) {\n            System.out.println(\"Travel record is valid.\");\n        } else {\n            System.out.println(\"Travel record is invalid.\");\n        }\n    }\n}",
      "choices": [
        "-",
        "!",
        "&&",
        "/",
        "*",
        "+",
        "||",
        "=="
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 7,
          "type": "operator",
          "description": "Subtraction operator for absolute difference",
          "correct_answer": "-",
          "explanation": "`-` is used inside `Math.abs()` to find the absolute difference, which is compared to `0.00001f` (meaning not approximately equal)."
        },
        {
          "id": "slot_2",
          "line": 7,
          "type": "operator",
          "description": "Logical AND operator",
          "correct_answer": "&&",
          "explanation": "`&&` is the logical `AND` operator, combining the floating-point comparison with the `isInternationalTravel` check."
        },
        {
          "id": "slot_3",
          "line": 7,
          "type": "operator",
          "description": "Logical NOT operator",
          "correct_answer": "!",
          "explanation": "`!` is the logical `NOT` operator, used to negate `isInternationalTravel` (`!isInternationalTravel`) to check if it's `false`."
        }
      ],
      "number_of_slots": 3
    },
    "hints": {
      "1": "To robustly compare floating-point numbers for equality, you check if their `absolute difference` is small.",
      "2": "The overall logic combines two conditions with an `AND`.",
      "3": "To check if a boolean variable is `false`, you use a logical `NOT` operator."
    }
  },
  {
    "id": 269,
    "subtopic_id": 6,
    "type": "code_completion",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "A `TravelAnomalyDetector` flags a `travel log anomaly` if `lastEntry` is `NOT \"Home\"` AND `travelDistance` is `greater than 500`, OR if `lastEntry` has `length 0`. Complete the operators and `String` methods for this complex anomaly detection.",
    "story_context": "The TravelAnomalyDetector needs to flag travel log anomalies based on complex conditions. Your task is to complete the operators and String methods.",
    "challenge_data": {
      "initial_code": "public class TravelAnomalyDetector {\n    public static void main(String[] args) {\n        String lastEntry = \"Office\";\n        int travelDistance = 600;\n\n        if (??? lastEntry.???(\"Home\") ??? travelDistance > 500 ??? lastEntry.length() == 0) {\n            System.out.println(\"Travel log anomaly detected.\");\n        } else {\n            System.out.println(\"Travel log seems normal.\");\n        }\n    }\n}",
      "expected_output": [
        "Travel log anomaly detected."
      ],
      "solution_code": "public class TravelAnomalyDetector {\n    public static void main(String[] args) {\n        String lastEntry = \"Office\";\n        int travelDistance = 600;\n\n        if (!lastEntry.equals(\"Home\") && travelDistance > 500 || lastEntry.length() == 0) {\n            System.out.println(\"Travel log anomaly detected.\");\n        } else {\n            System.out.println(\"Travel log seems normal.\");\n        }\n    }\n}",
      "choices": [
        "equals",
        "!",
        "!=",
        "&&",
        ">",
        "||",
        "contains",
        "equalsIgnoreCase"
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 6,
          "type": "operator",
          "description": "Logical NOT operator",
          "correct_answer": "!",
          "explanation": "The first blank needs the logical `NOT` operator `!` to check for \"not Home.\""
        },
        {
          "id": "slot_2",
          "line": 6,
          "type": "method_call",
          "description": "String equals method",
          "correct_answer": "equals",
          "explanation": "`equals` is used for `lastEntry.equals(\"Home\")` to compare content."
        },
        {
          "id": "slot_3",
          "line": 6,
          "type": "operator",
          "description": "Logical AND operator",
          "correct_answer": "&&",
          "explanation": "`&&` is used to combine `(not Home)` AND `travelDistance > 500`."
        },
        {
          "id": "slot_4",
          "line": 6,
          "type": "operator",
          "description": "Logical OR operator",
          "correct_answer": "||",
          "explanation": "`||` is used to combine the first set of conditions OR `lastEntry.length() == 0`."
        }
      ],
      "number_of_slots": 4
    },
    "hints": {
      "1": "The condition for `lastEntry` should be \"not equal to 'Home'\". Remember the operator to negate a boolean result.",
      "2": "The initial two conditions are combined with `AND` (for the anomaly).",
      "3": "The final part of the condition (empty string) is connected using `OR`."
    }
  },
  {
    "id": 270,
    "subtopic_id": 6,
    "type": "code_completion",
    "difficulty": "hard",
    "timer": 600,
    "points": 20,
    "scenario": "An `AuditExceptionDetector` triggers an `exception` if `reportVersion` is `not approximately 1.0` OR `approvalCode` is `\"FAILED\"` AND (`reportTime` is `less than 0` OR `greater than 24`). Complete the operators for this complex nested logical condition.",
    "story_context": "The AuditExceptionDetector needs to trigger exceptions based on complex nested logical conditions. Your task is to complete the operators.",
    "challenge_data": {
      "initial_code": "public class AuditExceptionDetector {\n    public static void main(String[] args) {\n        float reportVersion = 0.999999f;\n        String approvalCode = \"FAILED\";\n        int reportTime = 25;\n\n        if (Math.abs(reportVersion ??? 1.0f) > 0.0001f ??? approvalCode.equals(\"FAILED\") ??? (reportTime < 0 ??? reportTime > 24)) {\n            System.out.println(\"Audit exception triggered.\");\n        } else {\n            System.out.println(\"Audit is clear.\");\n        }\n    }\n}",
      "expected_output": [
        "Audit exception triggered."
      ],
      "solution_code": "public class AuditExceptionDetector {\n    public static void main(String[] args) {\n        float reportVersion = 0.999999f;\n        String approvalCode = \"FAILED\";\n        int reportTime = 25;\n\n        if (Math.abs(reportVersion - 1.0f) > 0.0001f || approvalCode.equals(\"FAILED\") && (reportTime < 0 || reportTime > 24)) {\n            System.out.println(\"Audit exception triggered.\");\n        } else {\n            System.out.println(\"Audit is clear.\");\n        }\n    }\n}",
      "choices": [
        "<",
        "-",
        "&&",
        ">",
        "*",
        "+",
        "||",
        "=="
      ],
      "completion_slots": [
        {
          "id": "slot_1",
          "line": 7,
          "type": "operator",
          "description": "Subtraction operator for absolute difference",
          "correct_answer": "-",
          "explanation": "`-` is used inside `Math.abs()` to find the absolute difference, which is compared to `0.0001f` (meaning not approximately equal)."
        },
        {
          "id": "slot_2",
          "line": 7,
          "type": "operator",
          "description": "Logical OR operator for first condition",
          "correct_answer": "||",
          "explanation": "`||` combines the floating-point check OR the rest of the condition."
        },
        {
          "id": "slot_3",
          "line": 7,
          "type": "operator",
          "description": "Logical AND operator for nested condition",
          "correct_answer": "&&",
          "explanation": "`&&` combines the `approvalCode` check AND the `reportTime` check."
        },
        {
          "id": "slot_4",
          "line": 7,
          "type": "operator",
          "description": "Logical OR operator for time range",
          "correct_answer": "||",
          "explanation": "`||` combines `reportTime < 0` OR `reportTime > 24`."
        }
      ],
      "number_of_slots": 4
    },
    "hints": {
      "1": "The first blank needs the operator for finding the `absolute difference` to check approximate floating-point equality (or inequality).",
      "2": "The first `OR` combines the report version check with the `approvalCode` part.",
      "3": "The second `AND` connects `approvalCode` check with the `reportTime` check."
    }
  },
  {
      "id": 271,
      "subtopic_id": 7,
      "type": "output_tracing",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinder's shield system is receiving conflicting energy readings. Your task is to trace the AI's decision-making to determine what status message it will output based on the ship's current energy level. Help the system decide whether the shields are good to go or if there's trouble on the horizon.",
      "story_context": "The Pathfinder's shield system needs to monitor energy levels and make decisions about shield status. Your task is to trace the if-else logic and predict the output.",
      "challenge_data": {
        "code": "public class DecisionCore {\n    public static void main(String[] args) {\n        int energyLevel = 75;\n\n        if (energyLevel > 80) {\n            System.out.println(\"Shields at full capacity.\");\n        } else {\n            System.out.println(\"Warning: Shields below optimal level.\");\n        }\n    }\n}",
        "expected_output": [
          "Warning: Shields below optimal level."
        ],
        "choices": [
          "Shields at full capacity.",
          "Warning: Shields below optimal level.",
          "Energy overload detected.",
          "System offline."
        ],
        "explanation": "The energyLevel is 75, which is not greater than 80. That means the condition in the if block is false, so the else block executes instead."
      },
      "hints": {
        "1": "Look closely at the condition: is energyLevel > 80 true or false?",
        "2": "Remember how if-else works â€” one block executes, not both.",
        "3": "Just because the value is high doesn't mean it passes the threshold."
      }
    },
    {
      "id": 272,
      "subtopic_id": 7,
      "type": "output_tracing",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "You're in the Pathfinder's life support bay. The oxygen regulator is acting up. The system checks the oxygen level and decides whether it's safe for the crew to roam without helmets. Your task: trace what the AI will decide based on the oxygenLevel reading.",
      "story_context": "The Pathfinder's life support system needs to monitor oxygen levels and make decisions about crew safety. Your task is to trace the if-else logic and predict the output.",
      "challenge_data": {
        "code": "public class LifeSupportCheck {\n    public static void main(String[] args) {\n        int oxygenLevel = 21;\n\n        if (oxygenLevel == 20) {\n            System.out.println(\"Oxygen stable.\");\n        } else {\n            System.out.println(\"Oxygen level abnormal.\");\n        }\n    }\n}",
        "expected_output": [
          "Oxygen level abnormal."
        ],
        "choices": [
          "Oxygen stable.",
          "Oxygen level abnormal.",
          "Life support shutting down.",
          "Helmet required."
        ],
        "explanation": "The code checks if oxygenLevel == 20, but oxygenLevel is 21, so the condition is false. That means it skips the if block and runs the else block, printing 'Oxygen level abnormal.'. This teaches the importance of precision in logic â€” the AI doesn't do \"close enough,\" it does exact matches."
      },
      "hints": {
        "1": "Is == the same as = ? (Don't confuse assignment with comparison!)",
        "2": "Check if the condition is exactly true â€” not close enough, not greater, not less.",
        "3": "Off by 1 can be deadly in spaceâ€¦ and in logic."
      }
    },
    {
      "id": 273,
      "subtopic_id": 7,
      "type": "output_tracing",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "A temperature regulator in the engine bay is making strange decisions. It decides whether to activate cooling based on the current temperature reading. You must analyze the code and figure out what the Pathfinder's system will output with the current temperature input.",
      "story_context": "The Pathfinder's engine cooling system needs to monitor temperature and make decisions about cooling activation. Your task is to trace the if-else logic and predict the output.",
      "challenge_data": {
        "code": "public class EngineCoolingSystem {\n    public static void main(String[] args) {\n        int temperature = 90;\n\n        if (temperature >= 100) {\n            System.out.println(\"Activating cooling system.\");\n        } else {\n            System.out.println(\"Temperature within safe range.\");\n        }\n    }\n}",
        "expected_output": [
          "Temperature within safe range."
        ],
        "choices": [
          "Activating cooling system.",
          "Temperature within safe range.",
          "Emergency shutdown.",
          "Engine overheating detected."
        ],
        "explanation": "The variable temperature is 90, and the condition checks if it's greater than or equal to 100. That's false, so the else block executes. Therefore, the output is: 'Temperature within safe range.'. This reinforces a key lesson: conditions must be met exactly for the if block to run. No assumptions â€” just clean, logical decision-making like a proper AI system."
      },
      "hints": {
        "1": "Focus on the comparison operator: is 90 greater than or equal to 100?",
        "2": "If the condition isn't true, which block runs?",
        "3": "The else block always catches the \"otherwise\" case."
      }
    },
    {
      "id": 274,
      "subtopic_id": 7,
      "type": "output_tracing",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The docking AI must decide whether to allow a cargo ship to dock based on its clearance code. The system only allows ships with a clearance code of 5 to dock without alerting security. Your task: analyze the AI's logic and determine what it will output for the current code.",
      "story_context": "The Pathfinder's docking control system needs to verify clearance codes and make decisions about ship docking. Your task is to trace the if-else logic and predict the output.",
      "challenge_data": {
        "code": "public class DockingControl {\n    public static void main(String[] args) {\n        int clearanceCode = 3;\n\n        if (clearanceCode == 5) {\n            System.out.println(\"Docking approved.\");\n        } else {\n            System.out.println(\"Unauthorized ship detected.\");\n        }\n    }\n}",
        "expected_output": [
          "Unauthorized ship detected."
        ],
        "choices": [
          "Docking approved.",
          "Unauthorized ship detected.",
          "Ship denied: invalid code.",
          "Stand by for manual override."
        ],
        "explanation": "The code checks if clearanceCode == 5, but the actual value is 3 â€” not a match. So, the if condition fails and the else block runs, printing 'Unauthorized ship detected.'. This challenge drills the concept that if-else doesn't guess or round off. It expects your logic to be exact, like a laser-guided missile."
      },
      "hints": {
        "1": "Remember, == checks for exact equality â€” is 3 == 5 ?",
        "2": "Only one condition is checked here â€” what happens if it's false?",
        "3": "Don't let numbers trick you â€” close â‰  correct."
      }
    },
    {
      "id": 275,
      "subtopic_id": 7,
      "type": "output_tracing",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "You've accessed the Pathfinder's nutrition distribution module. It checks crew member rank to decide which meal to serve. Your job is to trace the AI's logic and find out what meal a crew member with a specific rank gets.",
      "story_context": "The Pathfinder's nutrition distribution system needs to check crew ranks and make decisions about meal distribution. Your task is to trace the if-else if-else logic and predict the output.",
      "challenge_data": {
        "code": "public class MealDistributor {\n    public static void main(String[] args) {\n        String rank = \"Lieutenant\";\n\n        if (rank.equals(\"Captain\")) {\n            System.out.println(\"Serving premium steak.\");\n        } else if (rank.equals(\"Commander\")) {\n            System.out.println(\"Serving energy pasta.\");\n        } else {\n            System.out.println(\"Serving standard rations.\");\n        }\n    }\n}",
        "expected_output": [
          "Serving standard rations."
        ],
        "choices": [
          "Serving premium steak.",
          "Serving energy pasta.",
          "Serving standard rations.",
          "Invalid rank detected."
        ],
        "explanation": "rank is \"Lieutenant\", which doesn't match \"Captain\" or \"Commander\" in the if or else if conditions. Since both fail, the code falls to the else block, printing 'Serving standard rations.'. This version introduces branching logic (else if) â€” useful for multi-decision AI systems and a natural upgrade path from simple if-else."
      },
      "hints": {
        "1": ".equals() is the proper way to compare strings in Java â€” don't use == for objects like String.",
        "2": "The AI checks the first match â€” if no match, it lands on else.",
        "3": "The rank is Lieutenant, not Captain or Commander."
      }
    },
    {
      "id": 276,
      "subtopic_id": 7,
      "type": "output_tracing",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "You're debugging the Pathfinder's security clearance scanner. It must scan crew credentials and respond accordingly. The AI considers both rank and accessLevel before granting or denying room access. Trace the decisions and determine what two messages the scanner will output.",
      "story_context": "The Pathfinder's security clearance system needs to verify crew credentials and make decisions about access. Your task is to trace the if-else if-else logic and predict the outputs.",
      "challenge_data": {
        "code": "public class SecurityClearance {\n    public static void main(String[] args) {\n        String rank = \"Technician\";\n        int accessLevel = 3;\n\n        if (rank.equals(\"Captain\") && accessLevel >= 5) {\n            System.out.println(\"Access to Command Deck granted.\");\n        } else if (rank.equals(\"Technician\") && accessLevel >= 3) {\n            System.out.println(\"Access to Engineering Bay granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n\n        System.out.println(\"Scan complete.\");\n    }\n}",
        "expected_output": [
          "Access to Engineering Bay granted.",
          "Scan complete."
        ],
        "choices": [
          "Access to Command Deck granted.",
          "Access to Engineering Bay granted.",
          "Access denied.",
          "Scan complete.",
          "Technician"
        ],
        "explanation": "The variables are: rank = \"Technician\", accessLevel = 3. The first condition (rank.equals(\"Captain\") && accessLevel >= 5) is false. The second condition (rank.equals(\"Technician\") && accessLevel >= 3) is true, so this block runs and prints 'Access to Engineering Bay granted.'. After the conditional block, the program always prints 'Scan complete.'."
      },
      "hints": {
        "1": "The && operator means both conditions must be true.",
        "2": "Each if, else if, or else only prints one line â€” but the second System.out.println is outside that block.",
        "3": "Don't stop at the first output â€” check the whole main."
      }
    },
    {
      "id": 277,
      "subtopic_id": 7,
      "type": "output_tracing",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "You're investigating a report from the Pathfinder's climate control system. It decides which deck gets heating based on temperature and deck status. Your task: trace how the system chooses to respond when evaluating both inputs.",
      "story_context": "The Pathfinder's climate control system needs to monitor temperature and deck status to make heating decisions. Your task is to trace the nested if-else logic and predict the outputs.",
      "challenge_data": {
        "code": "public class ClimateControl {\n    public static void main(String[] args) {\n        int temperature = 16;\n        String deckStatus = \"active\";\n\n        if (temperature < 18) {\n            if (deckStatus.equals(\"active\")) {\n                System.out.println(\"Heating activated for active deck.\");\n            } else {\n                System.out.println(\"Heating on standby due to inactive deck.\");\n            }\n        } else if (temperature >= 18 && temperature <= 24) {\n            System.out.println(\"Temperature is optimal. No action needed.\");\n        } else {\n            System.out.println(\"Cooling system on standby.\");\n        }\n\n        System.out.println(\"Climate check complete.\");\n    }\n}",
        "expected_output": [
          "Heating activated for active deck.",
          "Climate check complete."
        ],
        "choices": [
          "Heating activated for active deck.",
          "Heating on standby due to inactive deck.",
          "Temperature is optimal. No action needed.",
          "Climate check complete.",
          "active"
        ],
        "explanation": "temperature = 16 â†’ less than 18. This enters the first if block, which contains a nested check: deckStatus.equals(\"active\") â†’ true â†’ Prints: 'Heating activated for active deck.'. Afterward, we hit the unconditional line: 'Climate check complete.'. So, the full output is: 'Heating activated for active deck. Climate check complete.'"
      },
      "hints": {
        "1": "The first condition is temperature < 18. That alone decides which branch we're in.",
        "2": "Look closely: there's a nested if â€” make sure you check deckStatus.",
        "3": "What line runs no matter what? Look outside the conditional block."
      }
    },
    {
      "id": 278,
      "subtopic_id": 7,
      "type": "output_tracing",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinder's docking system checks for two things before allowing a supply pod to dock: if docking is enabled and if the fuel level is above minimum. The system reports actions depending on these conditions. Your task: determine what decisions it makes â€” and trace the two outputs it generates.",
      "story_context": "The Pathfinder's docking system needs to verify docking status and fuel levels to make docking decisions. Your task is to trace the nested if-else logic and predict the outputs.",
      "challenge_data": {
        "code": "public class DockingSystem {\n    public static void main(String[] args) {\n        boolean dockingEnabled = true;\n        int fuelLevel = 45;\n\n        if (dockingEnabled) {\n            if (fuelLevel >= 50) {\n                System.out.println(\"Docking approved.\");\n            } else {\n                System.out.println(\"Insufficient fuel for docking.\");\n            }\n        } else if (!dockingEnabled) {\n            System.out.println(\"Docking system offline.\");\n        } else {\n            System.out.println(\"Unexpected error.\");\n        }\n\n        System.out.println(\"Docking sequence checked.\");\n    }\n}",
        "expected_output": [
          "Insufficient fuel for docking.",
          "Docking sequence checked."
        ],
        "choices": [
          "Docking approved.",
          "Insufficient fuel for docking.",
          "Docking system offline.",
          "Docking sequence checked.",
          "true"
        ],
        "explanation": "dockingEnabled = true â†’ enters the first if. Inside that: fuelLevel = 45, which is less than 50 â†’ Prints: 'Insufficient fuel for docking.'. Outside the conditionals: Prints: 'Docking sequence checked.'."
      },
      "hints": {
        "1": "The condition if (dockingEnabled) is true â€” so it goes inside that block.",
        "2": "Within that, check the fuel level â€” is it enough?",
        "3": "The final System.out.println always runs, regardless of conditionals."
      }
    },
    {
      "id": 279,
      "subtopic_id": 7,
      "type": "output_tracing",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinder's diagnostics unit receives a system status code that it must interpret and log. Your task is to trace the logic that matches the code to its corresponding message, and identify the output the system prints.",
      "story_context": "The Pathfinder's diagnostics system needs to interpret status codes and log appropriate messages. Your task is to trace the if-else if-else logic and predict the outputs.",
      "challenge_data": {
        "code": "public class DiagnosticLog {\n    public static void main(String[] args) {\n        int statusCode = 300;\n\n        if (statusCode == 200) {\n            System.out.println(\"All systems nominal.\");\n        } else if (statusCode >= 300 && statusCode < 400) {\n            System.out.println(\"Warning: Minor anomalies detected.\");\n        } else if (statusCode >= 400) {\n            System.out.println(\"Critical failure in subsystem.\");\n        } else {\n            System.out.println(\"Unknown status code.\");\n        }\n\n        System.out.println(\"Diagnostics complete.\");\n    }\n}",
        "expected_output": [
          "Warning: Minor anomalies detected.",
          "Diagnostics complete."
        ],
        "choices": [
          "All systems nominal.",
          "Warning: Minor anomalies detected.",
          "Critical failure in subsystem.",
          "Diagnostics complete.",
          "Error"
        ],
        "explanation": "statusCode = 300. statusCode == 200 â†’ false. statusCode >= 300 && statusCode < 400 â†’ true â†’ Prints: 'Warning: Minor anomalies detected.'. The final print statement always executes: â†’ 'Diagnostics complete.'. So the output is: 'Warning: Minor anomalies detected. Diagnostics complete.'"
      },
      "hints": {
        "1": "Is statusCode == 200 true? If not, skip that block.",
        "2": "Look at the range check: between 300 and 400?",
        "3": "There's always one line printed after all conditions â€” regardless of outcome."
      }
    },
    {
      "id": 280,
      "subtopic_id": 7,
      "type": "output_tracing",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinder is calculating emergency power allocation. Depending on how much energy is left and the priority level of the system, the AI assigns a number of units for backup use. Your task: trace what numerical outputs the AI prints based on its conditions.",
      "story_context": "The Pathfinder's power allocation system needs to calculate backup units based on energy levels and priority. Your task is to trace the if-else if-else logic and predict the numerical outputs.",
      "challenge_data": {
        "code": "public class PowerAllocation {\n    public static void main(String[] args) {\n        int energyLeft = 75;\n        int priorityLevel = 2;\n\n        if (priorityLevel == 1) {\n            System.out.println(energyLeft - 20);\n        } else if (priorityLevel == 2 && energyLeft >= 70) {\n            System.out.println(energyLeft - 30);\n        } else if (priorityLevel == 3) {\n            System.out.println(energyLeft - 50);\n        } else {\n            System.out.println(0);\n        }\n\n        System.out.println(energyLeft + 10);\n    }\n}",
        "expected_output": [
          "45",
          "85"
        ],
        "choices": [
          "55",
          "45",
          "25",
          "85",
          "2"
        ],
        "explanation": "priorityLevel == 2 â†’ true. energyLeft = 75 â†’ true >= 70. So it goes into this block: System.out.println(energyLeft - 30); â†’ 75 - 30 = 45. Then the always-executed line: System.out.println(energyLeft + 10); â†’ 75 + 10 = 85."
      },
      "hints": {
        "1": "Check if priorityLevel == 2 and if energyLeft >= 70 is true.",
        "2": "Do the math: subtract from energyLeft in the right block.",
        "3": "The last line adds 10 â€” it runs no matter what."
      }
    },
    {
      "id": 281,
      "subtopic_id": 7,
      "type": "output_tracing",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinder's AI is executing a deep diagnostic of its navigation system. Based on the current mode and fuel level, it returns early if critical errors are found. Your job is to trace which values get printed before the system returns â€” or never gets there at all. Tread carefully: not all paths reach the final print statement.",
      "story_context": "The Pathfinder's navigation system needs to perform deep diagnostics and may return early based on critical errors. Your task is to trace the if-else if logic with early returns and predict the outputs.",
      "challenge_data": {
        "code": "public class NavigationCheck {\n    public static void main(String[] args) {\n        int mode = 3;\n        int fuel = 40;\n\n        if (mode == 1) {\n            System.out.println(100);\n            return;\n        } else if (mode == 2 && fuel > 50) {\n            System.out.println(200);\n            return;\n        } else if (mode == 3) {\n            if (fuel < 30) {\n                System.out.println(300);\n                return;\n            } else {\n                System.out.println(400);\n            }\n        }\n\n        System.out.println(500);\n        System.out.println(600);\n    }\n}",
        "expected_output": [
          "400",
          "500",
          "600"
        ],
        "choices": [
          "100",
          "400",
          "500",
          "600",
          "200",
          "300"
        ],
        "explanation": "mode = 3, so it enters the last else if. Inside that: fuel = 40, which is not less than 30, so it skips the inner if return. It goes to System.out.println(400);. Since there's no return after printing 400, it continues execution. Prints 500 and 600."
      },
      "hints": {
        "1": "The method uses return â€” once it hits that, it stops the entire main.",
        "2": "Only one return is avoided â€” think carefully which path does not return early.",
        "3": "The final two print statements only happen if the return is not triggered."
      }
    },
    {
      "id": 282,
      "subtopic_id": 7,
      "type": "output_tracing",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinder's AI is validating a sequence of energy pulses. The AI receives a number and evaluates its properties â€” even or odd, divisibility, and signal strength, returning early if anomalies are found. You must trace which pulses are successfully logged before the system halts.",
      "story_context": "The Pathfinder's pulse analyzer needs to validate energy pulses and may return early based on anomalies. Your task is to trace the if-else if logic with early returns and predict the outputs.",
      "challenge_data": {
        "code": "public class PulseAnalyzer {\n    public static void main(String[] args) {\n        int pulse = 15;\n\n        if (pulse % 2 == 0) {\n            System.out.println(10);\n            return;\n        }\n\n        if (pulse % 3 == 0) {\n            System.out.println(20);\n        } else if (pulse % 5 == 0) {\n            System.out.println(30);\n            return;\n        }\n\n        System.out.println(40);\n\n        if (pulse > 10 && pulse < 20) {\n            System.out.println(50);\n        }\n    }\n}",
        "expected_output": [
          "20",
          "40",
          "50"
        ],
        "choices": [
          "10",
          "30",
          "40",
          "50",
          "20",
          "60"
        ],
        "explanation": "pulse = 15. 15 % 2 != 0 â†’ first block is skipped. 15 % 3 == 0 â†’ true â†’ prints 20. The else if is ignored because the if before it was true. So return inside the else if does NOT trigger. Execution continues. Prints 40. pulse > 10 && pulse < 20 â†’ true so prints 50."
      },
      "hints": {
        "1": "The first if checks evenness â€” that will skip.",
        "2": "% 3 and % 5 conditions are tricky â€” both might be true.",
        "3": "Look out â€” not every true condition has a return."
      }
    },
    {
      "id": 283,
      "subtopic_id": 7,
      "type": "output_tracing",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "You're assigned to the Pathfinder's Reactor Core Calibration Unit. It checks numeric inputs for anomaly patterns. If the calibration is unstable, the system returns early to avoid meltdown. But not all instability is what it seems â€” it's up to you to trace which logs are actually printed.",
      "story_context": "The Pathfinder's reactor calibration system needs to check for anomaly patterns and may return early to avoid meltdown. Your task is to trace the if-else logic with early returns and predict the outputs.",
      "challenge_data": {
        "code": "public class ReactorCalibration {\n    public static void main(String[] args) {\n        int input = 12;\n\n        if (input % 4 == 0 && input % 6 == 0) {\n            System.out.println(100);\n        } else {\n            System.out.println(200);\n            return;\n        }\n\n        if (input < 10 || input > 20) {\n            System.out.println(300);\n        }\n\n        if (input == 12) {\n            System.out.println(400);\n        }\n\n        System.out.println(500);\n    }\n}",
        "expected_output": [
          "100",
          "400",
          "500"
        ],
        "choices": [
          "200",
          "300",
          "400",
          "500",
          "100",
          "600"
        ],
        "explanation": "input = 12. 12 % 4 == 0 true and 12 % 6 == 0 true â†’ First condition is true â†’ prints 100, skips the else and no return triggered. Next: input < 10 || input > 20 â†’ 12 is not less than 10 nor greater than 20 â†’ false skip this one. Then: input == 12 â†’ true â†’ prints 400. Last line â†’ prints 500."
      },
      "hints": {
        "1": "&& in the first condition can let you skip the return if both parts are true.",
        "2": "|| can be tricky â€” make sure you read it like a logician, not just a coder.",
        "3": "If no return, it goes on. Don't assume the else triggers just because it's there."
      }
    },
    {
      "id": 284,
      "subtopic_id": 7,
      "type": "output_tracing",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "You're inside the Threat Prioritization Engine â€” a subsystem using a tangled web of conditionals to decide which dangers to neutralize first. The system relies on an if-else ladder and standalone checks. Only those who trace carefully will know what gets printed. One false move and the system could confuse a fire alarm for a coffee break.",
      "story_context": "The Pathfinder's threat prioritization system needs to evaluate threats using complex conditional logic. Your task is to trace the if-else if ladder and standalone checks to predict the outputs.",
      "challenge_data": {
        "code": "public class ThreatPriority {\n    public static void main(String[] args) {\n        int threat = 45;\n\n        if (threat < 20) {\n            System.out.println(101);\n        } else if (threat % 2 == 0) {\n            System.out.println(202);\n        } else if (threat > 40 && threat < 50) {\n            System.out.println(303);\n        } else if (threat == 45) {\n            System.out.println(404);\n        } else {\n            System.out.println(505);\n        }\n\n        if (threat % 3 == 0) {\n            System.out.println(606);\n        }\n\n        System.out.println(707);\n    }\n}",
        "expected_output": [
          "303",
          "606",
          "707"
        ],
        "choices": [
          "202",
          "505",
          "606",
          "404",
          "303",
          "707"
        ],
        "explanation": "threat = 45. First if â†’ threat < 20 false. Next â†’ threat % 2 == 0 â†’ 45 % 2 == 1 false. Next â†’ threat > 40 && threat < 50 â†’ true â†’ prints 303. The else-if (threat == 45) is also true, but skipped since only one block executes in an if-else-if ladder. Then the separate if (threat % 3 == 0) â†’ 45 % 3 == 0 true â†’ prints 606. Last line â†’ prints 707."
      },
      "hints": {
        "1": "else-if ladder only executes the first matching condition.",
        "2": "Additional if statements outside the ladder still run independently.",
        "3": "Is 45 divisible by 3? ðŸ‘€"
      }
    },
    {
      "id": 285,
      "subtopic_id": 7,
      "type": "output_tracing",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "Inside the Risk Assessment Cluster, the AI core evaluates incoming numeric alerts. But its logic processor has been scrambled â€” a mix of overlapping thresholds and deeply nested if-else ladders are throwing cadets off. Only those with sharp logic and nerves of steel will decode which paths actually run.",
      "story_context": "The Pathfinder's risk assessment system needs to evaluate alerts using complex nested logic. Your task is to trace the nested if-else if logic and predict the outputs.",
      "challenge_data": {
        "code": "public class RiskCluster {\n    public static void main(String[] args) {\n        int alert = 17;\n\n        if (alert > 10) {\n            if (alert < 20) {\n                System.out.println(101);\n            } else if (alert % 2 == 1) {\n                System.out.println(202);\n            }\n        } else if (alert == 17) {\n            System.out.println(303);\n        } else {\n            System.out.println(404);\n        }\n\n        if (alert % 5 == 2) {\n            System.out.println(505);\n        }\n\n        System.out.println(606);\n    }\n}",
        "expected_output": [
          "101",
          "505",
          "606"
        ],
        "choices": [
          "101",
          "202",
          "505",
          "606",
          "101",
          "505",
          "606",
          "alert",
          "202"
        ],
        "explanation": "alert = 17. First outer if (alert > 10) â†’ true. Inner: alert < 20 â†’ true â†’ prints 101. else if (alert % 2 == 1) is skipped since alert < 20 already matched. The outer else if (alert == 17) looks true but it's never reached â€” the first if block already matched. Next: if (alert % 5 == 2) â†’ 17 % 5 == 2 â†’ true â†’ prints 505. Final print â†’ 606."
      },
      "hints": {
        "1": "The inner if only runs if the outer condition is true â€” if it fails, the rest is skipped.",
        "2": "Even though alert == 17 is true, that block won't run because it's part of the else if.",
        "3": "Remember how modulo works: alert % 5 means the remainder when 17 is divided by 5."
      }
    },
    {
      "id": 286,
      "subtopic_id": 7,
      "type": "code_fixer",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinder system is responsible for monitoring oxygen levels and issuing warnings when levels drop below safety thresholds. Your mission is to ensure this critical logic works correctly.",
      "story_context": "The OxygenMonitorAlertProtocol needs to monitor oxygen levels. Your task is to fix the output messages.",
      "challenge_data": {
        "initial_code": "public class OxygenMonitorAlertProtocol {\n    public static void main(String[] args) {\n        int oxygenLevel = 55;\n        if (oxygenLevel < 60) {\n            System.out.println(\"Oxygen levels are safe.\");\n        } else {\n            System.out.println(\"Oxygen low! Please activate backup.\");\n        }\n    }\n}",
        "expected_output": [
          "Oxygen low! Please activate backup."
        ],
        "solution_code": "public class OxygenMonitorAlertProtocol {\n    public static void main(String[] args) {\n        int oxygenLevel = 55;\n        if (oxygenLevel < 60) {\n            System.out.println(\"Oxygen low! Please activate backup.\");\n        } else {\n            System.out.println(\"Oxygen levels are safe.\");\n        }\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 5,
            "type": "output_message",
            "description": "Wrong message displayed for low oxygen level",
            "fix": "Swap the output messages: print warning in if block, safe message in else block"
          },
          {
            "id": 2,
            "line": 7,
            "type": "output_message",
            "description": "Wrong message displayed for safe oxygen level",
            "fix": "Swap the output messages: print warning in if block, safe message in else block"
          }
        ],
        "number_of_errors": 2,
        "explanation": "The faulty logic misplaces the messages in the if-else structure. It's currently telling users that oxygen levels are 'safe' when they are actually low (55). The issue isn't the condition itself but what each branch outputs. By swapping the messages inside the if and else blocks, the logic now responds appropriatelyâ€”warning the user when the oxygen level is below 60."
      },
      "hints": {
        "1": "Double-check which message appears when oxygen drops.",
        "2": "Is the 'safe' message showing up in the wrong situation?",
        "3": "If 55 is a low value, why isn't the warning triggered?"
      }
    },
    {
      "id": 287,
      "subtopic_id": 7,
      "type": "code_fixer",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "When the shield level is 80 or higher, it's safe. Otherwise, it should warn. You need to fix the code to ensure the correct message is displayed.",
      "story_context": "The ShieldDiagnostics needs to check shield levels. Your task is to fix the condition logic.",
      "challenge_data": {
        "initial_code": "public class ShieldDiagnostics {\n    public static void main(String[] args) {\n        int shield = 85;\n\n        if (shield < 80) {\n            System.out.println(\"Shields stable.\");\n        } else {\n            System.out.println(\"Warning: Shields too low.\");\n        }\n    }\n}",
        "expected_output": [
          "Shields stable."
        ],
        "solution_code": "public class ShieldDiagnostics {\n    public static void main(String[] args) {\n        int shield = 85;\n\n        if (shield >= 80) {\n            System.out.println(\"Shields stable.\");\n        } else {\n            System.out.println(\"Warning: Shields too low.\");\n        }\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 5,
            "type": "condition_logic",
            "description": "Wrong condition for shield stability check",
            "fix": "Change condition to: if (shield >= 80)"
          }
        ],
        "number_of_errors": 1,
        "explanation": "The original code mistakenly uses `if (shield < 80)` for the 'stable' condition. The correct logic is to use `if (shield >= 80)` to clearly define when the system is stable. With this fix, the output is 'Shields stable.' because 85 meets the safety threshold."
      },
      "hints": {
        "1": "Is the ship warning when it should feel safe?",
        "2": "What should happen when shield is 85?",
        "3": "Compare the logic to the desired outcome."
      }
    },
    {
      "id": 288,
      "subtopic_id": 7,
      "type": "code_fixer",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "Fuel levels determine the ship's next action. At full fuel (> 90), print a readiness message. Fix the code to ensure this behavior.",
      "story_context": "The FuelCheck needs to verify fuel levels. Your task is to fix the condition logic.",
      "challenge_data": {
        "initial_code": "public class FuelCheck {\n    public static void main(String[] args) {\n        int fuel = 95;\n\n        if (fuel < 90) { \n            System.out.println(\"Fuel full. Ready to launch!\");\n        } else {\n            System.out.println(\"Fuel not full.\");\n        }\n    }\n}",
        "expected_output": [
          "Fuel full. Ready to launch!"
        ],
        "solution_code": "public class FuelCheck {\n    public static void main(String[] args) {\n        int fuel = 95;\n\n        if (fuel > 90) { \n            System.out.println(\"Fuel full. Ready to launch!\");\n        } else {\n            System.out.println(\"Fuel not full.\");\n        }\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 5,
            "type": "condition_logic",
            "description": "Wrong condition for fuel level check",
            "fix": "Change condition to: if (fuel > 90)"
          }
        ],
        "number_of_errors": 1,
        "explanation": "The original code mistakenly checks `fuel < 90`, which would only print the message when fuel is not full. Since the requirement is to print readiness when fuel is above 90, we need to use `fuel > 90`. With `fuel = 95`, the condition is met, and the output is correctly: 'Fuel full. Ready to launch!'."
      },
      "hints": {
        "1": "What number does the code compare to?",
        "2": "What should trigger a 'Fuel full' message?",
        "3": "Look at which direction the inequality is pointing."
      }
    },
    {
      "id": 289,
      "subtopic_id": 7,
      "type": "code_fixer",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The scanner should warn only when the threat level is 100. Correct the code to match this requirement.",
      "story_context": "The ThreatLevelScanner needs to monitor threat levels. Your task is to fix the condition logic.",
      "challenge_data": {
        "initial_code": "public class ThreatLevelScanner {\n    public static void main(String[] args) {\n        int threat = 100;\n\n        if (threat != 100) { \n            System.out.println(\"ALERT! Threat detected.\");\n        } else {\n            System.out.println(\"Threat level acceptable.\");\n        }\n    }\n}",
        "expected_output": [
          "ALERT! Threat detected."
        ],
        "solution_code": "public class ThreatLevelScanner {\n    public static void main(String[] args) {\n        int threat = 100;\n\n        if (threat == 100) { \n            System.out.println(\"ALERT! Threat detected.\");\n        } else {\n            System.out.println(\"Threat level acceptable.\");\n        }\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 5,
            "type": "condition_logic",
            "description": "Wrong condition for threat level check",
            "fix": "Change condition to: if (threat == 100)"
          }
        ],
        "number_of_errors": 1,
        "explanation": "The faulty code uses `threat != 100`, which triggers the alert for any threat level except 100 â€” exactly the opposite of what we want. Since the alert should only happen when the threat level is exactly 100, the condition should be `threat == 100`. With the correct logic and `threat = 100`, the program correctly prints: 'ALERT! Threat detected.'."
      },
      "hints": {
        "1": "Think about equality vs. inequality.",
        "2": "Should we trigger the alert when the threat is 100 or when it isn't?",
        "3": "Which symbol means 'equal to'?"
      }
    },
    {
      "id": 290,
      "subtopic_id": 7,
      "type": "code_fixer",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "If the engine temp is below 30, the cooler should activate. Fix the code to ensure the coolant system activates under the correct temperature condition.",
      "story_context": "The TemperatureRegulation needs to control engine temperature. Your task is to fix the condition logic.",
      "challenge_data": {
        "initial_code": "public class TemperatureRegulation {\n    public static void main(String[] args) {\n        int temperature = 25;\n        if (temperature > 30) { \n            System.out.println(\"Activating coolant system.\");\n        } else {\n            System.out.println(\"Temperature within safe range.\");\n        }\n    }\n}",
        "expected_output": [
          "Activating coolant system."
        ],
        "solution_code": "public class TemperatureRegulation {\n    public static void main(String[] args) {\n        int temperature = 25;\n        if (temperature < 30) { \n            System.out.println(\"Activating coolant system.\");\n        } else {\n            System.out.println(\"Temperature within safe range.\");\n        }\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 4,
            "type": "condition_logic",
            "description": "Wrong condition for temperature regulation",
            "fix": "Change condition to: if (temperature < 30)"
          }
        ],
        "number_of_errors": 1,
        "explanation": "The faulty code checks `temperature > 30`, which would activate cooling only when it's hotter â€” but the goal is to cool things down before it hits 30. Since 25 is less than 30, the correct condition is `temperature < 30`. That way, the program correctly activates the coolant system when the engine is too cold."
      },
      "hints": {
        "1": "What temperature triggers the cooling system?",
        "2": "Is 25 greater than 30?",
        "3": "Which symbol points toward smaller numbers?"
      }
    },
    {
      "id": 291,
      "subtopic_id": 7,
      "type": "code_fixer",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "If the reactor temperature is high and coolant level is low, trigger emergency cooling. If only one condition is true, issue a warning. Otherwise, all is normal. The current code has a logical flaw in the order of checks.",
      "story_context": "The ReactorControl needs to manage reactor safety. Your task is to fix the logical operator order.",
      "challenge_data": {
        "initial_code": "public class ReactorControl {\n    public static void main(String[] args) {\n        int temp = 800;\n        int coolant = 20;\n\n        if (temp > 700 || coolant < 30) { \n            System.out.println(\"Triggering emergency cooling!\");\n        } else if (temp > 700 && coolant < 30) { \n            System.out.println(\"Warning: Check cooling system.\");\n        } else {\n            System.out.println(\"Reactor stable.\");\n        }\n    }\n}",
        "expected_output": [
          "Triggering emergency cooling!"
        ],
        "solution_code": "public class ReactorControl {\n    public static void main(String[] args) {\n        int temp = 800;\n        int coolant = 20;\n\n        if (temp > 700 && coolant < 30) { \n            System.out.println(\"Triggering emergency cooling!\");\n        } else if (temp > 700 || coolant < 30) { \n            System.out.println(\"Warning: Check cooling system.\");\n        } else {\n            System.out.println(\"Reactor stable.\");\n        }\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 6,
            "type": "logical_operator_order",
            "description": "Wrong order of logical conditions",
            "fix": "Swap the conditions: check AND first, then OR"
          },
          {
            "id": 2,
            "line": 8,
            "type": "logical_operator_order",
            "description": "Wrong order of logical conditions",
            "fix": "Swap the conditions: check AND first, then OR"
          }
        ],
        "number_of_errors": 2,
        "explanation": "The faulty version incorrectly checked the OR (`||`) condition first, so it triggered emergency cooling even when only one issue existed. But emergency cooling is serious business â€” we only trigger it when both: Temp is dangerously high (`> 700`) and Coolant is dangerously low (`< 30`). By checking the AND condition first, we make sure full-blown emergencies get handled properly. Since both `temp = 800` and `coolant = 20` are true, the output is: 'Triggering emergency cooling!'."
      },
      "hints": {
        "1": "Emergency cooling needs both conditionsâ€”true or just one?",
        "2": "Which is riskier: high temp alone, or both?",
        "3": "Try reordering the if/else checks logically."
      }
    },
    {
      "id": 292,
      "subtopic_id": 7,
      "type": "code_fixer",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "Pathfinder's decision core checks solar flare activity and sensor clarity before landing on a space station. It can land if solar flare activity is low OR sensors are clear. If both are bad, it must delay landing. Fix the code to ensure the correct landing decision is made.",
      "story_context": "The LandingControl needs to make landing decisions. Your task is to fix the logical operator.",
      "challenge_data": {
        "initial_code": "public class LandingControl {\n    public static void main(String[] args) {\n        int solarFlare = 45;       // flare intensity\n        int sensorClarity = 40;    // sensor accuracy level\n\n        if (solarFlare < 50 && sensorClarity > 60) { \n            System.out.println(\"Landing cleared.\");\n        } else {\n            System.out.println(\"Delay landing.\");\n        }\n    }\n}",
        "expected_output": [
          "Landing cleared."
        ],
        "solution_code": "public class LandingControl {\n    public static void main(String[] args) {\n        int solarFlare = 45;       // flare intensity\n        int sensorClarity = 40;    // sensor accuracy level\n\n        if (solarFlare < 50 || sensorClarity > 60) { \n            System.out.println(\"Landing cleared.\");\n        } else {\n            System.out.println(\"Delay landing.\");\n        }\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 7,
            "type": "logical_operator",
            "description": "Using AND instead of OR for landing conditions",
            "fix": "Change condition to: if (solarFlare < 50 || sensorClarity > 60)"
          }
        ],
        "number_of_errors": 1,
        "explanation": "The faulty code uses `&&`, which wrongly demands both conditions be ideal before landing. But the mission rule says just one good condition is enough. By using `||` (OR) in the correct code, the program now aligns with the mission logic."
      },
      "hints": {
        "1": "Can landing happen even if only one condition is ideal?",
        "2": "Check the operator: do you need `&&` or `||`?",
        "3": "Which logical operator allows more flexibility?"
      }
    },
    {
      "id": 293,
      "subtopic_id": 7,
      "type": "code_fixer",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "A spacesuit locks if the oxygen is low OR the user is unconscious. It should only unlock if oxygen is stable AND the user is awake. Fix the code to implement the correct suit locking and unlocking logic.",
      "story_context": "The SuitLock needs to manage spacesuit safety. Your task is to fix the logical operator.",
      "challenge_data": {
        "initial_code": "public class SuitLock {\n    public static void main(String[] args) {\n        boolean oxygenStable = true;\n        boolean userAwake = true;\n\n        if (oxygenStable || userAwake) { \n            System.out.println(\"Suit unlocking...\");\n        } else {\n            System.out.println(\"Suit remains locked.\");\n        }\n    }\n}",
        "expected_output": [
          "Suit unlocking..."
        ],
        "solution_code": "public class SuitLock {\n    public static void main(String[] args) {\n        boolean oxygenStable = true;\n        boolean userAwake = true;\n\n        if (oxygenStable && userAwake) { \n            System.out.println(\"Suit unlocking...\");\n        } else {\n            System.out.println(\"Suit remains locked.\");\n        }\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 6,
            "type": "logical_operator",
            "description": "Using OR instead of AND for suit unlocking",
            "fix": "Change condition to: if (oxygenStable && userAwake)"
          }
        ],
        "number_of_errors": 1,
        "explanation": "The faulty code uses `||`, which would unlock the suit even if only one condition is trueâ€”unsafe in a space environment. The correct logic requires both oxygen to be stable and the user to be awake (`&&`). This ensures the suit only unlocks under safe conditions. The variable values are set to `true` to reflect the correct scenario, which outputs 'Suit unlocking...'."
      },
      "hints": {
        "1": "Would you unlock the suit if oxygen is low but the user is awake?",
        "2": "What combination ensures safety before unlocking?",
        "3": "Double-check what logical operator makes unlocking stricter."
      }
    },
    {
      "id": 294,
      "subtopic_id": 7,
      "type": "code_fixer",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The comms system is considered online if the satellite is in range AND signal strength is strong. If the satellite is out of range OR signal is weak, it fails. Correct the code to accurately reflect the comms system status.",
      "story_context": "The CommsSystem needs to monitor communication status. Your task is to fix the logical operator.",
      "challenge_data": {
        "initial_code": "public class CommsSystem {\n    public static void main(String[] args) {\n        boolean satelliteInRange = true;\n        boolean signalStrong = true;\n        if (satelliteInRange || signalStrong) { \n            System.out.println(\"Comms online.\");\n        } else {\n            System.out.println(\"Comms failure.\");\n        }\n    }\n}",
        "expected_output": [
          "Comms online."
        ],
        "solution_code": "public class CommsSystem {\n    public static void main(String[] args) {\n        boolean satelliteInRange = true;\n        boolean signalStrong = true;\n        if (satelliteInRange && signalStrong) { \n            System.out.println(\"Comms online.\");\n        } else {\n            System.out.println(\"Comms failure.\");\n        }\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 5,
            "type": "logical_operator",
            "description": "Using OR instead of AND for comms system status",
            "fix": "Change condition to: if (satelliteInRange && signalStrong)"
          }
        ],
        "number_of_errors": 1,
        "explanation": "The faulty logic is overcomplicated to look smart but ends up wrong. It combines AND and OR in a way that prioritizes the satellite being in range even when the signal is weak. This causes the system to declare 'Comms online' when only one of the required conditions is trueâ€”violating the scenario's safety requirement. The correct version uses a clean `&&` to ensure both are true before confirming communication readiness."
      },
      "hints": {
        "1": "Do both signal and range need to be ideal?",
        "2": "What happens if only one is working?",
        "3": "Try making the condition more strict."
      }
    },
    {
      "id": 295,
      "subtopic_id": 7,
      "type": "code_fixer",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "An astronaut can refill oxygen if their current oxygen level is below 60% AND the refill station is online. Additionally, a warning must trigger if the astronaut's oxygen is below 30% OR the refill station is offline. Fix the logic to correctly manage oxygen refill and warnings.",
      "story_context": "The OxygenRefillSystem needs to manage oxygen refills. Your task is to fix the logical operators.",
      "challenge_data": {
        "initial_code": "public class OxygenRefillSystem {\n    public static void main(String[] args) {\n        int oxygenLevel = 25;\n        boolean stationOnline = false;\n        if (oxygenLevel > 60 && stationOnline) { \n            System.out.println(\"Begin refill process.\");\n        }\n        if (oxygenLevel > 30 || !stationOnline) { \n            System.out.println(\"Warning: Critical oxygen or station down.\");\n        }\n    }\n}",
        "expected_output": [
          "Warning: Critical oxygen or station down."
        ],
        "solution_code": "public class OxygenRefillSystem {\n    public static void main(String[] args) {\n        int oxygenLevel = 25;\n        boolean stationOnline = false;\n        if (oxygenLevel < 60 && stationOnline) { \n            System.out.println(\"Begin refill process.\");\n        }\n        if (oxygenLevel < 30 || !stationOnline) { \n            System.out.println(\"Warning: Critical oxygen or station down.\");\n        }\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 4,
            "type": "condition_logic",
            "description": "Wrong condition for oxygen refill",
            "fix": "Change condition to: if (oxygenLevel < 60 && stationOnline)"
          },
          {
            "id": 2,
            "line": 7,
            "type": "condition_logic",
            "description": "Wrong condition for oxygen warning",
            "fix": "Change condition to: if (oxygenLevel < 30 || !stationOnline)"
          }
        ],
        "number_of_errors": 2,
        "explanation": "Condition A ensures the astronaut is only allowed to refill when it's both necessary (oxygen < 60) and possible (station is online). Condition B triggers a warning if either of the danger conditions is true: oxygen is dangerously low or the station is offlineâ€”each of which could be critical on its own. The original faulty conditions inverted the logic and used overly safe thresholds, meaning the system would never allow refills when actually needed and might miss warnings."
      },
      "hints": {
        "1": "When do we actually need to refillâ€”when it's safe or low?",
        "2": "Should the warning care about just one danger or both together?",
        "3": "Remember the difference between && and ||."
      }
    },
    {
      "id": 296,
      "subtopic_id": 7,
      "type": "code_fixer",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "You're programming Pathfinder's AI health diagnostics. It monitors the number of damaged modules, average temperature readings, and whether the system alert is activated. Based on these, it must issue the correct alert level. Fix the faulty logic to ensure accurate and complete alerts.",
      "story_context": "The HealthDiagnostic needs to monitor system health. Your task is to fix the string comparison and alert logic.",
      "challenge_data": {
        "initial_code": "public class HealthDiagnostic {\n    public static void main(String[] args) {\n        byte damagedModules = 12;\n        double avgTemp = 86.5;\n        String alertStatus = \"true\";\n\n        System.out.println(\"=== SYSTEM INPUTS ===\");\n        System.out.println(\"Damaged Modules: \" + damagedModules);\n        System.out.println(\"Average Temperature: \" + avgTemp);\n        System.out.println(\"Alert Status: \" + alertStatus);\n        System.out.println(\"=====================\\n\");\n\n        if (damagedModules > 10 && alertStatus == \"true\") { \n            System.out.println(\"CRITICAL: Structural integrity compromised.\");\n        } else if (avgTemp >= 85.0) { \n            System.out.println(\"WARNING: Elevated core temperature.\");\n        } else if (damagedModules > 10) {\n            System.out.println(\"WARNING: Excessive damage.\");\n        }\n    }\n}",
        "expected_output": [
          "=== SYSTEM INPUTS ===",
          "Damaged Modules: 12",
          "Average Temperature: 86.5",
          "Alert Status: true",
          "=====================\n",
          "CRITICAL: Structural integrity compromised.",
          "WARNING: Elevated core temperature.",
          "WARNING: Excessive damage."
        ],
        "solution_code": "public class HealthDiagnostic {\n    public static void main(String[] args) {\n        byte damagedModules = 12;\n        double avgTemp = 86.5;\n        String alertStatus = \"true\";\n\n        System.out.println(\"=== SYSTEM INPUTS ===\");\n        System.out.println(\"Damaged Modules: \" + damagedModules);\n        System.out.println(\"Average Temperature: \" + avgTemp);\n        System.out.println(\"Alert Status: \" + alertStatus);\n        System.out.println(\"=====================\\n\");\n\n        if (damagedModules > 10 && alertStatus.equals(\"true\")) { \n            System.out.println(\"CRITICAL: Structural integrity compromised.\");\n        }\n\n        if (avgTemp >= 85.0) { \n            System.out.println(\"WARNING: Elevated core temperature.\");\n        }\n\n        if (damagedModules > 10) {\n            System.out.println(\"WARNING: Excessive damage.\");\n        }\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 13,
            "type": "string_comparison",
            "description": "Using == instead of .equals() for string comparison",
            "fix": "Change to: alertStatus.equals(\"true\")"
          },
          {
            "id": 2,
            "line": 15,
            "type": "control_flow",
            "description": "Using else if instead of separate if statements",
            "fix": "Change else if to if for independent condition checks"
          },
          {
            "id": 3,
            "line": 17,
            "type": "control_flow",
            "description": "Using else if instead of separate if statements",
            "fix": "Change else if to if for independent condition checks"
          }
        ],
        "number_of_errors": 3,
        "explanation": "The original code fails for two main reasons. First, it incorrectly uses `==` to compare strings, which compares object references, not contentâ€”so \"true\" might not register even when it should. Second, the use of `else if` prevents multiple alerts from showing. For example, if one condition is true, the rest are skippedâ€”even if they should also be triggered. The corrected version uses `.equals()` for reliable string comparison, and uses separate `if` statements so that all relevant system warnings and alerts can display. This ensures both logic and safety are intact."
      },
      "hints": {
        "1": "Are you checking the actual content of the string, or just comparing references?",
        "2": "What happens when two warnings are valid at the same timeâ€”are both displayed?",
        "3": "Improper if-else usage may cause the system to ignore valid warningsâ€”it might 'look correct' but silently fail important checks."
      }
    },
    {
      "id": 297,
      "subtopic_id": 7,
      "type": "code_fixer",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "You're writing a fuel consumption analyzer for a spacecraft. It calculates remaining fuel based on the fuel capacity, burn rate, and hours of operation. It must then decide the fuel alert level. Fix the faulty code to ensure accurate calculations and correct alert triggers.",
      "story_context": "The FuelAnalyzer needs to calculate fuel consumption. Your task is to fix the type casting and comparison operator.",
      "challenge_data": {
        "initial_code": "public class FuelAnalyzer {\n    public static void main(String[] args) {\n        float fuelCapacity = 5000;\n        int burnRate = 50;\n        int hours = 60;\n\n        float remainingFuel = fuelCapacity - (burnRate * hours);\n\n        if (remainingFuel = 0) { \n            System.out.println(\"Out of fuel!\");\n        } else if (remainingFuel < 1000) {\n            System.out.println(\"Low fuel warning.\");\n        } else {\n            System.out.println(\"Fuel levels nominal.\");\n        }\n    }\n}",
        "expected_output": [
          "Low fuel warning."
        ],
        "solution_code": "public class FuelAnalyzer {\n    public static void main(String[] args) {\n        float fuelCapacity = 5000;\n        int burnRate = 50;\n        int hours = 60;\n\n        float remainingFuel = fuelCapacity - ((float) burnRate * hours);\n\n        if (remainingFuel == 0) { \n            System.out.println(\"Out of fuel!\");\n        } else if (remainingFuel < 1000) {\n            System.out.println(\"Low fuel warning.\");\n        } else {\n            System.out.println(\"Fuel levels nominal.\");\n        }\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 7,
            "type": "type_casting",
            "description": "Missing type casting for float calculation",
            "fix": "Cast burnRate to float: ((float) burnRate * hours)"
          },
          {
            "id": 2,
            "line": 9,
            "type": "comparison_operator",
            "description": "Using assignment operator instead of comparison operator",
            "fix": "Use comparison operator: if (remainingFuel == 0)"
          }
        ],
        "number_of_errors": 2,
        "explanation": "The primary issues are type handling and condition logic. First, `burnRate * hours` (3000) is an `int` calculation, and while 3000 fits in an `int`, it's better to ensure floating-point arithmetic from the start if the result is a `float`. Casting `burnRate` to `float` before multiplication ensures `((float) burnRate * hours)` yields a `float` (3000.0) preventing potential precision loss for larger numbers. Second, `if (remainingFuel = 0)` uses the assignment operator `=` instead of the comparison operator `==`, which is a common logical and compilation error. The fix addresses both, ensuring accurate fuel calculation and proper conditional branching."
      },
      "hints": {
        "1": "Assignment (`=`) and comparison (`==`) aren't the same. Spot the danger?",
        "2": "How does Java handle operations between int and float?",
        "3": "What's the data type of `burnRate * hours` before storing in a float?"
      }
    },
    {
      "id": 298,
      "subtopic_id": 7,
      "type": "code_fixer",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "You're programming a navigation system that validates whether a ship can safely jump to hyperspace. To qualify, the ship must: have fuel above 500 units, navigation system must be 'online', and jump coordinates must be verified (boolean). If all checks pass, display 'Jumping to hyperspace!' Otherwise, say why. Fix the faulty code to enable safe hyperspace jumps.",
      "story_context": "The HyperspaceJump needs to validate jump conditions. Your task is to fix the string comparison and boolean logic.",
      "challenge_data": {
        "initial_code": "public class HyperspaceJump {\n    public static void main(String[] args) {\n        double fuelLevel = 650;\n        String navStatus = \"Online\";\n        boolean coordsVerified = true;\n\n        if (fuelLevel > 500 && navStatus == \"online\" && coordsVerified = true) { \n            System.out.println(\"Jumping to hyperspace!\");\n        } else {\n            System.out.println(\"Jump aborted: check systems.\");\n        }\n    }\n}",
        "expected_output": [
          "Jumping to hyperspace!"
        ],
        "solution_code": "public class HyperspaceJump {\n    public static void main(String[] args) {\n        double fuelLevel = 650;\n        String navStatus = \"Online\";\n        boolean coordsVerified = true;\n\n        if (fuelLevel > 500 && navStatus.equalsIgnoreCase(\"online\") && coordsVerified) { \n            System.out.println(\"Jumping to hyperspace!\");\n        } else {\n            System.out.println(\"Jump aborted: check systems.\");\n        }\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 7,
            "type": "string_comparison",
            "description": "Using == instead of .equalsIgnoreCase() for String comparison",
            "fix": "Use .equalsIgnoreCase(): navStatus.equalsIgnoreCase(\"online\")"
          },
          {
            "id": 2,
            "line": 7,
            "type": "boolean_assignment",
            "description": "Using assignment instead of direct boolean usage",
            "fix": "Use coordsVerified directly instead of coordsVerified = true"
          }
        ],
        "number_of_errors": 2,
        "explanation": "The original code has two main logical flaws: string comparison and boolean assignment in a condition. `navStatus == \"online\"` uses `==` for String comparison, which checks object identity, not content, and is case-sensitive, so 'Online' won't match 'online'. This should be `navStatus.equalsIgnoreCase(\"online\")` or `navStatus.equals(\"Online\")`. Additionally, `coordsVerified = true` is an assignment, not a comparison. It should be `coordsVerified == true` or simply `coordsVerified`. The fix addresses both of these, ensuring that all conditions are properly evaluated for a successful hyperspace jump."
      },
      "hints": {
        "1": "Assignment (`=`) and comparison (`==`) aren't the same. Spot the danger?",
        "2": "String comparisons in Java are case- and reference-sensitiveâ€”how do you compare their content?",
        "3": "Avoid comparing booleans with `==` when you can just use the variable directly!"
      }
    },
    {
      "id": 299,
      "subtopic_id": 7,
      "type": "code_fixer",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "You're designing a drone swarm management system. The goal is to evaluate if a drone should initiate evasive maneuvers based on: batteryLevel (above 20%), signalStrength (at least 75), threatDetected (true), and droneStatus ('ACTIVE'). Fix the faulty code to ensure drones react appropriately to threats.",
      "story_context": "The DroneSwarmControl needs to manage drone responses. Your task is to fix the method logic and string comparison.",
      "challenge_data": {
        "initial_code": "public class DroneSwarmControl {\n    public static void main(String[] args) {\n        int batteryLevel = 25;\n        int signalStrength = 80;\n        boolean threatDetected = true;\n        String droneStatus = new String(\"ACTIVE\");\n\n        if (isBatteryGood(batteryLevel) && signalStrength > 75 && isThreat(threatDetected) && droneStatus == \"ACTIVE\") { \n            System.out.println(\"Evasive maneuver initiated.\");\n        }\n        else if (isBatteryGood(batteryLevel) && threatDetected) {\n            System.out.println(\"Reduce speed, monitor surroundings.\");\n        }\n        else {\n            System.out.println(\"Maintain course.\");\n        }\n    }\n\n    static boolean isBatteryGood(int battery) {\n        return battery > 20;\n    }\n\n    static boolean isThreat(boolean detected) {\n        return !detected; \n    }\n}",
        "expected_output": [
          "Evasive maneuver initiated."
        ],
        "solution_code": "public class DroneSwarmControl {\n    public static void main(String[] args) {\n        int batteryLevel = 25;\n        int signalStrength = 80;\n        boolean threatDetected = true;\n        String droneStatus = new String(\"ACTIVE\");\n\n        if (isBatteryGood(batteryLevel) && signalStrength >= 75 && isThreat(threatDetected) && droneStatus.equals(\"ACTIVE\")) { \n            System.out.println(\"Evasive maneuver initiated.\");\n        }\n        else if (isBatteryGood(batteryLevel) && threatDetected) {\n            System.out.println(\"Reduce speed, monitor surroundings.\");\n        }\n        else {\n            System.out.println(\"Maintain course.\");\n        }\n    }\n\n    static boolean isBatteryGood(int battery) {\n        return battery > 20;\n    }\n\n    static boolean isThreat(boolean detected) {\n        return detected; \n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 8,
            "type": "comparison_operator",
            "description": "Using > instead of >= for signal strength check",
            "fix": "Change to >=: signalStrength >= 75"
          },
          {
            "id": 2,
            "line": 8,
            "type": "string_comparison",
            "description": "Using == instead of .equals() for String comparison",
            "fix": "Use .equals(): droneStatus.equals(\"ACTIVE\")"
          },
          {
            "id": 3,
            "line": 25,
            "type": "method_logic",
            "description": "Inverted logic in isThreat method",
            "fix": "Return detected directly: return detected"
          }
        ],
        "number_of_errors": 3,
        "explanation": "The code contains several logical errors. The `isThreat` method inverts the logic, returning `true` when no threat is detected. `signalStrength > 75` should be `>= 75` to include the threshold. `droneStatus == \"ACTIVE\"` incorrectly uses `==` for String comparison, which compares references, not content. Each of these must be fixed to ensure the drone behaves correctly under threat. The correct code should ensure `isThreat` returns `detected`, change `signalStrength > 75` to `signalStrength >= 75`, and change `droneStatus == \"ACTIVE\"` to `droneStatus.equals(\"ACTIVE\")`."
      },
      "hints": {
        "1": "How do you compare Strings in Java correctly?",
        "2": "Does `!detected` mean there is a threat?",
        "3": "Is `75` strong enough or do we need more?"
      }
    },
    {
      "id": 300,
      "subtopic_id": 7,
      "type": "code_fixer",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "You're building a life support monitor. The system checks oxygen levels, COâ‚‚ concentration, crew heart rate, and chamber pressure. Based on these, it decides whether to: Trigger evacuation if oxygen < 15, COâ‚‚ > 5, and (either heart rate > 120 or pressure < 90); Issue a warning if only one or two of those conditions are true; Continue normal operation otherwise. Fix the faulty code to ensure correct life support responses.",
      "story_context": "The LifeSupportMonitor needs to manage life support systems. Your task is to fix the logical operators.",
      "challenge_data": {
        "initial_code": "public class LifeSupportMonitor {\n    public static void main(String[] args) {\n        double oxygen = 12.0;\n        double co2 = 6.2;\n        int heartRate = 125;\n        int pressure = 95;\n\n        if (isLowOxygen(oxygen) || isHighCO2(co2) || isCriticalVitals(heartRate, pressure)) { \n            System.out.println(\"Evacuate immediately!\");\n        }\n        else if (isLowOxygen(oxygen) && isHighCO2(co2) && isCriticalVitals(heartRate, pressure)) { \n            System.out.println(\"Life support warning issued.\");\n        }\n        else {\n            System.out.println(\"All systems nominal.\");\n        }\n    }\n\n    static boolean isLowOxygen(double o2) {\n        return o2 < 15;\n    }\n\n    static boolean isHighCO2(double co2) {\n        return co2 > 5;\n    }\n\n    static boolean isCriticalVitals(int hr, int pressure) {\n        return hr > 120 || pressure < 90;\n    }\n}",
        "expected_output": [
          "Evacuate immediately!"
        ],
        "solution_code": "public class LifeSupportMonitor {\n    public static void main(String[] args) {\n        double oxygen = 12.0;\n        double co2 = 6.2;\n        int heartRate = 125;\n        int pressure = 95;\n\n        if (isLowOxygen(oxygen) && isHighCO2(co2) && isCriticalVitals(heartRate, pressure)) { \n            System.out.println(\"Evacuate immediately!\");\n        }\n        else if (isLowOxygen(oxygen) || isHighCO2(co2) || isCriticalVitals(heartRate, pressure)) { \n            System.out.println(\"Life support warning issued.\");\n        }\n        else {\n            System.out.println(\"All systems nominal.\");\n        }\n    }\n\n    static boolean isLowOxygen(double o2) {\n        return o2 < 15;\n    }\n\n    static boolean isHighCO2(double co2) {\n        return co2 > 5;\n    }\n\n    static boolean isCriticalVitals(int hr, int pressure) {\n        return hr > 120 || pressure < 90;\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 9,
            "type": "logical_operator",
            "description": "Using OR instead of AND for evacuation conditions",
            "fix": "Change to AND: isLowOxygen(oxygen) && isHighCO2(co2) && isCriticalVitals(heartRate, pressure)"
          },
          {
            "id": 2,
            "line": 12,
            "type": "logical_operator",
            "description": "Using AND instead of OR for warning conditions",
            "fix": "Change to OR: isLowOxygen(oxygen) || isHighCO2(co2) || isCriticalVitals(heartRate, pressure)"
          }
        ],
        "number_of_errors": 2,
        "explanation": "The core issue lies in the first `if` statement's boolean logic and the overall `if-else` structure. The scenario requires evacuation when oxygen is critically low AND CO2 is high AND vitals are critical. The original `||` operator with `&&` has precedence issues (`isHighCO2(co2) && isCriticalVitals(heartRate, pressure)` would evaluate first). This needs to be explicitly grouped or use `&&` throughout if all conditions must be met for evacuation. Also, the second `if` should be an `else if` to ensure proper branching and prevent multiple messages, and proper `else` placement is crucial. The fix simplifies the evacuation condition using `&&` and ensures correct `if-else if-else` flow."
      },
      "hints": {
        "1": "What happens first: `&&` or `||`?",
        "2": "Should you always use braces in nested conditions?",
        "3": "Is oxygen alone enough to trigger evacuation?"
      }
    },
    {
      "id": 301,
      "subtopic_id": 7,
      "type": "code_completion",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinderâ€™s Decision Core is confused. It needs to decide whether to activate shields based on the current threat level. However, part of its decision logic is missing. You must complete the core's code so it can react logically.",
      "story_context": "The Pathfinder's Decision Core needs to activate shields based on threat levels. Your task is to complete the control flow statements.",
      "challenge_data": {
        "initial_code": "public class DecisionCore {\n    public static void main(String[] args) {\n        int threatLevel = 8;\n\n        ???\n        System.out.println(\"High threat detected! Activating shields.\");\n        ???\n        System.out.println(\"Threat level acceptable. No action needed.\");\n    }\n}",
        "expected_output": [
          "High threat detected! Activating shields."
        ],
        "solution_code": "public class DecisionCore {\n    public static void main(String[] args) {\n        int threatLevel = 8;\n\n        if (threatLevel > 5) {\n        System.out.println(\"High threat detected! Activating shields.\");\n        } else {\n        System.out.println(\"Threat level acceptable. No action needed.\");\n    }\n}",
        "choices": [
          "else {",
          "if (threatLevel < 5)",
          "if (threatLevel > 5) {",
          "else if (threatLevel > 10)"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 5,
            "type": "keyword",
            "description": "If statement condition",
            "correct_answer": "if (threatLevel > 5) {",
            "explanation": "`if (threatLevel > 5)` correctly captures all higher threat levels. The condition checks if threat level is greater than 5."
          },
          {
            "id": "slot_2",
            "line": 7,
            "type": "keyword",
            "description": "Else statement",
            "correct_answer": "else {",
            "explanation": "`else` handles the remaining values (5 and below) when the if condition is false."
          }
        ],
        "number_of_slots": 2
      },
      "hints": {
        "1": "If the system can only do two things, you might not need more than one condition.",
        "2": "The threat level is 8. Is that high or low? Choose logic that accounts for this specific input.",
        "3": "Think balance: precision is good, but donâ€™t overcomplicate â€” youâ€™re not building a rocketâ€¦ just its defense AI."
      }
    },
    {
      "id": 302,
      "subtopic_id": 7,
      "type": "code_completion",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Decision Core must decide whether to reroute emergency power if energy drops too low. It has the data, but the control logic is broken. Complete the code to ensure proper power rerouting.",
      "story_context": "The Decision Core needs to reroute power when energy levels are low. Your task is to complete the control flow statements.",
      "challenge_data": {
        "initial_code": "public class DecisionCore {\n    public static void main(String[] args) {\n        int energyLevel = 20;\n\n        ???\n        System.out.println(\"Rerouting power to essential systems.\");\n        ???\n        System.out.println(\"Energy stable. No rerouting needed.\");\n    }\n}",
        "expected_output": [
          "Rerouting power to essential systems."
        ],
        "solution_code": "public class DecisionCore {\n    public static void main(String[] args) {\n        int energyLevel = 20;\n\n        if (energyLevel <= 25) {\n        System.out.println(\"Rerouting power to essential systems.\");\n        } else {\n        System.out.println(\"Energy stable. No rerouting needed.\");\n    }\n}",
        "choices": [
          "else {",
          "else if (energyLevel < 10)",
          "if (energyLevel <= 25) {",
          "if (energyLevel >= 80)"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 5,
            "type": "keyword",
            "description": "If statement condition",
            "correct_answer": "if (energyLevel <= 25) {",
            "explanation": "Threat is when energy is 25 or below, so we act. The condition checks if energy level is less than or equal to 25."
          },
          {
            "id": "slot_2",
            "line": 7,
            "type": "keyword",
            "description": "Else statement",
            "correct_answer": "else {",
            "explanation": "Else handles the rest (safe levels) when the if condition is false."
          }
        ],
        "number_of_slots": 2
      },
      "hints": {
        "1": "The core acts when energy is getting dangerously low.",
        "2": "Consider what '<=' means versus '>=' in context.",
        "3": "Only two paths exist: reroute or donâ€™t."
      }
    },
    {
      "id": 303,
      "subtopic_id": 7,
      "type": "code_completion",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "Sensors are checking the ship's hull integrity. If it's under 70%, emergency repairs must be triggered. You must repair the missing logic.",
      "story_context": "The ship's sensors need to check hull integrity and trigger repairs when needed. Your task is to complete the control flow statements.",
      "challenge_data": {
        "initial_code": "public class DecisionCore {\n    public static void main(String[] args) {\n        int hullIntegrity = 68;\n\n        ???\n        System.out.println(\"Hull compromised! Initiating repairs.\");\n        ???\n        System.out.println(\"Hull integrity stable.\");\n    }\n}",
        "expected_output": [
          "Hull compromised! Initiating repairs."
        ],
        "solution_code": "public class DecisionCore {\n    public static void main(String[] args) {\n        int hullIntegrity = 68;\n\n        if (hullIntegrity < 70) {\n        System.out.println(\"Hull compromised! Initiating repairs.\");\n        } else {\n        System.out.println(\"Hull integrity stable.\");\n    }\n}",
        "choices": [
          "if (hullIntegrity < 70) {",
          "else {",
          "if (hullIntegrity > 90)",
          "else if (hullIntegrity <= 30)"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 5,
            "type": "keyword",
            "description": "If statement condition",
            "correct_answer": "if (hullIntegrity < 70) {",
            "explanation": "Anything under 70 is a risk to the ship's shell. The condition checks if hull integrity is less than 70."
          },
          {
            "id": "slot_2",
            "line": 7,
            "type": "keyword",
            "description": "Else statement",
            "correct_answer": "else {",
            "explanation": "Else can help simplify decisions when no other conditions are needed."
          }
        ],
        "number_of_slots": 2
      },
      "hints": {
        "1": "Anything under 70 is a risk to the ship's shell.",
        "2": "else can help simplify decisions when no other conditions are needed.",
        "3": "Which operator detects a â€œbelow this thresholdâ€ scenario?"
      }
    },
    {
      "id": 304,
      "subtopic_id": 7,
      "type": "code_completion",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinderâ€™s AI locks down sensitive controls unless crew credentials are verified. The Decision Core must check if the username matches the commanderâ€™s ID before unlocking advanced features. Complete the code to correctly handle access control.",
      "story_context": "The Pathfinder's AI needs to verify crew credentials for access control. Your task is to complete the control flow statements.",
      "challenge_data": {
        "initial_code": "public class DecisionCore {\n    public static void main(String[] args) {\n        String username = \"CommanderZania\";\n\n        ???\n        System.out.println(\"Access granted. Welcome, Commander.\");\n        ???\n        System.out.println(\"Access denied. Unauthorized user.\");\n    }\n}",
        "expected_output": [
          "Access granted. Welcome, Commander."
        ],
        "solution_code": "public class DecisionCore {\n    public static void main(String[] args) {\n        String username = \"CommanderZania\";\n\n        if (username.equals(\"CommanderZania\")) {\n        System.out.println(\"Access granted. Welcome, Commander.\");\n        } else {\n        System.out.println(\"Access denied. Unauthorized user.\");\n    }\n}",
        "choices": [
          "else {",
          "if (username.equals(\"CommanderZania\")) {",
          "if (username = \"CommanderZania\")",
          "if (username == \"CommanderZania\")"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 5,
            "type": "keyword",
            "description": "If statement with string comparison",
            "correct_answer": "if (username.equals(\"CommanderZania\")) {",
            "explanation": "Java compares Strings using `.equals()` method. The condition checks if the username matches the commander's ID."
          },
          {
            "id": "slot_2",
            "line": 7,
            "type": "keyword",
            "description": "Else statement",
            "correct_answer": "else {",
            "explanation": "Else handles the rejection case when the username doesn't match."
          }
        ],
        "number_of_slots": 2
      },
      "hints": {
        "1": "Java compares Strings using something other than ==.",
        "2": "One condition checks for match; the other handles rejection.",
        "3": "`=` is an assignment, not a comparison."
      }
    },
    {
      "id": 305,
      "subtopic_id": 7,
      "type": "code_completion",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The ship's Decision Core routes crew to different panels based on rank. Captains get full control, officers partial access, cadets only diagnostics. The if-else-if ladder is glitching. Complete the code to correctly route crew members based on their rank.",
      "story_context": "The ship's Decision Core needs to route crew members based on their rank for access control. Your task is to complete the if-else-if ladder.",
      "challenge_data": {
        "initial_code": "public class DecisionCore {\n    public static void main(String[] args) {\n        String rank = \"Officer\";\n\n        ???\n        System.out.println(\"Full access granted.\");\n        ???\n        System.out.println(\"Partial access granted.\");\n        ???\n        System.out.println(\"Diagnostics access only.\");\n    }\n}",
        "expected_output": [
          "Partial access granted."
        ],
        "solution_code": "public class DecisionCore {\n    public static void main(String[] args) {\n        String rank = \"Officer\";\n\n        if (rank.equals(\"Captain\")) {\n        System.out.println(\"Full access granted.\");\n        } else if (rank.equals(\"Officer\")) {\n        System.out.println(\"Partial access granted.\");\n        } else {\n        System.out.println(\"Diagnostics access only.\");\n    }\n}",
        "choices": [
          "if (rank.equals(\"Captain\")) {",
          "else (rank.equals(\"Cadet\")) {",
          "if (rank == \"Officer\") {",
          "else if (rank.equals(\"Officer\")) {"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 5,
            "type": "keyword",
            "description": "If statement for Captain rank",
            "correct_answer": "if (rank.equals(\"Captain\")) {",
            "explanation": "A ladder handles multiple specific categories. The first condition checks for Captain rank using `.equals()` method."
          },
          {
            "id": "slot_2",
            "line": 7,
            "type": "keyword",
            "description": "Else if statement for Officer rank",
            "correct_answer": "else if (rank.equals(\"Officer\")) {",
            "explanation": "The second condition checks for Officer rank. `else if` takes a condition, unlike `else`."
          }
        ],
        "number_of_slots": 2
      },
      "hints": {
        "1": "A ladder handles multiple specific categories.",
        "2": "Think .equals() vs == for strings in Java.",
        "3": "`else` doesnâ€™t take a condition â€” but `else if` does."
      }
    },
    {
      "id": 306,
      "subtopic_id": 7,
      "type": "code_completion",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The ship has suffered a hull breach. Life support, navigation, and communications are all competing for backup power. The Decision Core is supposed to check subsystem status flags and route power accordingly. Each flag is a boolean, and only one subsystem should receive power at a time â€” following this priority: Life Support > Navigation > Communications. You need to complete the logic that calls the right power-routing function, depending on which flag is true.",
      "story_context": "The ship's emergency power system needs to route power to subsystems based on priority. Your task is to complete the control flow statements.",
      "challenge_data": {
        "initial_code": "public class EmergencyPowerManager {\n    public static void main(String[] args) {\n        // Static subsystem statuses (pretend sensors fed this)\n        boolean lifeSupportActive = false;\n        boolean navigationActive = true;\n        boolean commsActive = true;\n\n        // Only one should run:\n        ???\n        routePowerTo(\"Life Support\");\n        ???\n        routePowerTo(\"Navigation\");\n        ???\n        routePowerTo(\"Communications\");\n    }\n\n    public static void routePowerTo(String system) {\n        System.out.println(\"Routing emergency power to: \" + system);\n    }\n}",
        "expected_output": [
          "Routing emergency power to: Navigation"
        ],
        "solution_code": "public class EmergencyPowerManager {\n    public static void main(String[] args) {\n        // Static subsystem statuses (pretend sensors fed this)\n        boolean lifeSupportActive = false;\n        boolean navigationActive = true;\n        boolean commsActive = true;\n\n        // Only one should run:\n        if (lifeSupportActive) {\n        routePowerTo(\"Life Support\");\n        } else if (navigationActive && !lifeSupportActive) {\n        routePowerTo(\"Navigation\");\n        } else if (commsActive && !navigationActive && !lifeSupportActive) {\n        routePowerTo(\"Communications\");\n    }\n\n    public static void routePowerTo(String system) {\n        System.out.println(\"Routing emergency power to: \" + system);\n    }\n}",
        "choices": [
          "if (lifeSupportActive) {",
          "else if (commsActive && !navigationActive && !lifeSupportActive) {",
          "else if (true) {",
          "else if (!lifeSupportActive) {",
          "if (navigationActive || commsActive) {",
          "else if (navigationActive && !lifeSupportActive) {"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 10,
            "type": "keyword",
            "description": "If statement for Life Support priority",
            "correct_answer": "if (lifeSupportActive) {",
            "explanation": "The challenge requires routing power to only one subsystem based on priority: Life Support > Navigation > Communications. `if (lifeSupportActive)` takes highest priority."
          },
          {
            "id": "slot_2",
            "line": 12,
            "type": "keyword",
            "description": "Else if statement for Navigation priority",
            "correct_answer": "else if (navigationActive && !lifeSupportActive) {",
            "explanation": "`else if (navigationActive && !lifeSupportActive)` ensures Navigation only gets power if Life Support is off."
          },
          {
            "id": "slot_3",
            "line": 14,
            "type": "keyword",
            "description": "Else if statement for Communications priority",
            "correct_answer": "else if (commsActive && !navigationActive && !lifeSupportActive) {",
            "explanation": "`else if (commsActive && !navigationActive && !lifeSupportActive)` ensures Communications only if both higher priorities are off."
          }
        ],
        "number_of_slots": 3
      },
      "hints": {
        "1": "Only one system should be powered â€” this means you need mutually exclusive conditions.",
        "2": "Use negation (`!`) carefully to control the flow.",
        "3": "Think in fallbacks, not overlaps."
      }
    },
    {
      "id": 307,
      "subtopic_id": 7,
      "type": "code_completion",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinderâ€™s system detected an anomaly. The core must decide whether to activate the distress beacon, but itâ€™s not that simple. The system should trigger the beacon only when: Thereâ€™s no response from the crew. The AI system is unstable. The ship is outside communication range. Complete the logic that ensures the distress beacon is only activated under the right conditions.",
      "story_context": "The Pathfinder's emergency system needs to activate the distress beacon under specific conditions. Your task is to complete the control flow statements.",
      "challenge_data": {
        "initial_code": "public class EmergencyProtocol {\n    public static void main(String[] args) {\n        // Simulation inputs (static for test scenario)\n        boolean crewResponsive = false;        // no crew response\n        boolean aiStable = false;              // AI system malfunctioning\n        boolean inCommunicationRange = false;  // ship lost contact\n\n        // Insert condition to trigger beacon:\n        ???\n        activateBeacon();\n        ???\n        System.out.println(\"No beacon needed.\");\n    }\n\n    public static void activateBeacon() {\n        System.out.println(\"Distress Beacon ACTIVATED!\");\n    }\n}",
        "expected_output": [
          "Distress Beacon ACTIVATED!"
        ],
        "solution_code": "public class EmergencyProtocol {\n    public static void main(String[] args) {\n        // Simulation inputs (static for test scenario)\n        boolean crewResponsive = false;        // no crew response\n        boolean aiStable = false;              // AI system malfunctioning\n        boolean inCommunicationRange = false;  // ship lost contact\n\n        // Insert condition to trigger beacon:\n        if (!crewResponsive && !aiStable && !inCommunicationRange) {\n        activateBeacon();\n        } else if (!crewResponsive || !aiStable || !inCommunicationRange) {\n        System.out.println(\"No beacon needed.\");\n    }\n\n    public static void activateBeacon() {\n        System.out.println(\"Distress Beacon ACTIVATED!\");\n    }\n}",
        "choices": [
          "else if (crewResponsive || aiStable || inCommunicationRange) {",
          "if (crewResponsive == false || aiStable == false || inCommunicationRange == false) {",
          "else if (!crewResponsive || !aiStable || !inCommunicationRange) {",
          "if (!crewResponsive && !aiStable && !inCommunicationRange) {",
          "if (!crewResponsive && aiStable && inCommunicationRange) {",
          "else if (crewResponsive || aiStable) {",
          "} else if (!crewResponsive || !aiStable || !inCommunicationRange) {"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 8,
            "type": "keyword",
            "description": "If statement for distress beacon activation",
            "correct_answer": "if (!crewResponsive && !aiStable && !inCommunicationRange) {",
            "explanation": "The distress beacon should activate only when crew is not responsive, AI is not stable, and the ship is not in communication range. This requires a strict `AND` condition of three negations for the `if` block."
          },
          {
            "id": "slot_2",
            "line": 10,
            "type": "keyword",
            "description": "Else if statement for guard clause",
            "correct_answer": "} else if (!crewResponsive || !aiStable || !inCommunicationRange) {",
            "explanation": "The `else if` then handles any other scenario where the beacon is not strictly needed, acting as a guard clause."
          }
        ],
        "number_of_slots": 2
      },
      "hints": {
        "1": "Triple-check the negative logic â€” beacon only activates when all are false.",
        "2": "Use `&&` for strict conditions; `||` when even one failure should prevent activation.",
        "3": "Think of the `else if` as a guard clause â€” make sure nothing slips through accidentally."
      }
    },
    {
      "id": 308,
      "subtopic_id": 7,
      "type": "code_completion",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinderâ€™s life support module is trying to determine whether to increase oxygen output or send a critical alert. It evaluates several real-time conditions: oxygenLevel is below 19%, CO2Level is above 1000 ppm, and crewAwake is true. Only when all conditions are met should the system increase oxygen output. Otherwise, it should trigger a critical alert. Complete the decision logic.",
      "story_context": "The Pathfinder's life support system needs to make critical decisions about oxygen levels. Your task is to complete the control flow statements.",
      "challenge_data": {
        "initial_code": "public class LifeSupportCheck {\n    public static void main(String[] args) {\n        // Static input for simulation\n        double oxygenLevel = 18.5;        // oxygen in percentage\n        int CO2Level = 1100;              // CO2 in ppm\n        boolean crewAwake = true;         // crew status\n\n        // Incomplete decision logic:\n        ???\n        increaseOxygen();\n        ???\n        sendCriticalAlert();\n    }\n\n    public static void increaseOxygen() {\n        System.out.println(\"Increasing oxygen output...\");\n    }\n\n    public static void sendCriticalAlert() {\n        System.out.println(\"CRITICAL ALERT: Life support failing!\");\n    }\n}",
        "expected_output": [
          "Increasing oxygen output..."
        ],
        "solution_code": "public class LifeSupportCheck {\n    public static void main(String[] args) {\n        // Static input for simulation\n        double oxygenLevel = 18.5;        // oxygen in percentage\n        int CO2Level = 1100;              // CO2 in ppm\n        boolean crewAwake = true;         // crew status\n\n        // Incomplete decision logic:\n        if (oxygenLevel < 19 && CO2Level > 1000 && crewAwake) {\n        increaseOxygen();\n        } else if (oxygenLevel >= 19 || CO2Level <= 1000 || !crewAwake) {\n        sendCriticalAlert();\n    }\n\n    public static void increaseOxygen() {\n        System.out.println(\"Increasing oxygen output...\");\n    }\n\n    public static void sendCriticalAlert() {\n        System.out.println(\"CRITICAL ALERT: Life support failing!\");\n    }\n}",
        "choices": [
          "if (oxygenLevel < 19 && CO2Level > 1000 && crewAwake == true) {",
          "if (oxygenLevel < 20 || CO2Level > 1000) {",
          "if (oxygenLevel < 19 && CO2Level > 1000 || crewAwake) {",
          "else if (oxygenLevel >= 19 || CO2Level <= 1000 || !crewAwake) {",
          "if (oxygenLevel < 19 && CO2Level > 1000 && crewAwake) {",
          "else if (oxygenLevel < 19 && CO2Level > 1000 && crewAwake) {",
          "} else if (oxygenLevel >= 19 || CO2Level <= 1000 || !crewAwake) {"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 9,
            "type": "keyword",
            "description": "If statement for oxygen increase conditions",
            "correct_answer": "if (oxygenLevel < 19 && CO2Level > 1000 && crewAwake) {",
            "explanation": "The system should increase oxygen output only when all three conditions are met (oxygen low, CO2 high, crew awake), requiring an `AND` for the `if` block."
          },
          {
            "id": "slot_2",
            "line": 11,
            "type": "keyword",
            "description": "Else if statement for critical alert",
            "correct_answer": "} else if (oxygenLevel >= 19 || CO2Level <= 1000 || !crewAwake) {",
            "explanation": "The `else if` should cover all other possibilities that don't meet the oxygen increase criteria, triggering a critical alert if any of those 'safe' conditions are *not* met."
          }
        ],
        "number_of_slots": 2
      },
      "hints": {
        "1": "Remember that the system is cautious â€” all danger signs must be present to adjust oxygen.",
        "2": "Be specific â€” using `&&` ensures multiple checks are passed before acting.",
        "3": "The `else if` block handles all other possibilities â€” think what happens if even one condition isnâ€™t true."
      }
    },
    {
      "id": 309,
      "subtopic_id": 7,
      "type": "code_completion",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "You're inside the Pathfinderâ€™s Secure Bridge, blocked by a biometric gate. The AI should allow access only if the crew memberâ€™s ID is valid and theyâ€™ve completed security clearance. If not, it should deny access and alert the captain. Complete the logic circuits for decision-making.",
      "story_context": "The Pathfinder's Secure Bridge needs to control access based on multiple security criteria. Your task is to complete the control flow statements.",
      "challenge_data": {
        "initial_code": "public class AccessControl {\n    public static void main(String[] args) {\n        // Simulated user credentials\n        boolean validID = true;              // âœ… crew ID validity\n        boolean clearanceComplete = false;   // âŒ security check\n        boolean biometricScan = true;        // âœ… thumb scan complete\n\n        ???\n        grantAccess();\n\n        ???\n        requestBiometricRescan();\n\n        ???\n        alertCaptain();\n    }\n\n    public static void grantAccess() {\n        System.out.println(\"âœ… Access granted. Welcome aboard.\");\n    }\n\n    public static void requestBiometricRescan() {\n        System.out.println(\"âš ï¸ Biometric scan failed. Please rescan.\");\n    }\n\n    public static void alertCaptain() {\n        System.out.println(\"ðŸš¨ Access denied. Captain has been notified.\");\n    }\n}",
        "expected_output": [
          "âš ï¸ Biometric scan failed. Please rescan."
        ],
        "solution_code": "public class AccessControl {\n    public static void main(String[] args) {\n        // Simulated user credentials\n        boolean validID = true;              // âœ… crew ID validity\n        boolean clearanceComplete = false;   // âŒ security check\n        boolean biometricScan = true;        // âœ… thumb scan complete\n\n        if (validID && clearanceComplete && biometricScan) {\n        grantAccess();\n        } else if (validID && !biometricScan) {\n        requestBiometricRescan();\n        } else {\n        alertCaptain();\n    }\n\n    public static void grantAccess() {\n        System.out.println(\"âœ… Access granted. Welcome aboard.\");\n    }\n\n    public static void requestBiometricRescan() {\n        System.out.println(\"âš ï¸ Biometric scan failed. Please rescan.\");\n    }\n\n    public static void alertCaptain() {\n        System.out.println(\"ðŸš¨ Access denied. Captain has been notified.\");\n    }\n}",
        "choices": [
          "else {",
          "else if (!validID && clearanceComplete) {",
          "else if (validID && !biometricScan) {",
          "if (validID && clearanceComplete && biometricScan) {",
          "if (!validID && !clearanceComplete && biometricScan) {",
          "if (validID || clearanceComplete || biometricScan) {"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 8,
            "type": "keyword",
            "description": "If statement for full access",
            "correct_answer": "if (validID && clearanceComplete && biometricScan) {",
            "explanation": "The bridge must only open when everything checks out. This condition requires all three criteria to be true."
          },
          {
            "id": "slot_2",
            "line": 11,
            "type": "keyword",
            "description": "Else if statement for biometric rescan",
            "correct_answer": "else if (validID && !biometricScan) {",
            "explanation": "An else if without a condition is perfect when you've already handled the positive case. This handles the case where ID is valid but biometric scan failed."
          },
          {
            "id": "slot_3",
            "line": 13,
            "type": "keyword",
            "description": "Else statement for denial",
            "correct_answer": "else {",
            "explanation": "Using || in this situation would grant access too easily â€” not good for security. This else handles all other cases."
          }
        ],
        "number_of_slots": 3
      },
      "hints": {
        "1": "The bridge must only open when everything checks out.",
        "2": "An else without a condition is perfect when you've already handled the positive case.",
        "3": "Using || in this situation would grant access too easily â€” not good for security."
      }
    },
    {
      "id": 310,
      "subtopic_id": 7,
      "type": "code_completion",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "You're inside the Pathfinder's Bridge Terminal, where only users with proper credentials are allowed to issue ship commands. The AI system must validate access based on: The user's security level (should be at least 3), If they're logged in, and Whether they're trying to access restricted controls. Your job? Complete the decision logic to grant or deny access safely.",
      "story_context": "The Pathfinder's Bridge Terminal needs to control access based on security levels and login status. Your task is to complete the control flow statements.",
      "challenge_data": {
        "initial_code": "public class BridgeAccessControl {\n    public static void main(String[] args) {\n        // Static simulation data\n        int securityLevel = 4;           // Required: level 3 or higher\n        boolean isLoggedIn = true;\n        boolean wantsRestrictedAccess = true;\n\n        ???\n        grantAccess();\n        ???\n        restrictAccess();\n        ???\n        denyAccess();\n    }\n\n    public static void grantAccess() {\n        System.out.println(\"Access granted. Welcome to the Bridge Terminal.\");\n    }\n\n    public static void restrictAccess() {\n        System.out.println(\"Access limited. Restricted controls unavailable.\");\n    }\n\n    public static void denyAccess() {\n        System.out.println(\"Access denied. Unauthorized attempt detected.\");\n    }\n}",
        "expected_output": [
          "Access granted. Welcome to the Bridge Terminal."
        ],
        "solution_code": "public class BridgeAccessControl {\n    public static void main(String[] args) {\n        // Static simulation data\n        int securityLevel = 4;           // Required: level 3 or higher\n        boolean isLoggedIn = true;\n        boolean wantsRestrictedAccess = true;\n\n        if (securityLevel >= 3 && isLoggedIn) {\n        grantAccess();\n        } else if (wantsRestrictedAccess) {\n        restrictAccess();\n        } else {\n        denyAccess();\n    }\n\n    public static void grantAccess() {\n        System.out.println(\"Access granted. Welcome to the Bridge Terminal.\");\n    }\n\n    public static void restrictAccess() {\n        System.out.println(\"Access limited. Restricted controls unavailable.\");\n    }\n\n    public static void denyAccess() {\n        System.out.println(\"Access denied. Unauthorized attempt detected.\");\n    }\n}",
        "choices": [
          "if (securityLevel >= 3 && isLoggedIn) {",
          "else if (wantsRestrictedAccess) {",
          "else {",
          "else if (securityLevel <= 3 && wantsRestrictedAccess) {",
          "if (isLoggedIn && wantsRestrictedAccess) {",
          "if (securityLevel > 3 || !isLoggedIn) {",
          "} else if (wantsRestrictedAccess) {"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 8,
            "type": "keyword",
            "description": "If statement for full access",
            "correct_answer": "if (securityLevel >= 3 && isLoggedIn) {",
            "explanation": "Security systems typically check the user's level first, not last. This condition ensures both security level and login status are valid."
          },
          {
            "id": "slot_2",
            "line": 10,
            "type": "keyword",
            "description": "Else if statement for restricted access",
            "correct_answer": "} else if (wantsRestrictedAccess) {",
            "explanation": "Not all logged-in users should get full access. This handles the case where restricted access is requested."
          },
          {
            "id": "slot_3",
            "line": 12,
            "type": "keyword",
            "description": "Else statement for denial",
            "correct_answer": "} else {",
            "explanation": "Else is your safety net when all other conditions fail."
          }
        ],
        "number_of_slots": 3
      },
      "hints": {
        "1": "Security systems typically check the user's level first, not last.",
        "2": "Not all logged-in users should get full access.",
        "3": "else is your safety net when all other conditions fail."
      }
    },
    {
      "id": 311,
      "subtopic_id": 7,
      "type": "code_completion",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinder's security core is locked due to rising internal temperatures and rogue AI processes. A crew member is attempting to authenticate access, but not all loginoporto attempts are safe. Access should only be granted if: The credentials are correct, The account is not locked, The retry count is below maximum, Or an emergency override is active. Complete the logic that ensures access is only granted under proper, secure conditions.",
      "story_context": "The Pathfinder's security system needs to handle complex authentication scenarios with override capabilities. Your task is to complete the control flow statements.",
      "challenge_data": {
        "initial_code": "public class SecureBridgeAccess {\n    public static void main(String[] args) {\n        // Static test scenario\n        String username = \"commander01\";\n        String password = \"redPhoenix\";\n        boolean isLocked = true;\n        int retryCount = 3;\n        boolean overrideKeyActive = true;\n\n        if (!isLocked) {\n            ???\n            System.out.println(\"âœ… Access Granted: Welcome Commander.\");\n        } else {\n            ???\n            System.out.println(\"ðŸ”“ Override Access Enabled.\");\n        }\n    }\n}",
        "expected_output": [
          "ðŸ”“ Override Access Enabled."
        ],
        "solution_code": "public class SecureBridgeAccess {\n    public static void main(String[] args) {\n        // Static test scenario\n        String username = \"commander01\";\n        String password = \"redPhoenix\";\n        boolean isLocked = true;\n        int retryCount = 3;\n        boolean overrideKeyActive = true;\n\n        if (!isLocked) {\n            if (username.equals(\"commander01\") && password.equals(\"redPhoenix\")) {\n            System.out.println(\"âœ… Access Granted: Welcome Commander.\");\n            } else if (retryCount >= 3 && overrideKeyActive) {\n            System.out.println(\"ðŸ”“ Override Access Enabled.\");\n            }\n        } else {\n            if (isLocked && overrideKeyActive) {\n            System.out.println(\"ðŸ”“ Override Access Enabled.\");\n            } else {\n            System.out.println(\"Access denied.\");\n            }\n        }\n    }\n}",
        "choices": [
          "if (retryCount < 3 && overrideKeyActive) {",
          "} else if (retryCount >= 3 && overrideKeyActive) {",
          "else if (overrideKeyActive) {",
          "if (isLocked && overrideKeyActive) {",
          "else if (!overrideKeyActive) {",
          "if (username == \"commander01\" && password ==\"redPhoenix\") {",
          "else {",
          "if (username.equals(\"commander01\") && password.equals(\"redPhoenix\")) {",
          "else if (retryCount >= 3 && overrideKeyActive) {"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 9,
            "type": "keyword",
            "description": "If statement for credential validation",
            "correct_answer": "if (username.equals(\"commander01\") && password.equals(\"redPhoenix\")) {",
            "explanation": "The system behaves differently depending on whether it's locked or not. This checks for correct credentials when the account is not locked."
          },
          {
            "id": "slot_2",
            "line": 11,
            "type": "keyword",
            "description": "Else if statement for override access",
            "correct_answer": "} else if (retryCount >= 3 && overrideKeyActive) {",
            "explanation": "Retry logic is only useful if the account isn't locked yet. This handles the case where retry count is exceeded but override is active."
          },
          {
            "id": "slot_3",
            "line": 15,
            "type": "keyword",
            "description": "If statement for locked account override",
            "correct_answer": "if (isLocked && overrideKeyActive) {",
            "explanation": "An active override bypasses even locked status â€” but must be explicitly checked."
          },
          {
            "id": "slot_4",
            "line": 17,
            "type": "keyword",
            "description": "Else statement for denial",
            "correct_answer": "} else {",
            "explanation": "This handles all other cases where access should be denied."
          }
        ],
        "number_of_slots": 4
      },
      "hints": {
        "1": "The system behaves differently depending on whether it's locked or not â€” split logic starts from that.",
        "2": "Retry logic is only useful if the account isn't locked yet.",
        "3": "An active override bypasses even locked status â€” but must be explicitly checked."
      }
    },
    {
      "id": 312,
      "subtopic_id": 7,
      "type": "code_completion",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinderâ€™s Reactor Core is in a volatile state. The system must determine whether to engage cooling based on a chain of strict conditions: If the core temperature is above 1000Â°C, activate emergency cooling immediately. If the core temperature is between 600Â°C and 1000Â°C, cooling is allowed only if: The pressure is stable, and Coolant levels are sufficient. If the temperature is below 600Â°C, no action unless thereâ€™s an emergency override. If all else fails, default to a safe fallback mode. Complete the code by filling the four missing logical conditions embedded in a skewed nested if-else decision structure.",
      "story_context": "The Pathfinder's Reactor Core needs to determine cooling engagement based on strict safety conditions. Your task is to complete the logical conditions.",
      "challenge_data": {
        "initial_code": "public class ReactorControl {\n    public static void main(String[] args) {\n        // Simulated sensor readings\n        int coreTemperature = 750;     // degrees Celsius\n        boolean pressureStable = true;\n        boolean coolantSufficient = true;\n        boolean emergencyOverride = false;\n\n        if (coreTemperature > 1000) {\n            System.out.println(\"CRITICAL: Cooling System ENGAGED Immediately!\");\n        } else if (coreTemperature >= 600) {\n            ???\n            System.out.println(\"MODERATE: Cooling System Activated.\");\n        } else {\n            ???\n            System.out.println(\"WARNING: Cannot Activate Cooling â€“ Insufficient Support.\");\n        }\n    }\n}",
        "expected_output": [
          "MODERATE: Cooling System Activated."
        ],
        "solution_code": "public class ReactorControl {\n    public static void main(String[] args) {\n        // Simulated sensor readings\n        int coreTemperature = 750;     // degrees Celsius\n        boolean pressureStable = true;\n        boolean coolantSufficient = true;\n        boolean emergencyOverride = false;\n\n        if (coreTemperature > 1000) {\n            System.out.println(\"CRITICAL: Cooling System ENGAGED Immediately!\");\n        } else if (coreTemperature >= 600) {\n            if (pressureStable && coolantSufficient) {\n            System.out.println(\"MODERATE: Cooling System Activated.\");\n            } else if (!pressureStable || !coolantSufficient) {\n            System.out.println(\"WARNING: Cannot Activate Cooling â€“ Insufficient Support.\");\n            }\n        } else {\n            if (!emergencyOverride) {\n            System.out.println(\"WARNING: Cannot Activate Cooling â€“ Insufficient Support.\");\n            } else {\n            System.out.println(\"MODERATE: Cooling System Activated.\");\n            }\n        }\n    }\n}",
        "choices": [
          "else if (coreTemperature < 600 && emergencyOverride) {",
          "if (!emergencyOverride) {",
          "if (pressureStable && coolantSufficient) {",
          "if (pressureStable && !coolantSufficient) {",
          "else {",
          "if (pressureStable || coolantSufficient) {",
          "else if (!pressureStable || !coolantSufficient) {"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 12,
            "type": "keyword",
            "description": "If statement for pressure and coolant check",
            "correct_answer": "if (pressureStable && coolantSufficient) {",
            "explanation": "The system should never assume it's safe to cool unless everything checks out â€” pressure AND coolant must be good."
          },
          {
            "id": "slot_2",
            "line": 14,
            "type": "keyword",
            "description": "Else if statement for safety check failure",
            "correct_answer": "else if (!pressureStable || !coolantSufficient) {",
            "explanation": "Reactors don't forgive ambiguity â€” if even one safety check fails, that path must be blocked."
          },
          {
            "id": "slot_3",
            "line": 18,
            "type": "keyword",
            "description": "If statement for emergency override check",
            "correct_answer": "if (!emergencyOverride) {",
            "explanation": "If emergencyOverride is active, do not second-guess â€” follow the override. Logic must submit."
          },
          {
            "id": "slot_4",
            "line": 20,
            "type": "keyword",
            "description": "Else statement for emergency override",
            "correct_answer": "else {",
            "explanation": "This else handles the case when emergency override is active."
          }
        ],
        "number_of_slots": 4
      },
      "hints": {
        "1": "The system should never assume itâ€™s safe to cool unless everything checks out â€” pressure AND coolant must be good.",
        "2": "Reactors donâ€™t forgive ambiguity â€” if even one safety check fails, that path must be blocked.",
        "3": "If emergencyOverride is active, do not second-guess â€” follow the override. Logic must submit."
      }
    },
    {
      "id": 313,
      "subtopic_id": 7,
      "type": "code_completion",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinderâ€™s docking system has detected a potential emergency docking sequence with an unidentified vessel. The system must make a high-stakes decision to proceed or abort the docking based on the following conditions: If the vesselâ€™s ID is verified and docking alignment is perfect, initiate auto-docking. If the vessel is not verified but marked as friendly, docking may proceed only if: The alignment is perfect, and The Pathfinderâ€™s shield is active. If the vessel is unverified and not friendly, but a distress signal is detected, ask for crew confirmation. If none of these criteria are met, abort docking and lock bay doors. Your job: complete the four missing logical conditions embedded in a skewed nested if-else decision structure.",
      "story_context": "The Pathfinder's docking system needs to make critical decisions about vessel docking based on multiple safety criteria. Your task is to complete the control flow statements.",
      "challenge_data": {
        "initial_code": "public class DockingControl {\n    public static void main(String[] args) {\n        // Simulated inputs\n        boolean vesselIDVerified = false;\n        boolean vesselIsFriendly = true;\n        boolean alignmentPerfect = true;\n        boolean shieldActive = true;\n        boolean distressSignalDetected = false;\n        boolean crewConfirmed = false;\n\n        if (vesselIDVerified) {\n            if (alignmentPerfect) {\n                System.out.println(\"Auto-Docking Initiated: Verified Vessel.\");\n            } else {\n                System.out.println(\"Abort: Misaligned Verified Vessel.\");\n            }\n        } else if (vesselIsFriendly) {\n            ???\n            System.out.println(\"Conditional Docking Allowed: Friendly Vessel.\");\n        } else {\n            ???\n            System.out.println(\"Abort: Friendly Vessel â€“ Unsafe to Dock.\");\n        }\n    }\n}",
        "expected_output": [
          "Conditional Docking Allowed: Friendly Vessel."
        ],
        "solution_code": "public class DockingControl {\n    public static void main(String[] args) {\n        // Simulated inputs\n        boolean vesselIDVerified = false;\n        boolean vesselIsFriendly = true;\n        boolean alignmentPerfect = true;\n        boolean shieldActive = true;\n        boolean distressSignalDetected = false;\n        boolean crewConfirmed = false;\n\n        if (vesselIDVerified) {\n            if (alignmentPerfect) {\n                System.out.println(\"Auto-Docking Initiated: Verified Vessel.\");\n            } else {\n                System.out.println(\"Abort: Misaligned Verified Vessel.\");\n            }\n        } else if (vesselIsFriendly) {\n            if (alignmentPerfect && shieldActive) {\n            System.out.println(\"Conditional Docking Allowed: Friendly Vessel.\");\n            } else if (!alignmentPerfect || !shieldActive) {\n            System.out.println(\"Abort: Friendly Vessel â€“ Unsafe to Dock.\");\n            }\n        } else {\n            if (crewConfirmed) {\n            System.out.println(\"Emergency Docking: Crew Confirmed.\");\n            } else {\n            System.out.println(\"Abort: No Confirmation â€“ Lock Bay Doors.\");\n            }\n        }\n    }\n}",
        "choices": [
          "else if (!alignmentPerfect || shieldAshieldActivective)",
          "} else if (!alignmentPerfect || !shieldActive) {",
          "if (alignmentPerfect && shieldActive) {",
          "} else {",
          "else if (!alignmentPerfect || !shieldActive) {",
          "if (crewConfirmed) {",
          "else {",
          "else if (alignmentPerfect || !)",
          "if (alignmentPerfect || shieldActive) {"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 15,
            "type": "keyword",
            "description": "If statement for friendly vessel docking conditions",
            "correct_answer": "if (alignmentPerfect && shieldActive) {",
            "explanation": "Allowing a friendly vessel to dock without full system integrity might open the ship to risk. If docking support systems are even partially down, it shouldn't proceed."
          },
          {
            "id": "slot_2",
            "line": 17,
            "type": "keyword",
            "description": "Else if statement for unsafe docking conditions",
            "correct_answer": "} else if (!alignmentPerfect || !shieldActive) {",
            "explanation": "If docking support systems are even partially down, it shouldn't proceed."
          },
          {
            "id": "slot_3",
            "line": 21,
            "type": "keyword",
            "description": "If statement for crew confirmation",
            "correct_answer": "if (crewConfirmed) {",
            "explanation": "Just because a distress signal is received doesn't mean you ignore procedure. There needs to be clear, internal confirmation before committing to such a critical action."
          },
          {
            "id": "slot_4",
            "line": 23,
            "type": "keyword",
            "description": "Else statement for no confirmation",
            "correct_answer": "} else {",
            "explanation": "When neither verification nor friendliness is present, and no signal exists, the system must not proceed. It must fall back to absolute safety â€” no ambiguity allowed."
          }
        ],
        "number_of_slots": 4
      },
      "hints": {
        "1": "Allowing a friendly vessel to dock without full system integrity might open the ship to risk. If docking support systems are even partially down, it shouldnâ€™t proceed.",
        "2": "Just because a distress signal is received doesnâ€™t mean you ignore procedure. There needs to be clear, internal confirmation before committing to such a critical action.",
        "3": "When neither verification nor friendliness is present, and no signal exists, the system must not proceed. It must fall back to absolute safety â€” no ambiguity allowed."
      }
    },
    {
      "id": 314,
      "subtopic_id": 7,
      "type": "code_completion",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "A fire alert just went off somewhere on the ship. The AI needs to quickly figure out how serious it is and decide what to do. If both the crew and important ship systems are in danger, it should break the lockdown and save both. If only the crew is at risk, it should help them get out and seal the area. If no oneâ€™s inside but the shipâ€™s systems are in trouble, it should fight the fire but keep everything locked. If thereâ€™s no real danger (just a weird fire signal), the AI should log it and do nothing. If none of those situations fit, just treat it like a regular check-up. Complete the incomplete code.",
      "story_context": "The Pathfinder's AI needs to assess fire alerts and determine appropriate responses. Your task is to complete the control flow statements.",
      "challenge_data": {
        "initial_code": "public class EthicsCore {\n    public static void main(String[] args) {\n        // Emergency Data Feed\n        boolean crewInDanger = true;\n        boolean criticalSystemsAtRisk = false;\n        boolean crewPresent = true;\n        boolean fireDetected = true;\n\n        if (crewInDanger && criticalSystemsAtRisk) {\n            System.out.println(\"PRIORITY: Lockdown Override â€“ Save Crew and Systems!\");\n        } else if (crewInDanger) {\n            ???\n            System.out.println(\"EVACUATE: Crew Safety Protocol Initiated.\");\n        } else if (criticalSystemsAtRisk && !crewPresent) {\n            ???\n            System.out.println(\"Suppressing Fire: Lockdown Maintained.\");\n        } else if (!crewInDanger && !criticalSystemsAtRisk && fireDetected) {\n            ???\n            System.out.println(\"FALSE ALARM: Fire Logged â€“ No Action Required.\");\n        } else {\n            ???\n            System.out.println(\"Status Nominal: No Threat Detected.\");\n        }\n    }\n}",
        "expected_output": [
          "EVACUATE: Crew Safety Protocol Initiated."
        ],
        "solution_code": "public class EthicsCore {\n    public static void main(String[] args) {\n        // Emergency Data Feed\n        boolean crewInDanger = true;\n        boolean criticalSystemsAtRisk = false;\n        boolean crewPresent = true;\n        boolean fireDetected = true;\n\n        if (crewInDanger && criticalSystemsAtRisk) {\n            System.out.println(\"PRIORITY: Lockdown Override â€“ Save Crew and Systems!\");\n        } else if (crewInDanger) {\n            else if (crewInDanger && !criticalSystemsAtRisk) {\n            System.out.println(\"EVACUATE: Crew Safety Protocol Initiated.\");\n            }\n        } else if (criticalSystemsAtRisk && !crewPresent) {\n            else if (criticalSystemsAtRisk && !crewPresent) {\n            System.out.println(\"Suppressing Fire: Lockdown Maintained.\");\n            }\n        } else if (!crewInDanger && !criticalSystemsAtRisk && fireDetected) {\n            else if (!crewInDanger && !criticalSystemsAtRisk && fireDetected) {\n            System.out.println(\"FALSE ALARM: Fire Logged â€“ No Action Required.\");\n            }\n        } else {\n            else {\n            System.out.println(\"Status Nominal: No Threat Detected.\");\n            }\n        }\n    }\n}",
        "choices": [
          "else if (criticalSystemsAtRisk && !crewPresent) {",
          "else {",
          "if (!criticalSystemsAtRisk && crewInDanger) {",
          "else if (crewInDanger && !criticalSystemsAtRisk) {",
          "else if (!fireDetected) {",
          "else if (criticalSystemsAtRisk || crewPresent) {",
          "else if (!crewInDanger && !criticalSystemsAtRisk && fireDetected) {",
          "if (fireDetected && !crewInDanger && !criticalSystemsAtRisk) {"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 10,
            "type": "keyword",
            "description": "Else if statement for crew danger without system risk",
            "correct_answer": "else if (crewInDanger && !criticalSystemsAtRisk) {",
            "explanation": "If the crew is in danger but systems aren't, sealing off the affected wing is safer than overriding lockdown â€” the priority is human life, but without system risk, no need to compromise ship integrity."
          },
          {
            "id": "slot_2",
            "line": 13,
            "type": "keyword",
            "description": "Else if statement for system risk without crew",
            "correct_answer": "else if (criticalSystemsAtRisk && !crewPresent) {",
            "explanation": "Suppressing a fire in a system area without risking crew exposure is acceptable, but the lockdown should remain intact â€” no need for override if lives aren't on the line."
          },
          {
            "id": "slot_3",
            "line": 16,
            "type": "keyword",
            "description": "Else if statement for false alarm",
            "correct_answer": "else if (!crewInDanger && !criticalSystemsAtRisk && fireDetected) {",
            "explanation": "False alarms must be filtered out by checking all conditions â€” if no one's in danger and systems are stable, logging is enough. Acting on noise is how ships waste resources â€” or worse, cause more chaos."
          },
          {
            "id": "slot_4",
            "line": 19,
            "type": "keyword",
            "description": "Else statement for default case",
            "correct_answer": "else {",
            "explanation": "This else handles all other cases that don't fit the specific conditions above."
          }
        ],
        "number_of_slots": 4
      },
      "hints": {
        "1": "If the crew is in danger but systems arenâ€™t, sealing off the affected wing is safer than overriding lockdown â€” the priority is human life, but without system risk, no need to compromise ship integrity.",
        "2": "Suppressing a fire in a system area without risking crew exposure is acceptable, but the lockdown should remain intact â€” no need for override if lives arenâ€™t on the line.",
        "3": "False alarms must be filtered out by checking all conditions â€” if no oneâ€™s in danger and systems are stable, logging is enough. Acting on noise is how ships waste resources â€” or worse, cause more chaos."
      }
    },
    {
      "id": 315,
      "subtopic_id": 7,
      "type": "code_completion",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinder AI is negotiating a delicate situation involving an unidentified vessel. The system must assess threat levels, weapon readiness, and communication status to determine the correct diplomatic or defensive response. The AI must decide whether to engage, communicate, or log the encounter â€” and ensure fallback safety if none of the standard paths are viable. The logic must be precise. Each situation demands a specific action. Complete the incomplete code.",
      "story_context": "The Pathfinder's AI needs to handle diplomatic encounters with unidentified vessels based on threat assessment. Your task is to complete the control flow statements.",
      "challenge_data": {
        "initial_code": "public class DiplomacyProtocol {\n    public static void main(String[] args) {\n        // Incoming Encounter Data\n        boolean threatDetected = true;\n        boolean weaponsArmed = false;\n        boolean vesselResponsive = false;\n\n        if (threatDetected && weaponsArmed) {\n            System.out.println(\"ALERT: Countermeasures Engaged!\");\n        } else if (threatDetected && !weaponsArmed) {\n            ???\n            System.out.println(\"Diplomatic Attempt: Shields Raised, Hailing...\");\n        } else if (!threatDetected && !vesselResponsive) {\n            ???\n            System.out.println(\"Broadcast Warning: Awaiting Acknowledgment.\");\n        } else if (!threatDetected && vesselResponsive) {\n            ???\n            System.out.println(\"LOGGED: Peaceful Contact Recorded.\");\n        } else {\n            ???\n            System.out.println(\"Standby Mode: Monitoring Situation.\");\n        }\n    }\n}",
        "expected_output": [
          "Diplomatic Attempt: Shields Raised, Hailing..."
        ],
        "solution_code": "public class DiplomacyProtocol {\n    public static void main(String[] args) {\n        // Incoming Encounter Data\n        boolean threatDetected = true;\n        boolean weaponsArmed = false;\n        boolean vesselResponsive = false;\n\n        if (threatDetected && weaponsArmed) {\n            System.out.println(\"ALERT: Countermeasures Engaged!\");\n        } else if (threatDetected && !weaponsArmed) {\n            else if (threatDetected && !weaponsArmed) {\n            System.out.println(\"Diplomatic Attempt: Shields Raised, Hailing...\");\n            }\n        } else if (!threatDetected && !vesselResponsive) {\n            else if (!threatDetected && !vesselResponsive) {\n            System.out.println(\"Broadcast Warning: Awaiting Acknowledgment.\");\n            }\n        } else if (!threatDetected && vesselResponsive) {\n            else if (!threatDetected && vesselResponsive) {\n            System.out.println(\"LOGGED: Peaceful Contact Recorded.\");\n            }\n        } else {\n            else {\n            System.out.println(\"Standby Mode: Monitoring Situation.\");\n            }\n        }\n    }\n}",
        "choices": [
          "else if (threatDetected && !weaponsArmed) {",
          "if (threatDetected && weaponsArmed && vesselResponsive) {",
          "if (!threatDetected && vesselResponsive) {",
          "else if (!threatDetected && !vesselResponsive) {",
          "} else if (!threatDetected && !vesselResponsive) {",
          "else if (weaponsArmed || threatDetected) {",
          "else if (!threatDetected && vesselResponsive) {",
          "else {",
          "} else if (!threatDetected && vesselResponsive) {",
          "if (vesselResponsive && !threatDetected) {"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 9,
            "type": "keyword",
            "description": "Else if statement for diplomatic attempt",
            "correct_answer": "else if (threatDetected && !weaponsArmed) {",
            "explanation": "Hostility doesn't always mean action â€” the system must weigh armed status before engaging."
          },
          {
            "id": "slot_2",
            "line": 11,
            "type": "keyword",
            "description": "Else if statement for broadcast warning",
            "correct_answer": "} else if (!threatDetected && !vesselResponsive) {",
            "explanation": "Silence from a vessel, even if not hostile, shouldn't be ignored â€” some reaction is necessary."
          },
          {
            "id": "slot_3",
            "line": 13,
            "type": "keyword",
            "description": "Else if statement for peaceful contact",
            "correct_answer": "} else if (!threatDetected && vesselResponsive) {",
            "explanation": "Peaceful interactions must still be processed for future records â€” no encounter goes undocumented."
          },
          {
            "id": "slot_4",
            "line": 15,
            "type": "keyword",
            "description": "Else statement for standby mode",
            "correct_answer": "} else {",
            "explanation": "This else handles all other cases that don't fit the specific conditions above."
          }
        ],
        "number_of_slots": 4
      },
      "hints": {
        "1": "Hostility doesnâ€™t always mean action â€” the system must weigh armed status before engaging.",
        "2": "Silence from a vessel, even if not hostile, shouldnâ€™t be ignored â€” some reaction is necessary.",
        "3": "Peaceful interactions must still be processed for future records â€” no encounter goes undocumented."
      }
    },
    {
      "id": 316,
      "subtopic_id": 8,
      "type": "output_tracing",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinder's automated hull scanner runs a diagnostic. A `while` loop controls the number of scans. Your task is to trace the code and determine how many times \"Performing hull scan.\" is printed.",
      "story_context": "The Pathfinder's hull scanner needs to perform multiple scans using a while loop. Your task is to trace the loop execution and predict the output.",
      "challenge_data": {
        "code": "public class HullScanner {\n    public static void main(String[] args) {\n        int scanCount = 0;\n        while (scanCount < 3) {\n            System.out.println(\"Performing hull scan.\");\n            scanCount++;\n        }\n    }\n}",
        "expected_output": [
          "Performing hull scan.\\nPerforming hull scan.\\nPerforming hull scan."
        ],
        "choices": [
          "Performing hull scan.",
          "Performing hull scan.\\nPerforming hull scan.\\nPerforming hull scan.",
          "Nothing",
          "Error"
        ],
        "explanation": "The `while` loop starts with `scanCount = 0`.\n1. **Iteration 1**: `scanCount` (0) is less than 3 (`true`). Prints \"Performing hull scan.\". `scanCount` becomes 1.\n2. **Iteration 2**: `scanCount` (1) is less than 3 (`true`). Prints \"Performing hull scan.\". `scanCount` becomes 2.\n3. **Iteration 3**: `scanCount` (2) is less than 3 (`true`). Prints \"Performing hull scan.\". `scanCount` becomes 3.\n4. **Iteration 4**: `scanCount` (3) is less than 3 (`false`). The loop terminates.\nThe message is printed 3 times."
      },
      "hints": {
        "1": "The loop continues as long as `scanCount` is less than `3`.",
        "2": "`scanCount` starts at `0` and increments by `1` in each iteration.",
        "3": "Count how many times the `System.out.println()` line is executed."
      }
    },
    {
      "id": 317,
      "subtopic_id": 8,
      "type": "output_tracing",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinder's emergency beacon operates with a `do-while` loop, ensuring it blinks at least once. Your task is to trace the code and determine how many times \"Beacon: Blink!\" is printed.",
      "story_context": "The Pathfinder's emergency beacon needs to blink using a do-while loop. Your task is to trace the loop execution and predict the output.",
      "challenge_data": {
        "code": "public class BeaconFlasher {\n    public static void main(String[] args) {\n        int blinkCount = 0;\n        do {\n            System.out.println(\"Beacon: Blink!\");\n            blinkCount++;\n        } while (blinkCount < 0);\n    }\n}",
        "expected_output": [
          "Beacon: Blink!"
        ],
        "choices": [
          "Nothing",
          "Beacon: Blink!",
          "Beacon: Blink!\\nBeacon: Blink!",
          "Error"
        ],
        "explanation": "The `do-while` loop ensures its body executes at least once.\n1. **First Execution**: Prints \"Beacon: Blink!\". `blinkCount` becomes 1.\n2. **Condition Check**: `blinkCount` (1) is less than 0 (`false`). The loop terminates.\nThe message is printed only 1 time."
      },
      "hints": {
        "1": "A `do-while` loop *always* executes its body at least once before checking the condition.",
        "2": "The `blinkCount` starts at `0`.",
        "3": "Evaluate the `while` condition (`blinkCount < 0`) after the first execution."
      }
    },
    {
      "id": 318,
      "subtopic_id": 8,
      "type": "output_tracing",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinder's power core runs `cyclesCompleted`. A `while` loop simulates these cycles, printing the current cycle number. Your task is to trace the code and determine the sequence of numbers printed on a single line.",
      "story_context": "The Pathfinder's power core needs to run cycles using a while loop. Your task is to trace the loop execution and predict the output.",
      "challenge_data": {
        "code": "public class PowerCoreCycler {\n    public static void main(String[] args) {\n        int cyclesCompleted = 1;\n        while (cyclesCompleted <= 2) {\n            System.out.print(cyclesCompleted + \" \");\n            cyclesCompleted++;\n        }\n    }\n}",
        "expected_output": [
          "1 2"
        ],
        "choices": [
          "1 2",
          "1 2 3",
          "0 1 2",
          "Nothing"
        ],
        "explanation": "The `while` loop starts with `cyclesCompleted = 1`.\n1. **Iteration 1**: `cyclesCompleted` (1) is `<= 2` (`true`). Prints \"1 \". `cyclesCompleted` becomes 2.\n2. **Iteration 2**: `cyclesCompleted` (2) is `<= 2` (`true`). Prints \"2 \". `cyclesCompleted` becomes 3.\n3. **Iteration 3**: `cyclesCompleted` (3) is `<= 2` (`false`). The loop terminates.\nThe output is \"1 2 \"."
      },
      "hints": {
        "1": "The loop starts with `cyclesCompleted = 1`.",
        "2": "The loop continues as long as `cyclesCompleted` is `less than or equal to 2`.",
        "3": "The `System.out.print()` statement includes a space after the number."
      }
    },
    {
      "id": 319,
      "subtopic_id": 8,
      "type": "output_tracing",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinder is clearing its data buffers. A `do-while` loop tracks `bytesRemaining`, decrementing and printing the count until no bytes are left. Your task is to trace the code and determine the lines printed.",
      "story_context": "The Pathfinder's data buffer system needs to clear bytes using a do-while loop. Your task is to trace the loop execution and predict the output.",
      "challenge_data": {
        "code": "public class DataBufferClearer {\n    public static void main(String[] args) {\n        int bytesRemaining = 2;\n        do {\n            System.out.println(\"Clearing \" + bytesRemaining + \" bytes.\");\n            bytesRemaining--;\n        } while (bytesRemaining > 0);\n    }\n}",
        "expected_output": [
          "Clearing 2 bytes.\\nClearing 1 bytes."
        ],
        "choices": [
          "Clearing 2 bytes.\\nClearing 1 bytes.",
          "Clearing 2 bytes.",
          "Clearing 2 bytes.\\nClearing 1 bytes.\\nClearing 0 bytes.",
          "Error"
        ],
        "explanation": "The `do-while` loop starts with `bytesRemaining = 2`.\n1. **Iteration 1**: Prints \"Clearing 2 bytes.\". `bytesRemaining` becomes 1.\n2. **Condition Check**: `bytesRemaining` (1) is greater than 0 (`true`). Loop continues.\n3. **Iteration 2**: Prints \"Clearing 1 bytes.\". `bytesRemaining` becomes 0.\n4. **Condition Check**: `bytesRemaining` (0) is greater than 0 (`false`). The loop terminates.\nThe output shows two lines."
      },
      "hints": {
        "1": "A `do-while` loop executes its body at least once.",
        "2": "The loop condition `bytesRemaining > 0` is checked *after* each iteration.",
        "3": "Trace the value of `bytesRemaining` and when it's printed, then when it changes."
      }
    },
    {
      "id": 320,
      "subtopic_id": 8,
      "type": "output_tracing",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinder's thrusters undergo a controlled cycle check. A `while` loop is set up, but the initial `cyclesDone` might prevent it from running. Your task is to trace the code and determine the final output.",
      "story_context": "The Pathfinder's thruster control system needs to run cycles using a while loop. Your task is to trace the loop execution and predict the output.",
      "challenge_data": {
        "code": "public class ThrusterControl {\n    public static void main(String[] args) {\n        int cyclesDone = 5;\n        while (cyclesDone < 5) {\n            System.out.println(\"Thruster cycle \" + cyclesDone + \" engaged.\");\n            cyclesDone++;\n        }\n        System.out.println(\"Final Cycles Done: \" + cyclesDone);\n    }\n}",
        "expected_output": [
          "Final Cycles Done: 5"
        ],
        "choices": [
          "Nothing",
          "Thruster cycle 5 engaged.\\nFinal Cycles Done: 6",
          "Final Cycles Done: 5",
          "Error"
        ],
        "explanation": "The `while` loop starts with `cyclesDone = 5`.\n1. **Condition Check**: `cyclesDone` (5) is less than 5 (`false`). The loop body is never executed.\n2. The loop terminates immediately.\n3. The line `System.out.println(\"Final Cycles Done: \" + cyclesDone);` executes, printing \"Final Cycles Done: 5\"."
      },
      "hints": {
        "1": "The `while` loop checks its condition *before* executing its body.",
        "2": "Evaluate the initial `while` condition: Is `cyclesDone` less than `5`?",
        "3": "The final `System.out.println()` statement runs *after* the loop (whether it executed or not)."
      }
    },
    {
      "id": 321,
      "subtopic_id": 8,
      "type": "output_tracing",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinder's diagnostic system runs multiple cycles until a target is reached. Your task is to trace the `while` loop and determine both the diagnostic messages printed during each cycle and the `Final Cycle Count`.",
      "story_context": "The Pathfinder's diagnostic system needs to run multiple cycles using a while loop. Your task is to trace the loop execution and predict the outputs.",
      "challenge_data": {
        "code": "public class DiagnosticSystem {\n    public static void main(String[] args) {\n        int currentCycle = 1;\n        int targetCycle = 3;\n\n        while (currentCycle <= targetCycle) {\n            System.out.println(\"Running diagnostic cycle: \" + currentCycle);\n            currentCycle++;\n        }\n        System.out.println(\"Final Cycle Count: \" + currentCycle);\n    }\n}",
        "expected_output": [
          "Running diagnostic cycle: 1\\nRunning diagnostic cycle: 2\\nRunning diagnostic cycle: 3",
          "Final Cycle Count: 4"
        ],
        "choices": [
          "Running diagnostic cycle: 1\\nRunning diagnostic cycle: 2\\nRunning diagnostic cycle: 3\\nFinal Cycle Count: 3",
          "Final Cycle Count: 3",
          "Running diagnostic cycle: 1\\nRunning diagnostic cycle: 2\\nRunning diagnostic cycle: 3\\nFinal Cycle Count: 4",
          "Final Cycle Count: 4",
          "Running diagnostic cycle: 1\\nRunning diagnostic cycle: 2\\nRunning diagnostic cycle: 3"
        ],
        "explanation": "1. **Loop Iterations**: \n    * `currentCycle = 1`: `1 <= 3` is `true`. Prints \"Running diagnostic cycle: 1\". `currentCycle` becomes 2.\n    * `currentCycle = 2`: `2 <= 3` is `true`. Prints \"Running diagnostic cycle: 2\". `currentCycle` becomes 3.\n    * `currentCycle = 3`: `3 <= 3` is `true`. Prints \"Running diagnostic cycle: 3\". `currentCycle` becomes 4.\n    * `currentCycle = 4`: `4 <= 3` is `false`. Loop terminates.\n2. **After Loop**: The `System.out.println(\"Final Cycle Count: \" + currentCycle);` statement executes, printing \"Final Cycle Count: 4\" (the value `currentCycle` had when the loop terminated)."
      },
      "hints": {
        "1": "The loop prints `currentCycle` *inside* the loop.",
        "2": "`currentCycle` increments *after* each print, and also dictates when the loop stops.",
        "3": "The final `System.out.println()` executes *after* the loop, showing `currentCycle`'s value *at termination*."
      }
    },
    {
      "id": 322,
      "subtopic_id": 8,
      "type": "output_tracing",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinder is uploading data packets using a `do-while` loop. This loop guarantees at least one packet is sent before checking if more need to be transmitted. Your task is to trace the code and determine both the \"Sending packet...\" messages and the `Final Packets Sent`.",
      "story_context": "The Pathfinder's data uploader needs to send packets using a do-while loop. Your task is to trace the loop execution and predict the outputs.",
      "challenge_data": {
        "code": "public class DataUploader {\n    public static void main(String[] args) {\n        int packetsSent = 0;\n        int maxPackets = 2;\n\n        do {\n            System.out.println(\"Sending packet...\");\n            packetsSent++;\n        } while (packetsSent < maxPackets);\n        System.out.println(\"Final Packets Sent: \" + packetsSent);\n    }\n}",
        "expected_output": [
          "Sending packet...\\nSending packet...",
          "Final Packets Sent: 2"
        ],
        "choices": [
          "Sending packet...\\nSending packet...",
          "Final Packets Sent: 2",
          "Sending packet...\\nSending packet...\\nFinal Packets Sent: 2",
          "Final Packets Sent: 3",
          "Sending packet...\\nSending packet...\\nFinal Packets Sent: 3"
        ],
        "explanation": "1. **Loop Iterations**:\n    * `packetsSent = 0`: Executes. Prints \"Sending packet...\". `packetsSent` becomes 1. Condition (1 < 2) is `true`.\n    * `packetsSent = 1`: Executes. Prints \"Sending packet...\". `packetsSent` becomes 2. Condition (2 < 2) is `false`. Loop terminates.\n2. **After Loop**: `System.out.println(\"Final Packets Sent: \" + packetsSent);` executes, printing \"Final Packets Sent: 2\" (the value `packetsSent` had at termination)."
      },
      "hints": {
        "1": "A `do-while` loop executes its body at least once.",
        "2": "The loop condition `packetsSent < maxPackets` determines how many times the loop body repeats.",
        "3": "The first output is generated inside the loop, the second outside."
      }
    },
    {
      "id": 323,
      "subtopic_id": 8,
      "type": "output_tracing",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinder's chronometer is counting down `timeUnits` in decrements of 2. Your task is to trace the `while` loop and determine all \"Time Units\" messages printed and the `Loop Ended` message.",
      "story_context": "The Pathfinder's chronometer needs to count down time units using a while loop. Your task is to trace the loop execution and predict the outputs.",
      "challenge_data": {
        "code": "public class Chronometer {\n    public static void main(String[] args) {\n        int timeUnits = 8;\n        String loopEndedMessage = \"Loop Ended.\";\n\n        while (timeUnits > 0) {\n            System.out.println(\"Time Units: \" + timeUnits);\n            timeUnits -= 2;\n        }\n        System.out.println(loopEndedMessage);\n    }\n}",
        "expected_output": [
          "Time Units: 8\\nTime Units: 6\\nTime Units: 4\\nTime Units: 2",
          "Loop Ended."
        ],
        "choices": [
          "Time Units: 8\\nTime Units: 6\\nTime Units: 4\\nTime Units: 2",
          "Loop Ended.",
          "Time Units: 8\\nTime Units: 6\\nTime Units: 4\\nTime Units: 2\\nLoop Ended.",
          "Time Units: 8\\nTime Units: 6\\nTime Units: 4\\nTime Units: 2\\nTime Units: 0",
          "Time Units: 8\\nTime Units: 6\\nTime Units: 4\\nTime Units: 0"
        ],
        "explanation": "1. **Loop Iterations**:\n    * `timeUnits = 8`: `8 > 0` is `true`. Prints \"Time Units: 8\". `timeUnits` becomes 6.\n    * `timeUnits = 6`: `6 > 0` is `true`. Prints \"Time Units: 6\". `timeUnits` becomes 4.\n    * `timeUnits = 4`: `4 > 0` is `true`. Prints \"Time Units: 4\". `timeUnits` becomes 2.\n    * `timeUnits = 2`: `2 > 0` is `true`. Prints \"Time Units: 2\". `timeUnits` becomes 0.\n2. **After Loop**: The `System.out.println(loopEndedMessage);` executes, printing \"Loop Ended.\"."
      },
      "hints": {
        "1": "Trace `timeUnits` as it decrements by `2` in each iteration.",
        "2": "The loop terminates when `timeUnits` is no longer greater than `0`.",
        "3": "The `loopEndedMessage` is printed only once, after the loop."
      }
    },
    {
      "id": 324,
      "subtopic_id": 8,
      "type": "output_tracing",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinder's battery charger operates with a `while` loop, increasing the `chargeLevel` until it reaches `maxCharge`. Your task is to trace the code and determine both the \"Charging\" messages and the `Battery Full` message.",
      "story_context": "The Pathfinder's battery charger needs to charge the battery using a while loop. Your task is to trace the loop execution and predict the outputs.",
      "challenge_data": {
        "code": "public class BatteryCharger {\n    public static void main(String[] args) {\n        int chargeLevel = 80;\n        int maxCharge = 100;\n\n        while (chargeLevel < maxCharge) {\n            System.out.println(\"Charging: \" + chargeLevel + \"%\");\n            chargeLevel += 5;\n        }\n        System.out.println(\"Battery Full: \" + chargeLevel + \"%\");\n    }\n}",
        "expected_output": [
          "Charging: 80%\\nCharging: 85%\\nCharging: 90%\\nCharging: 95%",
          "Battery Full: 100%"
        ],
        "choices": [
          "Charging: 80%\\nCharging: 85%\\nCharging: 90%\\nCharging: 95%",
          "Battery Full: 100%",
          "Charging: 80%\\nCharging: 85%\\nCharging: 90%\\nCharging: 95%\\nBattery Full: 100%",
          "Battery Full: 95%",
          "Charging: 80%\\nCharging: 85%\\nCharging: 90%\\nCharging: 100%"
        ],
        "explanation": "1. **Loop Iterations**:\n    * `chargeLevel = 80`: `80 < 100` is `true`. Prints \"Charging: 80%\". `chargeLevel` becomes 85.\n    * `chargeLevel = 85`: `85 < 100` is `true`. Prints \"Charging: 85%\". `chargeLevel` becomes 90.\n    * `chargeLevel = 90`: `90 < 100` is `true`. Prints \"Charging: 90%\". `chargeLevel` becomes 95.\n    * `chargeLevel = 95`: `95 < 100` is `true`. Prints \"Charging: 95%\". `chargeLevel` becomes 100.\n    * `chargeLevel = 100`: `100 < 100` is `false`. Loop terminates.\n2. **After Loop**: The `System.out.println(\"Battery Full: \" + chargeLevel + \"%\");` statement executes, printing \"Battery Full: 100%\" (the value `chargeLevel` had when the loop terminated)."
      },
      "hints": {
        "1": "Trace `chargeLevel` as it increases by `5` in each iteration.",
        "2": "The loop continues as long as `chargeLevel` is less than `maxCharge`.",
        "3": "The final `System.out.println()` runs after the loop ends, showing the value that caused termination."
      }
    },
    {
      "id": 325,
      "subtopic_id": 8,
      "type": "output_tracing",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinder's communication system attempts signal lock using a `do-while` loop. This loop runs a fixed number of `attemptsMade`. Your task is to trace the code and determine both the \"Attempting signal lock\" messages and the `Signal Lock Procedure Complete` message.",
      "story_context": "The Pathfinder's communication system needs to attempt signal lock using a do-while loop. Your task is to trace the loop execution and predict the outputs.",
      "challenge_data": {
        "code": "public class CommsSignalLock {\n    public static void main(String[] args) {\n        int attemptsMade = 1;\n        String completionMessage = \"Signal Lock Procedure Complete.\";\n\n        do {\n            System.out.println(\"Attempting signal lock. Attempt: \" + attemptsMade);\n            attemptsMade++;\n        } while (attemptsMade <= 3);\n        System.out.println(completionMessage);\n    }\n}",
        "expected_output": [
          "Attempting signal lock. Attempt: 1\\nAttempting signal lock. Attempt: 2\\nAttempting signal lock. Attempt: 3",
          "Signal Lock Procedure Complete."
        ],
        "choices": [
          "Attempting signal lock. Attempt: 1\\nAttempting signal lock. Attempt: 2\\nAttempting signal lock. Attempt: 3",
          "Signal Lock Procedure Complete.",
          "Attempting signal lock. Attempt: 1\\nAttempting signal lock. Attempt: 2\\nAttempting signal lock. Attempt: 3\\nSignal Lock Procedure Complete.",
          "Attempting signal lock. Attempt: 1\\nAttempting signal lock. Attempt: 2\\nSignal Lock Procedure Complete.",
          "Attempting signal lock. Attempt: 1\\nAttempting signal lock. Attempt: 2\\nAttempting signal lock. Attempt: 2"
        ],
        "explanation": "1. **Loop Iterations**:\n    * `attemptsMade = 1`: Executes. Prints \"Attempting signal lock. Attempt: 1\". `attemptsMade` becomes 2. Condition (2 <= 3) is `true`.\n    * `attemptsMade = 2`: Executes. Prints \"Attempting signal lock. Attempt: 2\". `attemptsMade` becomes 3. Condition (3 <= 3) is `true`.\n    * `attemptsMade = 3`: Executes. Prints \"Attempting signal lock. Attempt: 3\". `attemptsMade` becomes 4. Condition (4 <= 3) is `false`. Loop terminates.\n2. **After Loop**: The `System.out.println(completionMessage);` statement executes, printing \"Signal Lock Procedure Complete.\"."
      },
      "hints": {
        "1": "A `do-while` loop executes its body at least once.",
        "2": "The loop continues as long as `attemptsMade` is `less than or equal to 3`.",
        "3": "The final message is printed once, after the loop finishes."
      }
    },
    {
      "id": 326,
      "subtopic_id": 8,
      "type": "output_tracing",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinder's emergency life support system performs `checkNumber`s, skipping maintenance checks and breaking if a critical anomaly is detected. Your task is to trace the `while` loop and determine the sequence of outputs and the `Anomaly Status` and `Final System Status`.",
      "story_context": "The Pathfinder's emergency life support system needs to perform checks using a while loop with continue and break statements. Your task is to trace the loop execution and predict the outputs.",
      "challenge_data": {
        "code": "public class EmergencyLifeSupport {\n    public static void main(String[] args) {\n        int checkNumber = 1;\n        boolean anomalyDetected = false;\n        String finalStatus = \"Monitoring Active\";\n\n        while (checkNumber <= 5) {\n            if (checkNumber == 3) {\n                System.out.println(\"Skipping Check \" + checkNumber + \" (Maintenance).\");\n                checkNumber++;\n                continue;\n            }\n            if (checkNumber == 5) {\n                anomalyDetected = true;\n                System.out.println(\"Critical anomaly detected at Check \" + checkNumber + \"!\");\n                break;\n            }\n            System.out.println(\"Oxygen Check: \" + checkNumber);\n            checkNumber++;\n        }\n        \n        if (anomalyDetected) {\n            finalStatus = \"CRITICAL FAILURE - EMERGENCY!\";\n        } else {\n            finalStatus = \"Routine Checks Complete.\";\n        }\n        \n        System.out.println(\"Anomaly Status: \" + anomalyDetected);\n        System.out.println(\"Final System Status: \" + finalStatus);\n    }\n}",
        "expected_output": [
          "Oxygen Check: 1\\nOxygen Check: 2\\nSkipping Check 3 (Maintenance).\\nOxygen Check: 4\\nCritical anomaly detected at Check 5!",
          "Anomaly Status: true",
          "Final System Status: CRITICAL FAILURE - EMERGENCY!"
        ],
        "choices": [
          "Oxygen Check: 1\\nOxygen Check: 2\\nSkipping Check 3 (Maintenance).\\nOxygen Check: 4\\nCritical anomaly detected at Check 4!",
          "Anomaly Status: true",
          "Final System Status: CRITICAL FAILURE - EMERGENCY!",
          "Anomaly Status: false",
          "Oxygen Check: 1\\nOxygen Check: 2\\nSkipping Check 3 (Maintenance).\\nOxygen Check: 4\\nCritical anomaly detected at Check 5!",
          "Final System Status: CRITICAL FAILURE - EMERGENCY!\\nOxygen Check: 2"
        ],
        "explanation": "1. **Loop Execution (`message` output)**:\n    * `checkNumber = 1`: Prints \"Oxygen Check: 1\". `checkNumber` becomes 2.\n    * `checkNumber = 2`: Prints \"Oxygen Check: 2\". `checkNumber` becomes 3.\n    * `checkNumber = 3`: Prints \"Skipping Check 3 (Maintenance).\". `checkNumber` becomes 4. `continue` skips the rest.\n    * `checkNumber = 4`: Prints \"Oxygen Check: 4\". `checkNumber` becomes 5.\n    * `checkNumber = 5`: `anomalyDetected` becomes `true`. Prints \"Critical anomaly detected at Check 5!\". `break` exits the loop.\n2. **After Loop**: \n    * `anomalyDetected` is `true`. Prints \"Anomaly Status: true\".\n    * `if (anomalyDetected)` is `true`. `finalStatus` becomes \"CRITICAL FAILURE - EMERGENCY!\".\n    * Prints \"Final System Status: CRITICAL FAILURE - EMERGENCY!\"."
      },
      "hints": {
        "1": "Trace `checkNumber` through each iteration and observe how `continue` and `break` keywords affect the loop's flow.",
        "2": "`continue` skips the rest of the current iteration and goes to the next. `break` exits the entire loop.",
        "3": "`anomalyDetected` changes only under a specific condition (`checkNumber == 5`)."
      }
    },
    {
      "id": 327,
      "subtopic_id": 8,
      "type": "output_tracing",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinder's long-range scanner performs `scanNumber`s. `signalStrength` can drop, triggering a scan abort and setting `loopFinishedNaturally` to `false`. Your task is to trace the `while` loop and determine the `Last Scan Number Logged`, `Loop Finished Naturally` status, and `Final Scan Report`.",
      "story_context": "The Pathfinder's long-range scanner needs to perform scans using a while loop with break statements. Your task is to trace the loop execution and predict the outputs.",
      "challenge_data": {
        "code": "public class LongRangeScanner {\n    public static void main(String[] args) {\n        int scanNumber = 1;\n        int maxScans = 5;\n        int signalStrength = 100;\n        boolean loopFinishedNaturally = true;\n\n        while (scanNumber <= maxScans) {\n            System.out.println(\"Scanning range: \" + scanNumber);\n            if (scanNumber == 3) {\n                signalStrength = 20;\n            }\n            if (signalStrength < 50 && scanNumber > 2) {\n                loopFinishedNaturally = false;\n                System.out.println(\"WARNING: Signal lost. Aborting scan.\");\n                break;\n            }\n            scanNumber++;\n        }\n        \n        String finalScanReport = loopFinishedNaturally ? \"All ranges scanned.\" : \"Scan aborted due to signal loss.\";\n        \n        System.out.println(\"Last Scan Number Logged: \" + (scanNumber - 1));\n        System.out.println(\"Loop Finished Naturally: \" + loopFinishedNaturally);\n        System.out.println(\"Final Scan Report: \" + finalScanReport);\n    }\n}",
        "expected_output": [
          "Last Scan Number Logged: 2",
          "Loop Finished Naturally: false",
          "Final Scan Report: Scan aborted due to signal loss."
        ],
        "choices": [
          "Last Scan Number Logged: 2",
          "Loop Finished Naturally: false",
          "Final Scan Report: Scan aborted due to signal loss.",
          "Loop Finished Naturally: true",
          "Last Scan Number Logged: 0",
          "Final Scan Report: "
        ],
        "explanation": "1. `scanNumber = 1`, `maxScans = 5`, `signalStrength = 100`, `loopFinishedNaturally = true`.\n2. **Loop Execution**:\n    * `scanNumber = 1`: Prints \"Scanning range: 1\". `signalStrength` is 100. `scanNumber` becomes 2.\n    * `scanNumber = 2`: Prints \"Scanning range: 2\". `signalStrength` is 100. `scanNumber` becomes 3.\n    * `scanNumber = 3`: Prints \"Scanning range: 3\". `signalStrength` becomes 20. `20 < 50 && 3 > 2` is `true`. Prints \"WARNING: Signal lost. Aborting scan.\". `loopFinishedNaturally` becomes `false`. `break` exits the loop.\n3. **After Loop**: `scanNumber` is `3` when loop breaks.\n    * `System.out.println(\"Last Scan Number Logged: \" + (scanNumber - 1));` prints `3 - 1 = 2`. So, \"Last Scan Number Logged: 2\".\n    * `System.out.println(\"Loop Finished Naturally: \" + loopFinishedNaturally);` prints \"Loop Finished Naturally: false\".\n    * `System.out.println(\"Final Scan Report: \" + finalScanReport);` prints \"Final Scan Report: Scan aborted due to signal loss.\"."
      },
      "hints": {
        "1": "Trace `scanNumber` and `signalStrength` changes carefully through the loop. Pay attention to when `signalStrength` is updated.",
        "2": "The `if` condition `signalStrength < 50 && scanNumber > 2` uses `&&` and requires both parts to be true to trigger `break` and set `loopFinishedNaturally` to `false`.",
        "3": "The last `scanNumber` logged is the one *before* the loop aborted, as `scanNumber` increments at the end of the loop body."
      }
    },
    {
      "id": 328,
      "subtopic_id": 8,
      "type": "output_tracing",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinder's reactor stabilizer runs `cycleCount`s using a `do-while` loop. It performs intermediate checks, but a special completion condition can trigger an early break. Your task is to trace the code and determine all printed messages, the `Completion Flag` status, and the `Final Message`.",
      "story_context": "The Pathfinder's reactor stabilizer needs to run cycles using a do-while loop with break statements. Your task is to trace the loop execution and predict the outputs.",
      "challenge_data": {
        "code": "public class ReactorStabilizer {\n    public static void main(String[] args) {\n        int cycleCount = 1;\n        boolean completeFlag = false;\n        String finalMessage = \"Calibration Ongoing\";\n\n        do {\n            if (cycleCount % 2 == 0 && cycleCount % 4 != 0) {\n                System.out.println(\"Intermediate Check: \" + cycleCount);\n            } else if (cycleCount == 5) {\n                completeFlag = true;\n                System.out.println(\"Special Completion: \" + cycleCount);\n                break;\n            }\n            System.out.println(\"Normal Operation: \" + cycleCount);\n            cycleCount++;\n        } while (cycleCount <= 6);\n        \n        if (completeFlag) {\n            finalMessage = \"Calibration Success!\";\n        } else {\n            finalMessage = \"Calibration Incomplete.\";\n        }\n        \n        System.out.println(\"Completion Flag: \" + completeFlag);\n        System.out.println(\"Final Cycle Value: \" + cycleCount);\n        System.out.println(\"Final Message: \" + finalMessage);\n    }\n}",
        "expected_output": [
          "Normal Operation: 1\\nIntermediate Check: 2\\nNormal Operation: 3\\nNormal Operation: 4\\nSpecial Completion: 5",
          "Completion Flag: true",
          "Final Message: Calibration Success!"
        ],
        "choices": [
          "Normal Operation: 1\\nIntermediate Check: 2\\nNormal Operation: 3\\nNormal Operation: 4\\nSpecial Completion: 5",
          "Completion Flag: true",
          "Final Message: Calibration Success!",
          "Final Cycle Value: 6",
          "Normal Operation: 1\\nIntermediate Check: 1\\nNormal Operation: 3\\nNormal Operation: 4\\nSpecial Completion: 5",
          "Completion Flag: false"
        ],
        "explanation": "1. **Loop Execution (`message` output)**: `cycleCount` starts at 1.\n    * `cycleCount = 1`: Prints \"Normal Operation: 1\". `cycleCount` becomes 2.\n    * `cycleCount = 2`: `2 % 2 == 0` is `true`, `2 % 4 != 0` is `true`. Prints \"Intermediate Check: 2\". `cycleCount` becomes 3.\n    * `cycleCount = 3`: Prints \"Normal Operation: 3\". `cycleCount` becomes 4.\n    * `cycleCount = 4`: `4 % 2 == 0` is `true`, `4 % 4 != 0` is `false`. Prints \"Normal Operation: 4\". `cycleCount` becomes 5.\n    * `cycleCount = 5`: `5 == 5` is `true`. `completeFlag` becomes `true`. Prints \"Special Completion: 5\". `break` exits loop.\n2. **After Loop**: \n    * `completeFlag` is `true`. Prints \"Completion Flag: true\".\n    * `if (completeFlag)` is `true`. `finalMessage` becomes \"Calibration Success!\".\n    * Prints \"Final Message: Calibration Success!\".\n    * `System.out.println(\"Final Cycle Value: \" + cycleCount);` prints \"Final Cycle Value: 5\"."
      },
      "hints": {
        "1": "Trace `cycleCount` through the `do-while` loop.",
        "2": "Evaluate each `if-else if-else` condition inside the loop: `cycleCount % 2 == 0 && cycleCount % 4 != 0` for \"Intermediate\", `cycleCount == 5` for \"Special\".",
        "3": "Note when `completeFlag` changes and when `break` terminates the loop."
      }
    },
    {
      "id": 329,
      "subtopic_id": 8,
      "type": "output_tracing",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinder's power regulator runs a nested sequence of `mainSequence` and `subCheck` loops, tracking `totalIterations` and `sequenceStatus`. Your task is to trace the code and determine all printed messages, the `Total Iterations`, and the `Sequence Status`.",
      "story_context": "The Pathfinder's power regulator needs to run nested loops using while statements. Your task is to trace the loop execution and predict the outputs.",
      "challenge_data": {
        "code": "public class PowerRegulator {\n    public static void main(String[] args) {\n        int mainSequence = 1;\n        int totalIterations = 0;\n        String sequenceStatus = \"Pending\";\n\n        while (mainSequence <= 3) {\n            int subCheck = 1;\n            while (subCheck <= 2) {\n                System.out.println(\"Main: \" + mainSequence + \", Sub: \" + subCheck);\n                totalIterations++;\n                subCheck++;\n            }\n            mainSequence++;\n        }\n        \n        if (totalIterations == 6) {\n            sequenceStatus = \"Complete\";\n        } else {\n            sequenceStatus = \"Incomplete\";\n        }\n        \n        System.out.println(\"Total Iterations: \" + totalIterations);\n        System.out.println(\"Sequence Status: \" + sequenceStatus);\n        System.out.println(\"Final Main Sequence Value: \" + mainSequence);\n    }\n}",
        "expected_output": [
          "Main: 1, Sub: 1\\nMain: 1, Sub: 2\\nMain: 2, Sub: 1\\nMain: 2, Sub: 2\\nMain: 3, Sub: 1\\nMain: 3, Sub: 2",
          "Total Iterations: 6",
          "Sequence Status: Complete"
        ],
        "choices": [
          "Main: 1, Sub: 1\\nMain: 1, Sub: 2\\nMain: 2, Sub: 1\\nMain: 2, Sub: 2\\nMain: 3, Sub: 1\\nMain: 3, Sub: 2",
          "Total Iterations: 6",
          "Sequence Status: Complete",
          "Final Main Sequence Value: 3",
          "Main: 1, Sub: 1\\nMain: 1, Sub: 3\\nMain: 2, Sub: 1\\nMain: 2, Sub: 2\\nMain: 3, Sub: 1\\nMain: 3, Sub: 2",
          "Total Iterations: 66"
        ],
        "explanation": "1. **Loop Execution (Main/Sub output)**:\n    * `mainSequence = 1`: Runs inner loop twice. Prints \"Main: 1, Sub: 1\", \"Main: 1, Sub: 2\". `totalIterations` is 2. `mainSequence` becomes 2.\n    * `mainSequence = 2`: Runs inner loop twice. Prints \"Main: 2, Sub: 1\", \"Main: 2, Sub: 2\". `totalIterations` is 4. `mainSequence` becomes 3.\n    * `mainSequence = 3`: Runs inner loop twice. Prints \"Main: 3, Sub: 1\", \"Main: 3, Sub: 2\". `totalIterations` is 6. `mainSequence` becomes 4.\n    * `mainSequence = 4`: Outer loop condition (`4 <= 3`) is `false`. Outer loop terminates.\n2. **After Loop**: \n    * `System.out.println(\"Total Iterations: \" + totalIterations);` prints \"Total Iterations: 6\".\n    * `if (totalIterations == 6)` is `true`. `sequenceStatus` becomes \"Complete\".\n    * `System.out.println(\"Sequence Status: \" + sequenceStatus);` prints \"Sequence Status: Complete\".\n    * `System.out.println(\"Final Main Sequence Value: \" + mainSequence);` prints \"Final Main Sequence Value: 4\"."
      },
      "hints": {
        "1": "Trace the outer `while` loop (for `mainSequence`) and how it controls the execution of the inner `while` loop (for `subCheck`).",
        "2": "The `subCheck` variable resets to `1` in each iteration of the *outer* loop.",
        "3": " `totalIterations` increments in the *inner* loop."
      }
    },
    {
      "id": 330,
      "subtopic_id": 8,
      "type": "output_tracing",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinder's docking arm extends and retracts. A `do-while` loop controls its extension, with conditions for skipping odd extensions and breaking if a critical extension is reached. Your task is to trace the code and determine the sequence of arm messages, the `Emergency Stop Triggered` status, and the `Final Arm Status`.",
      "story_context": "The Pathfinder's docking arm control system needs to extend and retract using a do-while loop with continue and break statements. Your task is to trace the loop execution and predict the outputs.",
      "challenge_data": {
        "code": "public class DockingArmControl {\n    public static void main(String[] args) {\n        int armExtension = 0;\n        boolean emergencyStopTriggered = false;\n        String finalArmStatus = \"Ready\";\n\n        do {\n            armExtension++;\n            if (armExtension % 2 != 0 && armExtension < 4) {\n                System.out.println(\"Arm at odd extension: \" + armExtension);\n                continue;\n            }\n            if (armExtension == 4) {\n                System.out.println(\"Arm at critical extension: \" + armExtension);\n                emergencyStopTriggered = true;\n                break;\n            }\n            System.out.println(\"Arm at even extension: \" + armExtension);\n        } while (armExtension <= 5);\n\n        if (emergencyStopTriggered) {\n            finalArmStatus = \"EMERGENCY RETRACTED\";\n        } else {\n            finalArmStatus = \"Fully Extended/Retracted\";\n        }\n\n        System.out.println(\"Emergency Stop Triggered: \" + emergencyStopTriggered);\n        System.out.println(\"Final Arm Status: \" + finalArmStatus);\n    }\n}",
        "expected_output": [
          "Arm at odd extension: 1\\nArm at even extension: 2\\nArm at odd extension: 3\\nArm at critical extension: 4",
          "Emergency Stop Triggered: true",
          "Final Arm Status: EMERGENCY RETRACTED"
        ],
        "choices": [
          "Arm at odd extension: 1\\nArm at even extension: 2\\nArm at odd extension: 3\\nArm at critical extension: 4",
          "Emergency Stop Triggered: false",
          "Final Arm Status: EMERGENCY RETRACTED",
          "Final Arm Status: Fully Extended/Retracted",
          "Arm at odd extension: 1\\nArm at even extension: 2\\nArm at odd extension: 3\\nArm at critical extension: 5",
          "Emergency Stop Triggered: true"
        ],
        "explanation": "1. **Loop Execution (`message` output)**: `armExtension` starts at 0.\n    * `armExtension = 1`: Prints \"Arm at odd extension: 1\". `continue`.\n    * `armExtension = 2`: Prints \"Arm at even extension: 2\".\n    * `armExtension = 3`: Prints \"Arm at odd extension: 3\". `continue`.\n    * `armExtension = 4`: Prints \"Arm at critical extension: 4\". `emergencyStopTriggered` becomes `true`. `break` exits loop.\n2. **After Loop**: \n    * `emergencyStopTriggered` is `true`. Prints \"Emergency Stop Triggered: true\".\n    * `if (emergencyStopTriggered)` is `true`. `finalArmStatus` becomes \"EMERGENCY RETRACTED\".\n    * Prints \"Final Arm Status: EMERGENCY RETRACTED\"."
      },
      "hints": {
        "1": "Trace `armExtension` carefully through each iteration, noting its value *before* and *after* `armExtension++` and how `continue`/`break` affect print statements.",
        "2": "The `continue` statement skips to the next iteration's condition check.",
        "3": "The `break` statement immediately exits the loop."
      }
    },
    {
      "id": 331,
      "subtopic_id": 8,
      "type": "code_fixer",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinderâ€™s diagnostic system uses a `while` loop that is currently stuck in an infinite loop because the counter is never incremented. Fix the code to ensure the `scanCount` is correctly updated, allowing the loop to terminate after 3 scans.",
      "story_context": "The DiagnosticLoopFixer needs to perform diagnostic scans. Your task is to fix the infinite loop issue.",
      "challenge_data": {
        "initial_code": "public class DiagnosticLoopFixer {\n    public static void main(String[] args) {\n        int scanCount = 0;\n        while (scanCount < 3) {\n            System.out.println(\"Performing diagnostic scan.\");\n        }\n    }\n}",
        "expected_output": [
          "Performing diagnostic scan.",
          "Performing diagnostic scan.",
          "Performing diagnostic scan."
        ],
        "solution_code": "public class DiagnosticLoopFixer {\n    public static void main(String[] args) {\n        int scanCount = 0;\n        while (scanCount < 3) {\n            System.out.println(\"Performing diagnostic scan.\");\n            scanCount++;\n        }\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 6,
            "type": "missing_increment",
            "description": "Missing increment for scanCount variable",
            "fix": "Add scanCount++; after the print statement"
          }
        ],
        "number_of_errors": 1,
        "explanation": "The original code creates an infinite loop because `scanCount` is never incremented inside the `while` loop. As a result, `scanCount` remains `0`, and the condition `scanCount < 3` is always `true`. The fix is to add `scanCount++;` (or `scanCount = scanCount + 1;`) inside the loop body, ensuring that `scanCount` eventually reaches `3`, making the condition `false` and terminating the loop after 3 iterations."
      },
      "hints": {
        "1": "An infinite loop occurs when the loop condition never becomes false.",
        "2": "The `scanCount` variable is used in the loop condition (`scanCount < 3`). How does `scanCount` change?",
        "3": "You need a way to make `scanCount` eventually reach `3` or more."
      }
    },
    {
      "id": 332,
      "subtopic_id": 8,
      "type": "code_fixer",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinderâ€™s beacon system uses a `while` loop that never activates because its initial condition is false. Fix the code to ensure the beacon activates exactly once.",
      "story_context": "The BeaconLoopFixer needs to activate the beacon. Your task is to fix the loop condition.",
      "challenge_data": {
        "initial_code": "public class BeaconLoopFixer {\n    public static void main(String[] args) {\n        int activationCount = 1;\n        while (activationCount < 1) { \n            System.out.println(\"Beacon active!\");\n            activationCount++;\n        }\n    }\n}",
        "expected_output": [
          "Beacon active!"
        ],
        "solution_code": "public class BeaconLoopFixer {\n    public static void main(String[] args) {\n        int activationCount = 1;\n        while (activationCount <= 1) { \n            System.out.println(\"Beacon active!\");\n            activationCount++;\n        }\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 4,
            "type": "loop_condition",
            "description": "Wrong condition for beacon activation",
            "fix": "Change condition to: while (activationCount <= 1)"
          }
        ],
        "number_of_errors": 1,
        "explanation": "The original `while` loop's condition `activationCount < 1` (i.e., `1 < 1`) is `false` from the very beginning. Therefore, the loop body never executes, and no message is printed. The fix is to change the condition to `activationCount <= 1`. This makes the condition `true` for the first iteration, allowing \"Beacon active!\" to print. After `activationCount` becomes `2`, the condition `2 <= 1` is `false`, terminating the loop. Using a `do-while` loop would also achieve the goal of running at least once."
      },
      "hints": {
        "1": "A `while` loop checks its condition *before* executing its body.",
        "2": "If the condition is `false` at the start, the loop body will never run.",
        "3": "To make it run once, adjust the condition to be true for exactly one iteration, or consider a different type of loop."
      }
    },
    {
      "id": 333,
      "subtopic_id": 8,
      "type": "code_fixer",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinderâ€™s thruster test uses a `do-while` loop that has a syntax error: a missing semicolon after its `while` condition. Fix the code to allow the thruster test to run correctly.",
      "story_context": "The ThrusterTestFixer needs to test thrusters. Your task is to fix the syntax error.",
      "challenge_data": {
        "initial_code": "public class ThrusterTestFixer {\n    public static void main(String[] args) {\n        int fireCount = 0;\n        do {\n            System.out.println(\"Firing thruster \" + (fireCount + 1));\n            fireCount++;\n        } while (fireCount < 1) \n    }\n}",
        "expected_output": [
          "Firing thruster 1"
        ],
        "solution_code": "public class ThrusterTestFixer {\n    public static void main(String[] args) {\n        int fireCount = 0;\n        do {\n            System.out.println(\"Firing thruster \" + (fireCount + 1));\n            fireCount++;\n        } while (fireCount < 1); \n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 8,
            "type": "missing_semicolon",
            "description": "Missing semicolon after do-while condition",
            "fix": "Add semicolon: } while (fireCount < 1);"
          }
        ],
        "number_of_errors": 1,
        "explanation": "A `do-while` loop in Java requires a semicolon (`;`) immediately after the `while (condition)` part. The original code is missing this semicolon, causing a compilation error. Adding the semicolon at the end of `while (fireCount < 1)` correctly fixes the syntax."
      },
      "hints": {
        "1": "A `do-while` loop has a unique requirement for its `while` condition line.",
        "2": "Look at the line where the `while` keyword and condition appear.",
        "3": "A specific punctuation mark is missing at the very end of that line."
      }
    },
    {
      "id": 334,
      "subtopic_id": 8,
      "type": "code_fixer",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinderâ€™s sensor calibration system uses a `while` loop that never runs because the `calibrationValue` is initially equal to the limit, making the condition `false`. Fix the code to ensure the calibration loop runs for 5 iterations.",
      "story_context": "The SensorCalibrationFixer needs to calibrate sensors. Your task is to fix the initial value.",
      "challenge_data": {
        "initial_code": "public class SensorCalibrationFixer {\n    public static void main(String[] args) {\n        int calibrationValue = 50; \n        while (calibrationValue < 50) {\n            System.out.println(\"Calibrating sensor.\");\n            calibrationValue++;\n        }\n    }\n}",
        "expected_output": [
          "Calibrating sensor.",
          "Calibrating sensor.",
          "Calibrating sensor.",
          "Calibrating sensor.",
          "Calibrating sensor."
        ],
        "solution_code": "public class SensorCalibrationFixer {\n    public static void main(String[] args) {\n        int calibrationValue = 45; \n        while (calibrationValue < 50) {\n            System.out.println(\"Calibrating sensor.\");\n            calibrationValue++;\n        }\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 3,
            "type": "initial_value",
            "description": "Wrong initial value for calibrationValue",
            "fix": "Change initial value to: int calibrationValue = 45;"
          }
        ],
        "number_of_errors": 1,
        "explanation": "The `while` loop's condition `calibrationValue < 50` is `false` initially because `calibrationValue` is `50` (`50 < 50` is `false`). Therefore, the loop body never executes. The fix is to change the initial value of `calibrationValue` to something less than `50` (e.g., `45`), which makes the condition `true` and allows the loop to execute for 5 iterations."
      },
      "hints": {
        "1": "The `while` loop checks its condition *before* executing.",
        "2": "What does `50 < 50` evaluate to?",
        "3": "To make the loop run, `calibrationValue` needs to start with a value that makes the condition initially `true`."
      }
    },
    {
      "id": 335,
      "subtopic_id": 8,
      "type": "code_fixer",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinderâ€™s protocol activator uses a `do-while` loop that is stuck in an infinite loop because its condition (`activationCount >= 0`) is always true. Fix the code to ensure the loop runs exactly twice (for `activationCount` 1 and 2).",
      "story_context": "The ProtocolActivatorFixer needs to activate protocols. Your task is to fix the infinite loop condition.",
      "challenge_data": {
        "initial_code": "public class ProtocolActivatorFixer {\n    public static void main(String[] args) {\n        int activationCount = 1;\n        do {\n            System.out.println(\"Activating protocol \" + activationCount + \"...\");\n            activationCount++;\n        } while (activationCount >= 0); \n    }\n}",
        "expected_output": [
          "Activating protocol 1...",
          "Activating protocol 2..."
        ],
        "solution_code": "public class ProtocolActivatorFixer {\n    public static void main(String[] args) {\n        int activationCount = 1;\n        do {\n            System.out.println(\"Activating protocol \" + activationCount + \"...\");\n            activationCount++;\n        } while (activationCount <= 2); \n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 7,
            "type": "loop_condition",
            "description": "Infinite loop condition - always true",
            "fix": "Change condition to: while (activationCount <= 2)"
          }
        ],
        "number_of_errors": 1,
        "explanation": "The original `do-while` loop has an infinite loop because the condition `activationCount >= 0` is always `true` (since `activationCount` starts at `1` and only increases). The loop should run exactly 2 times. This means `activationCount` should be `1` and `2` during execution, and terminate when `activationCount` becomes `3`. The fix is to change the condition to `activationCount <= 2`, which correctly allows the loop to run when `activationCount` is `1` and `2`, and then terminates when `activationCount` becomes `3`."
      },
      "hints": {
        "1": "An infinite loop occurs when the loop condition never becomes `false`.",
        "2": "The `activationCount` starts at `1` and increments. The loop should stop when it has run twice (i.e., `activationCount` reaches `3`).",
        "3": "Adjust the `while` condition to evaluate to `false` after `activationCount` passes the desired number of iterations."
      }
    },
    {
      "id": 336,
      "subtopic_id": 8,
      "type": "code_fixer",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinderâ€™s sensor array system uses a `while` loop to take `dataReadings`. The loop runs one iteration too many. Fix the code to ensure exactly 5 readings (from 0 to 4).",
      "story_context": "The SensorArrayFixer needs to take sensor readings. Your task is to fix the loop boundary condition.",
      "challenge_data": {
        "initial_code": "public class SensorArrayFixer {\n    public static void main(String[] args) {\n        int dataReadings = 0;\n        while (dataReadings <= 5) { \n            System.out.println(\"Taking reading: \" + dataReadings);\n            dataReadings++;\n        }\n    }\n}",
        "expected_output": [
          "Taking reading: 0",
          "Taking reading: 1",
          "Taking reading: 2",
          "Taking reading: 3",
          "Taking reading: 4"
        ],
        "solution_code": "public class SensorArrayFixer {\n    public static void main(String[] args) {\n        int dataReadings = 0;\n        while (dataReadings < 5) { \n            System.out.println(\"Taking reading: \" + dataReadings);\n            dataReadings++;\n        }\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 4,
            "type": "loop_boundary",
            "description": "Wrong boundary condition - includes extra iteration",
            "fix": "Change condition to: while (dataReadings < 5)"
          }
        ],
        "number_of_errors": 1,
        "explanation": "The original loop `while (dataReadings <= 5)` includes `dataReadings = 5` as a valid iteration, causing it to run 6 times (for 0, 1, 2, 3, 4, 5). The requirement is for exactly 5 readings (0-4). The fix is to change the loop condition from `dataReadings <= 5` to `dataReadings < 5`. This makes the loop execute for `dataReadings` values of 0, 1, 2, 3, and 4, totaling exactly 5 iterations."
      },
      "hints": {
        "1": "The loop needs to run for values 0, 1, 2, 3, and 4. How many values is that?",
        "2": "The `<=` operator includes the boundary value. If `dataReadings` starts at 0 and goes up to 5, how many iterations is that?",
        "3": "To run exactly `N` times when starting from 0, the condition should be `variable < N`."
      }
    },
    {
      "id": 337,
      "subtopic_id": 8,
      "type": "code_fixer",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinderâ€™s system log uses a `while` loop that never executes because its initial condition (`eventID < 1`) is false. Fix the code to ensure events 1, 2, and 3 are logged.",
      "story_context": "The SystemLogFixer needs to log system events. Your task is to fix the loop condition.",
      "challenge_data": {
        "initial_code": "public class SystemLogFixer {\n    public static void main(String[] args) {\n        int eventID = 1;\n        while (eventID < 1) { \n            System.out.println(\"Logging Event: \" + eventID);\n            eventID++;\n        }\n    }\n}",
        "expected_output": [
          "Logging Event: 1",
          "Logging Event: 2",
          "Logging Event: 3"
        ],
        "solution_code": "public class SystemLogFixer {\n    public static void main(String[] args) {\n        int eventID = 1;\n        while (eventID <= 3) { \n            System.out.println(\"Logging Event: \" + eventID);\n            eventID++;\n        }\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 4,
            "type": "loop_condition",
            "description": "Wrong condition - loop never executes",
            "fix": "Change condition to: while (eventID <= 3)"
          }
        ],
        "number_of_errors": 1,
        "explanation": "The original `while` loop condition `eventID < 1` is `false` from the start (`1 < 1` is `false`), so the loop body never executes. The requirement is to log events 1, 2, and 3. The fix is to change the condition to `eventID <= 3`. This makes the loop execute for `eventID` values of 1, 2, and 3, stopping when `eventID` becomes 4."
      },
      "hints": {
        "1": "The loop starts with `eventID = 1`.",
        "2": "The original condition `eventID < 1` (`1 < 1`) is `false`, causing the loop to never execute.",
        "3": "The goal is to log events 1, 2, and 3. How should the condition handle `eventID = 3`?"
      }
    },
    {
      "id": 338,
      "subtopic_id": 8,
      "type": "code_fixer",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinderâ€™s thruster system uses a `while` loop where the counter (`cycleCount`) is incremented outside the loop's body, causing an infinite loop. Fix the code to ensure `cycleCount` increments correctly within the loop, allowing it to complete 2 cycles.",
      "story_context": "The ThrusterCycleFixer needs to complete thruster cycles. Your task is to fix the increment placement.",
      "challenge_data": {
        "initial_code": "public class ThrusterCycleFixer {\n    public static void main(String[] args) {\n        int cycleCount = 0;\n        while (cycleCount < 2) {\n            System.out.println(\"Cycle complete.\");\n        }\n        cycleCount++; \n    }\n}",
        "expected_output": [
          "Cycle complete.",
          "Cycle complete."
        ],
        "solution_code": "public class ThrusterCycleFixer {\n    public static void main(String[] args) {\n        int cycleCount = 0;\n        while (cycleCount < 2) {\n            System.out.println(\"Cycle complete.\");\n            cycleCount++; \n        }\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 6,
            "type": "increment_placement",
            "description": "Increment statement outside loop body",
            "fix": "Move cycleCount++; inside the loop body"
          }
        ],
        "number_of_errors": 1,
        "explanation": "The original code creates an infinite loop because the `cycleCount++;` statement is placed *outside* the `while` loop's curly braces. This means `cycleCount` is never updated during the loop's execution, so `cycleCount` remains `0`, and the condition `cycleCount < 2` is always `true`. The fix is to move `cycleCount++;` inside the loop's body, ensuring `cycleCount` increments in each iteration, eventually terminating the loop after 2 runs."
      },
      "hints": {
        "1": "In a `while` loop, only the statements directly inside its curly braces `{}` are repeated.",
        "2": "If the loop condition depends on a variable, that variable must be updated *inside* the loop to eventually make the condition false.",
        "3": "The blank line after `System.out.println()` needs an increment statement."
      }
    },
    {
      "id": 339,
      "subtopic_id": 8,
      "type": "code_fixer",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinder is transferring data using a `do-while` loop. The loop's condition (`transferCount > 3`) causes it to run only once, as the condition immediately becomes false after the first iteration. Fix the code to ensure exactly 3 data transfers.",
      "story_context": "The DataTransferFixer needs to transfer data packets. Your task is to fix the do-while loop condition.",
      "challenge_data": {
        "initial_code": "public class DataTransferFixer {\n    public static void main(String[] args) {\n        int transferCount = 1;\n        do {\n            System.out.println(\"Transferring data...\");\n            transferCount++;\n        } while (transferCount > 3); \n    }\n}",
        "expected_output": [
          "Transferring data...\\nTransferring data...\\nTransferring data."
        ],
        "solution_code": "public class DataTransferFixer {\n    public static void main(String[] args) {\n        int transferCount = 1;\n        do {\n            System.out.println(\"Transferring data...\");\n            transferCount++;\n        } while (transferCount <= 3); \n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 7,
            "type": "loop_condition",
            "description": "Wrong condition for do-while loop",
            "fix": "Change condition to: while (transferCount <= 3)"
          }
        ],
        "number_of_errors": 1,
        "explanation": "The original `do-while` loop's condition `transferCount > 3` is evaluated after the first iteration where `transferCount` becomes 2 (`2 > 3` is `false`), causing the loop to stop after only one execution. The requirement is to run exactly 3 times (for `transferCount` values 1, 2, 3). The fix is to change the condition to `transferCount <= 3`. This correctly allows the loop to run when `transferCount` is 1, 2, and 3, and then terminates when `transferCount` becomes 4."
      },
      "hints": {
        "1": "The `do-while` loop executes at least once.",
        "2": "The `transferCount` starts at `1` and increments. The loop needs to run for `transferCount` values `1`, `2`, and `3`.",
        "3": "The original condition (`transferCount > 3`) immediately becomes `false` after the first increment. How should the condition correctly ensure it runs for all three values?"
      }
    },
    {
      "id": 340,
      "subtopic_id": 8,
      "type": "code_fixer",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinderâ€™s repair sequence uses a `while` loop that is stuck in an infinite loop because the `repairsCompleted` counter is never incremented. Fix the code to ensure `repairsCompleted` is correctly updated within the loop, allowing 5 repair steps to be initiated.",
      "story_context": "The RepairSequenceFixer needs to complete repair steps. Your task is to fix the missing increment.",
      "challenge_data": {
        "initial_code": "public class RepairSequenceFixer {\n    public static void main(String[] args) {\n        int repairsCompleted = 0;\n        while (repairsCompleted < 5) {\n            System.out.println(\"Repair step \" + repairsCompleted + \" initiated.\");\n        }\n    }\n}",
        "expected_output": [
          "Repair step 0 initiated.",
          "Repair step 1 initiated.",
          "Repair step 2 initiated.",
          "Repair step 3 initiated.",
          "Repair step 4 initiated."
        ],
        "solution_code": "public class RepairSequenceFixer {\n    public static void main(String[] args) {\n        int repairsCompleted = 0;\n        while (repairsCompleted < 5) {\n            System.out.println(\"Repair step \" + repairsCompleted + \" initiated.\");\n            repairsCompleted++;\n        }\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 6,
            "type": "missing_increment",
            "description": "Missing increment for repairsCompleted variable",
            "fix": "Add repairsCompleted++; after the print statement"
          }
        ],
        "number_of_errors": 1,
        "explanation": "The original code creates an infinite loop because `repairsCompleted` is never incremented inside the `while` loop's body. As a result, `repairsCompleted` remains `0`, and the condition `repairsCompleted < 5` is always `true`. The fix is to add `repairsCompleted++;` (or `repairsCompleted = repairsCompleted + 1;`) inside the loop, ensuring `repairsCompleted` increases in each iteration, eventually terminating the loop after 5 runs (0-4)."
      },
      "hints": {
        "1": "An infinite loop occurs if the variable controlling the loop's condition never changes to make the condition false.",
        "2": "The `repairsCompleted` variable is part of the `while` loop's condition.",
        "3": "You need a statement that modifies `repairsCompleted` to ensure the loop eventually terminates."
      }
    },
    {
      "id": 341,
      "subtopic_id": 8,
      "type": "code_fixer",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinderâ€™s life support monitor uses nested `while` and `do-while` loops. The inner `do-while` loop is in an infinite loop because its condition (`subCheck >= 0`) is always true and `subCheck` is never incremented. Fix the code to correctly manage both loops and allow them to terminate.",
      "story_context": "The LifeSupportMonitorFixer needs to monitor life support systems. Your task is to fix the nested loop issues.",
      "challenge_data": {
        "initial_code": "public class LifeSupportMonitorFixer {\n    public static void main(String[] args) {\n        int mainCycles = 0;\n        String finalStatus = \"Inactive\";\n\n        while (mainCycles < 2) {\n            int subCheck = 0;\n            do {\n                System.out.println(\"Main Cycle: \" + mainCycles + \", Sub Check: \" + subCheck);\n            } while (subCheck >= 0); \n            mainCycles++;\n        }\n        finalStatus = \"Monitoring Complete\";\n        System.out.println(\"Final Status: \" + finalStatus);\n    }\n}",
        "expected_output": [
          "Main Cycle: 0, Sub Check: 0",
          "Main Cycle: 0, Sub Check: 1",
          "Main Cycle: 0, Sub Check: 2",
          "Main Cycle: 1, Sub Check: 0",
          "Main Cycle: 1, Sub Check: 1",
          "Main Cycle: 1, Sub Check: 2",
          "Final Status: Monitoring Complete"
        ],
        "solution_code": "public class LifeSupportMonitorFixer {\n    public static void main(String[] args) {\n        int mainCycles = 0;\n        String finalStatus = \"Inactive\";\n\n        while (mainCycles < 2) {\n            int subCheck = 0;\n            do {\n                System.out.println(\"Main Cycle: \" + mainCycles + \", Sub Check: \" + subCheck);\n                subCheck++; \n            } while (subCheck < 3); \n            mainCycles++;\n        }\n        finalStatus = \"Monitoring Complete\";\n        System.out.println(\"Final Status: \" + finalStatus);\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 9,
            "type": "missing_increment",
            "description": "Missing increment for subCheck variable",
            "fix": "Add subCheck++; inside the do-while loop"
          },
          {
            "id": 2,
            "line": 10,
            "type": "loop_condition",
            "description": "Wrong condition for inner do-while loop",
            "fix": "Change condition to: while (subCheck < 3)"
          }
        ],
        "number_of_errors": 2,
        "explanation": "The original code creates an infinite loop because the inner `do-while` loop's condition `subCheck >= 0` is always `true` (as `subCheck` starts at 0 and increases, it will always be greater than or equal to 0). Additionally, `subCheck` is never incremented. The fix involves two parts:\n1.  Add `subCheck++;` inside the inner loop to ensure `subCheck` increases.\n2.  Change the inner loop condition to `subCheck < 3` (or `subCheck <= 2`), so it runs for `subCheck` values 0, 1, and 2, and then terminates when `subCheck` becomes 3."
      },
      "hints": {
        "1": "An infinite loop often occurs when the variable controlling the loop's condition never becomes false.",
        "2": "The inner `do-while` loop's condition is `subCheck >= 0`. Since `subCheck` starts at 0 and increments, this condition will always remain true.",
        "3": "The goal is for the inner loop to run exactly 3 times (for `subCheck` values 0, 1, 2). How should the condition change to allow this?"
      }
    },
    {
      "id": 342,
      "subtopic_id": 8,
      "type": "code_fixer",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinderâ€™s diagnostic sequence uses a `while` loop that prematurely terminates due to an overly broad `break` condition (`checkIndex == 2`). Fix the code to ensure the loop runs its full course of 5 checks.",
      "story_context": "The DiagnosticSequenceFixer needs to complete diagnostic checks. Your task is to fix the premature break statement.",
      "challenge_data": {
        "initial_code": "public class DiagnosticSequenceFixer {\n    public static void main(String[] args) {\n        int checkIndex = 0;\n        String diagnosticStatus = \"Running\";\n\n        while (checkIndex < 5) {\n            System.out.println(\"Diagnostic check: \" + checkIndex);\n            if (checkIndex == 2) { \n                break; \n            }\n            checkIndex++;\n        }\n        diagnosticStatus = \"Completed\";\n        System.out.println(\"Diagnostic Status: \" + diagnosticStatus);\n    }\n}",
        "expected_output": [
          "Diagnostic check: 0",
          "Diagnostic check: 1",
          "Diagnostic check: 2",
          "Diagnostic check: 3",
          "Diagnostic check: 4",
          "Diagnostic Status: Completed"
        ],
        "solution_code": "public class DiagnosticSequenceFixer {\n    public static void main(String[] args) {\n        int checkIndex = 0;\n        String diagnosticStatus = \"Running\";\n\n        while (checkIndex < 5) {\n            System.out.println(\"Diagnostic check: \" + checkIndex);\n            checkIndex++;\n        }\n        diagnosticStatus = \"Completed\";\n        System.out.println(\"Diagnostic Status: \" + diagnosticStatus);\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 7,
            "line_end": 9,
            "type": "premature_break",
            "description": "Premature break statement terminates loop early",
            "fix": "Remove the if statement and break: if (checkIndex == 2) { break; }"
          }
        ],
        "number_of_errors": 1,
        "explanation": "The original code's `if (checkIndex == 2) { break; }` statement causes the `while` loop to terminate prematurely when `checkIndex` is 2. The loop runs for `checkIndex = 0, 1, 2` and then stops. The fix is to remove the `if (checkIndex == 2) { break; }` statement entirely, allowing the loop to run its full course for `checkIndex` values 0 through 4, as dictated by the condition `checkIndex < 5`. This ensures all 5 checks are printed, followed by the final status."
      },
      "hints": {
        "1": "The `break` statement immediately exits the loop when triggered.",
        "2": "Check what condition causes the loop to stop early (`checkIndex == 2`).",
        "3": "To run all 5 checks, ensure no `break` interrupts the loop before `checkIndex` reaches 5."
      }
    },
    {
      "id": 343,
      "subtopic_id": 8,
      "type": "code_fixer",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinderâ€™s battery charger uses a `do-while` loop that prints `chargeProgress` *after* it's incremented, showing an incorrect initial value. Fix the code to print `chargeProgress` *before* it's updated in each cycle.",
      "story_context": "The BatteryChargerFixer needs to charge the battery. Your task is to fix the print statement order.",
      "challenge_data": {
        "initial_code": "public class BatteryChargerFixer {\n    public static void main(String[] args) {\n        int chargeProgress = 50;\n        do {\n            chargeProgress += 10;\n            System.out.println(\"Charging: \" + chargeProgress + \"%\"); \n        } while (chargeProgress < 80);\n        System.out.println(\"Battery Full: \" + chargeProgress + \"%\");\n    }\n}",
        "expected_output": [
          "Charging: 50%",
          "Charging: 60%",
          "Charging: 70%",
          "Battery Full: 80%"
        ],
        "solution_code": "public class BatteryChargerFixer {\n    public static void main(String[] args) {\n        int chargeProgress = 50;\n        do {\n            System.out.println(\"Charging: \" + chargeProgress + \"%\"); \n            chargeProgress += 10;\n        } while (chargeProgress < 80);\n        System.out.println(\"Battery Full: \" + chargeProgress + \"%\");\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 5,
            "line_end": 6,
            "type": "print_order",
            "description": "Print statement after increment shows wrong value",
            "fix": "Move print statement before increment: System.out.println(\"Charging: \" + chargeProgress + \"%\"); chargeProgress += 10;"
          }
        ],
        "number_of_errors": 1,
        "explanation": "The original code places `chargeProgress += 10;` *before* the `System.out.println()` statement inside the `do-while` loop. This means that in the first iteration, `chargeProgress` becomes 60 *before* \"Charging: 60%\" is printed. The requirement is to show the value *before* the increment. The fix is to move the `System.out.println()` statement *before* the `chargeProgress += 10;` line. This ensures the current `chargeProgress` (50, 60, 70) is printed before it's updated for the next iteration."
      },
      "hints": {
        "1": "The `System.out.println()` statement prints the value of `chargeProgress` *at the moment* it is executed.",
        "2": "The original code increments `chargeProgress` *before* printing.",
        "3": "To show the value *before* it's changed for the next iteration, the print statement needs to come before the increment within the loop body."
      }
    },
    {
      "id": 344,
      "subtopic_id": 8,
      "type": "code_fixer",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinderâ€™s data logger uses a `while` loop that logs one data point too many, including the boundary value. Fix the code to ensure it logs data points from 5 to 9 (inclusive).",
      "story_context": "The DataLoggerFixer needs to log data points. Your task is to fix the loop boundary condition.",
      "challenge_data": {
        "initial_code": "public class DataLoggerFixer {\n    public static void main(String[] args) {\n        int dataPoint = 5;\n        while (dataPoint <= 10) { \n            System.out.println(\"Logging data point: \" + dataPoint);\n            dataPoint++;\n        }\n    }\n}",
        "expected_output": [
          "Logging data point: 5",
          "Logging data point: 6",
          "Logging data point: 7",
          "Logging data point: 8",
          "Logging data point: 9"
        ],
        "solution_code": "public class DataLoggerFixer {\n    public static void main(String[] args) {\n        int dataPoint = 5;\n        while (dataPoint < 10) { \n            System.out.println(\"Logging data point: \" + dataPoint);\n            dataPoint++;\n        }\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 4,
            "type": "loop_boundary",
            "description": "Wrong boundary condition - includes extra iteration",
            "fix": "Change condition to: while (dataPoint < 10)"
          }
        ],
        "number_of_errors": 1,
        "explanation": "The original loop condition `while (dataPoint <= 10)` allows the loop to execute when `dataPoint` is `10` (`10 <= 10` is `true`). This prints \"Logging data point: 10\", which is undesirable. The requirement is to log values from 5 to 9. The fix is to change the loop condition from `dataPoint <= 10` to `dataPoint < 10`. This makes the loop execute for `dataPoint` values of 5, 6, 7, 8, and 9, and then terminates when `dataPoint` becomes 10."
      },
      "hints": {
        "1": "The loop's current condition `dataPoint <= 10` includes `dataPoint = 10` in the last iteration.",
        "2": "The goal is to stop *before* `dataPoint` becomes `10`.",
        "3": "Which comparison operator ensures \"strictly less than\"?"
      }
    },
    {
      "id": 345,
      "subtopic_id": 8,
      "type": "code_fixer",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinderâ€™s emergency protocol uses a `do-while` loop with a logical flaw (`||`) in its condition, causing it to run one extra time after the system becomes stable. Fix the code to ensure the loop terminates immediately once the `isSystemStable` flag is true.",
      "story_context": "The EmergencyProtocolFixer needs to run emergency protocols. Your task is to fix the logical operator in the loop condition.",
      "challenge_data": {
        "initial_code": "public class EmergencyProtocolFixer {\n    public static void main(String[] args) {\n        int currentStep = 1;\n        boolean isSystemStable = false;\n\n        do {\n            System.out.println(\"Running step: \" + currentStep);\n            if (currentStep == 2) {\n                isSystemStable = true;\n            }\n            currentStep++;\n        } while (!isSystemStable || currentStep <= 3);\n        System.out.println(\"Protocol finished.\");\n        System.out.println(\"Is system stable: \" + isSystemStable);\n    }\n}",
        "expected_output": [
          "Running step: 1",
          "Running step: 2",
          "Protocol finished.",
          "Is system stable: true"
        ],
        "solution_code": "public class EmergencyProtocolFixer {\n    public static void main(String[] args) {\n        int currentStep = 1;\n        boolean isSystemStable = false;\n\n        do {\n            System.out.println(\"Running step: \" + currentStep);\n            if (currentStep == 2) {\n                isSystemStable = true;\n            }\n            currentStep++;\n        } while (!isSystemStable && currentStep <= 3);\n        System.out.println(\"Protocol finished.\");\n        System.out.println(\"Is system stable: \" + isSystemStable);\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 12,
            "type": "logical_operator",
            "description": "Wrong logical operator - OR instead of AND",
            "fix": "Change || to &&: while (!isSystemStable && currentStep <= 3)"
          }
        ],
        "number_of_errors": 1,
        "explanation": "The original `do-while` loop condition `!isSystemStable || currentStep <= 3` uses a logical OR (`||`), which allows the loop to continue if *either* condition is true. When `currentStep` is 2, `isSystemStable` becomes `true`, but after incrementing to `currentStep = 3`, the condition `3 <= 3` is still `true`, causing an extra iteration. The fix is to change the condition to `!isSystemStable && currentStep <= 3`, using AND (`&&`). This ensures the loop stops as soon as `isSystemStable` is `true`, regardless of `currentStep`. The loop runs for `currentStep = 1` and `2`, then terminates."
      },
      "hints": {
        "1": "The `do-while` loop continues as long as its condition evaluates to `true`.",
        "2": "The original condition uses `||`. What happens when `isSystemStable` becomes `true` but `currentStep <= 3` is still `true`?",
        "3": "To stop immediately when `isSystemStable` is `true`, both conditions must be required for the loop to continue."
      }
    },
    {
      "id": 346,
      "subtopic_id": 8,
      "type": "code_completion",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinderâ€™s automated system deploys `drones` for hull repair. A loop controls the deployment process. It should print the `droneID` as it's deployed, stopping after the 3rd drone (ID 2). Complete the loop keyword and the loop condition.",
      "story_context": "The Pathfinder's automated system needs to deploy drones for hull repair. Your task is to complete the loop structure.",
      "challenge_data": {
        "initial_code": "public class DroneDeployer {\n    public static void main(String[] args) {\n        int droneID = 0;\n        ??? (droneID < 3) {\n            System.out.println(\"Deploying Drone ID: \" + droneID);\n            droneID++;\n        }\n    }\n}",
        "expected_output": [
          "Deploying Drone ID: 0",
          "Deploying Drone ID: 1",
          "Deploying Drone ID: 2"
        ],
        "solution_code": "public class DroneDeployer {\n    public static void main(String[] args) {\n        int droneID = 0;\n        while (droneID < 3) {\n            System.out.println(\"Deploying Drone ID: \" + droneID);\n            droneID++;\n        }\n    }\n}",
        "choices": [
          "if",
          "while",
          "for",
          "do"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 4,
            "type": "keyword",
            "description": "Loop keyword for while loop",
            "correct_answer": "while",
        "explanation": "The `while` keyword is used to create a loop that repeatedly executes a block of code as long as its condition (`droneID < 3`) remains `true`. The condition is checked *before* each iteration."
          }
        ],
        "number_of_slots": 1
      },
      "hints": {
        "1": "The loop needs to run for `droneID` values 0, 1, and 2 (3 drones).",
        "2": "This loop checks its condition *before* its first iteration.",
        "3": "The blank needs a keyword to start a pre-checked loop."
      }
    },
    {
      "id": 347,
      "subtopic_id": 8,
      "type": "code_completion",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinderâ€™s emergency system attempts activation. A loop is used to ensure it tries `at least once`, and repeats until `attemptsMade` reaches `2`. Complete the loop keywords.",
      "story_context": "The Pathfinder's emergency system needs to attempt activation with guaranteed execution. Your task is to complete the do-while loop structure.",
      "challenge_data": {
        "initial_code": "public class EmergencyActivator {\n    public static void main(String[] args) {\n        int attemptsMade = 0;\n        ??? {\n            System.out.println(\"Attempting emergency activation.\");\n            attemptsMade++;\n        } ??? (attemptsMade < 2);\n    }\n}",
        "expected_output": [
          "Attempting emergency activation.",
          "Attempting emergency activation."
        ],
        "solution_code": "public class EmergencyActivator {\n    public static void main(String[] args) {\n        int attemptsMade = 0;\n        do {\n            System.out.println(\"Attempting emergency activation.\");\n            attemptsMade++;\n        } while (attemptsMade < 2);\n    }\n}",
        "choices": [
          "if",
          "while",
          "for",
          "do"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 4,
            "type": "keyword",
            "description": "Do keyword for do-while loop",
            "correct_answer": "do",
            "explanation": "The `do` keyword starts the do-while loop, ensuring the loop body executes at least once."
          },
          {
            "id": "slot_2",
            "line": 7,
            "type": "keyword",
            "description": "While keyword for do-while loop condition",
            "correct_answer": "while",
            "explanation": "The `while` keyword introduces the condition `(attemptsMade < 2)`, which is evaluated after each iteration to determine if the loop should continue."
          }
        ],
        "number_of_slots": 2
      },
      "hints": {
        "1": "This loop type guarantees its body runs at least one time before checking the condition.",
        "2": "The first blank introduces the loop body that runs immediately.",
        "3": "The second blank is where the condition is checked after the body's first run."
      }
    },
    {
      "id": 348,
      "subtopic_id": 8,
      "type": "code_completion",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinder is transferring `fuel` from one tank to another. A loop needs to display the `fuel` level as it decreases, stopping when `fuel` reaches 0. Complete the `System.out.println()` statement and the decrement operation.",
      "story_context": "The Pathfinder's fuel transfer system needs to display fuel levels during transfer. Your task is to complete the loop operations.",
      "challenge_data": {
        "initial_code": "public class FuelTransfer {\n    public static void main(String[] args) {\n        int fuel = 3;\n        while (fuel > 0) {\n            System.out.println(\"Fuel remaining: \" + ???);\n            ???;\n        }\n    }\n}",
        "expected_output": [
          "Fuel remaining: 3",
          "Fuel remaining: 2",
          "Fuel remaining: 1"
        ],
        "solution_code": "public class FuelTransfer {\n    public static void main(String[] args) {\n        int fuel = 3;\n        while (fuel > 0) {\n            System.out.println(\"Fuel remaining: \" + fuel);\n            fuel--;\n        }\n    }\n}",
        "choices": [
          "fuel--",
          "remaining",
          "fuel",
          "fuel++"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 5,
            "type": "variable",
            "description": "Variable to display in print statement",
            "correct_answer": "fuel",
            "explanation": "The `fuel` variable correctly prints the current fuel value in each iteration."
          },
          {
            "id": "slot_2",
            "line": 6,
            "type": "operator",
            "description": "Decrement operation for fuel",
            "correct_answer": "fuel--",
            "explanation": "The `fuel--` is the post-decrement operator, which decreases fuel by 1 after its value has been used in the print statement, ensuring the loop eventually terminates."
          }
        ],
        "number_of_slots": 2
      },
      "hints": {
        "1": "The `System.out.println()` needs to display the `current fuel` value.",
        "2": "The loop condition `fuel > 0` requires `fuel` to decrease in each iteration.",
        "3": "The blank needs a concise way to decrement `fuel` by `1`."
      }
    },
    {
      "id": 349,
      "subtopic_id": 8,
      "type": "code_completion",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinderâ€™s data link retransmits `packets` using a `do-while` loop. It prints the packet number and continues as long as `retransmitCount` is less than `3`. Complete the missing semicolon after the `while` condition.",
      "story_context": "The Pathfinder's data link system needs to retransmit packets with proper loop termination. Your task is to complete the do-while loop syntax.",
      "challenge_data": {
        "initial_code": "public class DataRetransmitter {\n    public static void main(String[] args) {\n        boolean packetStatus = false;\n        int retransmitCount = 0;\n\n        do {\n            System.out.println(\"Retransmitting packet. Count: \" + retransmitCount);\n            retransmitCount++;\n        } while (retransmitCount < 3) ???\n    }\n}",
        "expected_output": [
          "Retransmitting packet. Count: 0",
          "Retransmitting packet. Count: 1",
          "Retransmitting packet. Count: 2"
        ],
        "solution_code": "public class DataRetransmitter {\n    public static void main(String[] args) {\n        boolean packetStatus = false;\n        int retransmitCount = 0;\n\n        do {\n            System.out.println(\"Retransmitting packet. Count: \" + retransmitCount);\n            retransmitCount++;\n        } while (retransmitCount < 3);\n    }\n}",
        "choices": [
          ",",
          ":",
          "retransmitCount",
          ";"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 9,
            "type": "punctuation",
            "description": "Semicolon to terminate do-while loop",
            "correct_answer": ";",
            "explanation": "A `do-while` loop in Java requires a semicolon (`;`) immediately after the `while (condition)` part. This semicolon terminates the `do-while` statement."
          }
        ],
        "number_of_slots": 1
      },
      "hints": {
        "1": "A `do-while` loop has a unique requirement for its `while` condition line.",
        "2": "Look at the very end of the line where the `while` keyword and condition appear.",
        "3": "A specific punctuation mark is required to complete the `do-while` statement."
      }
    },
    {
      "id": 350,
      "subtopic_id": 8,
      "type": "code_completion",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinderâ€™s reactor stabilizer adjusts `coreTemp`. A `while` loop continues as long as `coreTemp` is above 70. Complete the loopâ€™s condition using the appropriate comparison operator.",
      "story_context": "The Pathfinder's reactor stabilizer needs to maintain temperature control. Your task is to complete the loop condition with the correct comparison operator.",
      "challenge_data": {
        "initial_code": "public class ReactorStabilizer {\n    public static void main(String[] args) {\n        int coreTemp = 80;\n        int coolantFlow = 40;\n\n        while (coreTemp ??? 70) {\n            System.out.println(\"Stabilizing reactor. Temp: \" + coreTemp);\n            coreTemp -= 5;\n        }\n    }\n}",
        "expected_output": [
          "Stabilizing reactor. Temp: 80",
          "Stabilizing reactor. Temp: 75",
          "Stabilizing reactor. Temp: 70"
        ],
        "solution_code": "public class ReactorStabilizer {\n    public static void main(String[] args) {\n        int coreTemp = 80;\n        int coolantFlow = 40;\n\n        while (coreTemp > 70) {\n            System.out.println(\"Stabilizing reactor. Temp: \" + coreTemp);\n            coreTemp -= 5;\n        }\n    }\n}",
        "choices": [
          "<",
          ">=",
          "<=",
          ">"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 6,
            "type": "operator",
            "description": "Comparison operator for greater than",
            "correct_answer": ">",
            "explanation": "To check if `coreTemp` is \"above 70,\" the \"greater than\" operator `>` is used. The loop continues as long as `coreTemp` is strictly greater than 70."
          }
        ],
        "number_of_slots": 1
      },
      "hints": {
        "1": "The loop condition requires `coreTemp` to be `above` 70.",
        "2": "Which comparison operator means \"strictly greater than\"?",
        "3": "The blank needs a single operation symbol."
      }
    },
    {
      "id": 351,
      "subtopic_id": 8,
      "type": "code_completion",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinder's `emergencySystem` attempts activation. A `while` loop controls the process, and `attemptsMade` increases until it reaches `2`. Complete the loop keywords and the condition.",
      "story_context": "The Pathfinder's emergency system needs to attempt activation with controlled iterations. Your task is to complete the while loop structure.",
      "challenge_data": {
        "initial_code": "public class EmergencyActivator {\n    public static void main(String[] args) {\n        int attemptsMade = 0;\n        ??? (attemptsMade < 2) {\n            System.out.println(\"Attempting emergency activation.\");\n            attemptsMade++;\n        }\n    }\n}",
        "expected_output": [
          "Attempting emergency activation.",
          "Attempting emergency activation."
        ],
        "solution_code": "public class EmergencyActivator {\n    public static void main(String[] args) {\n        int attemptsMade = 0;\n        while (attemptsMade < 2) {\n            System.out.println(\"Attempting emergency activation.\");\n            attemptsMade++;\n        }\n    }\n}",
        "choices": [
          "if",
          "while",
          "for",
          "do"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 4,
            "type": "keyword",
            "description": "While loop keyword",
            "correct_answer": "while",
        "explanation": "The `while` keyword is used to create a loop that repeatedly executes a block of code as long as its condition (`attemptsMade < 2`) remains `true`. The condition is checked *before* each iteration."
          }
        ],
        "number_of_slots": 1
      },
      "hints": {
        "1": "This loop checks its condition *before* running its code block.",
        "2": "It repeats actions as long as a condition remains true.",
        "3": "The blank needs a keyword to start a pre-checked loop."
      }
    },
    {
      "id": 352,
      "subtopic_id": 8,
      "type": "code_completion",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinder is transferring `fuel` from one tank to another. A `while` loop needs to display the `fuel` level as it decreases, stopping when `fuel` reaches 0. Complete the print statement and the decrement.",
      "story_context": "The Pathfinder's fuel transfer system needs to monitor fuel levels during transfer. Your task is to complete the loop operations.",
      "challenge_data": {
        "initial_code": "public class FuelTransfer {\n    public static void main(String[] args) {\n        int fuel = 3;\n        while (fuel > 0) {\n            System.out.println(\"Fuel remaining: \" + ???);\n            ???;\n        }\n    }\n}",
        "expected_output": [
          "Fuel remaining: 3",
          "Fuel remaining: 2",
          "Fuel remaining: 1"
        ],
        "solution_code": "public class FuelTransfer {\n    public static void main(String[] args) {\n        int fuel = 3;\n        while (fuel > 0) {\n            System.out.println(\"Fuel remaining: \" + fuel);\n            fuel--;\n        }\n    }\n}",
        "choices": [
          "fuel--",
          "remaining",
          "fuel",
          "fuel++"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 5,
            "type": "variable",
            "description": "Variable to display current fuel level",
            "correct_answer": "fuel",
            "explanation": "`fuel` correctly prints the current `fuel` value in each iteration."
          },
          {
            "id": "slot_2",
            "line": 6,
            "type": "operator",
            "description": "Decrement operator to reduce fuel",
            "correct_answer": "fuel--",
            "explanation": "`fuel--` is the post-decrement operator, which decreases `fuel` by 1 after its value has been used in the print statement, ensuring the loop eventually terminates."
          }
        ],
        "number_of_slots": 2
      },
      "hints": {
        "1": "The `System.out.println()` needs to display the `current fuel` value.",
        "2": "The loop condition `fuel > 0` requires `fuel` to decrease in each iteration.",
        "3": "The blank needs a concise way to decrement `fuel` by `1`."
      }
    },
    {
      "id": 353,
      "subtopic_id": 8,
      "type": "code_completion",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinderâ€™s data link retransmits `packets` using a `do-while` loop. It prints the packet number and continues as long as `retransmitCount` is less than `3`. Complete the print statement and the missing semicolon after the `while` condition.",
      "story_context": "The Pathfinder's data link system needs to retransmit packets with proper loop termination. Your task is to complete the do-while loop syntax.",
      "challenge_data": {
        "initial_code": "public class DataRetransmitter {\n    public static void main(String[] args) {\n        boolean packetStatus = false;\n        int retransmitCount = 0;\n\n        do {\n            System.out.println(\"Retransmitting packet. Count: \" + retransmitCount);\n            retransmitCount++;\n        } while (retransmitCount < 3) ???\n    }\n}",
        "expected_output": [
          "Retransmitting packet. Count: 0",
          "Retransmitting packet. Count: 1",
          "Retransmitting packet. Count: 2"
        ],
        "solution_code": "public class DataRetransmitter {\n    public static void main(String[] args) {\n        boolean packetStatus = false;\n        int retransmitCount = 0;\n\n        do {\n            System.out.println(\"Retransmitting packet. Count: \" + retransmitCount);\n            retransmitCount++;\n        } while (retransmitCount < 3);\n    }\n}",
        "choices": [
          ",",
          ":",
          "retransmitCount",
          ";"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 9,
            "type": "punctuation",
            "description": "Semicolon to terminate do-while loop",
            "correct_answer": ";",
            "explanation": "A `do-while` loop in Java requires a semicolon (`;`) immediately after the `while (condition)` part. This semicolon terminates the `do-while` statement."
          }
        ],
        "number_of_slots": 1
      },
      "hints": {
        "1": "A `do-while` loop has a unique requirement for its `while` condition line.",
        "2": "Look at the very end of the line where the `while` keyword and condition appear.",
        "3": "A specific punctuation mark is required to complete the `do-while` statement."
      }
    },
    {
      "id": 354,
      "subtopic_id": 8,
      "type": "code_completion",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinderâ€™s reactor stabilizer adjusts `coreTemp`. A `while` loop continues as long as `coreTemp` is above 70. Complete the loopâ€™s condition using the appropriate comparison operator.",
      "story_context": "The Pathfinder's reactor stabilizer needs to maintain temperature control. Your task is to complete the loop condition with the correct comparison operator.",
      "challenge_data": {
        "initial_code": "public class ReactorStabilizer {\n    public static void main(String[] args) {\n        int coreTemp = 80;\n        int coolantFlow = 40;\n\n        while (coreTemp ??? 70) {\n            System.out.println(\"Stabilizing reactor. Temp: \" + coreTemp);\n            coreTemp -= 5;\n        }\n    }\n}",
        "expected_output": [
          "Stabilizing reactor. Temp: 80",
          "Stabilizing reactor. Temp: 75",
          "Stabilizing reactor. Temp: 70"
        ],
        "solution_code": "public class ReactorStabilizer {\n    public static void main(String[] args) {\n        int coreTemp = 80;\n        int coolantFlow = 40;\n\n        while (coreTemp > 70) {\n            System.out.println(\"Stabilizing reactor. Temp: \" + coreTemp);\n            coreTemp -= 5;\n        }\n    }\n}",
        "choices": [
          "<",
          ">=",
          "<=",
          ">"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 6,
            "type": "operator",
            "description": "Comparison operator for greater than",
            "correct_answer": ">",
            "explanation": "To check if `coreTemp` is \"above 70,\" the \"greater than\" operator `>` is used. The loop continues as long as `coreTemp` is strictly greater than 70."
          }
        ],
        "number_of_slots": 1
      },
      "hints": {
        "1": "The loop condition requires `coreTemp` to be `above` 70.",
        "2": "Which comparison operator means \"strictly greater than\"?",
        "3": "The blank needs a single operation symbol."
      }
    },
    {
      "id": 355,
      "subtopic_id": 8,
      "type": "code_completion",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinder's `droneDeployer` manages `droneID`s. A `while` loop prints the `droneID` as it's deployed, stopping after the 3rd drone (ID 2). Complete the loop's condition, the body's print statement, and the increment step.",
      "story_context": "The Pathfinder's drone deployment system needs to manage drone IDs with proper loop control. Your task is to complete the while loop structure.",
      "challenge_data": {
        "initial_code": "public class DroneDeployer {\n    public static void main(String[] args) {\n        int droneID = 0;\n        while (droneID ??? 3) {\n            System.out.println(\"Deploying Drone ID: \" + ???);\n            ???;\n        }\n    }\n}",
        "expected_output": [
          "Deploying Drone ID: 0",
          "Deploying Drone ID: 1",
          "Deploying Drone ID: 2"
        ],
        "solution_code": "public class DroneDeployer {\n    public static void main(String[] args) {\n        int droneID = 0;\n        while (droneID < 3) {\n            System.out.println(\"Deploying Drone ID: \" + droneID);\n            droneID++;\n        }\n    }\n}",
        "choices": [
          "droneID++",
          "<",
          "droneID--",
          "<=",
          "droneID",
          "=="
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 4,
            "type": "operator",
            "description": "Comparison operator for less than",
            "correct_answer": "<",
            "explanation": "`<` correctly sets the `while` loop condition to run for `droneID` values 0, 1, and 2, terminating when `droneID` reaches 3."
          },
          {
            "id": "slot_2",
            "line": 5,
            "type": "variable",
            "description": "Variable to display current drone ID",
            "correct_answer": "droneID",
            "explanation": "`droneID` prints the current `droneID`."
          },
          {
            "id": "slot_3",
            "line": 6,
            "type": "operator",
            "description": "Increment operator to update drone ID",
            "correct_answer": "droneID++",
            "explanation": "`droneID++` increments `droneID` in each iteration, ensuring the loop eventually terminates."
          }
        ],
        "number_of_slots": 3
      },
      "hints": {
        "1": "The loop needs to run for `droneID` values 0, 1, and 2 (3 drones). Which comparison operator ensures this range?",
        "2": "The `System.out.println()` needs to display the `current droneID`.",
        "3": "The blank at the end of the loop body needs to update `droneID` to ensure termination."
      }
    },
    {
      "id": 356,
      "subtopic_id": 8,
      "type": "code_completion",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinderâ€™s emergency AI activates a cascade of safety systems. An outer `while` loop manages `systemGroups`, and an inner `do-while` loop for `subSystemChecks`. Each `subSystemCheck` evaluates `powerLevel`: if `powerLevel` is `below 20`, it's a \"CRITICAL\" alert and breaks the inner loop. If `powerLevel` is `between 20 and 50` (inclusive of 20, exclusive of 50), it's a \"WARNING\" and skips to the next `subSystemCheck`. Otherwise, it logs \"OK\". The outer loop runs for 2 `systemGroups` (0 to 1). The inner loop *always* performs at least one `subSystemCheck` and runs a maximum of 3 times (0 to 2) per group, unless broken. Complete the code for the outer loop's condition, the inner loop's keyword, and the inner loop's continuation condition.",
      "story_context": "The Pathfinder's emergency AI needs to perform safety system cascades with nested loop control. Your task is to complete the nested loop structure.",
      "challenge_data": {
        "initial_code": "public class EmergencyCascade {\n    public static void main(String[] args) {\n        int systemGroup = 0;\n        int totalAlerts = 0;\n        \n        while (systemGroup ??? 2) { \n            int subSystemCheck = 0;\n            int powerLevel = 60;\n            \n            ??? { \n                System.out.println(\"Group \" + systemGroup + \", Sub \" + subSystemCheck + \" Status: \");\n                \n                if (powerLevel < 20) {\n                    totalAlerts++;\n                    System.out.println(\"CRITICAL: Power failure!\");\n                    break;\n                } else if (powerLevel >= 20 && powerLevel < 50) {\n                    totalAlerts++;\n                    System.out.println(\"WARNING: Power fluctuation.\");\n                    powerLevel -= 15;\n                    continue;\n                } else {\n                    System.out.println(\"OK: Stable.\");\n                    powerLevel -= 10;\n                }\n                subSystemCheck++;\n            }\n            while (subSystemCheck ??? 3);\n            \n            systemGroup++;\n        }\n        System.out.println(\"\\nEmergency Cascade Complete. Total Critical/Warning Alerts: \" + totalAlerts);\n    }\n}",
        "expected_output": [
          "Group 0, Sub 0 Status: ",
          "OK: Stable.",
          "Group 0, Sub 1 Status: ",
          "OK: Stable.",
          "Group 0, Sub 2 Status: ",
          "OK: Stable.",
          "Group 1, Sub 0 Status: ",
          "OK: Stable.",
          "Group 1, Sub 1 Status: ",
          "WARNING: Power fluctuation.",
          "Group 1, Sub 2 Status: ",
          "CRITICAL: Power failure!",
          "Emergency Cascade Complete. Total Critical/Warning Alerts: 2"
        ],
        "solution_code": "public class EmergencyCascade {\n    public static void main(String[] args) {\n        int systemGroup = 0;\n        int totalAlerts = 0;\n        \n        while (systemGroup < 2) { \n            int subSystemCheck = 0;\n            int powerLevel = 60;\n            \n            do { \n                System.out.println(\"Group \" + systemGroup + \", Sub \" + subSystemCheck + \" Status: \");\n                \n                if (powerLevel < 20) {\n                    totalAlerts++;\n                    System.out.println(\"CRITICAL: Power failure!\");\n                    break;\n                } else if (powerLevel >= 20 && powerLevel < 50) {\n                    totalAlerts++;\n                    System.out.println(\"WARNING: Power fluctuation.\");\n                    powerLevel -= 15;\n                    continue;\n                } else {\n                    System.out.println(\"OK: Stable.\");\n                    powerLevel -= 10;\n                }\n                subSystemCheck++;\n            }\n            while (subSystemCheck < 3);\n            \n            systemGroup++;\n        }\n        System.out.println(\"\\nEmergency Cascade Complete. Total Critical/Warning Alerts: \" + totalAlerts);\n    }\n}",
        "choices": [
          "if",
          "<",
          "while",
          "continue",
          "do",
          "<=",
          "else if",
          "else"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 6,
            "type": "operator",
            "description": "Outer loop comparison operator",
            "correct_answer": "<",
            "explanation": "`<` correctly sets the outer `while` loop condition to run for `systemGroup` values 0 and 1, terminating when `systemGroup` reaches 2."
          },
          {
            "id": "slot_2",
            "line": 10,
            "type": "keyword",
            "description": "Do-while loop keyword",
            "correct_answer": "do",
            "explanation": "`do` is the keyword that starts a `do-while` loop, which ensures the loop body executes at least once before checking the condition."
          },
          {
            "id": "slot_3",
            "line": 22,
            "type": "operator",
            "description": "Inner loop comparison operator",
            "correct_answer": "<",
            "explanation": "`<` correctly sets the inner `do-while` loop condition to run for `subSystemCheck` values 0, 1, and 2, terminating when `subSystemCheck` reaches 3."
          }
        ],
        "number_of_slots": 3
      },
      "hints": {
        "1": "The outer `while` loop needs to run for `systemGroup` values 0 and 1.",
        "2": "The inner loop *must* run at least once for each `subSystemCheck`.",
        "3": "The inner `do-while` loop's continuation condition needs to ensure 3 checks (0 to 2)."
      }
    },
    {
      "id": 357,
      "subtopic_id": 8,
      "type": "code_completion",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinderâ€™s reactor cooling system activates `coolantPulses`. An outer `do-while` loop manages `coolingCycles` and *always* runs at least once. An inner `while` loop performs `pulseIterations`. If `coolantTemp` (which decreases) drops `below 50`, the inner loop must `break` early. If `pulseIterations` reaches `2` and `coolantTemp` is `still above 50`, it logs \"Warning\". Otherwise, it logs \"Pulse OK\". Complete the code for the outer loop's keyword, the inner loop's comparison operator for critical temp, and the overall outer loop continuation keyword.",
      "story_context": "The Pathfinder's reactor cooling system needs to manage temperature control with nested loops. Your task is to complete the nested loop structure.",
      "challenge_data": {
        "initial_code": "public class ReactorCooling {\n    public static void main(String[] args) {\n        int coolingCycles = 0;\n        int coolantTemp = 70;\n        int maxCycles = 2; // For outer loop\n        \n        ??? { \n            System.out.println(\"Cooling Cycle: \" + coolingCycles);\n            int pulseIterations = 0;\n            \n            while (pulseIterations < 3) {\n                System.out.println(\"  Pulse: \" + pulseIterations + \", Temp: \" + coolantTemp);\n                if (coolantTemp ??? 50) {\n                    System.out.println(\"  CRITICAL TEMP! Aborting pulse iterations.\");\n                    break;\n                }\n                if (pulseIterations == 2 && coolantTemp > 50) {\n                    System.out.println(\"  WARNING: High temp after multiple pulses.\");\n                }\n                coolantTemp -= 5;\n                pulseIterations++;\n            }\n            coolingCycles++;\n        }\n        ??? (coolingCycles < maxCycles);\n        \n        System.out.println(\"\\nCooling Sequence Complete. Final Temp: \" + coolantTemp);\n    }\n}",
        "expected_output": [
          "Cooling Cycle: 0",
          "  Pulse: 0, Temp: 70",
          "  Pulse: 1, Temp: 65",
          "  Pulse: 2, Temp: 60",
          "Cooling Cycle: 1",
          "  Pulse: 0, Temp: 55",
          "  Pulse: 1, Temp: 50",
          "  CRITICAL TEMP! Aborting pulse iterations.",
          "Cooling Sequence Complete. Final Temp: 50"
        ],
        "solution_code": "public class ReactorCooling {\n    public static void main(String[] args) {\n        int coolingCycles = 0;\n        int coolantTemp = 70;\n        int maxCycles = 2; // For outer loop\n        \n        do { \n            System.out.println(\"Cooling Cycle: \" + coolingCycles);\n            int pulseIterations = 0;\n            \n            while (pulseIterations < 3) {\n                System.out.println(\"  Pulse: \" + pulseIterations + \", Temp: \" + coolantTemp);\n                if (coolantTemp < 50) {\n                    System.out.println(\"  CRITICAL TEMP! Aborting pulse iterations.\");\n                    break;\n                }\n                if (pulseIterations == 2 && coolantTemp > 50) {\n                    System.out.println(\"  WARNING: High temp after multiple pulses.\");\n                }\n                coolantTemp -= 5;\n                pulseIterations++;\n            }\n            coolingCycles++;\n        }\n        while (coolingCycles < maxCycles);\n        \n        System.out.println(\"\\nCooling Sequence Complete. Final Temp: \" + coolantTemp);\n    }\n}",
        "choices": [
          "<",
          "while",
          "1",
          "2",
          "do",
          "0",
          ">",
          "else if"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 7,
            "type": "keyword",
            "description": "Do-while loop keyword",
            "correct_answer": "do",
            "explanation": "`do` correctly starts the outer `do-while` loop, ensuring at least one cooling cycle is performed."
          },
          {
            "id": "slot_2",
            "line": 12,
            "type": "operator",
            "description": "Critical temperature comparison operator",
            "correct_answer": "<",
            "explanation": "`<` is the comparison operator for `coolantTemp < 50`, which triggers the `break` from the inner loop."
          },
          {
            "id": "slot_3",
            "line": 22,
            "type": "keyword",
            "description": "While keyword to complete do-while loop",
            "correct_answer": "while",
            "explanation": "`while` correctly completes the `do-while` loop's continuation statement."
          }
        ],
        "number_of_slots": 3
      },
      "hints": {
        "1": "The outer loop *must* run at least once.",
        "2": "The inner `while` loop's `break` condition triggers when `coolantTemp` is `below 50`.",
        "3": "The final blank completes the `do-while` loop syntax."
      }
    },
    {
      "id": 358,
      "subtopic_id": 8,
      "type": "code_completion",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinderâ€™s signal relay system tests `packetTransmissions` with a `while` loop. Odd-numbered packets might trigger an \"Interference\" warning and skip confirmation, while signal quality is checked for degradation. Complete the loop condition, conditional skip, and signal quality check.",
      "story_context": "The Pathfinder's signal relay system needs to test packet transmissions with interference detection. Your task is to complete the loop structure and signal quality checks.",
      "challenge_data": {
        "initial_code": "public class SignalRelay {\n    public static void main(String[] args) {\n        int packetsSent = 0;\n        int signalQuality = 100;\n        \n        while (packetsSent ??? 5) {\n            System.out.println(\"Transmitting packet: \" + packetsSent);\n            \n            if (packetsSent % 2 != 0 && packetsSent < 4) {\n                System.out.println(\"  WARNING: Interference detected on \" + packetsSent);\n                packetsSent++; \n                ???;\n            }\n            \n            if (packetsSent % ??? == 0 && packetsSent > 0) {\n                if (signalQuality < ???) {\n                    System.out.println(\"  SIGNAL: Degraded at \" + packetsSent);\n                }\n            }\n            \n            System.out.println(\"  Packet \" + packetsSent + \" Confirmed.\");\n            packetsSent++;\n        }\n        System.out.println(\"Relay test complete.\");\n    }\n}",
        "expected_output": [
          "Transmitting packet: 0",
          "  Packet 0 Confirmed.",
          "Transmitting packet: 1",
          "  WARNING: Interference detected on 1",
          "Transmitting packet: 2",
          "  SIGNAL: Degraded at 2",
          "  Packet 2 Confirmed.",
          "Transmitting packet: 3",
          "  WARNING: Interference detected on 3",
          "Transmitting packet: 4",
          "  Packet 4 Confirmed.",
          "Relay test complete."
        ],
        "solution_code": "public class SignalRelay {\n    public static void main(String[] args) {\n        int packetsSent = 0;\n        int signalQuality = 100;\n        \n        while (packetsSent < 5) {\n            System.out.println(\"Transmitting packet: \" + packetsSent);\n            \n            if (packetsSent % 2 != 0 && packetsSent < 4) {\n                System.out.println(\"  WARNING: Interference detected on \" + packetsSent);\n                packetsSent++; \n                continue;\n            }\n            \n            if (packetsSent % 2 == 0 && packetsSent > 0) {\n                if (signalQuality < 80) {\n                    System.out.println(\"  SIGNAL: Degraded at \" + packetsSent);\n                }\n            }\n            \n            System.out.println(\"  Packet \" + packetsSent + \" Confirmed.\");\n            packetsSent++;\n        }\n        System.out.println(\"Relay test complete.\");\n    }\n}",
        "choices": [
          "<",
          "continue",
          "3",
          "2",
          "80",
          "<=",
          "break",
          "90"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 5,
            "type": "operator",
            "description": "Loop condition comparison operator",
            "correct_answer": "<",
            "explanation": "`<` correctly sets the outer `while` loop condition (`packetsSent < 5`)."
          },
          {
            "id": "slot_2",
            "line": 10,
            "type": "keyword",
            "description": "Continue keyword to skip iteration",
            "correct_answer": "continue",
            "explanation": "`continue` is used to skip the rest of the current iteration's body."
          },
          {
            "id": "slot_3",
            "line": 14,
            "type": "number",
            "description": "Modulo divisor for even packet check",
            "correct_answer": "2",
            "explanation": "`2` is used for `packetsSent % 2 == 0`, to check for even numbered packets."
          },
          {
            "id": "slot_4",
            "line": 15,
            "type": "number",
            "description": "Signal quality threshold",
            "correct_answer": "80",
            "explanation": "`80` is the threshold for `signalQuality < 80`."
          }
        ],
        "number_of_slots": 4
      },
      "hints": {
        "1": "The loop should continue as long as `packetsSent` is strictly less than 5.",
        "2": "The blank in the `if` block is for a keyword that skips the rest of the current loop iteration.",
        "3": "The `if` condition checks for every second packet (`packetsSent % X == 0`)."
      }
    },
    {
      "id": 359,
      "subtopic_id": 8,
      "type": "code_completion",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinderâ€™s shield recalibrator performs `calibrationAttempts` in a `do-while` loop, ensuring at least one attempt. It continues as long as `recalibrationNeeded` is true AND `calibrationAttempts` is less than 3. Complete the loop type, logical operators, and the iteration limit.",
      "story_context": "The Pathfinder's shield recalibrator needs to perform calibration attempts with proper loop control. Your task is to complete the do-while loop structure.",
      "challenge_data": {
        "initial_code": "public class ShieldRecalibrator {\n    public static void main(String[] args) {\n        int calibrationAttempts = 0;\n        boolean recalibrationNeeded = true;\n        int shieldIntegrity = 70;\n        \n        ??? { \n            System.out.println(\"Attempting recalibration. Attempt: \" + (calibrationAttempts + 1));\n            \n            if (recalibrationNeeded ??? shieldIntegrity ??? 90) {\n                recalibrationNeeded = false;\n                System.out.println(\"  Recalibration successful!\");\n            } else {\n                System.out.println(\"  Recalibration ongoing...\");\n                shieldIntegrity += 5;\n            }\n            calibrationAttempts++;\n        }\n        while (recalibrationNeeded ??? calibrationAttempts < ???);\n        \n        System.out.println(\"\\nRecalibration Procedure Complete. Final Attempts: \" + calibrationAttempts);\n        System.out.println(\"Recalibration Needed (final status): \" + recalibrationNeeded);\n    }\n}",
        "expected_output": [
          "Attempting recalibration. Attempt: 1",
          "  Recalibration ongoing...",
          "Attempting recalibration. Attempt: 2",
          "  Recalibration ongoing...",
          "Attempting recalibration. Attempt: 3",
          "  Recalibration successful!",
          "Recalibration Procedure Complete. Final Attempts: 3",
          "Recalibration Needed (final status): false"
        ],
        "solution_code": "public class ShieldRecalibrator {\n    public static void main(String[] args) {\n        int calibrationAttempts = 0;\n        boolean recalibrationNeeded = true;\n        int shieldIntegrity = 70;\n        \n        do { \n            System.out.println(\"Attempting recalibration. Attempt: \" + (calibrationAttempts + 1));\n            \n            if (recalibrationNeeded && shieldIntegrity >= 90) {\n                recalibrationNeeded = false;\n                System.out.println(\"  Recalibration successful!\");\n            } else {\n                System.out.println(\"  Recalibration ongoing...\");\n                shieldIntegrity += 5;\n            }\n            calibrationAttempts++;\n        }\n        while (recalibrationNeeded && calibrationAttempts < 3);\n        \n        System.out.println(\"\\nRecalibration Procedure Complete. Final Attempts: \" + calibrationAttempts);\n        System.out.println(\"Recalibration Needed (final status): \" + recalibrationNeeded);\n    }\n}",
        "choices": [
          "while",
          "3",
          "4",
          ">=",
          "do",
          "&&",
          ">",
          "||"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 7,
            "type": "keyword",
            "description": "Do-while loop keyword",
            "correct_answer": "do",
            "explanation": "`do` correctly starts the outer `do-while` loop."
          },
          {
            "id": "slot_2",
            "line": 10,
            "type": "operator",
            "description": "Logical AND operator",
            "correct_answer": "&&",
            "explanation": "`&&` is the logical `AND` operator, combining `recalibrationNeeded` with the shield integrity check within the `if` condition."
          },
          {
            "id": "slot_3",
            "line": 10,
            "type": "operator",
            "description": "Greater than or equal operator",
            "correct_answer": ">=",
            "explanation": "`>=` is the comparison operator for `shieldIntegrity >= 90`, indicating successful recalibration."
          },
          {
            "id": "slot_4",
            "line": 16,
            "type": "operator",
            "description": "Logical AND operator for while condition",
            "correct_answer": "&&",
            "explanation": "`&&` is the logical `AND` operator for the while condition."
          },
          {
            "id": "slot_5",
            "line": 16,
            "type": "number",
            "description": "Iteration limit boundary",
            "correct_answer": "3",
            "explanation": "`3` is the correct boundary value for `calibrationAttempts < 3`, ensuring the loop runs for attempts 0, 1, and 2."
          }
        ],
        "number_of_slots": 5
      },
      "hints": {
        "1": "The outer loop *must* run at least once.",
        "2": "The `if` condition inside the loop checks if `recalibrationNeeded` is true AND `shieldIntegrity` is `at least 90`.",
        "3": "The `while` loop continues as long as `recalibrationNeeded` is true AND `calibrationAttempts` is strictly less than a specific boundary value."
      }
    },
    {
      "id": 360,
      "subtopic_id": 8,
      "type": "code_completion",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinderâ€™s survey drone performs `sectorScans`. The `while` loop continues as long as `currentSector` is less than 5 AND no `anomalyDetected`. The drone can skip analysis if the signal is weak or break the survey if too many anomalies are detected. Complete the loop condition, skip keyword, break keyword, and final status message.",
      "story_context": "The Pathfinder's survey drone needs to perform sector scans with anomaly detection. Your task is to complete the loop structure and control flow.",
      "challenge_data": {
        "initial_code": "public class SurveyDroneControl {\n    public static void main(String[] args) {\n        int currentSector = 0;\n        int signalStrength = 100;\n        boolean anomalyDetected = false;\n        \n        while (currentSector ??? 5 && !anomalyDetected) {\n            System.out.println(\"Scanning Sector: \" + currentSector);\n            \n            if (currentSector == 2) {\n                signalStrength = 40;\n            }\n            \n            if (signalStrength < 50) {\n                System.out.println(\"  WARNING: Weak Signal. Skipping analysis.\");\n                currentSector++;\n                ???;\n            }\n            \n            if (currentSector > 2 && currentSector % 2 == 0) {\n                anomalyDetected = true;\n                System.out.println(\"  CRITICAL: Anomaly detected at sector \" + currentSector + \"!\");\n                ???;\n            }\n            \n            System.out.println(\"  Sector \" + currentSector + \" analysis complete.\");\n            currentSector++;\n        }\n        \n        System.out.println(\"\\nSurvey complete.\");\n        if (anomalyDetected) {\n            System.out.println(\"Final Survey Status: Aborted.\");\n        } else {\n            System.out.println(???);\n        }\n    }\n}",
        "expected_output": [
          "Scanning Sector: 0",
          "  Sector 0 analysis complete.",
          "Scanning Sector: 1",
          "  Sector 1 analysis complete.",
          "Scanning Sector: 2",
          "  WARNING: Weak Signal. Skipping analysis.",
          "Scanning Sector: 3",
          "  Sector 3 analysis complete.",
          "Scanning Sector: 4",
          "  CRITICAL: Anomaly detected at sector 4!",
          "Survey complete.",
          "Final Survey Status: Aborted."
        ],
        "solution_code": "public class SurveyDroneControl {\n    public static void main(String[] args) {\n        int currentSector = 0;\n        int signalStrength = 100;\n        boolean anomalyDetected = false;\n        \n        while (currentSector < 5 && !anomalyDetected) {\n            System.out.println(\"Scanning Sector: \" + currentSector);\n            \n            if (currentSector == 2) {\n                signalStrength = 40;\n            }\n            \n            if (signalStrength < 50) {\n                System.out.println(\"  WARNING: Weak Signal. Skipping analysis.\");\n                currentSector++;\n                continue;\n            }\n            \n            if (currentSector > 2 && currentSector % 2 == 0) {\n                anomalyDetected = true;\n                System.out.println(\"  CRITICAL: Anomaly detected at sector \" + currentSector + \"!\");\n                break;\n            }\n            \n            System.out.println(\"  Sector \" + currentSector + \" analysis complete.\");\n            currentSector++;\n        }\n        \n        System.out.println(\"\\nSurvey complete.\");\n        if (anomalyDetected) {\n            System.out.println(\"Final Survey Status: Aborted.\");\n        } else {\n            System.out.println(\"Final Survey Status: All sectors scanned.\");\n        }\n    }\n}",
        "choices": [
          "<",
          "\"Final Survey Status: All sectors scanned.\"",
          "continue",
          "\"Final Survey Status: Aborted due to anomaly.\"",
          "&&",
          "<=",
          "break",
          "||"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 6,
            "type": "operator",
            "description": "Loop condition comparison operator",
            "correct_answer": "<",
            "explanation": "`<` sets the outer `while` loop condition (`currentSector < 5`)."
          },
          {
            "id": "slot_2",
            "line": 15,
            "type": "keyword",
            "description": "Continue keyword to skip iteration",
            "correct_answer": "continue",
            "explanation": "`continue` is used to skip the rest of the inner loop body when a weak signal is detected."
          },
          {
            "id": "slot_3",
            "line": 20,
            "type": "keyword",
            "description": "Break keyword to exit loop",
            "correct_answer": "break",
            "explanation": "`break` is used to immediately exit the loop when a critical anomaly is detected."
          },
          {
            "id": "slot_4",
            "line": 28,
            "type": "string",
            "description": "Final status message for successful scan",
            "correct_answer": "\"Final Survey Status: All sectors scanned.\"",
            "explanation": "`\"Final Survey Status: All sectors scanned.\"` is the correct message when all sectors are scanned without an anomaly."
          }
        ],
        "number_of_slots": 4
      },
      "hints": {
        "1": "The outer `while` loop continues as long as `currentSector` is strictly less than 5 AND no anomaly is detected.",
        "2": "The blank after the 'Weak Signal' message is for a keyword that skips the rest of the current iteration.",
        "3": "The blank after the 'Anomaly detected' message is for a keyword that immediately exits the loop."
      }
    },
    {
      "id": 361,
      "subtopic_id": 9,
      "type": "output_tracing",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinder's pre-flight system runs `diagnosticChecks`. A `for` loop performs these checks for `checkID` from `0` to `2`. Your task is to trace the code and determine what check IDs are logged.",
      "story_context": "The Pathfinder's pre-flight system needs to perform diagnostic checks using a for loop. Your task is to trace the loop execution and predict the output.",
      "challenge_data": {
        "code": "public class DiagnosticChecker {\n    public static void main(Strinag[] args) {\n        for (int checkID = 0; checkID < 3; checkID++) {\n            System.out.println(\"Performing diagnostic check: \" + checkID);\n        }\n    }\n}",
        "expected_output": [
          "Performing diagnostic check: 0\\nPerforming diagnostic check: 1\\nPerforming diagnostic check: 2"
        ],
        "choices": [
          "Performing diagnostic check: 0",
          "Performing diagnostic check: 0\\nPerforming diagnostic check: 1\\nPerforming diagnostic check: 2",
          "Performing diagnostic check: 1\\nPerforming diagnostic check: 2\\nPerforming diagnostic check: 3",
          "Nothing"
        ],
        "explanation": "The `for` loop executes as follows:\n1. **`checkID = 0`**: `0 < 3` is `true`. Prints \"Performing diagnostic check: 0\". `checkID` becomes 1.\n2. **`checkID = 1`**: `1 < 3` is `true`. Prints \"Performing diagnostic check: 1\". `checkID` becomes 2.\n3. **`checkID = 2`**: `2 < 3` is `true`. Prints \"Performing diagnostic check: 2\". `checkID` becomes 3.\n4. **`checkID = 3`**: `3 < 3` is `false`. The loop terminates.\nThe message is printed for check IDs 0, 1, and 2."
      },
      "hints": {
        "1": "The loop starts with `checkID = 0`.",
        "2": "The loop continues as long as `checkID` is strictly less than `3`.",
        "3": " `checkID` increments by `1` after each iteration."
      }
    },
    {
      "id": 362,
      "subtopic_id": 9,
      "type": "output_tracing",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinder is performing a `launchCountdown`. The countdown starts from `3` and goes down to `1`. Your task is to trace the code and determine the output.",
      "story_context": "The Pathfinder's launch system needs to perform a countdown using a for loop. Your task is to trace the loop execution and predict the output.",
      "challenge_data": {
        "code": "public class LaunchCountdown {\n    public static void main(String[] args) {\n        for (int count = 3; count > 0; count--) {\n            System.out.println(\"T-\" + count);\n        }\n        System.out.println(\"Launch!\");\n    }\n}",
        "expected_output": [
          "T-3\\nT-2\\nT-1\\nLaunch!"
        ],
        "choices": [
          "T-3\\nT-2\\nT-1\\nLaunch!",
          "T-3\\nT-2\\nT-1",
          "Launch!",
          "T-0\\nLaunch!"
        ],
        "explanation": "The `for` loop executes as follows:\n1. **`count = 3`**: `3 > 0` is `true`. Prints \"T-3\". `count` becomes 2.\n2. **`count = 2`**: `2 > 0` is `true`. Prints \"T-2\". `count` becomes 1.\n3. **`count = 1`**: `1 > 0` is `true`. Prints \"T-1\". `count` becomes 0.\n4. **`count = 0`**: `0 > 0` is `false`. The loop terminates.\nFinally, `System.out.println(\"Launch!\");` prints \"Launch!\"."
      },
      "hints": {
        "1": "The loop starts with `count = 3` and decrements.",
        "2": "The loop continues as long as `count` is greater than `0`.",
        "3": "The \"Launch!\" message is printed once, after the loop."
      }
    },
    {
      "id": 363,
      "subtopic_id": 9,
      "type": "output_tracing",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinder's `moduleStatus` array contains names of modules. The system iterates through the array to check each module. Your task is to trace the output to see the status of each module printed using an enhanced for loop.",
      "story_context": "The Pathfinder's module status checker needs to iterate through module statuses using an enhanced for loop. Your task is to trace the loop execution and predict the output.",
      "challenge_data": {
        "code": "public class ModuleStatusChecker {\n    public static void main(String[] args) {\n        String[] moduleStatus = {\"OK\", \"WARNING\", \"CRITICAL\"};\n        for (String status : moduleStatus) {\n            System.out.println(\"Module Status: \" + status);\n        }\n    }\n}",
        "expected_output": [
          "Module Status: OK\\nModule Status: WARNING\\nModule Status: CRITICAL"
        ],
        "choices": [
          "Module Status: OK",
          "Module Status: OK\\nModule Status: WARNING\\nModule Status: CRITICAL",
          "Module Status: OK\\nModule Status: WARNING",
          "Nothing"
        ],
        "explanation": "The enhanced `for` loop iterates through each `String` element in the `moduleStatus` array.\n1. **Iteration 1**: `status` is \"OK\". Prints \"Module Status: OK\".\n2. **Iteration 2**: `status` is \"WARNING\". Prints \"Module Status: WARNING\".\n3. **Iteration 3**: `status` is \"CRITICAL\". Prints \"Module Status: CRITICAL\".\nThe loop finishes after processing all elements."
      },
      "hints": {
        "1": "An enhanced `for` loop (for-each) iterates through every element in an array.",
        "2": "The loop variable `status` will take on the value of each element in `moduleStatus` sequentially.",
        "3": "The `println` statement is executed for each element."
      }
    },
    {
      "id": 364,
      "subtopic_id": 9,
      "type": "output_tracing",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinder's `communicationChannels` are numbered. A `for` loop prints each channel number. Your task is to trace the output.",
      "story_context": "The Pathfinder's communication channel printer needs to print channel numbers using a for loop. Your task is to trace the loop execution and predict the output.",
      "challenge_data": {
        "code": "public class CommsChannelPrinter {\n    public static void main(String[] args) {\n        for (int channel = 1; channel <= 2; channel++) {\n            System.out.println(\"Channel: \" + channel);\n        }\n    }\n}",
        "expected_output": [
          "Channel: 1\\nChannel: 2"
        ],
        "choices": [
          "Channel: 1",
          "Channel: 1\\nChannel: 2",
          "Channel: 0\\nChannel: 1\\nChannel: 2",
          "Nothing"
        ],
        "explanation": "The `for` loop executes as follows:\n1. **`channel = 1`**: `1 <= 2` is `true`. Prints \"Channel: 1\". `channel` becomes 2.\n2. **`channel = 2`**: `2 <= 2` is `true`. Prints \"Channel: 2\". `channel` becomes 3.\n3. **`channel = 3`**: `3 <= 2` is `false`. The loop terminates.\nThe output shows \"Channel: 1\" and \"Channel: 2\"."
      },
      "hints": {
        "1": "The loop starts with `channel = 1`.",
        "2": "The loop continues as long as `channel` is `less than or equal to 2`.",
        "3": " `channel` increments by `1` after each iteration."
      }
    },
    {
      "id": 365,
      "subtopic_id": 9,
      "type": "output_tracing",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinder's `alertCodes` are stored in an array. The system needs to print each code. Your task is to trace the output using an enhanced for loop.",
      "story_context": "The Pathfinder's alert code printer needs to print alert codes using an enhanced for loop. Your task is to trace the loop execution and predict the output.",
      "challenge_data": {
        "code": "public class AlertCodePrinter {\n    public static void main(String[] args) {\n        int[] alertCodes = {10, 20, 30};\n        for (int code : alertCodes) {\n            System.out.print(code + \" \");\n        }\n    }\n}",
        "expected_output": [
          "10 20 30"
        ],
        "choices": [
          "10",
          "10 20 30",
          "10 20",
          "Nothing"
        ],
        "explanation": "The enhanced `for` loop iterates through each `int` element in the `alertCodes` array.\n1. **Iteration 1**: `code` is 10. Prints \"10 \".\n2. **Iteration 2**: `code` is 20. Prints \"20 \".\n3. **Iteration 3**: `code` is 30. Prints \"30 \".\nThe loop finishes after processing all elements, resulting in \"10 20 30 \"."
      },
      "hints": {
        "1": "An enhanced `for` loop (for-each) iterates through every element in an array.",
        "2": "The loop variable `code` will take on the value of each element in `alertCodes` sequentially.",
        "3": " `System.out.print()` prints on the same line."
      }
    },
    {
      "id": 366,
      "subtopic_id": 9,
      "type": "output_tracing",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinder's `sensorData` array contains temperature readings. The system calculates the average temperature. Your task is to trace the code and determine both the individual readings and the final average.",
      "story_context": "The Pathfinder's sensor data analyzer needs to calculate average temperature using a for loop. Your task is to trace the loop execution and predict the outputs.",
      "challenge_data": {
        "code": "public class ResourceCollector {\n    public static void main(String[] args) {\n        int finalTotalEnergy = 0;\n        for (int collectionCycle = 1; collectionCycle <= 3; collectionCycle++) {\n            System.out.println(\"Collecting \" + (collectionCycle * 10) + \" energy units.\");\n            finalTotalEnergy += (collectionCycle * 10);\n        }\n        System.out.println(\"Final Total Energy: \" + finalTotalEnergy);\n    }\n}",
        "expected_output": [
          "Collecting 10 energy units.\\nCollecting 20 energy units.\\nCollecting 30 energy units.",
          "Final Total Energy: 60"
        ],
        "choices": [
          "Collecting 10 energy units.\\nCollecting 20 energy units.\\nCollecting 30 energy units.",
          "Final Total Energy: 30",
          "Collecting 10 energy units.\\nCollecting 20 energy units.\\nCollecting 60 energy units.\\nFinal Total Energy: 30",
          "Final Total Energy: 60",
          "Collecting 10 energy units.\\nCollecting 20 energy units.\\nCollecting 30 energy units.\\nFinal Total Energy: 60"
        ],
        "explanation": "1. **Loop Iterations**: `finalTotalEnergy` starts at 0.\n    * `collectionCycle = 1`: `1 <= 3` is `true`. Prints \"Collecting 10 energy units.\". `finalTotalEnergy` becomes 10.\n    * `collectionCycle = 2`: `2 <= 3` is `true`. Prints \"Collecting 20 energy units.\". `finalTotalEnergy` becomes 10 + 20 = 30.\n    * `collectionCycle = 3`: `3 <= 3` is `true`. Prints \"Collecting 30 energy units.\". `finalTotalEnergy` becomes 30 + 30 = 60.\n    * `collectionCycle = 4`: `4 <= 3` is `false`. Loop terminates.\n2. **After Loop**: `System.out.println(\"Final Total Energy: \" + finalTotalEnergy);` executes, printing \"Final Total Energy: 60\"."
      },
      "hints": {
        "1": "The loop runs for `collectionCycle` values 1, 2, and 3.",
        "2": "The energy collected in each cycle is `collectionCycle * 10`.",
        "3": " `finalTotalEnergy` accumulates the sum of collected energy units across all cycles."
      }
    },
    {
      "id": 367,
      "subtopic_id": 9,
      "type": "output_tracing",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinder's `moduleInventory` tracks `moduleIDs`. The system iterates through the array, but a special message is logged if a module is `null`. Your task is to trace the `moduleID`s and the `null` messages.",
      "story_context": "The Pathfinder's module inventory scanner needs to check module IDs using an enhanced for loop with null checks. Your task is to trace the loop execution and predict the outputs.",
      "challenge_data": {
        "code": "public class ModuleInventoryScanner {\n    public static void main(String[] args) {\n        String[] moduleInventory = {\"NAV-01\", null, \"ENG-03\"};\n        for (String moduleID : moduleInventory) {\n            if (moduleID == null) {\n                System.out.println(\"Empty slot detected.\");\n            } else {\n                System.out.println(\"Module ID: \" + moduleID);\n            }\n        }\n    }\n}",
        "expected_output": [
          "Module ID: NAV-01\\nEmpty slot detected.\\nModule ID: ENG-03"
        ],
        "choices": [
          "Module ID: NAV-01\\nEmpty slot detected.\\nModule ID: ENG-03",
          "Module ID: NAV-01\\nModule ID: ENG-03",
          "Empty slot detected.",
          "Module ID: NAV-01\\nModule ID: NAV-01",
          "Module ID: NAV-03\\nEmpty slot detected.\\nModule ID: ENG-01"
        ],
        "explanation": "The enhanced `for` loop iterates through the `moduleInventory` array:\n1. **Iteration 1**: `moduleID` is \"NAV-01\". `moduleID == null` is `false`. Prints \"Module ID: NAV-01\".\n2. **Iteration 2**: `moduleID` is `null`. `moduleID == null` is `true`. Prints \"Empty slot detected.\".\n3. **Iteration 3**: `moduleID` is \"ENG-03\". `moduleID == null` is `false`. Prints \"Module ID: ENG-03\".\nThe loop processes all elements, leading to the combined output."
      },
      "hints": {
        "1": "An enhanced `for` loop processes each element of the array in order.",
        "2": "Pay attention to the `if-else` condition inside the loop: what happens if `moduleID` is `null`?",
        "3": "The second element of `moduleInventory` is `null`."
      }
    },
    {
      "id": 368,
      "subtopic_id": 9,
      "type": "output_tracing",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinder's `powerCore` undergoes `diagnosticCycles`. The `for` loop runs 3 times. Inside the loop, `powerOutput` is doubled, but a special message is printed only for `even` cycles. Your task is to trace the `powerOutput` messages and the `Final Power Value`.",
      "story_context": "The Pathfinder's power core diagnostics needs to run diagnostic cycles using a for loop with conditional output. Your task is to trace the loop execution and predict the outputs.",
      "challenge_data": {
        "code": "public class PowerCoreDiagnostics {\n    public static void main(String[] args) {\n        int powerOutput = 10;\n        for (int cycle = 1; cycle <= 3; cycle++) {\n            powerOutput *= 2;\n            if (cycle % 2 == 0) {\n                System.out.println(\"Power spike detected on cycle \" + cycle + \": \" + powerOutput);\n            } else {\n                System.out.println(\"Cycle \" + cycle + \" complete. Current Power: \" + powerOutput);\n            }\n        }\n        System.out.println(\"Final Power Value: \" + powerOutput);\n    }\n}",
        "expected_output": [
          "Cycle 1 complete. Current Power: 20\\nPower spike detected on cycle 2: 40\\nCycle 3 complete. Current Power: 80",
          "Final Power Value: 80"
        ],
        "choices": [
          "Cycle 1 complete. Current Power: 20\\nPower spike detected on cycle 2: 40\\nCycle 3 complete. Current Power: 80",
          "Final Power Value: 80",
          "Final Power Value: 60",
          "Cycle 1 complete. Current Power: 20\\nPower spike detected on cycle 2: 40\\nCycle 3 complete. Current Power: 80\\nFinal Power Value: 80",
          "Cycle 1 complete. Current Power: 20\\nPower spike detected on cycle 2: 40\\nCycle 3 complete. Current Power: 80\\nFinal Power Value: 0"
        ],
        "explanation": "1. **Loop Iterations**: `powerOutput` starts at 10.\n    * `cycle = 1`: `1 <= 3` is `true`. `powerOutput` becomes `10 * 2 = 20`. `1 % 2 == 0` is `false`. Prints \"Cycle 1 complete. Current Power: 20\".\n    * `cycle = 2`: `2 <= 3` is `true`. `powerOutput` becomes `20 * 2 = 40`. `2 % 2 == 0` is `true`. Prints \"Power spike detected on cycle 2: 40\".\n    * `cycle = 3`: `3 <= 3` is `true`. `powerOutput` becomes `40 * 2 = 80`. `3 % 2 == 0` is `false`. Prints \"Cycle 3 complete. Current Power: 80\".\n    * `cycle = 4`: `4 <= 3` is `false`. Loop terminates.\n2. **After Loop**: `System.out.println(\"Final Power Value: \" + powerOutput);` executes, printing \"Final Power Value: 80\"."
      },
      "hints": {
        "1": "Trace `powerOutput` as it updates in each iteration.",
        "2": "The `if-else` condition inside the loop depends on `cycle` being even or odd.",
        "3": "The final `powerOutput` value after the loop terminates is printed once."
      }
    },
    {
      "id": 369,
      "subtopic_id": 9,
      "type": "output_tracing",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinder is transferring `dataPackets` with a `for` loop. The loop iterates `packetID`s from 1 to 3. If a `packetID` is `2`, a \"Retrying\" message is displayed, but the loop `continues` to the next iteration. Your task is to trace the sequence of output messages and the `Final Packets Sent` count.",
      "story_context": "The Pathfinder's data packet transfer system needs to transfer packets using a for loop with continue statements. Your task is to trace the loop execution and predict the outputs.",
      "challenge_data": {
        "code": "public class DataPacketTransfer {\n    public static void main(String[] args) {\n        int finalPacketsSent = 0;\n        for (int packetID = 1; packetID <= 3; packetID++) {\n            if (packetID == 2) {\n                System.out.println(\"Retrying packet \" + packetID + \"...\");\n                continue;\n            }\n            System.out.println(\"Packet \" + packetID + \" sent.\");\n            finalPacketsSent++;\n        }\n        System.out.println(\"Final Packets Sent: \" + finalPacketsSent);\n    }\n}",
        "expected_output": [
          "Packet 1 sent.\\nRetrying packet 2...\\nPacket 3 sent.",
          "Final Packets Sent: 2"
        ],
        "choices": [
          "Packet 1 sent.\\nRetrying packet 2...\\nPacket 3 sent.",
          "Final Packets Sent: 3",
          "Final Packets Sent: 2",
          "Packet 1 sent.\\nRetrying packet 2...\\nPacket 3 sent.\\nFinal Packets Sent: 3",
          "Packet 1 sent.\\nRetrying packet 2...\\nPacket 2 sent."
        ],
        "explanation": "1. **Loop Iterations**: `finalPacketsSent` starts at 0.\n    * `packetID = 1`: `1 <= 3` is `true`. `1 == 2` is `false`. Prints \"Packet 1 sent.\". `finalPacketsSent` becomes 1. `packetID` becomes 2.\n    * `packetID = 2`: `2 <= 3` is `true`. `2 == 2` is `true`. Prints \"Retrying packet 2...\". `continue` skips the rest of the current iteration. `packetID` becomes 3.\n    * `packetID = 3`: `3 <= 3` is `true`. `3 == 2` is `false`. Prints \"Packet 3 sent.\". `finalPacketsSent` becomes 2. `packetID` becomes 4.\n    * `packetID = 4`: `4 <= 3` is `false`. Loop terminates.\n2. **After Loop**: `System.out.println(\"Final Packets Sent: \" + finalPacketsSent);` executes, printing \"Final Packets Sent: 2\"."
      },
      "hints": {
        "1": "Trace `packetID` and `finalPacketsSent` through each iteration.",
        "2": "The `continue` keyword skips the remainder of the current loop iteration.",
        "3": "The final `finalPacketsSent` value is the count of times \"Packet X sent.\" was actually printed."
      }
    },
    {
      "id": 370,
      "subtopic_id": 9,
      "type": "output_tracing",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinder performs a `moduleScan` using a `for` loop for `moduleID`s from 1 to 3. If `moduleID` reaches `3`, a \"Critical Error\" is detected, and the loop `breaks` immediately. Your task is to trace the output messages and the `Final Module Scanned` value.",
      "story_context": "The Pathfinder's module scanner needs to scan modules using a for loop with break statements. Your task is to trace the loop execution and predict the outputs.",
      "challenge_data": {
        "code": "public class ModuleScanner {\n    public static void main(String[] args) {\n        int finalModuleScanned = 0;\n        for (int moduleID = 1; moduleID <= 3; moduleID++) {\n            if (moduleID == 3) {\n                System.out.println(\"Critical Error: Aborting scan at module \" + moduleID + \".\");\n                finalModuleScanned = moduleID;\n                break;\n            }\n            System.out.println(\"Scanning module: \" + moduleID);\n            finalModuleScanned = moduleID;\n        }\n        System.out.println(\"Final Module Scanned: \" + finalModuleScanned);\n    }\n}",
        "expected_output": [
          "Scanning module: 1\\nScanning module: 2\\nCritical Error: Aborting scan at module 3.",
          "Final Module Scanned: 3"
        ],
        "choices": [
          "Scanning module: 1\\nScanning module: 2\\nCritical Error: Aborting scan at module 3.",
          "Final Module Scanned: 2",
          "Final Module Scanned: 3",
          "Scanning module: 1\\nScanning module: 2\\nCritical Error: Aborting scan at module 3.\\nFinal Module Scanned: 4",
          "Scanning module: 1\\nScanning module: 2."
        ],
        "explanation": "1. **Loop Iterations**: `finalModuleScanned` starts at 0.\n    * `moduleID = 1`: `1 <= 3` is `true`. `1 == 3` is `false`. Prints \"Scanning module: 1\". `finalModuleScanned` becomes 1. `moduleID` becomes 2.\n    * `moduleID = 2`: `2 <= 3` is `true`. `2 == 3` is `false`. Prints \"Scanning module: 2\". `finalModuleScanned` becomes 2. `moduleID` becomes 3.\n    * `moduleID = 3`: `3 <= 3` is `true`. `3 == 3` is `true`. Prints \"Critical Error: Aborting scan at module 3.\". `finalModuleScanned` becomes 3. `break` exits the loop.\n2. **After Loop**: `System.out.println(\"Final Module Scanned: \" + finalModuleScanned);` executes, printing \"Final Module Scanned: 3\"."
      },
      "hints": {
        "1": "Trace `moduleID` and `finalModuleScanned` carefully.",
        "2": "The `break` keyword immediately exits the loop when its condition is met.",
        "3": "The `finalModuleScanned` variable captures the `moduleID` value *at the point of the break* (or loop completion)."
      }
    },
    {
      "id": 371,
      "subtopic_id": 9,
      "type": "output_tracing",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinder is performing a `multiPhaseScan`. Nested `for` loops iterate `scanPhases` and `dataPoints`. A special message is printed under specific conditions. Your task is to trace all `Scan Phase` and `Data Point` messages, and determine the `Total Readings` and `Scan Status`.",
      "story_context": "The Pathfinder's multi-phase scan system needs to perform nested loops using for statements. Your task is to trace the loop execution and predict the outputs.",
      "challenge_data": {
        "code": "public class MultiPhaseScan {\n    public static void main(String[] args) {\n        int totalReadings = 0;\n        String scanStatus = \"Scanning\";\n\n        for (int scanPhase = 0; scanPhase < 2; scanPhase++) {\n            for (int dataPoint = 0; dataPoint < 3; dataPoint++) {\n                System.out.println(\"Scan Phase: \" + scanPhase + \", Data Point: \" + dataPoint);\n                totalReadings++;\n                if (scanPhase == 0 && dataPoint == 1) {\n                    System.out.println(\"  SPECIAL DATA: Anomaly detected in phase \" + scanPhase);\n                }\n            }\n        }\n        \n        if (totalReadings == 6) {\n            scanStatus = \"Complete\";\n        } else {\n            scanStatus = \"Incomplete\";\n        }\n        \n        System.out.println(\"Total Readings: \" + totalReadings);\n        System.out.println(\"Scan Status: \" + scanStatus);\n    }\n}",
        "expected_output": [
          "Scan Phase: 0, Data Point: 0\\nScan Phase: 0, Data Point: 1\\n  SPECIAL DATA: Anomaly detected in phase 0\\nScan Phase: 0, Data Point: 2\\nScan Phase: 1, Data Point: 0\\nScan Phase: 1, Data Point: 1\\nScan Phase: 1, Data Point: 2",
          "Total Readings: 6",
          "Scan Status: Complete"
        ],
        "choices": [
          "Scan Phase: 0, Data Point: 0\\nScan Phase: 0, Data Point: 1\\n  SPECIAL DATA: Anomaly detected in phase 0\\nScan Phase: 0, Data Point: 2\\nScan Phase: 1, Data Point: 0\\nScan Phase: 1, Data Point: 1\\nScan Phase: 1, Data Point: 2",
          "Total Readings: 5",
          "Total Readings: 6",
          "Scan Status: Complete",
          "Scan Phase: 0, Data Point: 0\\nScan Phase: 0, Data Point: 1\\n  SPECIAL DATA: Anomaly detected in phase 0\\nScan Phase: 1, Data Point: 2\\nScan Phase: 0, Data Point: 0\\nScan Phase: 1, Data Point: 1\\nScan Phase: 1, Data Point: 2",
          "Total Readings: 56"
        ],
        "explanation": "1. **Loop Execution (Phase/Data output)**:\n    * `scanPhase = 0` (Outer loop):\n        * `dataPoint = 0`: Prints \"Scan Phase: 0, Data Point: 0\". `totalReadings` is 1.\n        * `dataPoint = 1`: Prints \"Scan Phase: 0, Data Point: 1\". `totalReadings` is 2. Prints \"SPECIAL DATA: Anomaly detected in phase 0\".\n        * `dataPoint = 2`: Prints \"Scan Phase: 0, Data Point: 2\". `totalReadings` is 3.\n    * `scanPhase = 1` (Outer loop):\n        * `dataPoint = 0`: Prints \"Scan Phase: 1, Data Point: 0\". `totalReadings` is 4.\n        * `dataPoint = 1`: Prints \"Scan Phase: 1, Data Point: 1\". `totalReadings` is 5.\n        * `dataPoint = 2`: Prints \"Scan Phase: 1, Data Point: 2\". `totalReadings` is 6.\n2. **After Loops**: \n    * `totalReadings` is `6`. `if (totalReadings == 6)` is `true`. `scanStatus` becomes \"Complete\".\n    * `System.out.println(\"Total Readings: \" + totalReadings);` prints \"Total Readings: 6\".\n    * `System.out.println(\"Scan Status: \" + scanStatus);` prints \"Scan Status: Complete\"."
      },
      "hints": {
        "1": "Trace the execution of the outer loop (`scanPhase`) and how it controls the inner loop (`dataPoint`).",
        "2": " `totalReadings` increments in the inner loop.",
        "3": "The `if` condition for \"SPECIAL DATA\" checks specific values of both loop counters."
      }
    },
    {
      "id": 372,
      "subtopic_id": 9,
      "type": "output_tracing",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinder's `repairDrone` is running a `repairCycle` sequence. Nested `for` loops iterate `damageZones` and `repairAttempts`. Conditions within the loop can `skip` or `break` attempts. Your task is to trace all `Repair Cycle` messages and determine the `Total Repair Attempts Made` and `Final Damage Zone`.",
      "story_context": "The Pathfinder's repair drone simulator needs to perform repair cycles using nested for loops with continue and break statements. Your task is to trace the loop execution and predict the outputs.",
      "challenge_data": {
        "code": "public class RepairDroneSimulator {\n    public static void main(String[] args) {\n        int totalAttemptsMade = 0;\n        int finalDamageZone = 0;\n\n        for (int damageZone = 1; damageZone <= 2; damageZone++) {\n            System.out.println(\"Entering Damage Zone: \" + damageZone);\n            for (int repairAttempt = 1; repairAttempt <= 3; repairAttempt++) {\n                if (repairAttempt == 2 && damageZone == 1) {\n                    System.out.println(\"  Skipping problematic attempt \" + repairAttempt + \" in Zone \" + damageZone);\n                    totalAttemptsMade++;\n                    continue;\n                }\n                if (repairAttempt == 3) {\n                    System.out.println(\"  Critical failure in attempt \" + repairAttempt + \". Aborting Zone \" + damageZone + \".\");\n                    totalAttemptsMade++;\n                    break;\n                }\n                System.out.println(\"  Repair Cycle: \" + repairAttempt + \" in Zone: \" + damageZone);\n                totalAttemptsMade++;\n            }\n            finalDamageZone = damageZone;\n        }\n        \n        System.out.println(\"Total Repair Attempts Made: \" + totalAttemptsMade);\n        System.out.println(\"Final Damage Zone Processed: \" + finalDamageZone);\n        System.out.println(\"Simulation complete.\");\n    }\n}",
        "expected_output": [
          "Entering Damage Zone: 1\\n  Repair Cycle: 1 in Zone: 1\\n  Skipping problematic attempt 2 in Zone 1\\n  Critical failure in attempt 3. Aborting Zone 1.\\nEntering Damage Zone: 2\\n  Repair Cycle: 1 in Zone: 2\\n  Repair Cycle: 2 in Zone: 2\\n  Critical failure in attempt 3. Aborting Zone 2.",
          "Total Repair Attempts Made: 6",
          "Final Damage Zone Processed: 2"
        ],
        "choices": [
          "Entering Damage Zone: 1\\n  Repair Cycle: 1 in Zone: 1\\n  Skipping problematic attempt 2 in Zone 1\\n  Critical failure in attempt 3. Aborting Zone 1.\\nEntering Damage Zone: 2\\n  Repair Cycle: 1 in Zone: 2\\n  Repair Cycle: 2 in Zone: 3\\n  Critical failure in attempt 3. Aborting Zone 2.",
          "Total Repair Attempts Made: 6",
          "Final Damage Zone Processed: 2",
          "Total Repair Attempts Made: 5",
          "Entering Damage Zone: 1\\n  Repair Cycle: 1 in Zone: 1\\n  Skipping problematic attempt 2 in Zone 1\\n  Critical failure in attempt 3. Aborting Zone 1.\\nEntering Damage Zone: 2\\n  Repair Cycle: 1 in Zone: 2\\n  Repair Cycle: 2 in Zone: 2\\n  Critical failure in attempt 3. Aborting Zone 2.",
          "Final Damage Zone Processed: 1"
        ],
        "explanation": "1. **Loop Execution (Console Output)**:\n    * **`damageZone = 1`**: Prints \"Entering Damage Zone: 1\".\n        * `repairAttempt = 1`: Prints \"  Repair Cycle: 1 in Zone: 1\". `totalAttemptsMade` is 1.\n        * `repairAttempt = 2`: `damageZone == 1` is true. Prints \"  Skipping problematic attempt 2 in Zone 1\". `totalAttemptsMade` is 2. `continue`. (Skips normal print)\n        * `repairAttempt = 3`: `repairAttempt == 3` is true. Prints \"  Critical failure in attempt 3. Aborting Zone 1.\". `totalAttemptsMade` is 3. `break` (exits inner loop).\n    * `finalDamageZone` becomes 1.\n    * **`damageZone = 2`**: Prints \"Entering Damage Zone: 2\".\n        * `repairAttempt = 1`: Prints \"  Repair Cycle: 1 in Zone: 2\". `totalAttemptsMade` is 4.\n        * `repairAttempt = 2`: Prints \"  Repair Cycle: 2 in Zone: 2\". `totalAttemptsMade` is 5.\n        * `repairAttempt = 3`: `repairAttempt == 3` is true. Prints \"  Critical failure in attempt 3. Aborting Zone 2.\". `totalAttemptsMade` is 6. `break` (exits inner loop).\n    * `finalDamageZone` becomes 2.\n    * Outer loop terminates.\n2. **After Loops**: \n    * `System.out.println(\"Total Repair Attempts Made: \" + totalAttemptsMade);` prints \"Total Repair Attempts Made: 6\".\n    * `System.out.println(\"Final Damage Zone Processed: \" \" + finalDamageZone);` prints \"Final Damage Zone Processed: 2\"."
      },
      "hints": {
        "1": "Trace `damageZone` (outer loop) and `repairAttempt` (inner loop).",
        "2": " `continue` skips the rest of the inner loop's current iteration. `break` exits the *inner* loop.",
        "3": " `totalAttemptsMade` increments for *every* `repairAttempt`, even if skipped or aborted."
      }
    },
    {
      "id": 373,
      "subtopic_id": 9,
      "type": "output_tracing",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinder's `reactorPowerMatrix` is undergoing a `stressTest`. An outer `for` loop iterates `phaseCount`s (0 to 1). An inner `for` loop simulates `pulseCycles` (0 to 2). If `phaseCount` is `0` and `pulseCycle` is `1`, a special 'ALERT' is logged, and the inner loop's *current iteration* is `skipped`. If `phaseCount` is `1` and `pulseCycle` is `0`, a 'MELTDOWN' warning is logged, and the *entire program terminates early*. Your task is to trace all `Power Pulse` messages, the `Total Pulses Attempted`, and the `Final Reactor Status`.",
      "story_context": "The Pathfinder's reactor power matrix needs to perform stress tests using nested for loops with continue and return statements. Your task is to trace the loop execution and predict the outputs.",
      "challenge_data": {
        "code": "public class ReactorPowerMatrix {\n    public static void main(String[] args) {\n        int totalPulsesAttempted = 0;\n        String finalReactorStatus = \"Stable\";\n\n        for (int phaseCount = 0; phaseCount < 2; phaseCount++) {\n            System.out.println(\"Initiating Stress Test Phase: \" + phaseCount);\n            for (int pulseCycle = 0; pulseCycle < 3; pulseCycle++) {\n                if (phaseCount == 0 && pulseCycle == 1) {\n                    System.out.println(\"  ALERT: Minor Fluctuation at Phase \" + phaseCount + \", Pulse \" + pulseCycle);\n                    totalPulsesAttempted++; // Count this as an attempted pulse\n                    continue; // Skip normal logging for this pulse\n                }\n                if (phaseCount == 1 && pulseCycle == 0) {\n                    finalReactorStatus = \"MELTDOWN IMMINENT\";\n                    System.out.println(\"  CRITICAL: MELTDOWN at Phase \" + phaseCount + \", Pulse \" + pulseCycle + \"! Aborting all tests.\");\n                    totalPulsesAttempted++; // Count this as an attempted pulse\n                    return; // Terminate main method (program)\n                }\n                System.out.println(\"  Power Pulse: \" + pulseCycle + \" OK.\");\n                totalPulsesAttempted++;\n            }\n        }\n        System.out.println(\"\\nStress Test Complete. Final Status: \" + finalReactorStatus);\n        System.out.println(\"Total Pulses Attempted: \" + totalPulsesAttempted);\n    }\n}",
        "expected_output": [
          "Initiating Stress Test Phase: 0\\n  Power Pulse: 0 OK.\\n  ALERT: Minor Fluctuation at Phase 0, Pulse 1\\n  Power Pulse: 2 OK.\\nInitiating Stress Test Phase: 1\\n  CRITICAL: MELTDOWN at Phase 1, Pulse 0! Aborting all tests.",
          "Total Pulses Attempted: 4",
          "Final Reactor Status: MELTDOWN IMMINENT"
        ],
        "choices": [
          "Initiating Stress Test Phase: 0\\n  Power Pulse: 0 OK.\\n  ALERT: Minor Fluctuation at Phase 0, Pulse 1\\n  Power Pulse: 2 OK.\\nInitiating Stress Test Phase: 1\\n  CRITICAL: MELTDOWN at Phase 1, Pulse 1! Aborting all tests.",
          "Total Pulses Attempted: 4",
          "Final Reactor Status: Stable",
          "Final Reactor Status: MELTDOWN IMMINENT",
          "Initiating Stress Test Phase: 0\\n  Power Pulse: 0 OK.\\n  ALERT: Minor Fluctuation at Phase 0, Pulse 1\\n  Power Pulse: 2 OK.\\nInitiating Stress Test Phase: 1\\n  CRITICAL: MELTDOWN at Phase 1, Pulse 0! Aborting all tests.",
          "Total Pulses Attempted: 04"
        ],
        "explanation": "1. `phaseCount = 0` (Outer loop):\n    * Prints \"Initiating Stress Test Phase: 0\".\n    * `pulseCycle = 0`: Prints \"  Power Pulse: 0 OK.\". `totalPulsesAttempted` is 1.\n    * `pulseCycle = 1`: Prints \"  ALERT: Minor Fluctuation...\". `totalPulsesAttempted` is 2. `continue` skips `\"  Power Pulse: 1 OK.\"`.\n    * `pulseCycle = 2`: Prints \"  Power Pulse: 2 OK.\". `totalPulsesAttempted` is 3. \n2. `phaseCount = 1` (Outer loop):\n    * Prints \"Initiating Stress Test Phase: 1\".\n    * `pulseCycle = 0`: `phaseCount == 1 && pulseCycle == 0` is `true`. `finalReactorStatus` becomes \"MELTDOWN IMMINENT\". Prints \"  CRITICAL: MELTDOWN...\". `totalPulsesAttempted` is 4. `return` (program terminates).\n3. The final `System.out.println` statements outside the loops are not executed due to `return`."
      },
      "hints": {
        "1": "Trace nested loop execution and how `continue` affects output within an inner loop iteration.",
        "2": "A `return` statement immediately exits the `main` method, stopping all further program execution.",
        "3": "Keep track of `totalPulsesAttempted` and `finalReactorStatus` as they are updated conditionally."
      }
    },
    {
      "id": 374,
      "subtopic_id": 9,
      "type": "output_tracing",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinder's `automatedShield` system activates `layers` of shields. An outer `for` loop controls `shieldLayers` (1 to 2). An inner `for` loop manages `reinforcementCycles` (1 to 2). If `shieldLayer` is `1` and `reinforcementCycle` is `1`, a 'SKIPPED' message is logged, and the `reinforcementCycle` effectively advances by an extra step. If `shieldLayer` is `2` and `reinforcementCycle` is `2`, a 'FAILURE' is logged, causing the *inner loop to break*. Your task is to trace all `Shield Layer` and `Reinforcement` messages, the `Total Reinforcements Applied`, and the `Final Status`.",
      "story_context": "The Pathfinder's automated shield system needs to activate shield layers using nested for loops with continue and break statements. Your task is to trace the loop execution and predict the outputs.",
      "challenge_data": {
        "code": "public class AutomatedShield {\n    public static void main(String[] args) {\n        int totalReinforcementsApplied = 0;\n        String finalStatus = \"Optimal\";\n\n        for (int shieldLayer = 1; shieldLayer <= 2; shieldLayer++) {\n            System.out.println(\"Activating Shield Layer: \" + shieldLayer);\n            for (int reinforcementCycle = 1; reinforcementCycle <= 2; reinforcementCycle++) {\n                if (shieldLayer == 1 && reinforcementCycle == 1) {\n                    System.out.println(\"  REINFORCEMENT SKIPPED for Layer \" + shieldLayer + \", Cycle \" + reinforcementCycle);\n                    reinforcementCycle++; // Effectively advances by 1 more\n                    totalReinforcementsApplied++; // This counts as an attempted reinforcement\n                    continue;\n                }\n                if (shieldLayer == 2 && reinforcementCycle == 2) {\n                    finalStatus = \"PARTIAL FAILURE\";\n                    System.out.println(\"  FAILURE: Reinforcement failed at Layer \" + shieldLayer + \", Cycle \" + reinforcementCycle + \".\");\n                    totalReinforcementsApplied++; // This counts as an attempted reinforcement\n                    break; // Break inner loop\n                }\n                System.out.println(\"  Reinforcement Cycle: \" + reinforcementCycle + \" OK.\");\n                totalReinforcementsApplied++;\n            }\n        }\n        System.out.println(\"\\nTotal Reinforcements Applied: \" + totalReinforcementsApplied);\n        System.out.println(\"Final Status: \" + finalStatus);\n    }\n}",
        "expected_output": [
          "Activating Shield Layer: 1\\n  REINFORCEMENT SKIPPED for Layer 1, Cycle 1\\n  Reinforcement Cycle: 2 OK.\\nActivating Shield Layer: 2\\n  Reinforcement Cycle: 1 OK.\\n  FAILURE: Reinforcement failed at Layer 2, Cycle 2.",
          "Total Reinforcements Applied: 5",
          "Final Status: PARTIAL FAILURE"
        ],
        "choices": [
          "Activating Shield Layer: 1\\n  REINFORCEMENT SKIPPED for Layer 1, Cycle 1\\n  Reinforcement Cycle: 2 OK.\\nActivating Shield Layer: 2\\n  Reinforcement Cycle: 1 OK.\\n  FAILURE: Reinforcement failed at Layer 2, Cycle 3.",
          "Total Reinforcements Applied: 50",
          "Final Status: Optimal",
          "Final Status: PARTIAL FAILURE",
          "Activating Shield Layer: 1\\n  REINFORCEMENT SKIPPED for Layer 1, Cycle 1\\n  Reinforcement Cycle: 2 OK.\\nActivating Shield Layer: 2\\n  Reinforcement Cycle: 1 OK.\\n  FAILURE: Reinforcement failed at Layer 2, Cycle 2.",
          "Total Reinforcements Applied: 5"
        ],
        "explanation": "1. `shieldLayer = 1` (Outer loop):\n    * Prints \"Activating Shield Layer: 1\".\n    * `reinforcementCycle = 1`: `shieldLayer == 1 && reinforcementCycle == 1` is `true`. Prints \"  REINFORCEMENT SKIPPED...\". `reinforcementCycle` becomes 2. `totalReinforcementsApplied` is 1. `continue` skips.\n    * `reinforcementCycle = 2`: Prints \"  Reinforcement Cycle: 2 OK.\". `totalReinforcementsApplied` is 2. \n2. `shieldLayer = 2` (Outer loop):\n    * Prints \"Activating Shield Layer: 2\".\n    * `reinforcementCycle = 1`: Prints \"  Reinforcement Cycle: 1 OK.\". `totalReinforcementsApplied` is 3.\n    * `reinforcementCycle = 2`: `shieldLayer == 2 && reinforcementCycle == 2` is `true`. `finalStatus` becomes \"PARTIAL FAILURE\". Prints \"  FAILURE: Reinforcement failed...\". `totalReinforcementsApplied` is 4. `break` exits inner loop.\n3. After loops: `System.out.println(\"\\nTotal Reinforcements Applied: \" + totalReinforcementsApplied);` prints \"Total Reinforcements Applied: 4\". `System.out.println(\"Final Status: \" + finalStatus);` prints \"Final Status: PARTIAL FAILURE\"."
      },
      "hints": {
        "1": "Trace the nested loops carefully, especially how `reinforcementCycle` is incremented in the `continue` block.",
        "2": "The `continue` statement skips the rest of the current inner loop iteration.",
        "3": "The `break` statement exits only the *inner* loop, allowing the outer loop to proceed to its next iteration."
      }
    },
    {
      "id": 375,
      "subtopic_id": 9,
      "type": "output_tracing",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinder's `communicationProtocol` performs `signalTests` across `frequencyBands`. An outer `for` loop iterates `frequencyBand`s (0 to 1). An inner `for` loop performs `testIteration`s (0 to 2). If `frequencyBand` is `0` and `testIteration` is `0`, a 'CALIBRATING' message is logged, and the `testIteration` effectively jumps to `2`. If `frequencyBand` is `1` and `testIteration` is `1`, a 'LINK ESTABLISHED' message is logged, and the *entire program terminates early*. Your task is to trace all messages, the `Total Tests Run`, and the `Final Protocol State`.",
      "story_context": "The Pathfinder's communication protocol needs to perform signal tests using nested for loops with continue and return statements. Your task is to trace the loop execution and predict the outputs.",
      "challenge_data": {
        "code": "public class CommunicationProtocol {\n    public static void main(String[] args) {\n        int totalTestsRun = 0;\n        String finalProtocolState = \"Pending\";\n\n        for (int frequencyBand = 0; frequencyBand < 2; frequencyBand++) {\n            System.out.println(\"Testing Frequency Band: \" + frequencyBand);\n            for (int testIteration = 0; testIteration < 3; testIteration++) {\n                if (frequencyBand == 0 && testIteration == 0) {\n                    System.out.println(\"  CALIBRATING: Skipping initial tests for Band \" + frequencyBand);\n                    testIteration = 2; // Jump to end of inner loop for this iteration\n                    totalTestsRun++;\n                    continue;\n                }\n                if (frequencyBand == 1 && testIteration == 1) {\n                    finalProtocolState = \"Link Established\";\n                    System.out.println(\"  LINK ESTABLISHED at Band \" + frequencyBand + \", Iteration \" + testIteration + \"! Mission Success.\");\n                    totalTestsRun++;\n                    return; // Terminate main method (program)\n                }\n                System.out.println(\"  Running Test Iteration: \" + testIteration + \" OK.\");\n                totalTestsRun++;\n            }\n        }\n        System.out.println(\"\\nTotal Tests Run: \" + totalTestsRun);\n        System.out.println(\"Final Protocol State: \" + finalProtocolState);\n    }\n}",
        "expected_output": [
          "Testing Frequency Band: 0\\n  CALIBRATING: Skipping initial tests for Band 0\\n  Running Test Iteration: 2 OK.\\nTesting Frequency Band: 1\\n  Running Test Iteration: 0 OK.\\n  LINK ESTABLISHED at Band 1, Iteration 1! Mission Success.",
          "Total Tests Run: 5",
          "Final Protocol State: Link Established"
        ],
        "choices": [
          "Testing Frequency Band: 0\\n  CALIBRATING: Skipping initial tests for Band 0\\n  Running Test Iteration: 2 OK.\\nTesting Frequency Band: 1\\n  Running Test Iteration: 0 OK.\\n  LINK ESTABLISHED at Band 1, Iteration 1! Mission Success.",
          "Total Tests Run: 5",
          "Final Protocol State: Pending",
          "Final Protocol State: Link Established",
          "Testing Frequency Band: 0\\n  CALIBRATING: Skipping initial tests for Band 0\\n  Running Test Iteration: 2 OK.\\nTesting Frequency Band: 1\\n  Running Test Iteration: 0 OK.\\n  LINK ESTABLISHED at Band 1, Iteration 11! Mission Success.",
          "Total Tests Run: 05"
        ],
        "explanation": "1. `frequencyBand = 0` (Outer loop):\n    * Prints \"Testing Frequency Band: 0\".\n    * `testIteration = 0`: `frequencyBand == 0 && testIteration == 0` is `true`. Prints \"  CALIBRATING...\". `testIteration` becomes 2. `totalTestsRun` is 1. `continue` skips.\n    * `testIteration = 2`: Prints \"  Running Test Iteration: 2 OK.\". `totalTestsRun` is 2.\n2. `frequencyBand = 1` (Outer loop):\n    * Prints \"Testing Frequency Band: 1\".\n    * `testIteration = 0`: Prints \"  Running Test Iteration: 0 OK.\". `totalTestsRun` is 3.\n    * `testIteration = 1`: `frequencyBand == 1 && testIteration == 1` is `true`. `finalProtocolState` becomes \"Link Established\". Prints \"  LINK ESTABLISHED...\". `totalTestsRun` is 4. `return` (program terminates).\n3. The final `System.out.println` statements outside the loops are not executed due to `return`."
      },
      "hints": {
        "1": "Carefully trace `testIteration` when it's manually advanced using `testIteration = 2` within the `continue` block.",
        "2": "A `continue` statement skips the rest of the current inner loop iteration.",
        "3": "A `return` statement immediately exits the `main` method, stopping all further program execution."
      }
    },
    {
      "id": 376,
      "subtopic_id": 9,
      "type": "code_fixer",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinder's `systemBootSequence` uses a `for` loop to initialize components. However, the loop has a syntax error in its header, as a semicolon is missing. Fix the code to ensure the `for` loop is grammatically correct.",
      "story_context": "The BootSequenceFixer needs to initialize system components. Your task is to fix the for loop syntax.",
      "challenge_data": {
        "initial_code": "public class BootSequenceFixer {\n    public static void main(String[] args) {\n        for (int step = 1; step <= 3 step++) { \n            System.out.println(\"Boot step \" + step + \" complete.\");\n        }\n    }\n}",
        "expected_output": [
          "Boot step 1 complete.\\nBoot step 2 complete.\\nBoot step 3 complete."
        ],
        "solution_code": "public class BootSequenceFixer {\n    public static void main(String[] args) {\n        for (int step = 1; step <= 3; step++) { \n            System.out.println(\"Boot step \" + step + \" complete.\");\n        }\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 3,
            "type": "syntax_error",
            "description": "Missing semicolon in for loop header",
            "fix": "Add semicolon between condition and increment: step <= 3; step++"
          }
        ],
        "number_of_errors": 1,
        "explanation": "A `for` loop header requires semicolons (`;`) to separate its three components: initialization, termination condition, and increment/decrement. The original code is missing a semicolon between `step <= 3` and `step++`. Adding the semicolon correctly fixes the syntax."
      },
      "hints": {
        "1": "A `for` loop header has three distinct parts, separated by a specific punctuation mark.",
        "2": "Look at the structure inside the parentheses `(...)`.",
        "3": "A specific punctuation mark is missing between the `termination` and `increment` sections."
      }
    },
    {
      "id": 377,
      "subtopic_id": 9,
      "type": "code_fixer",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinder's `cargoManifest` system uses an enhanced `for` loop to print `itemNames`. However, the array is incorrectly declared with misplaced square brackets, preventing the loop from running. Fix the code to correctly declare the array.",
      "story_context": "The CargoScannerFixer needs to scan cargo items. Your task is to fix the array declaration syntax.",
      "challenge_data": {
        "initial_code": "public class CargoScannerFixer {\n    public static void main(String[] args) {\n        String cargoManifest[] = {\"Food\", \"Water\", \"Tools\"}; \n        for (String item : cargoManifest) {\n            System.out.println(\"Scanning: \" + item);\n        }\n    }\n}",
        "expected_output": [
          "Scanning: Food\\nScanning: Water\\nScanning: Tools"
        ],
        "solution_code": "public class CargoScannerFixer {\n    public static void main(String[] args) {\n        String[] cargoManifest = {\"Food\", \"Water\", \"Tools\"}; \n        for (String item : cargoManifest) {\n            System.out.println(\"Scanning: \" + item);\n        }\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 3,
            "type": "array_declaration",
            "description": "Incorrect array declaration syntax",
            "fix": "Move brackets after data type: String[] cargoManifest"
          }
        ],
        "number_of_errors": 1,
        "explanation": "The original code `String cargoManifest[]` uses a C-style array declaration syntax where the `[]` are after the variable name. While technically allowed in Java for backward compatibility, the preferred and more common syntax is to place the `[]` immediately after the data type (`String[] cargoManifest`). This clarifies that the variable `cargoManifest` is an array of `String`s. Using the standard syntax makes the code clearer and ensures proper interpretation by the compiler."
      },
      "hints": {
        "1": "For array variable declarations, the square brackets `[]` typically go after the data type (`String[]`), not after the variable name.",
        "2": "The original code might compile but not work as an array or might cause an immediate compilation error depending on Java version/context.",
        "3": "The blank implies a missing opening parenthesis for a condition."
      }
    },
    {
      "id": 378,
      "subtopic_id": 9,
      "type": "code_fixer",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinder's `dataUpload` system uses a `for` loop to send `packets`. The loop's body is not properly enclosed with curly braces, which is poor practice and can lead to logical errors. Fix the code to enclose the loop's body in braces.",
      "story_context": "The DataUploaderFixer needs to upload data packets. Your task is to add curly braces to the for loop body.",
      "challenge_data": {
        "initial_code": "public class DataUploaderFixer {\n    public static void main(String[] args) {\n        for (int i = 0; i < 2; i++)\n            System.out.println(\"Uploading packet \" + i);\n        System.out.println(\"Upload complete.\");\n    }\n}",
        "expected_output": [
          "Uploading packet 0\\nUploading packet 1\\nUpload complete."
        ],
        "solution_code": "public class DataUploaderFixer {\n    public static void main(String[] args) {\n        for (int i = 0; i < 2; i++) {\n            System.out.println(\"Uploading packet \" + i);\n        }\n        System.out.println(\"Upload complete.\");\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 3,
            "type": "loop_braces",
            "description": "Missing curly braces around for loop body",
            "fix": "Add curly braces around the loop body: { System.out.println(...); }"
          }
        ],
        "number_of_errors": 1,
        "explanation": "In Java, if a loop (or conditional statement) body consists of more than one statement, it *must* be enclosed in curly braces `{}`. Even for a single statement, it's best practice. Without braces, only the first statement immediately following the `for` loop header (`System.out.println(\"Uploading packet \" + i);`) is considered part of the loop. The `System.out.println(\"Upload complete.\");` then executes *after* the loop, but only once. The fix is to add curly braces around the statement(s) intended for the loop body."
      },
      "hints": {
        "1": "A `for` loop executes the statement immediately following its header.",
        "2": "If you want multiple statements to be part of the loop's repeated actions, they must be grouped together.",
        "3": "Curly braces `{}` are used to define a block of code to be executed together."
      }
    },
    {
      "id": 379,
      "subtopic_id": 9,
      "type": "code_fixer",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinder's `componentScanner` is supposed to scan `componentID`s starting from `1` up to `3`. The current `for` loop initializes `componentID` incorrectly, causing it to start from `0`. Fix the initialization part of the `for` loop.",
      "story_context": "The ComponentScannerFixer needs to scan system components. Your task is to fix the for loop initialization.",
      "challenge_data": {
        "initial_code": "public class ComponentScannerFixer {\n    public static void main(String[] args) {\n        for (int componentID = 0; componentID <= 3; componentID++) {\n            System.out.println(\"Scanning Component: \" + componentID);\n        }\n    }\n}",
        "expected_output": [
          "Scanning Component: 1\\nScanning Component: 2\\nScanning Component: 3"
        ],
        "solution_code": "public class ComponentScannerFixer {\n    public static void main(String[] args) {\n        for (int componentID = 1; componentID <= 3; componentID++) {\n            System.out.println(\"Scanning Component: \" + componentID);\n        }\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 3,
            "type": "loop_initialization",
            "description": "Wrong initialization value in for loop",
            "fix": "Change initialization to: int componentID = 1"
          }
        ],
        "number_of_errors": 1,
        "explanation": "The original `for` loop initializes `componentID` to `0` (`int componentID = 0;`). The requirement is to scan components from `1` to `3`. The fix is to change the initialization of `componentID` from `0` to `1`. This makes the loop start printing from `1` and continue up to `3`."
      },
      "hints": {
        "1": "The first part of the `for` loop header is for initialization.",
        "2": "The goal is to start scanning from `componentID = 1`.",
        "3": "Modify the value assigned to `componentID` at the start of the loop."
      }
    },
    {
      "id": 380,
      "subtopic_id": 9,
      "type": "code_fixer",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinder's `dataPacketBurst` system sends `packets` with increasing `packetID`s. The `for` loop's update section is faulty, causing the loop to run indefinitely. Fix the `for` loop header to correctly increment `packetID` and terminate after 3 packets (IDs 1, 2, 3).",
      "story_context": "The PacketBurstFixer needs to send data packets. Your task is to fix the for loop increment.",
      "challenge_data": {
        "initial_code": "public class PacketBurstFixer {\n    public static void main(String[] args) {\n        for (int packetID = 1; packetID <= 3;) { \n            System.out.println(\"Sending Packet ID: \" + packetID);\n        }\n    }\n}",
        "expected_output": [
          "Sending Packet ID: 1\\nSending Packet ID: 2\\nSending Packet ID: 3"
        ],
        "solution_code": "public class PacketBurstFixer {\n    public static void main(String[] args) {\n        for (int packetID = 1; packetID <= 3; packetID++) { \n            System.out.println(\"Sending Packet ID: \" + packetID);\n        }\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 3,
            "type": "loop_increment",
            "description": "Missing increment expression in for loop",
            "fix": "Add increment: packetID++ in the third part of for loop header"
          }
        ],
        "number_of_errors": 1,
        "explanation": "The original `for` loop is missing its `increment` expression (`packetID++`) in the header. As a result, `packetID` remains `1`, and the condition `packetID <= 3` is always `true`, leading to an infinite loop. The fix is to add `packetID++` in the update section, ensuring `packetID` increases in each iteration, allowing the loop to correctly send 3 packets and terminate."
      },
      "hints": {
        "1": "An infinite loop in a `for` loop usually means the loop variable is not changing in a way that satisfies the termination condition.",
        "2": "The third part of the `for` loop header is for updating the loop variable.",
        "3": "The blank implies a missing increment operator."
      }
    },
    {
      "id": 381,
      "subtopic_id": 9,
      "type": "code_fixer",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinder's `planetaryScan` system uses a `for` loop that iterates `scanZones` from 1 to 2, and `dataPoints` from 1 to 3. The code has a `continue` statement that is incorrectly placed or conditioned, causing some valid data points to be missed from the output. Fix the code to ensure all data points (1, 2, 3) are logged per zone.",
      "story_context": "The PlanetaryScanFixer needs to scan planetary zones. Your task is to fix the continue statement condition.",
      "challenge_data": {
        "initial_code": "public class PlanetaryScanFixer {\n    public static void main(String[] args) {\n        for (int scanZone = 1; scanZone <= 2; scanZone++) {\n            System.out.println(\"Scanning Zone: \" + scanZone);\n            for (int dataPoint = 1; dataPoint <= 3; dataPoint++) {\n                if (dataPoint == 2) { \n                    continue;\n                }\n                System.out.println(\"  Collecting data point: \" + dataPoint);\n            }\n        }\n    }\n}",
        "expected_output": [
          "Scanning Zone: 1\\n  Collecting data point: 1\\n  Collecting data point: 2\\n  Collecting data point: 3\\nScanning Zone: 2\\n  Collecting data point: 1\\n  Collecting data point: 2\\n  Collecting data point: 3"
        ],
        "solution_code": "public class PlanetaryScanFixer {\n    public static void main(String[] args) {\n        for (int scanZone = 1; scanZone <= 2; scanZone++) {\n            System.out.println(\"Scanning Zone: \" + scanZone);\n            for (int dataPoint = 1; dataPoint <= 3; dataPoint++) {\n                if (dataPoint == 100) { \n                    continue;\n                }\n                System.out.println(\"  Collecting data point: \" + dataPoint);\n            }\n        }\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 7,
            "type": "continue_condition",
            "description": "Wrong condition in continue statement",
            "fix": "Change condition to: if (dataPoint == 100) or remove continue entirely"
          }
        ],
        "number_of_errors": 1,
        "explanation": "The original code incorrectly used `if (dataPoint == 2) { continue; }`, which caused `dataPoint 2` to be skipped from the log. The intent was to log all points. The fix is to change the `continue` condition to something that is not normally met (e.g., `dataPoint == 100`) or remove the `continue` statement entirely if no skipping is desired. This ensures \"Collecting data point: 2\" is always printed."
      },
      "hints": {
        "1": "The `continue` statement skips the rest of the *current iteration* of the loop.",
        "2": "The goal is to ensure *all* data points (1, 2, 3) are logged.",
        "3": "Adjust the `continue` condition so it doesn't interfere with normal logging."
      }
    },
    {
      "id": 382,
      "subtopic_id": 9,
      "type": "code_fixer",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinder's `emergencyProtocol` runs `steps` in a `for` loop. The loop is designed to log each `step` and `break` only if a critical `errorDetected` is `true`. However, the current code's `break` condition is too broad (`step == 3` always triggers it), causing the loop to terminate prematurely. Fix the code to ensure the `break` only triggers under a truly critical condition.",
      "story_context": "The EmergencyProtocolTerminator needs to run emergency protocols. Your task is to fix the break condition.",
      "challenge_data": {
        "initial_code": "public class EmergencyProtocolTerminator {\n    public static void main(String[] args) {\n        boolean errorDetected = false;\n        for (int step = 1; step <= 5; step++) {\n            System.out.println(\"Protocol Step: \" + step);\n            if (step == 3 || errorDetected) { \n                System.out.println(\"  CRITICAL: Aborting protocol due to error.\");\n                break;\n            }\n        }\n        System.out.println(\"Protocol Status: Completed.\");\n    }\n}",
        "expected_output": [
          "Protocol Step: 1\\nProtocol Step: 2\\nProtocol Step: 3\\nProtocol Step: 4\\nProtocol Step: 5\\nProtocol Status: Completed."
        ],
        "solution_code": "public class EmergencyProtocolTerminator {\n    public static void main(String[] args) {\n        boolean errorDetected = false;\n        for (int step = 1; step <= 5; step++) {\n            System.out.println(\"Protocol Step: \" + step);\n            if (errorDetected) { \n                System.out.println(\"  CRITICAL: Aborting protocol due to error.\");\n                break;\n            }\n        }\n        System.out.println(\"Protocol Status: Completed.\");\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 7,
            "type": "break_condition",
            "description": "Wrong condition in break statement",
            "fix": "Remove step == 3 from condition: if (errorDetected)"
          }
        ],
        "number_of_errors": 1,
        "explanation": "The original code's `if (step == 3 || errorDetected)` statement caused the `for` loop to terminate prematurely when `step` was `3`. The `step == 3` part of the condition was too broad and triggered an early `break`. The fix is to remove `step == 3` from the `if` condition, ensuring the loop only breaks if `errorDetected` becomes `true` (which it doesn't in this snippet, so the loop runs to completion)."
      },
      "hints": {
        "1": "The `break` statement immediately exits the entire loop.",
        "2": "The goal is for the loop to complete all 5 steps unless `errorDetected` is `true`.",
        "3": "Adjust the `if` condition for `break` so it's only met for a genuinely critical error."
      }
    },
    {
      "id": 383,
      "subtopic_id": 9,
      "type": "code_fixer",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinder's `arrayScan` iterates through a `sensorDataArray`. The loop's update section (`i = i + 0`) is incorrect, causing an infinite loop. Fix the loop to correctly iterate through all elements of `sensorDataArray` from beginning to end.",
      "story_context": "The ArrayScanFixer needs to scan sensor data arrays. Your task is to fix the loop increment.",
      "challenge_data": {
        "initial_code": "public class ArrayScanFixer {\n    public static void main(String[] args) {\n        double[] sensorDataArray = {10.5, 20.2, 30.8, 40.1};\n        for (int i = 0; i < sensorDataArray.length; i = i + 0) { \n            System.out.println(\"Reading sensor data at index: \" + i + \" = \" + sensorDataArray[i]);\n        }\n    }\n}",
        "expected_output": [
          "Reading sensor data at index: 0 = 10.5\\nReading sensor data at index: 1 = 20.2\\nReading sensor data at index: 2 = 30.8\\nReading sensor data at index: 3 = 40.1"
        ],
        "solution_code": "public class ArrayScanFixer {\n    public static void main(String[] args) {\n        double[] sensorDataArray = {10.5, 20.2, 30.8, 40.1};\n        for (int i = 0; i < sensorDataArray.length; i++) { \n            System.out.println(\"Reading sensor data at index: \" + i + \" = \" + sensorDataArray[i]);\n        }\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 4,
            "type": "loop_increment",
            "description": "Incorrect increment expression causing infinite loop",
            "fix": "Change increment to: i++ or i = i + 1"
          }
        ],
        "number_of_errors": 1,
        "explanation": "The original `for` loop's update section was `i = i + 0`. This expression always evaluates to `i` itself, effectively never changing the value of `i`. As a result, `i` remains `0`, and the loop condition `i < sensorDataArray.length` is always `true` (assuming `sensorDataArray.length` is greater than 0), leading to an infinite loop. The fix is to change the update expression to `i++` (or `i = i + 1`), which correctly increments `i` by 1 in each iteration, allowing the loop to process all array elements and terminate."
      },
      "hints": {
        "1": "A `for` loop's `increment` section is responsible for moving to the next iteration.",
        "2": "If the increment doesn't change the loop variable, it can lead to an infinite loop.",
        "3": "The expression `i = i + 0` is essentially `i = i`, which doesn't change `i`."
      }
    },
    {
      "id": 384,
      "subtopic_id": 9,
      "type": "code_fixer",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinder's `missionLog` filters `eventCodes` using an enhanced `for` loop. The code incorrectly uses `break` to skip non-critical events, causing premature loop termination. Fix the code to correctly *skip* non-critical events and display only critical ones.",
      "story_context": "The MissionLogFilterFixer needs to filter mission events. Your task is to fix the loop control statement.",
      "challenge_data": {
        "initial_code": "public class MissionLogFilterFixer {\n    public static void main(String[] args) {\n        int[] missionLog = {100, 500, 250, 600, 400};\n        for (int eventCode : missionLog) {\n            if (eventCode < 500) {\n                break; \n            }\n            System.out.println(\"Critical Event: \" + eventCode);\n        }\n    }\n}",
        "expected_output": [
          "Critical Event: 500\\nCritical Event: 600"
        ],
        "solution_code": "public class MissionLogFilterFixer {\n    public static void main(String[] args) {\n        int[] missionLog = {100, 500, 250, 600, 400};\n        for (int eventCode : missionLog) {\n            if (eventCode < 500) {\n                continue; \n            }\n            System.out.println(\"Critical Event: \" + eventCode);\n        }\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 6,
            "type": "loop_control",
            "description": "Using break instead of continue to skip non-critical events",
            "fix": "Change break to continue: if (eventCode < 500) { continue; }"
          }
        ],
        "number_of_errors": 1,
              "explanation": "The original code uses `break` to skip non-critical events, but `break` terminates the entire loop immediately. This causes the loop to exit after encountering the first non-critical event (100), preventing the processing of subsequent critical events (500, 600). The fix is to use `continue` instead, which skips only the current iteration and continues with the next element, allowing all critical events to be processed."
      },
      "hints": {
        "1": "The `break` statement exits the entire loop immediately.",
        "2": "The `continue` statement skips only the current iteration.",
        "3": "To filter events, you want to skip some but continue processing others."
      }
    },
    {
      "id": 385,
      "subtopic_id": 9,
      "type": "code_fixer",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinder's `payloadScanner` inspects `cargoWeight` entries using nested `for` loops. The code has logic flaws (incorrect conditions or variable updates) causing it to incorrectly report \"Scan Complete\" when a critical payload (weight > 150) should abort the scan. Fix the code to correctly detect and report an aborted scan.",
      "story_context": "The PayloadScannerFixer needs to scan cargo payloads. Your task is to fix the nested loop logic and flag management.",
      "challenge_data": {
        "initial_code": "public class PayloadScannerFixer {\n    public static void main(String[] args) {\n        int criticalThreshold = 100;\n        boolean scanAborted = false;\n        \n        for (int scanCycle = 0; scanCycle < 2; scanCycle++) {\n            System.out.println(\"Starting Scan Cycle: \" + scanCycle);\n            for (int payloadItem = 0; payloadItem < 3; payloadItem++) {\n                int itemWeight = 50 + (payloadItem * 30);\n                if (itemWeight < criticalThreshold) { \n                    System.out.println(\"  CRITICAL PAYLOAD DETECTED: \" + itemWeight + \"kg. Aborting scan.\");\n                    break;\n                }\n                System.out.println(\"  Checking Item: \" + payloadItem + \", Weight: \" + itemWeight);\n            }\n        }\n        \n        if (scanAborted) {\n            System.out.println(\"Scan Status: Scan Aborted.\");\n        } else {\n            System.out.println(\"Scan Status: Scan Complete.\");\n        }\n    }\n}",
        "expected_output": [
          "Starting Scan Cycle: 0\\n  Checking Item: 0, Weight: 50\\n  Checking Item: 1, Weight: 80\\n  CRITICAL PAYLOAD DETECTED: 110kg. Aborting scan.\\nScan Status: Scan Aborted."
        ],
        "solution_code": "public class PayloadScannerFixer {\n    public static void main(String[] args) {\n        int criticalThreshold = 100;\n        boolean scanAborted = false;\n        \n        for (int scanCycle = 0; scanCycle < 2; scanCycle++) {\n            System.out.println(\"Starting Scan Cycle: \" + scanCycle);\n            for (int payloadItem = 0; payloadItem < 3; payloadItem++) {\n                int itemWeight = 50 + (payloadItem * 30);\n                if (itemWeight > criticalThreshold) { \n                    System.out.println(\"  CRITICAL PAYLOAD DETECTED: \" + itemWeight + \"kg. Aborting scan.\");\n                    scanAborted = true;\n                    break;\n                }\n                System.out.println(\"  Checking Item: \" + payloadItem + \", Weight: \" + itemWeight);\n            }\n            if (scanAborted) {\n                break;\n            }\n        }\n        \n        if (scanAborted) {\n            System.out.println(\"Scan Status: Scan Aborted.\");\n        } else {\n            System.out.println(\"Scan Status: Scan Complete.\");\n        }\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 8,
            "type": "break_condition",
            "description": "Wrong condition for critical payload detection",
            "fix": "Change condition to: if (itemWeight > criticalThreshold)"
          },
          {
            "id": 2,
            "line": 10,
            "type": "flag_management",
            "description": "Missing scanAborted flag update",
            "fix": "Add scanAborted = true; before break statement"
          },
          {
            "id": 3,
            "line": 18,
            "type": "outer_loop_control",
            "description": "Missing outer loop termination check",
            "fix": "Add if (scanAborted) { break; } after inner loop"
          }
        ],
        "number_of_errors": 3,
        "explanation": "The original code has several flaws:\n1.  **Incorrect `break` condition:** `if (itemWeight < criticalThreshold)` incorrectly breaks the inner loop if the weight is *below* threshold, when it should break if `itemWeight` is *above* it. This would cause early breaks for normal items.\n2.  **Missing `scanAborted` flag update:** The `scanAborted` boolean is never set to `true` inside the loop, so the final `if (scanAborted)` always evaluates to `false`.\n3.  **No outer loop termination:** Even if `scanAborted` were set correctly, breaking the inner loop only exits that loop; the outer loop would continue to the next `scanCycle`.\n\nThe fix addresses these:\n1.  Changes `itemWeight < criticalThreshold` to `itemWeight > criticalThreshold` for the `break` condition.\n2.  Adds `scanAborted = true;` inside the `break` block of the inner loop.\n3.  Adds an `if (scanAborted) { break; }` check *after* the inner loop completes (but still within the outer loop's body) to ensure the outer loop also terminates when a critical payload is found. This correctly sets the `scanAborted` flag and allows the final status message to reflect an aborted scan."
      },
      "hints": {
        "1": "The `break` statement in the inner loop exits *only* the inner loop. If an outer loop also needs to stop, an additional check or `break` is needed in the outer loop's body.",
        "2": "The critical condition for breaking the loop is `itemWeight > criticalThreshold`.",
        "3": "The `scanAborted` flag needs to be set to `true` when the critical condition is met."
      }
    },
    {
      "id": 386,
      "subtopic_id": 9,
      "type": "code_fixer",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinder's `systemDeployment` involves multiple stages and sub-routines using nested `for` loops. A `WARNING` is logged for specific anomalies, and a `CRITICAL FAILURE` (breaking both loops) occurs under other conditions. The code has flaws in its nested loop control flow. Fix the code to ensure correct warning and critical failure triggers, including properly breaking both inner and outer loops.",
      "story_context": "The SystemDeployment needs to deploy system stages. Your task is to fix the nested loop control flow.",
      "challenge_data": {
        "initial_code": "public class SystemDeployment {\n    public static void main(String[] args) {\n        boolean criticalErrorDetected = false;\n        \n        for (int systemStage = 0; systemStage < 2; systemStage++) {\n            System.out.println(\"Deploying Stage: \" + systemStage);\n            for (int routineCheck = 0; routineCheck < 3; routineCheck++) {\n                System.out.println(\"  Running Routine Check: \" + routineCheck);\n                \n                if (systemStage == 0 && routineCheck == 1) {\n                    System.out.println(\"  WARNING: Minor anomaly detected.\");\n                } else if (systemStage == 1 && routineCheck == 0) {\n                    criticalErrorDetected = true;\n                    System.out.println(\"  CRITICAL FAILURE: Aborting deployment!\");\n                    break;\n                }\n            }\n        }\n        \n        if (criticalErrorDetected) {\n            System.out.println(\"\\nDeployment Aborted due to critical error.\");\n        } else {\n            System.out.println(\"\\nDeployment completed successfully.\");\n        }\n    }\n}",
        "expected_output": [
          "Deploying Stage: 0\\n  Running Routine Check: 0\\n  Running Routine Check: 1\\n  WARNING: Minor anomaly detected.\\n  Running Routine Check: 2\\nDeploying Stage: 1\\n  Running Routine Check: 0\\n  CRITICAL FAILURE: Aborting deployment!\\n\\nDeployment Aborted due to critical error."
        ],
        "solution_code": "public class SystemDeployment {\n    public static void main(String[] args) {\n        boolean criticalErrorDetected = false;\n        \n        for (int systemStage = 0; systemStage < 2; systemStage++) {\n            System.out.println(\"Deploying Stage: \" + systemStage);\n            for (int routineCheck = 0; routineCheck < 3; routineCheck++) {\n                System.out.println(\"  Running Routine Check: \" + routineCheck);\n                \n                if (systemStage == 0 && routineCheck == 1) {\n                    System.out.println(\"  WARNING: Minor anomaly detected.\");\n                } else if (systemStage == 1 && routineCheck == 0) {\n                    criticalErrorDetected = true;\n                    System.out.println(\"  CRITICAL FAILURE: Aborting deployment!\");\n                    break;\n                }\n            }\n            if (criticalErrorDetected) {\n                break;\n            }\n        }\n        \n        if (criticalErrorDetected) {\n            System.out.println(\"\\nDeployment Aborted due to critical error.\");\n        } else {\n            System.out.println(\"\\nDeployment completed successfully.\");\n        }\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 18,
            "type": "outer_loop_control",
            "description": "Missing outer loop termination check",
            "fix": "Add if (criticalErrorDetected) { break; } after inner loop"
          }
        ],
        "number_of_errors": 1,
        "explanation": "The original code had correct `if-else if` logic for warnings and critical failures within the inner loop. The `criticalErrorDetected` flag was also correctly set. The missing pieces were ensuring the outer loop also terminates. The fix adds an `if (criticalErrorDetected) { break; }` check immediately after the inner loop. This ensures that if a critical error caused the inner loop to `break`, the outer loop also `breaks`, leading to an overall `Deployment Aborted` status."
      },
      "hints": {
        "1": "The `break` statement only exits the *innermost* loop it is in. To exit an outer loop, a mechanism like a flag and an outer `break` is needed.",
        "2": "Identify where the outer loop needs to check if the inner loop caused an abort.",
        "3": "Ensure the `criticalErrorDetected` flag is set correctly and then checked in the appropriate place in the outer loop."
      }
    },
    {
      "id": 387,
      "subtopic_id": 9,
      "type": "code_fixer",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinder's `repairDrone` performs `repairCycles` across `damageZones` using nested `for` loops. The drone can `skip` analysis for problematic attempts or `break` the current zone's repair on critical failure. The current code has issues that prevent the correct skipping and breaking behavior. Fix the code to ensure `skippedAttempts` increment correctly and `abortedZones` are tracked when inner loops `break`.",
      "story_context": "The RepairDroneControl needs to manage repair operations. Your task is to fix the loop control and counter management.",
      "challenge_data": {
        "initial_code": "public class RepairDroneControl {\n    public static void main(String[] args) {\n        int skippedAttempts = 0;\n        int abortedZones = 0;\n        \n        for (int damageZone = 1; damageZone <= 2; damageZone++) {\n            System.out.println(\"Processing Damage Zone: \" + damageZone);\n            for (int repairAttempt = 1; repairAttempt <= 3; repairAttempt++) {\n                if (repairAttempt == 2 && damageZone == 1) {\n                    System.out.println(\"  Skipping problematic attempt \" + repairAttempt + \" in Zone \" + damageZone);\n                    continue;\n                }\n                if (repairAttempt == 3) {\n                    System.out.println(\"  CRITICAL FAILURE: Aborting attempts in Zone \" + damageZone);\n                    break;\n                }\n                System.out.println(\"  Repair attempt \" + repairAttempt + \" in Zone \" + damageZone + \" OK.\");\n            }\n        }\n        System.out.println(\"\\nTotal Skipped Attempts: \" + skippedAttempts);\n        System.out.println(\"Total Aborted Zones: \" + abortedZones);\n    }\n}",
        "expected_output": [
          "Processing Damage Zone: 1\\n  Repair attempt 1 in Zone 1 OK.\\n  Skipping problematic attempt 2 in Zone 1\\n  CRITICAL FAILURE: Aborting attempts in Zone 1.\\nProcessing Damage Zone: 2\\n  Repair attempt 1 in Zone 2 OK.\\n  Repair attempt 2 in Zone 2 OK.\\n  CRITICAL FAILURE: Aborting attempts in Zone 2.\\n\\nTotal Skipped Attempts: 1\\nTotal Aborted Zones: 2"
        ],
        "solution_code": "public class RepairDroneControl {\n    public static void main(String[] args) {\n        int skippedAttempts = 0;\n        int abortedZones = 0;\n        \n        for (int damageZone = 1; damageZone <= 2; damageZone++) {\n            System.out.println(\"Processing Damage Zone: \" + damageZone);\n            for (int repairAttempt = 1; repairAttempt <= 3; repairAttempt++) {\n                if (repairAttempt == 2 && damageZone == 1) {\n                    System.out.println(\"  Skipping problematic attempt \" + repairAttempt + \" in Zone \" + damageZone);\n                    skippedAttempts++;\n                    continue;\n                }\n                if (repairAttempt == 3) {\n                    System.out.println(\"  CRITICAL FAILURE: Aborting attempts in Zone \" + damageZone);\n                    abortedZones++;\n                    break;\n                }\n                System.out.println(\"  Repair attempt \" + repairAttempt + \" in Zone \" + damageZone + \" OK.\");\n            }\n        }\n        System.out.println(\"\\nTotal Skipped Attempts: \" + skippedAttempts);\n        System.out.println(\"Total Aborted Zones: \" + abortedZones);\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 10,
            "type": "counter_increment",
            "description": "Missing skippedAttempts increment",
            "fix": "Add skippedAttempts++; before continue statement"
          },
          {
            "id": 2,
            "line": 14,
            "type": "counter_increment",
            "description": "Missing abortedZones increment",
            "fix": "Add abortedZones++; before break statement"
          }
        ],
        "number_of_errors": 2,
        "explanation": "The original code correctly uses `continue` to skip the rest of the inner loop body and `break` to exit the inner loop for critical failures. The problem's description of faulty behavior regarding `skippedAttempts` and `abortedZones` implies an issue in their increment logic or final print, but the provided correct snippet shows standard and correct incrementing of `skippedAttempts` when `continue` is used, and `abortedZones` when `break` is used. This challenge tests careful tracing of `continue` and `break` impacts on counters."
      },
      "hints": {
        "1": "Carefully trace how `skippedAttempts` increments: does the `continue` prevent its increment or only the rest of the loop body?",
        "2": "The `break` statement exits only the *inner* loop. `abortedZones` should increment every time an inner loop `break` is triggered.",
        "3": "Simulate the execution step by step for both `damageZone` loops to get the final counts."
      }
    },
    {
      "id": 388,
      "subtopic_id": 9,
      "type": "code_fixer",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinder's `nestedSystemScan` performs checks in `systemLayers` and `subScanPoints`. A `WARNING` (using `continue`) occurs at (Layer 0, SubScan 1), and a `CRITICAL` anomaly (using `break`) at (Layer 1, SubScan 0), which should stop both loops. The code has flaws preventing correct `continue` and `break` behavior in nested loops. Fix the code to ensure proper skip and abort logic.",
      "story_context": "The NestedSystemScan needs to scan system layers. Your task is to fix the nested loop control flow.",
      "challenge_data": {
        "initial_code": "public class NestedSystemScan {\n    public static void main(String[] args) {\n        boolean scanAborted = false;\n        \n        for (int systemLayer = 0; systemLayer < 2; systemLayer++) {\n            System.out.println(\"Scanning System Layer: \" + systemLayer);\n            for (int subScanPoint = 0; subScanPoint < 3; subScanPoint++) {\n                if (systemLayer == 0 && subScanPoint == 1) {\n                    System.out.println(\"  WARNING: Minor anomaly at (\" + systemLayer + \",\" + subScanPoint + \").\");\n                }\n                \n                if (systemLayer == 1 && subScanPoint == 0) {\n                    scanAborted = true;\n                    System.out.println(\"  CRITICAL: Major anomaly at (\" + systemLayer + \",\" + subScanPoint + \"). Aborting scan.\");\n                    break;\n                }\n                \n                System.out.println(\"  Scan Point: \" + subScanPoint + \" OK.\");\n            }\n        }\n        \n        System.out.println(\"\\nScan Status: \" + (scanAborted ? \"Aborted\" : \"Complete\"));\n    }\n}",
        "expected_output": [
          "Scanning System Layer: 0\\n  Scan Point: 0 OK.\\n  WARNING: Minor anomaly at (0,1).\\n  Scan Point: 2 OK.\\nScanning System Layer: 1\\n  CRITICAL: Major anomaly at (1,0). Aborting scan.\\n\\nScan Status: Aborted"
        ],
        "solution_code": "public class NestedSystemScan {\n    public static void main(String[] args) {\n        boolean scanAborted = false;\n        \n        for (int systemLayer = 0; systemLayer < 2; systemLayer++) {\n            System.out.println(\"Scanning System Layer: \" + systemLayer);\n            for (int subScanPoint = 0; subScanPoint < 3; subScanPoint++) {\n                if (systemLayer == 0 && subScanPoint == 1) {\n                    System.out.println(\"  WARNING: Minor anomaly at (\" + systemLayer + \",\" + subScanPoint + \").\");\n                    continue;\n                }\n                \n                if (systemLayer == 1 && subScanPoint == 0) {\n                    scanAborted = true;\n                    System.out.println(\"  CRITICAL: Major anomaly at (\" + systemLayer + \",\" + subScanPoint + \"). Aborting scan.\");\n                    break;\n                }\n                \n                System.out.println(\"  Scan Point: \" + subScanPoint + \" OK.\");\n            }\n            if (scanAborted) {\n                break;\n            }\n        }\n        \n        System.out.println(\"\\nScan Status: \" + (scanAborted ? \"Aborted\" : \"Complete\"));\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 8,
            "type": "continue_statement",
            "description": "Missing continue statement for warning",
            "fix": "Add continue; after warning message"
          },
          {
            "id": 2,
            "line": 20,
            "type": "outer_loop_control",
            "description": "Missing outer loop termination check",
            "fix": "Add if (scanAborted) { break; } after inner loop"
          }
        ],
        "number_of_errors": 2,
        "explanation": "The original code had correct conditions for warning (`continue`) and critical (`break`). The main issue was ensuring the outer loop also terminates when the critical anomaly is detected in the inner loop. The fix involves adding an `if (scanAborted) { break; }` check inside the outer loop, immediately after the inner loop completes. This check ensures that if the `scanAborted` flag was set by a `break` in the inner loop, the outer loop also terminates, leading to the correct overall 'Aborted' status."
      },
      "hints": {
        "1": "A `continue` statement skips the rest of the current inner loop iteration.",
        "2": "A `break` statement only exits the innermost loop it's in. To exit an outer loop, an additional `break` based on a flag is needed.",
        "3": "Ensure the `scanAborted` flag is correctly set to `true` when the critical condition is met, and then checked by the outer loop."
      }
    },
    {
      "id": 389,
      "subtopic_id": 9,
      "type": "code_fixer",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinder's `droneFleetDeployment` system uses nested `for` loops. The outer loop iterates `droneGroups`. The inner loop performs `deployments`. If `droneGroup` is `1` and `deployment` is `2`, it signifies 'Resupply Needed' and should `skip` the remaining logging for that deployment but still count it. If `droneGroup` is `2` and `deployment` is `1`, it indicates 'Critical Maintenance' and should `break` the inner loop. The original code has flaws in skipping or breaking behavior. Fix the code to ensure correct loop control and accurate `totalDeployments` counting.",
      "story_context": "The DroneFleetDeployment needs to manage drone fleet operations. Your task is to fix the loop control and deployment counting.",
      "challenge_data": {
        "initial_code": "public class DroneFleetDeployment {\n    public static void main(String[] args) {\n        int totalDeployments = 0;\n        \n        for (int droneGroup = 1; droneGroup <= 2; droneGroup++) {\n            System.out.println(\"Deploying Drone Group: \" + droneGroup);\n            for (int deployment = 1; deployment <= 3; deployment++) {\n                if (droneGroup == 1 && deployment == 2) {\n                    System.out.println(\"  Resupply Needed: Skipping deployment \" + deployment);\n                    continue;\n                }\n                if (droneGroup == 2 && deployment == 1) {\n                    System.out.println(\"  CRITICAL MAINTENANCE: Aborting deployments in group \" + deployment);\n                    break;\n                }\n                System.out.println(\"  Drone \" + deployment + \" deployed.\");\n                totalDeployments++;\n            }\n        }\n        System.out.println(\"\\nTotal Fleet Deployments: \" + totalDeployments);\n    }\n}",
        "expected_output": [
          "Deploying Drone Group: 1\\n  Drone 1 deployed.\\n  Resupply Needed: Skipping deployment 2\\n  Drone 3 deployed.\\nDeploying Drone Group: 2\\n  CRITICAL MAINTENANCE: Aborting deployments in group 1.\\n\\nTotal Fleet Deployments: 5"
        ],
        "solution_code": "public class DroneFleetDeployment {\n    public static void main(String[] args) {\n        int totalDeployments = 0;\n        \n        for (int droneGroup = 1; droneGroup <= 2; droneGroup++) {\n            System.out.println(\"Deploying Drone Group: \" + droneGroup);\n            for (int deployment = 1; deployment <= 3; deployment++) {\n                if (droneGroup == 1 && deployment == 2) {\n                    System.out.println(\"  Resupply Needed: Skipping deployment \" + deployment);\n                    totalDeployments++; \n                    continue;\n                }\n                if (droneGroup == 2 && deployment == 1) {\n                    System.out.println(\"  CRITICAL MAINTENANCE: Aborting deployments in group \" + deployment);\n                    totalDeployments++;\n                    break;\n                }\n                System.out.println(\"  Drone \" + deployment + \" deployed.\");\n                totalDeployments++;\n            }\n        }\n        System.out.println(\"\\nTotal Fleet Deployments: \" + totalDeployments);\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 9,
            "type": "counter_increment",
            "description": "Missing totalDeployments increment for resupply",
            "fix": "Add totalDeployments++; before continue statement"
          },
          {
            "id": 2,
            "line": 13,
            "type": "counter_increment",
            "description": "Missing totalDeployments increment for critical maintenance",
            "fix": "Add totalDeployments++; before break statement"
          }
        ],
        "number_of_errors": 2,
        "explanation": "The original code had correct `continue` and `break` logic for skipping and breaking the inner loop. The problem's description of faulty behavior implies that these were not working as intended. This challenge tests careful tracing of how `continue` prevents the rest of the current iteration's code from executing (including the regular 'Drone deployed' message) and how `break` stops the inner loop entirely for a given group. The fix ensures these keywords are correctly positioned to achieve the precise output and `totalDeployments` count."
      },
      "hints": {
        "1": "A `continue` statement skips the rest of the current loop iteration, but the loop continues to the next iteration.",
        "2": "A `break` statement exits the *innermost* loop immediately.",
        "3": "Carefully trace how `totalDeployments` is incremented in each conditional branch and outside the `if` statements."
      }
    },
    {
      "id": 390,
      "subtopic_id": 9,
      "type": "code_fixer",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinder's `dynamicSectorScan` processes `sectorZones` and `subScans` using nested `for` loops. The code should skip analysis for weak signals (`continue`) or abort the entire survey for critical anomalies (`break`). The original code has flaws in its control flow that prevent correct `continue` or `break` behavior. Fix the code to ensure proper skip and abort logic for survey scans.",
      "story_context": "The DynamicSectorScan needs to scan sector zones. Your task is to fix the nested loop control flow.",
      "challenge_data": {
        "initial_code": "public class DynamicSectorScan {\n    public static void main(String[] args) {\n        int anomalyCount = 0;\n        int signalStrength = 100; // Starts strong\n        boolean surveyAborted = false;\n        \n        for (int sectorZone = 0; sectorZone < 2; sectorZone++) {\n            System.out.println(\"Initiating Sector Zone Scan: \" + sectorZone);\n            for (int subScan = 0; subScan < 3; subScan++) {\n                if (sectorZone == 1 && subScan == 1) {\n                    anomalyCount++;\n                    System.out.println(\"  ANOMALY DETECTED at (\" + sectorZone + \",\" + subScan + \")! Anomalies: \" + anomalyCount);\n                }\n                \n                if (signalStrength < 50) {\n                    System.out.println(\"  WARNING: Weak Signal. Skipping analysis.\");\n                }\n\n                if (anomalyCount >= 2) {\n                    surveyAborted = true;\n                    System.out.println(\"  SURVEY ABORTED: Too many anomalies detected.\");\n                }\n                \n                System.out.println(\"  Sub-Scan \" + subScan + \" OK.\");\n            }\n        }\n        \n        System.out.println(\"\\nSurvey complete.\");\n        if (surveyAborted) {\n            System.out.println(\"Final Survey Status: Aborted.\");\n        } else {\n            System.out.println(\"Final Survey Status: All sectors scanned.\");\n        }\n    }\n}",
        "expected_output": [
          "Initiating Sector Zone Scan: 0\\n  Sub-Scan 0 OK.\\n  Sub-Scan 1 OK.\\n  Sub-Scan 2 OK.\\nInitiating Sector Zone Scan: 1\\n  Sub-Scan 0 OK.\\n  ANOMALY DETECTED at (1,1)! Anomalies: 1\\n  Sub-Scan 2 OK.\\n\\nSurvey complete.\\nFinal Survey Status: All sectors scanned."
        ],
        "solution_code": "public class DynamicSectorScan {\n    public static void main(String[] args) {\n        int anomalyCount = 0;\n        int signalStrength = 100; // Starts strong\n        boolean surveyAborted = false;\n        \n        for (int sectorZone = 0; sectorZone < 2; sectorZone++) {\n            System.out.println(\"Initiating Sector Zone Scan: \" + sectorZone);\n            for (int subScan = 0; subScan < 3; subScan++) {\n                if (sectorZone == 1 && subScan == 1) {\n                    anomalyCount++;\n                    System.out.println(\"  ANOMALY DETECTED at (\" + sectorZone + \",\" + subScan + \")! Anomalies: \" + anomalyCount);\n                    continue;\n                }\n                \n                if (signalStrength < 50) {\n                    System.out.println(\"  WARNING: Weak Signal. Skipping analysis.\");\n                    continue;\n                }\n\n                if (anomalyCount >= 2) {\n                    surveyAborted = true;\n                    System.out.println(\"  SURVEY ABORTED: Too many anomalies detected.\");\n                    break;\n                }\n                \n                System.out.println(\"  Sub-Scan \" + subScan + \" OK.\");\n            }\n            if (surveyAborted) {\n                break;\n            }\n        }\n        \n        System.out.println(\"\\nSurvey complete.\");\n        if (surveyAborted) {\n            System.out.println(\"Final Survey Status: Aborted.\");\n        } else {\n            System.out.println(\"Final Survey Status: All sectors scanned.\");\n        }\n    }\n}",
        "errors": [
          {
            "id": 1,
            "line": 11,
            "type": "continue_statement",
            "description": "Missing continue statement for anomaly detection",
            "fix": "Add continue; after anomaly detection message"
          },
          {
            "id": 2,
            "line": 16,
            "type": "continue_statement",
            "description": "Missing continue statement for weak signal",
            "fix": "Add continue; after weak signal warning"
          },
          {
            "id": 3,
            "line": 21,
            "type": "break_statement",
            "description": "Missing break statement for survey abort",
            "fix": "Add break; after survey abort message"
          },
          {
            "id": 4,
            "line": 28,
            "type": "outer_loop_control",
            "description": "Missing outer loop termination check",
            "fix": "Add if (surveyAborted) { break; } after inner loop"
          }
        ],
        "number_of_errors": 4,
        "explanation": "The original code had various issues in its `continue` and `break` conditions, leading to incorrect behavior. The fixes ensure that:\n1. `continue` is correctly used for 'Anomaly Detected' and 'Weak Signal' conditions to skip the rest of the current inner loop iteration without breaking the loop.\n2. `break` is correctly used for `anomalyCount >= 2` to exit the inner loop, and `surveyAborted` is set. \n3. An `if (surveyAborted) { break; }` is added to the outer loop to ensure the entire survey aborts if a critical anomaly is found. This ensures the output reflects successful completion as `anomalyCount` does not reach 2 in this specific test case."
      },
      "hints": {
        "1": "The `continue` keyword skips the rest of the current inner loop iteration, moving to the next iteration.",
        "2": "The `break` keyword exits the *innermost* loop it's in immediately.",
        "3": "To abort an outer loop based on a condition inside an inner loop, a flag and an outer `break` are often needed."
      }
    },
    {
      "id": 391,
      "subtopic_id": 9,
      "type": "code_completion",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinder's `diagnosticRoutine` performs checks on various `systemParts`. A `for` loop is used to iterate through the `systemParts` array by index. Complete the loop's condition to iterate through all elements.",
      "story_context": "The Pathfinder's diagnostic routine needs to check all system parts. Your task is to complete the for loop condition.",
      "challenge_data": {
        "initial_code": "public class DiagnosticRoutine {\n    public static void main(String[] args) {\n        String[] systemParts = {\"Engine\", \"Navigation\", \"Life Support\"};\n        for (int i = 0; ???; i++) {\n            System.out.println(\"Checking: \" + systemParts[i]);\n        }\n    }\n}",
        "expected_output": [
          "Checking: Engine",
          "Checking: Navigation",
          "Checking: Life Support"
        ],
        "solution_code": "public class DiagnosticRoutine {\n    public static void main(String[] args) {\n        String[] systemParts = {\"Engine\", \"Navigation\", \"Life Support\"};\n        for (int i = 0; i < systemParts.length; i++) {\n            System.out.println(\"Checking: \" + systemParts[i]);\n        }\n    }\n}",
        "choices": [
          "i <= systemParts.length",
          "i == systemParts.length",
          "i > 0",
          "i < systemParts.length"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 4,
            "type": "loop_condition",
            "description": "For loop condition to iterate through array",
            "correct_answer": "i < systemParts.length",
        "explanation": "The loop needs to iterate through all valid indices of the `systemParts` array, which are from `0` to `length - 1`. The condition `i < systemParts.length` correctly ensures this, stopping before `i` becomes equal to the array's length, thus preventing an `ArrayIndexOutOfBoundsException`."
          }
        ],
        "number_of_slots": 1
      },
      "hints": {
        "1": "The loop should iterate through all valid indices of the `systemParts` array.",
        "2": "Arrays are zero-indexed, so the highest valid index is `length - 1`.",
        "3": "The blank requires a comparison operator and the array's length property."
      }
    },
    {
      "id": 392,
      "subtopic_id": 9,
      "type": "code_completion",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinder's `powerCore` needs diagnostics run in reverse order, from `5 down to 1`. Complete the `for` loop's initialization.",
      "story_context": "The Pathfinder's power core needs diagnostics run in reverse order. Your task is to complete the for loop initialization.",
      "challenge_data": {
        "initial_code": "public class PowerCoreDiagnostics {\n    public static void main(String[] args) {\n        for (int diagnosticID = ???; diagnosticID > 0; diagnosticID--) {\n            System.out.println(\"Running diagnostic for ID: \" + diagnosticID);\n        }\n    }\n}",
        "expected_output": [
          "Running diagnostic for ID: 5",
          "Running diagnostic for ID: 4",
          "Running diagnostic for ID: 3",
          "Running diagnostic for ID: 2",
          "Running diagnostic for ID: 1"
        ],
        "solution_code": "public class PowerCoreDiagnostics {\n    public static void main(String[] args) {\n        for (int diagnosticID = 5; diagnosticID > 0; diagnosticID--) {\n            System.out.println(\"Running diagnostic for ID: \" + diagnosticID);\n        }\n    }\n}",
        "choices": [
          "1",
          "0",
          "5",
          "diagnosticID"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 3,
            "type": "loop_initialization",
            "description": "For loop initialization for countdown",
            "correct_answer": "5",
        "explanation": "The countdown should start from `5`. Therefore, `5` is the correct initial value for `diagnosticID` to begin the countdown sequence."
          }
        ],
        "number_of_slots": 1
      },
      "hints": {
        "1": "The countdown should start from `5`.",
        "2": "The blank is for the initial value of the loop counter.",
        "3": "The loop decrements, indicating a countdown."
      }
    },
    {
      "id": 393,
      "subtopic_id": 9,
      "type": "code_completion",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinder's `commsLog` contains `messageCodes`. The system uses a `for` loop to iterate through these codes. If a `messageCode` is `below 100`, it should be `skipped` (not printed). Complete the loop's `if` condition with the correct comparison operator.",
      "story_context": "The Pathfinder's comms log filter needs to skip messages below a threshold. Your task is to complete the comparison operator.",
      "challenge_data": {
        "initial_code": "public class CommsLogFilter {\n    public static void main(String[] args) {\n        int[] commsLog = {50, 120, 80, 150};\n        for (int i = 0; i < commsLog.length; i++) {\n            if (commsLog[i] ??? 100) {\n                continue;\n            }\n            System.out.println(\"Processing message: \" + commsLog[i]);\n        }\n    }\n}",
        "expected_output": [
          "Processing message: 120",
          "Processing message: 150"
        ],
        "solution_code": "public class CommsLogFilter {\n    public static void main(String[] args) {\n        int[] commsLog = {50, 120, 80, 150};\n        for (int i = 0; i < commsLog.length; i++) {\n            if (commsLog[i] < 100) {\n                continue;\n            }\n            System.out.println(\"Processing message: \" + commsLog[i]);\n        }\n    }\n}",
        "choices": [
          "<",
          "==",
          "<=",
          ">"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 5,
            "type": "operator",
            "description": "Less than comparison operator",
            "correct_answer": "<",
        "explanation": "The condition for skipping needs to check if `messageCode` is `below` 100. Therefore, `<` is the correct comparison operator to identify messages below the threshold, causing the `continue` statement to skip the current iteration."
          }
        ],
        "number_of_slots": 1
      },
      "hints": {
        "1": "The condition for skipping needs to check if `messageCode` is `below` 100.",
        "2": "Which comparison operator means 'less than'?",
        "3": "The blank requires a single operation symbol."
      }
    },
    {
      "id": 394,
      "subtopic_id": 9,
      "type": "code_completion",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinder's `mainDiagnostics` runs `checkNumber`s. If `checkNumber` reaches `3`, it indicates a critical system failure, and the loop must `abort` immediately. Complete the keyword to abort the loop.",
      "story_context": "The Pathfinder's main diagnostics need to abort on critical failure. Your task is to complete the keyword to abort the loop.",
      "challenge_data": {
        "initial_code": "public class MainDiagnostics {\n    public static void main(String[] args) {\n        for (int checkNumber = 0; checkNumber < 5; checkNumber++) {\n            System.out.println(\"Running check: \" + checkNumber);\n            if (checkNumber == 3) {\n                System.out.println(\"Critical failure detected! Aborting.\");\n                ???;\n            }\n        }\n    }\n}",
        "expected_output": [
          "Running check: 0",
          "Running check: 1",
          "Running check: 2",
          "Running check: 3",
          "Critical failure detected! Aborting."
        ],
        "solution_code": "public class MainDiagnostics {\n    public static void main(String[] args) {\n        for (int checkNumber = 0; checkNumber < 5; checkNumber++) {\n            System.out.println(\"Running check: \" + checkNumber);\n            if (checkNumber == 3) {\n                System.out.println(\"Critical failure detected! Aborting.\");\n                break;\n            }\n        }\n    }\n}",
        "choices": [
          "exit",
          "continue",
          "return",
          "break"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 7,
            "type": "keyword",
            "description": "Break keyword to exit loop",
            "correct_answer": "break",
        "explanation": "The `break` keyword is used to immediately terminate the entire `for` loop, aborting further diagnostics, which is the required behavior for a critical system failure."
          }
        ],
        "number_of_slots": 1
      },
      "hints": {
        "1": "The loop needs to exit completely when `checkNumber` is `3`.",
        "2": "Which keyword immediately terminates the entire loop?",
        "3": "The blank needs a single control flow keyword."
      }
    },
    {
      "id": 395,
      "subtopic_id": 9,
      "type": "code_completion",
      "difficulty": "easy",
      "timer": 300,
      "points": 10,
      "scenario": "The Pathfinder's personnel system processes `crewRanks` using an enhanced `for` loop. If a `rank` is `null`, it should print \"Empty Rank Slot\" and `continue` to the next. Complete the `if` condition with the correct comparison operator.",
      "story_context": "The Pathfinder's personnel system needs to process crew ranks and handle null values. Your task is to complete the null comparison operator.",
      "challenge_data": {
        "initial_code": "public class CrewRankProcessor {\n    public static void main(String[] args) {\n        String[] crewRanks = {\"Captain\", \"Lieutenant\", null, \"Engineer\"};\n        for (String rank : crewRanks) {\n            if (rank ??? null) {\n                System.out.println(\"Empty Rank Slot.\");\n                continue;\n            }\n            System.out.println(\"Processing Rank: \" + rank);\n        }\n    }\n}",
        "expected_output": [
          "Processing Rank: Captain",
          "Processing Rank: Lieutenant",
          "Empty Rank Slot.",
          "Processing Rank: Engineer"
        ],
        "solution_code": "public class CrewRankProcessor {\n    public static void main(String[] args) {\n        String[] crewRanks = {\"Captain\", \"Lieutenant\", null, \"Engineer\"};\n        for (String rank : crewRanks) {\n            if (rank == null) {\n                System.out.println(\"Empty Rank Slot.\");\n                continue;\n            }\n            System.out.println(\"Processing Rank: \" + rank);\n        }\n    }\n}",
        "choices": [
          "!=",
          "equals",
          "not",
          "=="
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 5,
            "type": "operator",
            "description": "Equality comparison operator for null check",
            "correct_answer": "==",
        "explanation": "To check if a non-primitive variable (like a `String`) is pointing to `null` (nothing), the `==` operator is used. This correctly identifies empty rank slots."
          }
        ],
        "number_of_slots": 1
      },
      "hints": {
        "1": "To check if a variable points to 'nothing', you compare it to a specific keyword.",
        "2": "Which comparison operator checks for exact equality to `null`?",
        "3": "The blank requires a single operation symbol."
      }
    },
    {
      "id": 396,
      "subtopic_id": 9,
      "type": "code_completion",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinder's `systemDeployment` involves multiple stages and sub-routines using nested `for` loops. A `WARNING` is logged for specific anomalies, and a `CRITICAL FAILURE` occurs under other conditions. Complete the inner loop's `break` keyword and the outer loop's final status check keyword.",
      "story_context": "The Pathfinder's system deployment involves nested loops with critical failure handling. Your task is to complete the control flow keywords.",
      "challenge_data": {
        "initial_code": "public class SystemDeployment {\n    public static void main(String[] args) {\n        boolean criticalErrorDetected = false;\n        \n        for (int systemStage = 0; systemStage < 2; systemStage++) {\n            System.out.println(\"Deploying Stage: \" + systemStage);\n            for (int routineCheck = 0; routineCheck < 3; routineCheck++) {\n                System.out.println(\"  Running Routine Check: \" + routineCheck);\n                \n                if (systemStage == 0 && routineCheck == 1) {\n                    System.out.println(\"  WARNING: Minor anomaly detected.\");\n                } else if (systemStage == 1 && routineCheck == 0) {\n                    criticalErrorDetected = true;\n                    System.out.println(\"  CRITICAL FAILURE: Aborting deployment!\");\n                    break;\n                }\n            }\n            if (criticalErrorDetected) {\n                break;\n            }\n        }\n        \n        if (criticalErrorDetected) {\n            System.out.println(\"\\nDeployment Aborted due to critical error.\");\n        } else {\n            System.out.println(\"\\nDeployment completed successfully.\");\n        }\n    }\n}",
        "expected_output": [
          "Deploying Stage: 0",
          "  Running Routine Check: 0",
          "  Running Routine Check: 1",
          "  WARNING: Minor anomaly detected.",
          "  Running Routine Check: 2",
          "Deploying Stage: 1",
          "  Running Routine Check: 0",
          "  CRITICAL FAILURE: Aborting deployment!",
          "Deployment Aborted due to critical error."
        ],
        "solution_code": "public class SystemDeployment {\n    public static void main(String[] args) {\n        boolean criticalErrorDetected = false;\n        \n        for (int systemStage = 0; systemStage < 2; systemStage++) {\n            System.out.println(\"Deploying Stage: \" + systemStage);\n            for (int routineCheck = 0; routineCheck < 3; routineCheck++) {\n                System.out.println(\"  Running Routine Check: \" + routineCheck);\n                \n                if (systemStage == 0 && routineCheck == 1) {\n                    System.out.println(\"  WARNING: Minor anomaly detected.\");\n                } else if (systemStage == 1 && routineCheck == 0) {\n                    criticalErrorDetected = true;\n                    System.out.println(\"  CRITICAL FAILURE: Aborting deployment!\");\n                    break;\n                }\n            }\n            if (criticalErrorDetected) {\n                break;\n            }\n        }\n        \n        if (criticalErrorDetected) {\n            System.out.println(\"\\nDeployment Aborted due to critical error.\");\n        } else {\n            System.out.println(\"\\nDeployment completed successfully.\");\n        }\n    }\n}",
        "choices": [
          "<",
          "continue",
          "1",
          "2",
          "0",
          "<=",
          "break",
          "else if"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 12,
            "type": "keyword",
            "description": "Break keyword to exit inner loop",
            "correct_answer": "break",
            "explanation": "The inner loop needs a `break` to exit immediately on critical failure."
          },
          {
            "id": "slot_2",
            "line": 10,
            "type": "keyword",
            "description": "Else if keyword for chaining conditions",
            "correct_answer": "else if",
            "explanation": "The `else if` is used to chain the warning condition."
          },
          {
            "id": "slot_3",
            "line": 8,
            "type": "keyword",
            "description": "Continue keyword to skip iteration",
            "correct_answer": "continue",
            "explanation": "The `continue` keyword is used to skip the rest of the current iteration."
          },
          {
            "id": "slot_4",
            "line": 16,
            "type": "keyword",
            "description": "Break keyword to exit outer loop",
            "correct_answer": "break",
            "explanation": "The outer loop needs a `break` to exit when critical error is detected."
          }
        ],
        "number_of_slots": 4
      },
      "hints": {
        "1": "The inner loop needs a `break` to exit immediately on critical failure.",
        "2": "The `else if` is used to chain the warning condition.",
        "3": "The `continue` keyword is used to skip the rest of the current iteration."
      }
    },
    {
      "id": 397,
      "subtopic_id": 9,
      "type": "code_completion",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinder's `repairDrone` performs `repairCycles` across `damageZones` using nested `for` loops. The drone can `skip` analysis for problematic attempts or `break` the current zone's repair on critical failure. The system also tracks `skippedAttempts` and `abortedZones`. Complete the inner loop's `continue` keyword, the inner loop's `break` keyword, and the outer loop's `if` condition check.",
      "story_context": "The Pathfinder's repair drone control involves nested loops with skip and break logic. Your task is to complete the control flow keywords.",
      "challenge_data": {
        "initial_code": "public class RepairDroneControl {\n    public static void main(String[] args) {\n        int skippedAttempts = 0;\n        int abortedZones = 0;\n        \n        for (int damageZone = 1; damageZone <= 2; damageZone++) {\n            System.out.println(\"Processing Damage Zone: \" + damageZone);\n            for (int repairAttempt = 1; repairAttempt <= 3; repairAttempt++) {\n                if (repairAttempt == 2 && damageZone == 1) {\n                    System.out.println(\"  Skipping problematic attempt \" + repairAttempt + \" in Zone \" + damageZone);\n                    skippedAttempts++;\n                    continue;\n                }\n                if (repairAttempt == 3) {\n                    System.out.println(\"  CRITICAL FAILURE: Aborting attempts in Zone \" + damageZone);\n                    abortedZones++;\n                    break;\n                }\n                System.out.println(\"  Repair attempt \" + repairAttempt + \" in Zone \" + damageZone + \" OK.\");\n            }\n            if (abortedZones > 0) { // Corrected: outer loop condition for abort\n                break;\n            }\n        }\n        System.out.println(\"\\nTotal Skipped Attempts: \" + skippedAttempts);\n        System.out.println(\"Total Aborted Zones: \" + abortedZones);\n    }\n}",
        "expected_output": [
          "Processing Damage Zone: 1",
          "  Repair attempt 1 in Zone 1 OK.",
          "  Skipping problematic attempt 2 in Zone 1",
          "  CRITICAL FAILURE: Aborting attempts in Zone 1",
          "Total Skipped Attempts: 1",
          "Total Aborted Zones: 1"
        ],
        "solution_code": "public class RepairDroneControl {\n    public static void main(String[] args) {\n        int skippedAttempts = 0;\n        int abortedZones = 0;\n        \n        for (int damageZone = 1; damageZone <= 2; damageZone++) {\n            System.out.println(\"Processing Damage Zone: \" + damageZone);\n            for (int repairAttempt = 1; repairAttempt <= 3; repairAttempt++) {\n                if (repairAttempt == 2 && damageZone == 1) {\n                    System.out.println(\"  Skipping problematic attempt \" + repairAttempt + \" in Zone \" + damageZone);\n                    skippedAttempts++;\n                    continue;\n                }\n                if (repairAttempt == 3) {\n                    System.out.println(\"  CRITICAL FAILURE: Aborting attempts in Zone \" + damageZone);\n                    abortedZones++;\n                    break;\n                }\n                System.out.println(\"  Repair attempt \" + repairAttempt + \" in Zone \" + damageZone + \" OK.\");\n            }\n            if (abortedZones > 0) { // Corrected: outer loop condition for abort\n                break;\n            }\n        }\n        System.out.println(\"\\nTotal Skipped Attempts: \" + skippedAttempts);\n        System.out.println(\"Total Aborted Zones: \" + abortedZones);\n    }\n}",
        "choices": [
          "while",
          "continue",
          "1",
          "break",
          "0",
          "totalAttempts",
          "abortedZones",
          "else"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 9,
            "type": "keyword",
            "description": "Continue keyword to skip iteration",
            "correct_answer": "continue",
            "explanation": "The blank for 'Skipping' requires a keyword to skip the current inner loop iteration."
          },
          {
            "id": "slot_2",
            "line": 13,
            "type": "keyword",
            "description": "Break keyword to exit inner loop",
            "correct_answer": "break",
            "explanation": "The blank for 'Aborting' requires a keyword to exit the inner loop immediately."
          },
          {
            "id": "slot_3",
            "line": 17,
            "type": "variable_name",
            "description": "Variable name for outer loop condition",
            "correct_answer": "abortedZones",
            "explanation": "The outer loop needs a condition to check if any `abortedZones` occurred, to `break` early."
          }
        ],
        "number_of_slots": 3
      },
      "hints": {
        "1": "The blank for 'Skipping' requires a keyword to skip the current inner loop iteration.",
        "2": "The blank for 'Aborting' requires a keyword to exit the inner loop immediately.",
        "3": "The outer loop needs a condition to check if any `abortedZones` occurred, to `break` early."
      }
    },
    {
      "id": 398,
      "subtopic_id": 9,
      "type": "code_completion",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinder runs a `nestedSystemScan` over `systemLayers` and `subScanPoints`. If a \"WARNING\" (`Layer 0, Step 1`) occurs, it `skips` further logging for that step. If a \"CRITICAL\" (`Layer 1, Step 0`) occurs, it `breaks` the *current layer's* scan. Complete the inner loop's `continue` keyword, the inner loop's `break` keyword, and the final status logic.",
      "story_context": "The Pathfinder's nested system scan involves control flow with skip and break logic. Your task is to complete the control flow keywords.",
      "challenge_data": {
        "initial_code": "public class NestedSystemScan {\n    public static void main(String[] args) {\n        boolean scanAborted = false;\n        \n        for (int systemLayer = 0; systemLayer < 2; systemLayer++) {\n            System.out.println(\"Scanning System Layer: \" + systemLayer);\n            for (int subScanPoint = 0; subScanPoint < 3; subScanPoint++) {\n                if (systemLayer == 0 && subScanPoint == 1) {\n                    System.out.println(\"  WARNING: Minor anomaly at (\" + systemLayer + \",\" + subScanPoint + \").\");\n                    continue;\n                }\n                \n                if (systemLayer == 1 && subScanPoint == 0) {\n                    scanAborted = true;\n                    System.out.println(\"  CRITICAL: Major anomaly at (\" + systemLayer + \",\" + subScanPoint + \"). Aborting scan.\");\n                    break;\n                }\n                \n                System.out.println(\"  Scan Point: \" + subScanPoint + \" OK.\");\n            }\n            if (scanAborted) {\n                break;\n            }\n        }\n        \n        System.out.println(\"\\nScan Status: \" + (scanAborted ? \"Aborted\" : \"Complete\"));\n    }\n}",
        "expected_output": [
          "Scanning System Layer: 0",
          "  Scan Point: 0 OK.",
          "  WARNING: Minor anomaly at (0,1).",
          "  Scan Point: 2 OK.",
          "Scanning System Layer: 1",
          "  CRITICAL: Major anomaly at (1,0). Aborting scan.",
          "Scan Status: Aborted"
        ],
        "solution_code": "public class NestedSystemScan {\n    public static void main(String[] args) {\n        boolean scanAborted = false;\n        \n        for (int systemLayer = 0; systemLayer < 2; systemLayer++) {\n            System.out.println(\"Scanning System Layer: \" + systemLayer);\n            for (int subScanPoint = 0; subScanPoint < 3; subScanPoint++) {\n                if (systemLayer == 0 && subScanPoint == 1) {\n                    System.out.println(\"  WARNING: Minor anomaly at (\" + systemLayer + \",\" + subScanPoint + \").\");\n                    continue;\n                }\n                \n                if (systemLayer == 1 && subScanPoint == 0) {\n                    scanAborted = true;\n                    System.out.println(\"  CRITICAL: Major anomaly at (\" + systemLayer + \",\" + subScanPoint + \"). Aborting scan.\");\n                    break;\n                }\n                \n                System.out.println(\"  Scan Point: \" + subScanPoint + \" OK.\");\n            }\n            if (scanAborted) {\n                break;\n            }\n        }\n        \n        System.out.println(\"\\nScan Status: \" + (scanAborted ? \"Aborted\" : \"Complete\"));\n    }\n}",
        "choices": [
          "if",
          "continue",
          "String",
          "null",
          "true",
          "false",
          "break",
          "else if"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 8,
            "type": "keyword",
            "description": "Continue keyword to skip iteration",
            "correct_answer": "continue",
            "explanation": "The blank for 'WARNING' needs a keyword to skip the rest of the inner loop iteration."
          },
          {
            "id": "slot_2",
            "line": 13,
            "type": "keyword",
            "description": "Break keyword to exit inner loop",
            "correct_answer": "break",
            "explanation": "The blank for 'CRITICAL' needs a keyword to exit the inner loop immediately."
          },
          {
            "id": "slot_3",
            "line": 20,
            "type": "variable_name",
            "description": "Variable name for ternary operator",
            "correct_answer": "scanAborted",
            "explanation": "The final `Scan Status` output uses a ternary operator based on the `scanAborted` flag."
          }
        ],
        "number_of_slots": 3
      },
      "hints": {
        "1": "The blank for 'WARNING' needs a keyword to skip the rest of the inner loop iteration.",
        "2": "The blank for 'CRITICAL' needs a keyword to exit the inner loop immediately.",
        "3": "The final `Scan Status` output uses a ternary operator based on the `scanAborted` flag."
      }
    },
    {
      "id": 399,
      "subtopic_id": 9,
      "type": "code_completion",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinder deploys a fleet of `drones`. Nested `for` loops manage `droneGroups` and `deployments`. Specific conditions cause a `skip` or `break` in deployments. The system tracks `totalDeployments`. Complete the inner loop's `continue` keyword, the inner loop's `break` keyword, and the final total deployments.",
      "story_context": "The Pathfinder's drone fleet deployment involves nested loops with skip and break logic. Your task is to complete the control flow keywords.",
      "challenge_data": {
        "initial_code": "public class DroneFleetDeployment {\n    public static void main(String[] args) {\n        int totalDeployments = 0;\n        \n        for (int droneGroup = 1; droneGroup <= 2; droneGroup++) {\n            System.out.println(\"Deploying Drone Group: \" + droneGroup);\n            for (int deployment = 1; deployment <= 3; deployment++) {\n                if (droneGroup == 1 && deployment == 2) {\n                    System.out.println(\"  Resupply Needed: Skipping deployment \" + deployment);\n                    totalDeployments++;\n                    continue;\n                }\n                if (droneGroup == 2 && deployment == 1) {\n                    System.out.println(\"  CRITICAL MAINTENANCE: Aborting deployments in group \" + deployment);\n                    totalDeployments++;\n                    break;\n                }\n                System.out.println(\"  Drone \" + deployment + \" deployed.\");\n                totalDeployments++;\n            }\n        }\n        System.out.println(\"\\nTotal Fleet Deployments: \" + totalDeployments);\n    }\n}",
        "expected_output": [
          "Deploying Drone Group: 1",
          "  Drone 1 deployed.",
          "  Resupply Needed: Skipping deployment 2",
          "  Drone 3 deployed.",
          "Deploying Drone Group: 2",
          "  CRITICAL MAINTENANCE: Aborting deployments in group 1",
          "Total Fleet Deployments: 4"
        ],
        "solution_code": "public class DroneFleetDeployment {\n    public static void main(String[] args) {\n        int totalDeployments = 0;\n        \n        for (int droneGroup = 1; droneGroup <= 2; droneGroup++) {\n            System.out.println(\"Deploying Drone Group: \" + droneGroup);\n            for (int deployment = 1; deployment <= 3; deployment++) {\n                if (droneGroup == 1 && deployment == 2) {\n                    System.out.println(\"  Resupply Needed: Skipping deployment \" + deployment);\n                    totalDeployments++;\n                    continue;\n                }\n                if (droneGroup == 2 && deployment == 1) {\n                    System.out.println(\"  CRITICAL MAINTENANCE: Aborting deployments in group \" + deployment);\n                    totalDeployments++;\n                    break;\n                }\n                System.out.println(\"  Drone \" + deployment + \" deployed.\");\n                totalDeployments++;\n            }\n        }\n        System.out.println(\"\\nTotal Fleet Deployments: \" + totalDeployments);\n    }\n}",
        "choices": [
          "continue",
          "droneGroup",
          "1",
          "totalDeployments",
          "2",
          "0",
          "break",
          "deployment"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 9,
            "type": "keyword",
            "description": "Continue keyword to skip deployment",
            "correct_answer": "continue",
            "explanation": "The blank for 'Resupply Needed' requires a keyword to skip to the next deployment attempt."
          },
          {
            "id": "slot_2",
            "line": 13,
            "type": "keyword",
            "description": "Break keyword to exit inner loop",
            "correct_answer": "break",
            "explanation": "The blank for 'Critical Maintenance' requires a keyword to exit the inner loop immediately."
          },
          {
            "id": "slot_3",
            "line": 19,
            "type": "variable_name",
            "description": "Variable name for final output",
            "correct_answer": "totalDeployments",
            "explanation": "The final `println` should display the `totalDeployments` counter."
          }
        ],
        "number_of_slots": 3
      },
      "hints": {
        "1": "The blank for 'Resupply Needed' requires a keyword to skip to the next deployment attempt.",
        "2": "The blank for 'Critical Maintenance' requires a keyword to exit the inner loop immediately.",
        "3": "The final `println` should display the `totalDeployments` counter."
      }
    },
    {
      "id": 400,
      "subtopic_id": 9,
      "type": "code_completion",
      "difficulty": "medium",
      "timer": 450,
      "points": 15,
      "scenario": "The Pathfinder's `surveyDrone` performs `sectorScans`. Nested `for` loops manage `sectorZones` and `subScans`. The drone logs `anomalyCount` and handles `skip` or `break` based on conditions. Complete the `skip` keyword, the `break` keyword, and the final status message.",
      "story_context": "The Pathfinder's survey drone performs sector scans with anomaly detection. Your task is to complete the control flow keywords and final status message.",
      "challenge_data": {
        "initial_code": "public class SurveyAnomalyReport {\n    public static void main(String[] args) {\n        int anomalyCount = 0;\n        \n        for (int sectorZone = 0; sectorZone < 2; sectorZone++) {\n            System.out.println(\"Initiating Sector Zone Scan: \" + sectorZone);\n            for (int subScan = 0; subScan < 3; subScan++) {\n                if (sectorZone == 1 && subScan == 1) {\n                    anomalyCount++;\n                    System.out.println(\"  ANOMALY DETECTED at (\" + sectorZone + \",\" + subScan + \")! Anomalies: \" + anomalyCount);\n                    continue;\n                }\n                \n                if (anomalyCount == 2) {\n                    System.out.println(\"  SURVEY ABORTED: Too many anomalies detected.\");\n                    break;\n                }\n                \n                System.out.println(\"  Sub-Scan \" + subScan + \" OK.\");\n            }\n            if (anomalyCount == 2) {\n                System.out.println(\"  Exiting Sector Zone \" + sectorZone + \" early.\");\n                break;\n            }\n        }\n        \n        System.out.println(\"\\nSurvey complete.\");\n        if (anomalyCount == 2) {\n            System.out.println(\"Final Survey Status: Aborted.\");\n        } else {\n            System.out.println(\"Final Survey Status: Completed.\");\n        }\n    }\n}",
        "expected_output": [
          "Initiating Sector Zone Scan: 0",
          "  Sub-Scan 0 OK.",
          "  Sub-Scan 1 OK.",
          "  Sub-Scan 2 OK.",
          "Initiating Sector Zone Scan: 1",
          "  Sub-Scan 0 OK.",
          "  ANOMALY DETECTED at (1,1)! Anomalies: 1",
          "  SURVEY ABORTED: Too many anomalies detected.",
          "  Exiting Sector Zone 1 early.",
          "Survey complete.",
          "Final Survey Status: Aborted"
        ],
        "solution_code": "public class SurveyAnomalyReport {\n    public static void main(String[] args) {\n        int anomalyCount = 0;\n        \n        for (int sectorZone = 0; sectorZone < 2; sectorZone++) {\n            System.out.println(\"Initiating Sector Zone Scan: \" + sectorZone);\n            for (int subScan = 0; subScan < 3; subScan++) {\n                if (sectorZone == 1 && subScan == 1) {\n                    anomalyCount++;\n                    System.out.println(\"  ANOMALY DETECTED at (\" + sectorZone + \",\" + subScan + \")! Anomalies: \" + anomalyCount);\n                    continue;\n                }\n                \n                if (anomalyCount == 2) {\n                    System.out.println(\"  SURVEY ABORTED: Too many anomalies detected.\");\n                    break;\n                }\n                \n                System.out.println(\"  Sub-Scan \" + subScan + \" OK.\");\n            }\n            if (anomalyCount == 2) {\n                System.out.println(\"  Exiting Sector Zone \" + sectorZone + \" early.\");\n                break;\n            }\n        }\n        \n        System.out.println(\"\\nSurvey complete.\");\n        if (anomalyCount == 2) {\n            System.out.println(\"Final Survey Status: Aborted.\");\n        } else {\n            System.out.println(\"Final Survey Status: Completed.\");\n        }\n    }\n}",
        "choices": [
          "continue",
          "3",
          "null",
          "totalCount",
          "2",
          "System.out.println(\"Final Survey Status: Completed.\");",
          "break",
          "else if"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 9,
            "type": "keyword",
            "description": "Continue keyword to skip iteration",
            "correct_answer": "continue",
            "explanation": "The blank needs the keyword to skip the current inner loop iteration."
          },
          {
            "id": "slot_2",
            "line": 13,
            "type": "keyword",
            "description": "Break keyword to exit inner loop",
            "correct_answer": "break",
            "explanation": "The blank needs the keyword to exit the inner loop immediately."
          },
          {
            "id": "slot_3",
            "line": 22,
            "type": "method_call",
            "description": "Final status message method call",
            "correct_answer": "System.out.println(\"Final Survey Status: Completed.\");",
            "explanation": "The final `System.out.println()` displays the success message if no anomaly caused an early exit."
          }
        ],
        "number_of_slots": 3
      },
      "hints": {
        "1": "The blank needs the keyword to skip the current inner loop iteration.",
        "2": "The blank needs the keyword to exit the inner loop immediately.",
        "3": "The final `System.out.println()` displays the success message if no anomaly caused an early exit."
      }
    },
    {
      "id": 401,
      "subtopic_id": 9,
      "type": "code_completion",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinder launches `surveyDrones` to map a planetary grid. The process involves an outer `for` loop for `gridRows` and an inner `for` loop for `gridColumns`. If a \"Hazard Zone\" is found (Row 0, Column 1), the drone logs a warning and `skips` that column's analysis. If a \"Critical Anomaly\" is found (Row 1, Column 0), it logs a critical alert and `breaks` the inner loop, aborting the entire survey. Complete the code for the outer loop's initialization value, the inner loop's `skip` keyword, and the inner loop's `break` keyword.",
      "story_context": "The Pathfinder's planetary grid survey involves nested loops with hazard detection. Your task is to complete the loop initialization and control flow keywords.",
      "challenge_data": {
        "initial_code": "public class PlanetaryGridSurvey {\n    public static void main(String[] args) {\n        boolean surveyAborted = false;\n        \n        for (int gridRow = 0; gridRow < 2; gridRow++) {\n            System.out.println(\"Surveying Grid Row: \" + gridRow);\n            for (int gridColumn = 0; gridColumn < 3; gridColumn++) {\n                if (gridRow == 0 && gridColumn == 1) {\n                    System.out.println(\"  WARNING: Hazard Zone at (\" + gridRow + \",\" + gridColumn + \"). Skipping analysis.\");\n                    gridColumn++;\n                    continue;\n                }\n                if (gridRow == 1 && gridColumn == 0) {\n                    System.out.println(\"  CRITICAL: Anomaly detected at (\" + gridRow + \",\" + gridColumn + \"). Aborting grid row.\");\n                    surveyAborted = true;\n                    break;\n                }\n                System.out.println(\"  Analyzing Grid Point: (\" + gridRow + \",\" + gridColumn + \").\");\n            }\n            if (surveyAborted) {\n                System.out.println(\"  Survey Aborted for subsequent rows.\");\n                break;\n            }\n        }\n        \n        System.out.println(\"\\nSurvey complete.\");\n        if (surveyAborted) {\n            System.out.println(\"Final Survey Status: Aborted.\");\n        } else {\n            System.out.println(\"Final Survey Status: All points mapped.\");\n        }\n    }\n}",
        "expected_output": [
          "Surveying Grid Row: 0",
          "  Analyzing Grid Point: (0,0).",
          "  WARNING: Hazard Zone at (0,1). Skipping analysis.",
          "  Analyzing Grid Point: (0,2).",
          "Surveying Grid Row: 1",
          "  CRITICAL: Anomaly detected at (1,0). Aborting grid row.",
          "  Survey Aborted for subsequent rows.",
          "Survey complete.",
          "Final Survey Status: Aborted"
        ],
        "solution_code": "public class PlanetaryGridSurvey {\n    public static void main(String[] args) {\n        boolean surveyAborted = false;\n        \n        for (int gridRow = 0; gridRow < 2; gridRow++) {\n            System.out.println(\"Surveying Grid Row: \" + gridRow);\n            for (int gridColumn = 0; gridColumn < 3; gridColumn++) {\n                if (gridRow == 0 && gridColumn == 1) {\n                    System.out.println(\"  WARNING: Hazard Zone at (\" + gridRow + \",\" + gridColumn + \"). Skipping analysis.\");\n                    gridColumn++;\n                    continue;\n                }\n                if (gridRow == 1 && gridColumn == 0) {\n                    System.out.println(\"  CRITICAL: Anomaly detected at (\" + gridRow + \",\" + gridColumn + \"). Aborting grid row.\");\n                    surveyAborted = true;\n                    break;\n                }\n                System.out.println(\"  Analyzing Grid Point: (\" + gridRow + \",\" + gridColumn + \").\");\n            }\n            if (surveyAborted) {\n                System.out.println(\"  Survey Aborted for subsequent rows.\");\n                break;\n            }\n        }\n        \n        System.out.println(\"\\nSurvey complete.\");\n        if (surveyAborted) {\n            System.out.println(\"Final Survey Status: Aborted.\");\n        } else {\n            System.out.println(\"Final Survey Status: All points mapped.\");\n        }\n    }\n}",
        "choices": [
          "continue",
          "System.out.println(\"Final Survey Status: All points mapped.\");",
          "1",
          "gridRow++",
          "0",
          "gridColumn++",
          "System.out.println(\"Final Survey Status: Review Data.\");",
          "break"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 4,
            "type": "loop_initialization",
            "description": "Outer loop initialization value",
            "correct_answer": "0",
            "explanation": "`0` is the correct initialization for `gridRow` to start from 0."
          },
          {
            "id": "slot_2",
            "line": 9,
            "type": "keyword",
            "description": "Continue keyword to skip iteration",
            "correct_answer": "continue",
            "explanation": "`continue` is used to skip the rest of the inner loop body when a hazard zone is detected."
          },
          {
            "id": "slot_3",
            "line": 13,
            "type": "keyword",
            "description": "Break keyword to exit inner loop",
            "correct_answer": "break",
            "explanation": "`break` is used to immediately exit the inner loop when a critical anomaly is detected."
          }
        ],
        "number_of_slots": 3
      },
      "hints": {
        "1": "The outer loop for `gridRow` should start from `0`.",
        "2": "The blank for 'Hazard Zone' requires a keyword to skip the current grid column's analysis.",
        "3": "The blank for 'Critical Anomaly' requires a keyword to exit the inner loop immediately."
      }
    },
    {
      "id": 402,
      "subtopic_id": 9,
      "type": "code_completion",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinder's `maintenanceScheduler` generates a `schedule`. An outer `for` loop iterates through `systemAreas`. An inner `for` loop iterates `taskIDs` per area. If a task is 'Urgent' (Area 0, Task 2), the `taskID` should `reset` to `1` (causing it to repeat task 1). If a task is 'Blocked' (Area 1, Task 1), the inner loop should `break`. Complete the code for the outer loop's initialization value, the inner loop's conditional `reset`, and the inner loop's `break` keyword.",
      "story_context": "The Pathfinder's maintenance scheduler involves nested loops with task rescheduling. Your task is to complete the loop initialization and control flow keywords.",
      "challenge_data": {
        "initial_code": "public class MaintenanceScheduler {\n    public static void main(String[] args) {\n        int urgentTasks = 0;\n        \n        for (int systemArea = 0; systemArea < 2; systemArea++) {\n            System.out.println(\"Generating schedule for System Area: \" + systemArea);\n            for (int taskID = 1; taskID <= 2; taskID++) {\n                if (systemArea == 0 && taskID == 2) {\n                    urgentTasks++;\n                    System.out.println(\"  URGENT: Maintenance task \" + taskID + \" in area \" + systemArea + \". Rescheduling for Task 1.\");\n                    taskID = 1; // Corrected: Reset taskID to 1\n                    continue;\n                }\n                if (systemArea == 1 && taskID == 1) {\n                    System.out.println(\"  BLOCKED: Task \" + taskID + \" in area \" + systemArea + \" blocked. Aborting area schedule.\");\n                    break;\n                }\n                System.out.println(\"  Schedule Task: \" + taskID + \" in Area: \" + systemArea);\n            }\n        }\n        System.out.println(\"\\nMaintenance Schedule Generation Complete. Urgent Tasks: \" + urgentTasks);\n        if (urgentTasks > 0) {\n            System.out.println(\"Final Status: Review Needed.\");\n        } else {\n            System.out.println(\"Final Status: Schedule OK.\");\n        }\n    }\n}",
        "expected_output": [
          "Generating schedule for System Area: 0",
          "  Schedule Task: 1 in Area: 0",
          "  URGENT: Maintenance task 2 in area 0. Rescheduling for Task 1.",
          "  Schedule Task: 1 in Area: 0",
          "Generating schedule for System Area: 1",
          "  BLOCKED: Task 1 in area 1 blocked. Aborting area schedule.",
          "Maintenance Schedule Generation Complete. Urgent Tasks: 1",
          "Final Status: Review Needed"
        ],
        "solution_code": "public class MaintenanceScheduler {\n    public static void main(String[] args) {\n        int urgentTasks = 0;\n        \n        for (int systemArea = 0; systemArea < 2; systemArea++) {\n            System.out.println(\"Generating schedule for System Area: \" + systemArea);\n            for (int taskID = 1; taskID <= 2; taskID++) {\n                if (systemArea == 0 && taskID == 2) {\n                    urgentTasks++;\n                    System.out.println(\"  URGENT: Maintenance task \" + taskID + \" in area \" + systemArea + \". Rescheduling for Task 1.\");\n                    taskID = 1; // Corrected: Reset taskID to 1\n                    continue;\n                }\n                if (systemArea == 1 && taskID == 1) {\n                    System.out.println(\"  BLOCKED: Task \" + taskID + \" in area \" + systemArea + \" blocked. Aborting area schedule.\");\n                    break;\n                }\n                System.out.println(\"  Schedule Task: \" + taskID + \" in Area: \" + systemArea);\n            }\n        }\n        System.out.println(\"\\nMaintenance Schedule Generation Complete. Urgent Tasks: \" + urgentTasks);\n        if (urgentTasks > 0) {\n            System.out.println(\"Final Status: Review Needed.\");\n        } else {\n            System.out.println(\"Final Status: Schedule OK.\");\n        }\n    }\n}",
        "choices": [
          "continue",
          "1",
          "null",
          "\"Schedule OK\"",
          "0",
          "break",
          "urgentTasks",
          "\"Review Needed\""
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 9,
            "type": "variable_assignment",
            "description": "Task ID reset value",
            "correct_answer": "1",
            "explanation": "`1` is the correct value to reset `taskID` to 1, causing it to repeat task 1."
          },
          {
            "id": "slot_2",
            "line": 13,
            "type": "keyword",
            "description": "Break keyword to exit inner loop",
            "correct_answer": "break",
            "explanation": "`break` is used to immediately exit the inner loop when a task is blocked."
          },
          {
            "id": "slot_3",
            "line": 19,
            "type": "variable_name",
            "description": "Variable name for final output",
            "correct_answer": "urgentTasks",
            "explanation": "`urgentTasks` is the variable to print for the final count of urgent tasks."
          }
        ],
        "number_of_slots": 3
      },
      "hints": {
        "1": "The `taskID` needs to be reset to `1` for rescheduling.",
        "2": "The blank for 'Blocked' task requires a keyword to exit the inner loop.",
        "3": "The final `println` displays the `urgentTasks` counter."
      }
    },
    {
      "id": 403,
      "subtopic_id": 9,
      "type": "code_completion",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinder's `commsRelay` system tests communication links between `baseStations` and `relayPoints`. Nested `for` loops iterate these. If a link is 'Degraded' (Base 1, Relay 2), it `skips` the test. If a link is 'Broken' (Base 2, Relay 1), it `breaks` the current station's tests. Complete the code for the outer loop's initialization value, the inner loop's `skip` keyword, and the inner loop's `break` keyword.",
      "story_context": "The Pathfinder's communication relay test involves nested loops with link status handling. Your task is to complete the loop initialization and control flow keywords.",
      "challenge_data": {
        "initial_code": "public class CommsRelayTest {\n    public static void main(String[] args) {\n        int totalLinksTested = 0;\n        \n        for (int baseStation = 1; baseStation <= 2; baseStation++) {\n            System.out.println(\"Testing Base Station: \" + baseStation);\n            for (int relayPoint = 1; relayPoint <= 3; relayPoint++) {\n                if (baseStation == 1 && relayPoint == 2) {\n                    System.out.println(\"  Link Degraded at (\" + baseStation + \",\" + relayPoint + \"). Skipping test.\");\n                    totalLinksTested++;\n                    continue;\n                }\n                if (baseStation == 2 && relayPoint == 1) {\n                    System.out.println(\"  LINK BROKEN at (\" + baseStation + \",\" + relayPoint + \"). Aborting current station tests.\");\n                    totalLinksTested++;\n                    break;\n                }\n                System.out.println(\"  Link to Relay Point: (\" + baseStation + \",\" + relayPoint + \") OK.\");\n                totalLinksTested++;\n            }\n        }\n        System.out.println(\"\\nCommunication Test Complete. Total Links Tested: \" + totalLinksTested);\n    }\n}",
        "expected_output": [
          "Testing Base Station: 1",
          "  Link to Relay Point: (1,1) OK.",
          "  Link Degraded at (1,2). Skipping test.",
          "  Link to Relay Point: (1,3) OK.",
          "Testing Base Station: 2",
          "  LINK BROKEN at (2,1). Aborting current station tests.",
          "Communication Test Complete. Total Links Tested: 4"
        ],
        "solution_code": "public class CommsRelayTest {\n    public static void main(String[] args) {\n        int totalLinksTested = 0;\n        \n        for (int baseStation = 1; baseStation <= 2; baseStation++) {\n            System.out.println(\"Testing Base Station: \" + baseStation);\n            for (int relayPoint = 1; relayPoint <= 3; relayPoint++) {\n                if (baseStation == 1 && relayPoint == 2) {\n                    System.out.println(\"  Link Degraded at (\" + baseStation + \",\" + relayPoint + \"). Skipping test.\");\n                    totalLinksTested++;\n                    continue;\n                }\n                if (baseStation == 2 && relayPoint == 1) {\n                    System.out.println(\"  LINK BROKEN at (\" + baseStation + \",\" + relayPoint + \"). Aborting current station tests.\");\n                    totalLinksTested++;\n                    break;\n                }\n                System.out.println(\"  Link to Relay Point: (\" + baseStation + \",\" + relayPoint + \") OK.\");\n                totalLinksTested++;\n            }\n        }\n        System.out.println(\"\\nCommunication Test Complete. Total Links Tested: \" + totalLinksTested);\n    }\n}",
        "choices": [
          "continue",
          "relayPoint",
          "1",
          "2",
          "0",
          "totalLinksTested",
          "break",
          "baseStation"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 4,
            "type": "loop_initialization",
            "description": "Outer loop initialization value",
            "correct_answer": "1",
            "explanation": "`1` is the correct initial value for `baseStation`."
          },
          {
            "id": "slot_2",
            "line": 9,
            "type": "keyword",
            "description": "Continue keyword to skip test",
            "correct_answer": "continue",
            "explanation": "`continue` skips the rest of the inner loop's current iteration when a link is degraded."
          },
          {
            "id": "slot_3",
            "line": 13,
            "type": "keyword",
            "description": "Break keyword to exit inner loop",
            "correct_answer": "break",
            "explanation": "`break` immediately exits the inner loop when a link is broken."
          }
        ],
        "number_of_slots": 3
      },
      "hints": {
        "1": "The outer loop for `baseStation` should start from `1`.",
        "2": "The blank for 'Link Degraded' requires a keyword to skip to the next `relayPoint` test.",
        "3": "The blank for 'LINK BROKEN' requires a keyword to exit the inner loop immediately."
      }
    },
    {
      "id": 404,
      "subtopic_id": 9,
      "type": "code_completion",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinder's `cargoManifest` lists `itemWeights`. Nested `for` loops iterate `cargoBays` and `itemIDs`. If `itemWeight` is `above 100`, it's a 'Heavy Item' warning and `continues`. If `itemWeight` is `above 150`, it's an 'Overload' alert and `breaks` the inner loop. Complete the code for the outer loop's initialization, the inner loop's `continue` keyword, and the inner loop's `break` keyword.",
      "story_context": "The Pathfinder's cargo manifest system needs to process items with weight validation. Your task is to complete the nested loop structure with proper control flow.",
      "challenge_data": {
        "initial_code": "public class CargoManifestUpdater {\n    public static void main(String[] args) {\n        boolean overloadDetected = false;\n        \n        for (int cargoBay = ???; cargoBay < 2; cargoBay++) {\n            System.out.println(\"Processing Cargo Bay: \" + cargoBay);\n            for (int itemID = 0; itemID < 3; itemID++) {\n                int itemWeight = 50 + (itemID * 60);\n                if (itemWeight > 100 && itemWeight <= 150) {\n                    System.out.println(\"  WARNING: Heavy Item (\" + itemWeight + \"kg) at (\" + cargoBay + \",\" + itemID + \").\");\n                    itemID++;\n                    ???;\n                }\n                if (itemWeight > 150) {\n                    System.out.println(\"  OVERLOAD: Item \" + itemID + \" (\" + itemWeight + \"kg) exceeds capacity! Aborting bay scan.\");\n                    overloadDetected = true;\n                    ???;\n                }\n                System.out.println(\"  Item: (\" + cargoBay + \",\" + itemID + \") weight OK.\");\n            }\n            if (overloadDetected) {\n                break;\n            }\n        }\n        \n        System.out.println(\"\\nManifest scan complete.\");\n        if (overloadDetected) {\n            System.out.println(\"Final Manifest Status: Overload Detected.\");\n        } else {\n            System.out.println(\"Final Manifest Status: OK.\");\n        }\n    }\n}",
        "expected_output": [
          "Processing Cargo Bay: 0",
          "  WARNING: Heavy Item (110kg) at (0,1).",
          "  OVERLOAD: Item 2 (170kg) exceeds capacity! Aborting bay scan.",
          "Manifest scan complete.",
          "Final Manifest Status: Overload Detected."
        ],
        "solution_code": "public class CargoManifestUpdater {\n    public static void main(String[] args) {\n        boolean overloadDetected = false;\n        \n        for (int cargoBay = 0; cargoBay < 2; cargoBay++) {\n            System.out.println(\"Processing Cargo Bay: \" + cargoBay);\n            for (int itemID = 0; itemID < 3; itemID++) {\n                int itemWeight = 50 + (itemID * 60);\n                if (itemWeight > 100 && itemWeight <= 150) {\n                    System.out.println(\"  WARNING: Heavy Item (\" + itemWeight + \"kg) at (\" + cargoBay + \",\" + itemID + \").\");\n                    itemID++;\n                    continue;\n                }\n                if (itemWeight > 150) {\n                    System.out.println(\"  OVERLOAD: Item \" + itemID + \" (\" + itemWeight + \"kg) exceeds capacity! Aborting bay scan.\");\n                    overloadDetected = true;\n                    break;\n                }\n                System.out.println(\"  Item: (\" + cargoBay + \",\" + itemID + \") weight OK.\");\n            }\n            if (overloadDetected) {\n                break;\n            }\n        }\n        \n        System.out.println(\"\\nManifest scan complete.\");\n        if (overloadDetected) {\n            System.out.println(\"Final Manifest Status: Overload Detected.\");\n        } else {\n            System.out.println(\"Final Manifest Status: OK.\");\n        }\n    }\n}",
        "choices": [
          "continue",
          "cargoBay",
          "1",
          "0",
          "System.out.println(\"Final Manifest Status: OK.\");",
          "break",
          "System.out.println(\"Final Manifest Status: Partial Scan.\");",
          "itemID"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 5,
            "type": "number",
            "description": "Outer loop initialization value",
            "correct_answer": "0",
            "explanation": "`0` is the correct initialization for `cargoBay` to start from the first cargo bay."
          },
          {
            "id": "slot_2",
            "line": 10,
            "type": "keyword",
            "description": "Continue keyword to skip heavy item processing",
            "correct_answer": "continue",
            "explanation": "`continue` is used to skip the rest of the inner loop body when a heavy item is detected."
          },
          {
            "id": "slot_3",
            "line": 14,
            "type": "keyword",
            "description": "Break keyword to exit inner loop on overload",
            "correct_answer": "break",
            "explanation": "`break` is used to immediately exit the inner loop when an overload is detected."
          }
        ],
        "number_of_slots": 3
      },
      "hints": {
        "1": "The outer loop for `cargoBay` should start from `0`.",
        "2": "The blank for 'Heavy Item' requires a keyword to skip to the next item ID.",
        "3": "The blank for 'Overload' requires a keyword to exit the inner loop immediately."
      }
    },
    {
      "id": 405,
      "subtopic_id": 9,
      "type": "code_completion",
      "difficulty": "hard",
      "timer": 600,
      "points": 20,
      "scenario": "The Pathfinder's `finalDiagnosticSweep` performs nested `for` loop `sweeps` over `zones` and `subZones`. It tracks `successfulSweeps` and logs anomalies. If a critical anomaly occurs, it uses `continue` to skip the rest of the sub-zone processing. The final status message depends on the outcome. Complete the `continue` keyword, the `successfulSweeps` variable for counting, and the final completion message.",
      "story_context": "The Pathfinder's diagnostic system needs to perform sweeps with anomaly tracking. Your task is to complete the nested loop structure with proper control flow.",
      "challenge_data": {
        "initial_code": "public class FinalDiagnosticSweep {\n    public static void main(String[] args) {\n        int ??? = 0;\n        \n        for (int zone = 0; zone < 2; zone++) {\n            for (int subZone = 0; subZone < 3; subZone++) {\n                if (zone == 1 && subZone == 1) {\n                    System.out.println(\"Anomaly in Zone \" + zone + \", SubZone \" + subZone + \".\");\n                    successfulSweeps++;\n                    ???; \n                }\n                \n                System.out.println(\"Sweep OK for Zone \" + zone + \", SubZone \" + subZone + \".\");\n                successfulSweeps++;\n            }\n            System.out.println(\"Zone \" + zone + \" processed. Sweeps in zone: \" + (zone == 0 ? 3 : 2));\n        }\n        \n        System.out.println(\"\\nTotal Successful Sweeps: \" + successfulSweeps);\n        System.out.println(\"Final Status: \" + ???);\n    }\n}",
        "expected_output": [
          "Sweep OK for Zone 0, SubZone 0.",
          "Sweep OK for Zone 0, SubZone 1.",
          "Sweep OK for Zone 0, SubZone 2.",
          "Zone 0 processed. Sweeps in zone: 3",
          "Sweep OK for Zone 1, SubZone 0.",
          "Anomaly in Zone 1, SubZone 1.",
          "Sweep OK for Zone 1, SubZone 2.",
          "Zone 1 processed. Sweeps in zone: 2",
          "Total Successful Sweeps: 6",
          "Final Status: Sweep Complete"
        ],
        "solution_code": "public class FinalDiagnosticSweep {\n    public static void main(String[] args) {\n        int successfulSweeps = 0;\n        \n        for (int zone = 0; zone < 2; zone++) {\n            for (int subZone = 0; subZone < 3; subZone++) {\n                if (zone == 1 && subZone == 1) {\n                    System.out.println(\"Anomaly in Zone \" + zone + \", SubZone \" + subZone + \".\");\n                    successfulSweeps++;\n                    continue; \n                }\n                \n                System.out.println(\"Sweep OK for Zone \" + zone + \", SubZone \" + subZone + \".\");\n                successfulSweeps++;\n            }\n            System.out.println(\"Zone \" + zone + \" processed. Sweeps in zone: \" + (zone == 0 ? 3 : 2));\n        }\n        \n        System.out.println(\"\\nTotal Successful Sweeps: \" + successfulSweeps);\n        System.out.println(\"Final Status: \" + \"Sweep Complete\");\n    }\n}",
        "choices": [
          "totalSweeps",
          "\"Sweep Interrupted\"",
          "\"Sweep Complete\"",
          "continue",
          "successfulSweeps",
          "zone",
          "break",
          "subZone"
        ],
        "completion_slots": [
          {
            "id": "slot_1",
            "line": 3,
            "type": "variable",
            "description": "Variable to track successful sweeps",
            "correct_answer": "successfulSweeps",
            "explanation": "`successfulSweeps` is the variable holding the total count of sweeps."
          },
          {
            "id": "slot_2",
            "line": 9,
            "type": "keyword",
            "description": "Continue keyword to skip anomaly processing",
            "correct_answer": "continue",
            "explanation": "`continue` is the keyword to skip the rest of the inner loop's current iteration when an anomaly is detected."
          },
          {
            "id": "slot_3",
            "line": 16,
            "type": "string",
            "description": "Final status message string",
            "correct_answer": "\"Sweep Complete\"",
            "explanation": "`\"Sweep Complete\"` is the string literal for the final status message."
          }
        ],
        "number_of_slots": 3
      },
      "hints": {
        "1": "The first blank needs the keyword to skip the current inner loop iteration.",
        "2": "The second blank needs the variable holding the total count of successful sweeps.",
        "3": "The third blank needs the string literal for the final status message."
      }
    }
  ]