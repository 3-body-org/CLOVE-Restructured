[
  {
    "id": 1,
    "subtopic_id": 1,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder's AI is learning to track magical energy. A `SparkSpell` initializes a variable `spellPower`. Your task is to trace the code and determine the output displayed by the system.",
      "code": "public class SparkSpell {\n    public static void main(String[] args) {\n        int spellPower = 10;\n        System.out.println(spellPower);\n    }\n}",
      "choices": [
        "10",
        "0",
        "Error",
        "Nothing"
      ],
      "answer": [
        "10"
      ],
      "explanation": "The `int spellPower = 10;` line declares an integer variable named `spellPower` and initializes it with the value `10`. The `System.out.println(spellPower);` line then prints the current value stored in the `spellPower` variable, which is `10`."
    },
    "difficulty": "easy",
    "hints": {
      "1": "Identify the variable's initial assignment.",
      "2": "Follow the flow of execution, especially the last command.",
      "3": "Consider what `System.out.println()` does."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 2,
    "subtopic_id": 1,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `PotionInventory` system tracks magical ingredients. The `moonpetalDust` variable is initially set, then updated. Your task is to trace the code and determine its final value printed by the system.",
      "code": "public class PotionInventory {\n    public static void main(String[] args) {\n        int moonpetalDust = 5;\n        moonpetalDust = 7;\n        System.out.println(moonpetalDust);\n    }\n}",
      "choices": [
        "5",
        "7",
        "12",
        "Error"
      ],
      "answer": [
        "7"
      ],
      "explanation": "The variable `moonpetalDust` is first initialized to `5`. Then, `moonpetalDust = 7;` reassigns the variable, overwriting the previous value `5` with `7`. When `System.out.println(moonpetalDust);` is executed, it prints the most recently assigned value, which is `7`."
    },
    "difficulty": "easy",
    "hints": {
      "1": "Notice that the variable `moonpetalDust` is assigned a value twice.",
      "2": "In programming, a variable holds only its most recent value.",
      "3": "The `println` statement displays the value at the moment it's executed."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 3,
    "subtopic_id": 1,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "An `ArtifactLabeler` creates labels for magical items. The `artifactName` variable holds the name of an artifact. Your task is to trace the code and determine the complete label that will be printed.",
      "code": "public class ArtifactLabeler {\n    public static void main(String[] args) {\n        String artifactName = \"Amulet of Zarthus\";\n        System.out.println(\"Label: \" + artifactName);\n    }\n}",
      "choices": [
        "Amulet of Zarthus",
        "Label: Amulet of Zarthus",
        "Label: artifactName",
        "Error"
      ],
      "answer": [
        "Label: Amulet of Zarthus"
      ],
      "explanation": "The `String artifactName = \"Amulet of Zarthus\";` line declares a String variable `artifactName` and assigns it the text `\"Amulet of Zarthus\"`. The `System.out.println(\"Label: \" + artifactName);` line uses string concatenation (`+`) to join the literal string `\"Label: \"` with the *value* of `artifactName`. Therefore, the output will be `Label: Amulet of Zarthus`."
    },
    "difficulty": "easy",
    "hints": {
      "1": "Observe how the `+` operator is used with a `String` literal and a variable.",
      "2": "Think about what happens when text is combined with a variable's value.",
      "3": "Does the variable name itself get printed, or its content?"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 4,
    "subtopic_id": 1,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `MagicSurgeMonitor` detects magical energy fluctuations. The `majorSurgeDetected` flag indicates if a surge is active. Your task is to trace the code and determine which status message is printed based on the flag's value.",
      "code": "public class MagicSurgeMonitor {\n    public static void main(String[] args) {\n        boolean majorSurgeDetected = false;\n        if (majorSurgeDetected) {\n            System.out.println(\"Major Magic Surge Detected!\");\n        } else {\n            System.out.println(\"Energy levels stable.\");\n        }\n    }\n}",
      "choices": [
        "Major Magic Surge Detected!",
        "Energy levels stable.",
        "Error",
        "Nothing"
      ],
      "answer": [
        "Energy levels stable."
      ],
      "explanation": "The `boolean majorSurgeDetected = false;` line initializes the `majorSurgeDetected` variable to `false`. The `if (majorSurgeDetected)` condition checks if `majorSurgeDetected` is `true`. Since it's `false`, the `if` block is skipped, and the code inside the `else` block, `System.out.println(\"Energy levels stable.\");`, is executed."
    },
    "difficulty": "easy",
    "hints": {
      "1": "Consider the initial value assigned to the boolean variable.",
      "2": "An `if` statement's code block only runs if its condition evaluates to `true`.",
      "3": "If the `if` condition is `false`, the `else` block (if present) will execute."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 5,
    "subtopic_id": 1,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "An `OrbIdentifier` system assigns a unique ID to each magical orb. The `orbID` variable holds a single character. Your task is to trace the code and determine the full Orb ID that is displayed.",
      "code": "public class OrbIdentifier {\n    public static void main(String[] args) {\n        char orbID = 'A';\n        System.out.println(\"Orb ID: \" + orbID);\n    }\n}",
      "choices": [
        "A",
        "Orb ID: A",
        "Orb ID: orbID",
        "Error"
      ],
      "answer": [
        "Orb ID: A"
      ],
      "explanation": "The `char orbID = 'A';` line declares a character variable `orbID` and assigns it the single character `'A'`. The `System.out.println(\"Orb ID: \" + orbID);` statement uses string concatenation to combine the literal string `\"Orb ID: \"` with the value of the `orbID` variable. Thus, the output will be `Orb ID: A`."
    },
    "difficulty": "easy",
    "hints": {
      "1": "Identify the data type used for `orbID`.",
      "2": "Recall how characters are typically printed in Java.",
      "3": "The `+` symbol combines a literal string with the value of the variable."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 6,
    "subtopic_id": 1,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "An `ElementalInvocation` ritual is being performed. The `elementalCharge` is calculated by adding an `amplifier` value, and then the `amplifier` itself is reassigned. Your task is to trace the code and determine the final `Charge` and `Amplifier` values that are printed.",
      "code": "public class ElementalInvocation {\n    public static void main(String[] args) {\n        int elementalCharge = 25;\n        int amplifier = 5;\n        elementalCharge = elementalCharge + amplifier;\n        amplifier = 10;\n        System.out.println(\"Charge: \" + elementalCharge);\n        System.out.println(\"Amplifier: \" + amplifier);\n    }\n}",
      "choices": [
        "Charge: 25",
        "Amplifier: 5",
        "Charge: 30",
        "Amplifier: 10"
      ],
      "answer": [
        "Charge: 30",
        "Amplifier: 10"
      ],
      "explanation": "Initially, `elementalCharge` is `25` and `amplifier` is `5`. \n1. `elementalCharge = elementalCharge + amplifier;` calculates `25 + 5`, resulting in `30`. `elementalCharge` is now `30`.\n2. `amplifier = 10;` changes `amplifier` to `10`. This happens *after* `amplifier` was used in the `elementalCharge` calculation.\n3. The first `System.out.println()` prints \"Charge: 30\" (value of `elementalCharge`).\n4. The second `System.out.println()` prints \"Amplifier: 10\" (current value of `amplifier`)."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Trace the `elementalCharge` variable first, observing where its value changes.",
      "2": "Then, trace the `amplifier` variable. Notice when its value is used versus when it's updated.",
      "3": "Remember that `System.out.println()` outputs the *current* value of a variable at the time of execution."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 7,
    "subtopic_id": 1,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `ScrollInventory` system tracks different types of magical scrolls. The `illusionScrolls` count is updated based on `abjurationScrolls`. Your task is to trace the code and determine the final counts for both types of scrolls.",
      "code": "public class ScrollInventory {\n    public static void main(String[] args) {\n        int illusionScrolls = 10;\n        int abjurationScrolls = 5;\n        illusionScrolls = abjurationScrolls + 3; // Reassigns illusionScrolls\n        System.out.println(\"Illusion Scrolls: \" + illusionScrolls);\n        System.out.println(\"Abjuration Scrolls: \" + abjurationScrolls);\n    }\n}",
      "choices": [
        "Illusion Scrolls: 10",
        "Illusion Scrolls: 8",
        "Abjuration Scrolls: 5",
        "Abjuration Scrolls: 8"
      ],
      "answer": [
        "Illusion Scrolls: 8",
        "Abjuration Scrolls: 5"
      ],
      "explanation": "Initially, `illusionScrolls` is `10` and `abjurationScrolls` at `5`. \n1. The line `illusionScrolls = abjurationScrolls + 3;` first calculates `5 + 3`, which is `8`. It then assigns this `8` to `illusionScrolls`. So, `illusionScrolls` is now `8`.\n2. The value of `abjurationScrolls` remains `5` throughout the code.\n3. The first `System.out.println()` prints \"Illusion Scrolls: 8\".\n4. The second `System.out.println()` prints \"Abjuration Scrolls: 5\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Pay close attention to which variable is being reassigned in the line `illusionScrolls = abjurationScrolls + 3;`.",
      "2": "The value of `abjurationScrolls` is *read* for the calculation, but its own value is not *changed* by that line.",
      "3": "The two `System.out.println()` statements will print the current values of both variables independently."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 8,
    "subtopic_id": 1,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `TransmutationCharm` controls magical transformations. The `charmActive` status is copied to `canTransmute`, then `charmActive` is changed. Your task is to trace the code and determine the final states of both variables.",
      "code": "public class TransmutationCharm {\n    public static void main(String[] args) {\n        boolean charmActive = true;\n        boolean canTransmute = charmActive;\n        charmActive = false; // Charm becomes inactive\n        System.out.println(\"Can Transmute: \" + canTransmute);\n        System.out.println(\"Charm Active: \" + charmActive);\n    }\n}",
      "choices": [
        "Can Transmute: false",
        "Can Transmute: true",
        "Charm Active: false",
        "Charm Active: true"
      ],
      "answer": [
        "Can Transmute: true",
        "Charm Active: false"
      ],
      "explanation": "1. `charmActive` is initialized to `true`.\n2. `boolean canTransmute = charmActive;` means `canTransmute` is assigned the current value of `charmActive`, so `canTransmute` becomes `true`.\n3. `charmActive = false;` then changes `charmActive` to `false`. This only affects `charmActive`; `canTransmute` retains its `true` value from the assignment on line 2.\n4. The first `System.out.println()` prints \"Can Transmute: true\".\n5. The second `System.out.println()` prints \"Charm Active: false\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Variables store *copies* of values.",
      "2": "When `canTransmute = charmActive;` executes, `canTransmute` gets the *current* value of `charmActive`.",
      "3": "Subsequent changes to `charmActive` do not affect `canTransmute` because it already received its value."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 9,
    "subtopic_id": 1,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `ProphecyVerifier` calculates arcane numbers based on mystical entities. The `mythicalBeasts` count is affected by `ancientSecrets` through multiple operations. Your task is to trace the code and determine the final `Prophecy Number` and `Ancient Secrets Remaining`.",
      "code": "public class ProphecyVerifier {\n    public static void main(String[] args) {\n        int mythicalBeasts = 7;\n        int ancientSecrets = 3;\n        mythicalBeasts = mythicalBeasts * ancientSecrets; // First calculation\n        ancientSecrets = 5; // Reassigns ancientSecrets\n        mythicalBeasts = mythicalBeasts / ancientSecrets; // Second calculation\n        System.out.println(\"Prophecy Number: \" + mythicalBeasts);\n        System.out.println(\"Ancient Secrets Remaining: \" + ancientSecrets);\n    }\n}",
      "choices": [
        "Prophecy Number: 21",
        "Prophecy Number: 4",
        "Ancient Secrets Remaining: 3",
        "Ancient Secrets Remaining: 5"
      ],
      "answer": [
        "Prophecy Number: 4",
        "Ancient Secrets Remaining: 5"
      ],
      "explanation": "1. `mythicalBeasts` starts as `7`, `ancientSecrets` as `3`. \n2. `mythicalBeasts = mythicalBeasts * ancientSecrets;` becomes `mythicalBeasts = 7 * 3;`, so `mythicalBeasts` is now `21`. \n3. `ancientSecrets = 5;` changes `ancientSecrets` to `5`. \n4. `mythicalBeasts = mythicalBeasts / ancientSecrets;` becomes `mythicalBeasts = 21 / 5;`. In integer division, `21 / 5` is `4` (the remainder `1` is discarded). So `mythicalBeasts` is now `4`. \nFinally, `System.out.println(\"Prophecy Number: \" + mythicalBeasts);` prints `Prophecy Number: 4`."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Track the value of `mythicalBeasts` through each line of code.",
      "2": "Perform the calculations in the order they appear.",
      "3": "Remember that integer division (`/`) truncates the decimal part."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 10,
    "subtopic_id": 1,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `PortalNavigator` manages magical portal destinations. The `portalDestination` is initially set, then redirected to a `backupDestination`. The `backupDestination` is then updated separately. Your task is to trace the code and determine the final `Current Portal Destination` and `Next Backup Destination`.",
      "code": "public class PortalNavigator {\n    public static void main(String[] args) {\n        String portalDestination = \"Ethereal Realm\";\n        String backupDestination = \"Shadowfell\";\n        portalDestination = backupDestination; // Portal redirects\n        backupDestination = \"Astral Plane\"; // Backup is updated separately\n        System.out.println(\"Current Portal Destination: \" + portalDestination);\n        System.out.println(\"Next Backup Destination: \" + backupDestination);\n    }\n}",
      "choices": [
        "Current Portal Destination: Ethereal Realm",
        "Current Portal Destination: Shadowfell",
        "Next Backup Destination: Shadowfell",
        "Next Backup Destination: Astral Plane"
      ],
      "answer": [
        "Current Portal Destination: Shadowfell",
        "Next Backup Destination: Astral Plane"
      ],
      "explanation": "1. `portalDestination` is \"Ethereal Realm\", `backupDestination` is \"Shadowfell\".\n2. `portalDestination = backupDestination;` makes `portalDestination` take on the *current value* of `backupDestination`, which is \"Shadowfell\". So, `portalDestination` is now \"Shadowfell\".\n3. `backupDestination = \"Astral Plane\";` changes `backupDestination` to \"Astral Plane\". This change does not affect `portalDestination`, as `portalDestination` received a copy of the *value* of `backupDestination` from the previous line.\nTherefore, the output will be `Current Portal Destination: Shadowfell` and `Next Backup Destination: Astral Plane`."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Follow the value assigned to `portalDestination`.",
      "2": "When `portalDestination = backupDestination;`, `portalDestination` takes on the *current value* of `backupDestination`.",
      "3": "A later change to `backupDestination` does not change what `portalDestination` already received."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 11,
    "subtopic_id": 1,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `SpellManifestation` ritual is being performed. `rawMagic` is used to create `refinedMana`, then `rawMagic` changes. An `incantationPhrase` is combined with `refinedMana` to form a `finalIncantation`. Your task is to trace the code and determine the final `Current Raw Magic`, `Refined Mana`, and `Final Incantation` values that are printed.",
      "code": "public class SpellManifestation {\n    public static void main(String[] args) {\n        int rawMagic = 100;\n        int refinedMana = 50;\n        String incantationPhrase = \"Whisper of Elements\";\n\n        refinedMana = rawMagic / 2;\n\n        String finalIncantation = incantationPhrase + \" \" + refinedMana;\n\n        rawMagic = rawMagic - 70;\n\n        int remnantEnergy = rawMagic + 5;\n\n        System.out.println(\"Current Raw Magic: \" + rawMagic);\n        System.out.println(\"Refined Mana: \" + refinedMana);\n        System.out.println(\"Final Incantation: \" + finalIncantation);\n    }\n}",
      "choices": [
        "Current Raw Magic: 100",
        "Refined Mana: 50",
        "Final Incantation: Whisper of Elements 50",
        "Current Raw Magic: 30"
      ],
      "answer": [
        "Current Raw Magic: 30",
        "Refined Mana: 50",
        "Final Incantation: Whisper of Elements 50"
      ],
      "explanation": "1. `rawMagic` starts at `100`, `refinedMana` at `50`, `incantationPhrase` at \"Whisper of Elements\".\n2. `refinedMana = rawMagic / 2;` updates `refinedMana` to `100 / 2 = 50`.\n3. `String finalIncantation = incantationPhrase + \" \" + refinedMana;` concatenates \"Whisper of Elements\", a space, and the *current value* of `refinedMana` (which is `50`), resulting in `finalIncantation` being \"Whisper of Elements 50\".\n4. `rawMagic = rawMagic - 70;` updates `rawMagic` to `100 - 70 = 30`.\n5. `int remnantEnergy = rawMagic + 5;` updates `remnantEnergy` to `30 + 5 = 35`. This variable is calculated but not printed.\n6. The first `System.out.println()` prints \"Current Raw Magic: \" followed by the final `rawMagic` value (`30`).\n7. The second `System.out.println()` prints \"Refined Mana: \" followed by the final `refinedMana` value (`50`).\n8. The third `System.out.println()` prints \"Final Incantation: \" followed by `finalIncantation` (\"Whisper of Elements 50\")."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Follow each variable's value independently through every line of code, noting when it's assigned a new value.",
      "2": "Pay special attention to string concatenation (`+`) – it combines the literal string with the *value* of the variable at that moment.",
      "3": "Ensure you perform calculations in the correct order, especially when a variable is used *before* its own value is changed later."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 12,
    "subtopic_id": 1,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `RunicCompiler` processes magical runes. `runeCount` and `glyphID` are updated based on conditions involving `magicActive`. Your task is to trace the code and determine the final `Phase A`, `Phase B`, and `Phase C` outputs.",
      "code": "public class RunicCompiler {\n    public static void main(String[] args) {\n        int runeCount = 15;\n        char glyphID = 'X';\n        boolean magicActive = true;\n        \n        if (runeCount > 10) {\n            int localModifier = 5;\n            runeCount = runeCount + localModifier;\n            System.out.println(\"Phase A: \" + runeCount);\n            if (magicActive) {\n                glyphID = 'A';\n            }\n        } else {\n            runeCount = 5;\n        }\n\n        magicActive = !magicActive;\n\n        System.out.println(\"Phase B: \" + glyphID);\n        System.out.println(\"Phase C: \" + magicActive);\n    }\n}",
      "choices": [
        "Phase A: 15",
        "Phase A: 20",
        "Phase B: A",
        "Phase C: false"
      ],
      "answer": [
        "Phase A: 20",
        "Phase B: A",
        "Phase C: false"
      ],
      "explanation": "1. `runeCount` is `15`, `glyphID` is `'X'`, `magicActive` is `true`.\n2. `if (runeCount > 10)`: `15 > 10` is `true`.\n3. Inside the first `if` block:\n    * `int localModifier = 5;` declares a variable only visible in this block.\n    * `runeCount = runeCount + localModifier;` updates `runeCount` to `15 + 5 = 20`.\n    * `System.out.println(\"Phase A: \" + runeCount);` prints \"Phase A: 20\".\n    * `if (magicActive)`: `magicActive` is `true`.\n        * `glyphID = 'A';` updates `glyphID` to `'A'`.\n4. After the `if-else` structure, `magicActive = !magicActive;` flips `magicActive` from `true` to `false`.\n5. `System.out.println(\"Phase B: \" + glyphID);` prints \"Phase B: \" followed by the final `glyphID` (`'A'`).\n6. `System.out.println(\"Phase C: \" + magicActive);` prints \"Phase C: \" followed by the final `magicActive` value (`false`)."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Carefully trace `runeCount` and `glyphID` through the `if` blocks, noting when each variable is modified.",
      "2": "Remember that `localModifier` only exists within its specific `if` block.",
      "3": "The `!` operator flips the boolean value."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 13,
    "subtopic_id": 1,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `ArtifactAttunement` ritual determines the status of a magical artifact. `attunementScore` is calculated, then `activeGlyph` and `statusMessage` are conditionally updated. Your task is to trace the code and determine the `Final Score`, `Glyph Status`, and `Ritual Progress` outputs.",
      "code": "public class ArtifactAttunement {\n    public static void main(String[] args) {\n        double currentPower = 75.5;\n        int crystalPurity = 8;\n        String enchantmentType = \"Arcane\";\n        boolean activeGlyph = false;\n\n        double attunementScore = currentPower * crystalPurity / 10.0;\n\n        if (attunementScore > 60 && enchantmentType.equals(\"Arcane\")) {\n            activeGlyph = true;\n        }\n\n        String statusMessage = \"Attunement: \" + (activeGlyph ? \"Complete\" : \"Pending\");\n\n        if (activeGlyph) {\n            statusMessage = \"Attunement: Perfect\";\n        }\n        \n        int ritualProgress = (int) (attunementScore + crystalPurity);\n\n        System.out.println(\"Final Score: \" + attunementScore);\n        System.out.println(\"Glyph Status: \" + activeGlyph);\n        System.out.println(\"Ritual Progress: \" + ritualProgress + \"%\");\n    }\n}",
      "choices": [
        "Final Score: 60.4",
        "Glyph Status: true",
        "Ritual Progress: 68%",
        "Final Score: 75.5"
      ],
      "answer": [
        "Final Score: 60.4",
        "Glyph Status: true",
        "Ritual Progress: 68%"
      ],
      "explanation": "1. Variables initialized: `currentPower = 75.5`, `crystalPurity = 8`, `enchantmentType = \"Arcane\"`, `activeGlyph = false`.\n2. `attunementScore = currentPower * crystalPurity / 10.0;` calculates `75.5 * 8 = 604.0`, then `604.0 / 10.0 = 60.4`. So, `attunementScore` is `60.4`.\n3. `if (attunementScore > 60 && enchantmentType.equals(\"Arcane\"))`: `60.4 > 60` is `true`, AND `enchantmentType.equals(\"Arcane\")` is `true`. The condition is `true`.\n    * `activeGlyph = true;` updates `activeGlyph` to `true`.\n4. `String statusMessage = \"Attunement: \" + (activeGlyph ? \"Complete\" : \"Pending\");` evaluates `activeGlyph` (which is `true`), so `statusMessage` becomes \"Attunement: Complete\".\n5. `if (activeGlyph)`: This condition (`true`) is met.\n    * `statusMessage = \"Attunement: Perfect\";` updates `statusMessage` to \"Attunement: Perfect\".\n6. `int ritualProgress = (int) (attunementScore + crystalPurity);` calculates `60.4 + 8 = 68.4`. Casting to `int` truncates the decimal, so `ritualProgress` becomes `68`.\n7. **Output 1**: `System.out.println(\"Final Score: \" + attunementScore);` prints \"Final Score: 60.4\".\n8. **Output 2**: `System.out.println(\"Glyph Status: \" + activeGlyph);` prints \"Glyph Status: true\".\n9. **Output 3**: `System.out.println(\"Ritual Progress: \" + ritualProgress + \"%\");` prints \"Ritual Progress: 68%\"."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Calculate `attunementScore` precisely, noting the use of `10.0` for floating-point division.",
      "2": "Carefully evaluate the `if` condition involving `attunementScore` and `enchantmentType` to determine `activeGlyph`'s state.",
      "3": "Pay attention to the final values of all three variables being printed: `attunementScore`, `activeGlyph`, and `ritualProgress`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 14,
    "subtopic_id": 1,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `ScrollCataloger` organizes magical scrolls by `catalogID` and `volumeCount`, tracking if they are `damaged` or have a `legendaryMark`. Your task is to trace the code and determine the final `Catalog ID`, `Total Volume`, and `Is Collection Rare` outputs.",
      "code": "public class ScrollCataloger {\n    public static void main(String[] args) {\n        String baseID = \"ARC-\";\n        int volumeCount = 20;\n        boolean isDamaged = false;\n        boolean hasLegendaryMark = true;\n\n        String catalogID = baseID + volumeCount;\n\n        if (isDamaged || hasLegendaryMark) {\n            boolean rareScroll = hasLegendaryMark;\n            if (volumeCount > 15 && rareScroll) {\n                catalogID = catalogID + \"-LEGEND\";\n            }\n            System.out.println(\"Catalog ID: \" + catalogID);\n        } else {\n            System.out.println(\"Regular Scroll.\");\n        }\n\n        volumeCount = volumeCount * 2;\n        boolean isRare = hasLegendaryMark && !isDamaged;\n\n        System.out.println(\"Total Volume: \" + volumeCount);\n        System.out.println(\"Is Collection Rare: \" + isRare);\n    }\n}",
      "choices": [
        "Catalog ID: ARC-20",
        "Catalog ID: ARC-20-LEGEND",
        "Total Volume: 40",
        "Is Collection Rare: true"
      ],
      "answer": [
        "Catalog ID: ARC-20-LEGEND",
        "Total Volume: 40",
        "Is Collection Rare: true"
      ],
      "explanation": "1. Variables initialized: `baseID = \"ARC-\"`, `volumeCount = 20`, `isDamaged = false`, `hasLegendaryMark = true`.\n2. `catalogID = baseID + volumeCount;` sets `catalogID` to \"ARC-20\".\n3. `if (isDamaged || hasLegendaryMark)`: `false || true` evaluates to `true`. So the block is entered.\n    * `boolean rareScroll = hasLegendaryMark;` sets `rareScroll` to `true`.\n    * `if (volumeCount > 15 && rareScroll)`: `20 > 15` is `true`, AND `rareScroll` (`true`) is `true`. The condition is `true`.\n        * `catalogID = catalogID + \"-LEGEND\";` appends \"-LEGEND\", making `catalogID` \"ARC-20-LEGEND\".\n    * `System.out.println(\"Catalog ID: \" + catalogID);` prints \"Catalog ID: ARC-20-LEGEND\".\n4. The `else` block for the first `if` is skipped.\n5. `volumeCount = volumeCount * 2;` updates `volumeCount` to `20 * 2 = 40`.\n6. `boolean isRare = hasLegendaryMark && !isDamaged;` evaluates `true && !false` which is `true && true`, so `isRare` becomes `true`.\n7. `System.out.println(\"Total Volume: \" + volumeCount);\n` prints \"Total Volume: 40\".\n8. `System.out.println(\"Is Collection Rare: \" + isRare);` prints \"Is Collection Rare: true\"."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Trace `catalogID` carefully; it's initialized and then potentially modified inside an `if` block.",
      "2": "Follow `volumeCount` through its initial value and subsequent calculation.",
      "3": "Determine `isRare` by evaluating the final states of `hasLegendaryMark` and `isDamaged` and their logical `&&` operation."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 15,
    "subtopic_id": 1,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "An `ElementalConduit` manages magical `flowRate` and `conduitState`. A `stabilizerEngaged` flag is conditionally set, and `flowRate` is adjusted. Your task is to trace the code and determine the `Final Flow Rate`, `Conduit State`, and `Stabilizer Engaged` status.",
      "code": "public class ElementalConduit {\n    public static void main(String[] args) {\n        int flowRate = 200;\n        String conduitState = \"Open\";\n        boolean stabilizerEngaged = false;\n        \n        if (flowRate > 150) {\n            flowRate = flowRate / 2;\n            if (conduitState.equals(\"Open\")) {\n                stabilizerEngaged = true;\n                conduitState = \"Stabilized\";\n            } else {\n                stabilizerEngaged = false;\n            }\n        } else {\n            flowRate = flowRate + 50;\n        }\n\n        conduitState = conduitState + \"!\";\n\n        if (stabilizerEngaged) {\n            flowRate = flowRate + 50;\n        }\n\n        System.out.println(\"Final Flow Rate: \" + flowRate);\n        System.out.println(\"Conduit State: \" + conduitState);\n        System.out.println(\"Stabilizer Engaged: \" + stabilizerEngaged);\n    }\n}",
      "choices": [
        "Final Flow Rate: 100",
        "Final Flow Rate: 150",
        "Conduit State: Stabilized!",
        "Stabilizer Engaged: true"
      ],
      "answer": [
        "Final Flow Rate: 150",
        "Conduit State: Stabilized!",
        "Stabilizer Engaged: true"
      ],
      "explanation": "1. Variables initialized: `flowRate = 200`, `conduitState = \"Open\"`, `stabilizerEngaged = false`.\n2. `if (flowRate > 150)`: `200 > 150` is `true`. Block is entered.\n    * `flowRate = flowRate / 2;` updates `flowRate` to `200 / 2 = 100`.\n    * `if (conduitState.equals(\"Open\"))`: `\"Open\".equals(\"Open\")` is `true`. Nested block is entered.\n        * `stabilizerEngaged = true;` updates `stabilizerEngaged` to `true`.\n        * `conduitState = \"Stabilized\";` updates `conduitState` to \"Stabilized\".\n3. After the initial `if-else` block:\n    * `conduitState = conduitState + \"!\";` concatenates \"!\" to `conduitState`, making it \"Stabilized!\".\n4. `if (stabilizerEngaged)`: `stabilizerEngaged` is `true`. Block is entered.\n    * `flowRate = flowRate + 50;` updates `flowRate` to `100 + 50 = 150`.\n5. **Output 1**: `System.out.println(\"Final Flow Rate: \" + flowRate);` prints \"Final Flow Rate: 150\".\n6. **Output 2**: `System.out.println(\"Conduit State: \" + conduitState);` prints \"Conduit State: Stabilized!\".\n7. **Output 3**: `System.out.println(\"Stabilizer Engaged: \" + stabilizerEngaged);` prints \"Stabilizer Engaged: true\"."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Carefully follow `flowRate` through its initial calculation in the first `if` and its final adjustment based on `stabilizerEngaged`.",
      "2": "Track `conduitState` through both its assignment within the nested `if` and its final concatenation.",
      "3": "Determine the final state of `stabilizerEngaged` by evaluating its assignment within the nested `if` block."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 16,
    "subtopic_id": 1,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `ManaCounter` is being used to track magical crystals. However, the code attempts to print the `manaCrystals` variable before it has been declared, causing a compilation error. Fix the code to ensure `manaCrystals` is declared before it's used.",
      "code": "public class ManaCounter {\n    public static void main(String[] args) {\n        System.out.println(\"Mana Crystals: \" + manaCrystals);\n        int manaCrystals = 10;\n    }\n}",
      "expected_output": [
        "Mana Crystals: 10"
      ],
      "hidden_test_case": "",
      "explanation": "The original code attempted to print `manaCrystals` *before* the variable was declared. In Java, all variables must be declared before they are used. The fix involves simply moving the `int manaCrystals = 10;` line *before* the `System.out.println()` statement, ensuring the variable exists when it's referenced."
    },
    "difficulty": "easy",
    "hints": {
      "1": "In Java, a variable must be introduced before it can be used.",
      "2": "Think about the order of operations: declaration first, then usage.",
      "3": "Imagine trying to grab something that hasn't been placed on a shelf yet."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 17,
    "subtopic_id": 1,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `PotionMixer` tracks the `PotionStrength` of a brew. However, the variable name `PotionStrength` has inconsistent casing, which can cause issues in Java. Fix the code to follow Java's camelCase naming convention for variables.",
      "code": "public class PotionMixer {\n    public static void main(String[] args) {\n        int PotionStrength = 50;\n        System.out.println(\"Potion Strength: \" + PotionStrength);\n    }\n}",
      "expected_output": [
        "Potion Strength: 50"
      ],
      "hidden_test_case": "",
      "explanation": "The variable `PotionStrength` was declared with an uppercase 'P' but usually, Java variable names start with a lowercase letter (camelCase convention). While not strictly a compilation error unless used inconsistently, it's bad practice and could lead to confusion. The primary error here is that the compiler would likely throw an error if the `System.out.println` used `potionStrength` (lowercase 'p') while the declaration used `PotionStrength` (uppercase 'P'). The fix ensures both declaration and usage match the standard camelCase convention: `potionStrength`."
    },
    "difficulty": "easy",
    "hints": {
      "1": "Java is case-sensitive, meaning `PotionStrength` is different from `potionStrength`.",
      "2": "Follow Java's common naming convention for variables (camelCase).",
      "3": "Ensure the variable name is consistent everywhere it's used."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 18,
    "subtopic_id": 1,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `GolemController` manages the number of active `golemCount`. The code has a syntax error, as a statement is missing its terminator. Fix the code to ensure the `golemCount` variable is correctly declared.",
      "code": "public class GolemController {\n    public static void main(String[] args) {\n        int golemCount = 3\n        System.out.println(\"Active Golems: \" + golemCount);\n    }\n}",
      "expected_output": [
        "Active Golems: 3"
      ],
      "hidden_test_case": "",
      "explanation": "In Java, every statement must end with a semicolon (`;`). The faulty code was missing the semicolon after `int golemCount = 3`. Adding the semicolon makes the syntax correct, allowing the program to compile and run properly."
    },
    "difficulty": "easy",
    "hints": {
      "1": "Most statements in Java need a specific character to mark their end.",
      "2": "Think of it as a period at the end of a sentence.",
      "3": "Look for where one statement transitions to the next."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 19,
    "subtopic_id": 1,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "An `EssenceCollector` attempts to track `magicEssence`. However, the variable `magicEssence` is declared twice in the same scope, which is not allowed in Java. Fix the code to correctly update the `magicEssence` variable.",
      "code": "public class EssenceCollector {\n    public static void main(String[] args) {\n        int magicEssence = 20;\n        int magicEssence = 30; // Problem here: duplicate declaration\n        System.out.println(\"Collected Essence: \" + magicEssence);\n    }\n}",
      "expected_output": [
        "Collected Essence: 30"
      ],
      "hidden_test_case": "",
      "explanation": "The original code attempted to declare `magicEssence` twice using the `int` keyword, which is not allowed in the same scope. Once a variable is declared, you simply reassign its value if you want to change it. The fix removes the redundant `int` keyword from the second line, making it a proper reassignment `magicEssence = 30;`."
    },
    "difficulty": "easy",
    "hints": {
      "1": "A variable only needs to be declared once in its scope.",
      "2": "If you want to change a variable's value after its initial declaration, you just assign a new value.",
      "3": "Look for the repeated use of the `int` keyword for the same variable."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 20,
    "subtopic_id": 1,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `CharmActivator` sets the `isActivated` status. However, the `isActivated` variable is used before it is initialized, causing a compilation error. Fix the code to initialize `isActivated` before it's accessed.",
      "code": "public class CharmActivator {\n    public static void main(String[] args) {\n        boolean isActivated;\n        System.out.println(\"Charm Status: \" + isActivated);\n    }\n}",
      "expected_output": [
        "Charm Status: false"
      ],
      "hidden_test_case": "",
      "explanation": "The error occurs because `isActivated` is a local variable declared inside `main()` but not initialized before being used in the `System.out.println()`. Local variables in Java must be explicitly assigned a value before they can be used. The fix initializes `isActivated` to `false` (or `true`), resolving the compilation error."
    },
    "difficulty": "easy",
    "hints": {
      "1": "Local variables in Java don't get a default value automatically.",
      "2": "Before you use a variable in a calculation or print it, it needs to hold something.",
      "3": "Consider what a common starting state for a boolean might be if not explicitly known."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 21,
    "subtopic_id": 1,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `CharmActivator` sets the `isActivated` status. However, the `isActivated` variable is used before it is initialized, causing a compilation error. Fix the code to initialize `isActivated` before it's accessed.",
      "code": "public class CharmActivator {\n    public static void main(String[] args) {\n        boolean isActivated;\n        System.out.println(\"Charm Status: \" + isActivated);\n    }\n}",
      "expected_output": [
        "Charm Status: false"
      ],
      "hidden_test_case": "",
      "explanation": "The error occurs because `isActivated` is a local variable declared inside `main()` but not initialized before being used in the `System.out.println()`. Local variables in Java must be explicitly assigned a value before they can be used. The fix initializes `isActivated` to `false` (or `true`), resolving the compilation error."
    },
    "difficulty": "easy",
    "hints": {
      "1": "Local variables in Java don't get a default value automatically.",
      "2": "Before you use a variable in a calculation or print it, it needs to hold something.",
      "3": "Consider what a common starting state for a boolean might be if not explicitly known."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 22,
    "subtopic_id": 1,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "An `UltimateSpellCaster` is preparing to cast a powerful spell. The `ultimateSpellName` variable is assigned conditionally, but Java's compiler is being conservative about its initialization, causing an error. Fix the code to ensure `ultimateSpellName` is always initialized.",
      "code": "public class UltimateSpellCaster {\n    public static void main(String[] args) {\n        String ultimateSpellName;\n        if (true) {\n            ultimateSpellName = \"Oblivion Gate\";\n        }\n        System.out.println(\"Casting: \" + ultimateSpellName);\n    }\n}",
      "expected_output": [
        "Casting: Oblivion Gate"
      ],
      "hidden_test_case": "",
      "explanation": "Even though the `if (true)` condition ensures `ultimateSpellName` *will* be assigned, Java's compiler is conservative about local variable initialization. It doesn't analyze runtime logic and instead requires a static guarantee that the variable is initialized before any possible use. By initializing `ultimateSpellName` to `null` (or any default string) at the point of its declaration, we satisfy the compiler's requirement, ensuring it always has a value before `System.out.println()` attempts to use it."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Variables declared inside `if` blocks or loops are *local* to those blocks.",
      "2": "Java needs a guarantee that a local variable *will* definitely be assigned a value before it's used, regardless of conditional paths.",
      "3": "Consider what initial value `ultimateSpellName` holds if the `if` block hypothetically didn't run."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 23,
    "subtopic_id": 1,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "An `ElixirDensityCalculator` measures the density of a magical elixir. The `elixirDensity` variable is declared as a `float`, but the literal value assigned to it is treated as a `double` by default, causing a potential loss of precision. Fix the code to ensure the `float` variable correctly stores the decimal value.",
      "code": "public class ElixirDensityCalculator {\n    public static void main(String[] args) {\n        float elixirDensity = 3.1415926535;\n        System.out.println(\"Elixir Density: \" + elixirDensity);\n    }\n}",
      "expected_output": [
        "Elixir Density: 3.1415926535"
      ],
      "hidden_test_case": "",
      "explanation": "In Java, floating-point literals (numbers with decimal points like `3.14`) are treated as `double` by default. When you try to assign such a literal directly to a `float` variable without casting or explicit `f` suffix, it can cause a \"possible lossy conversion\" error or silently truncate precision. The `float` type is single-precision (32-bit), while `double` is double-precision (64-bit), offering more accuracy. Changing `float` to `double` for `elixirDensity` ensures that the full precision of the literal is retained."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Not all floating-point data types offer the same level of decimal accuracy.",
      "2": "Consider which primitive type in Java is specifically designed for *double precision*.",
      "3": "The value `3.1415926535` itself is by default interpreted as a specific floating-point type."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 24,
    "subtopic_id": 1,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `PortalConfigurator` attempts to set `destinationCoordinates` for a magical portal. However, the value assigned is a string, while the variable is declared as a `char`, leading to a type mismatch. Fix the code to correctly store the portal's destination.",
      "code": "public class PortalConfigurator {\n    public static void main(String[] args) {\n        char destinationCoordinates = \"XYZ-789\";\n        System.out.println(\"Portal Destination: \" + destinationCoordinates);\n    }\n}",
      "expected_output": [
        "Portal Destination: XYZ-789"
      ],
      "hidden_test_case": "",
      "explanation": "The `char` data type in Java is used to store a single character, enclosed in single quotes (e.g., `'A'`). The literal `\"XYZ-789\"` is a sequence of characters, which constitutes a `String`. Trying to assign a `String` literal to a `char` variable results in a type mismatch compilation error. The fix is to change the data type of `destinationCoordinates` from `char` to `String`."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Characters are single symbols; sequences of characters form a different type.",
      "2": "Think about the difference between single quotes (`' '`) and double quotes (`\" \"`).",
      "3": "Recall the non-primitive data type commonly used for text in Java."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 25,
    "subtopic_id": 1,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "An `OrbTally` counts `arcaneOrbs`. However, a decimal value is assigned to an `int` variable, causing a compilation error due to potential data loss. Fix the code to correctly store the count of `arcaneOrbs`.",
      "code": "public class OrbTally {\n    public static void main(String[] args) {\n        int arcaneOrbs = 7.5;\n        System.out.println(\"Arcane Orbs: \" + arcaneOrbs);\n    }\n}",
      "expected_output": [
        "Arcane Orbs: 7"
      ],
      "hidden_test_case": "",
      "explanation": "The `int` data type is used for whole numbers. Attempting to assign a decimal value (like `7.5`) directly to an `int` variable results in a \"possible lossy conversion\" error because Java doesn't implicitly truncate floating-point numbers to integers. The simplest fix, assuming `arcaneOrbs` must remain an integer, is to provide a whole number value. If the decimal was truly intended, the variable's type would need to be changed to `double` or `float`."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Integer types can only store whole numbers.",
      "2": "Decimal numbers require a floating-point data type.",
      "3": "Consider whether the intent is to have a whole number count or a precise decimal value."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 26,
    "subtopic_id": 1,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `GolemGuardian` is designed to monitor and report its status. However, the `guardianStatus` variable is declared within an `if` block, making it inaccessible outside, leading to a compilation error. Fix the code to ensure `guardianStatus` can be printed after the conditional check.",
      "code": "public class GolemGuardian {\n    public static void main(String[] args) {\n        if (true) {\n            String guardianStatus = \"Awake\";\n        }\n        System.out.println(\"Guardian State: \" + guardianStatus);\n    }\n}",
      "expected_output": [
        "Guardian State: Awake"
      ],
      "hidden_test_case": "",
      "explanation": "The `guardianStatus` variable was declared inside the `if` block. This means its scope is limited to that block, making it inaccessible outside of it, leading to a \"cannot find symbol\" error when `System.out.println()` tries to use it. The fix moves the declaration of `guardianStatus` outside the `if` block (e.g., at the beginning of the `main` method), giving it a wider scope, and then it can be reassigned inside the `if` block."
    },
    "difficulty": "medium",
    "hints": {
      "1": "A variable's \"scope\" defines where it can be seen and used in your code.",
      "2": "Variables declared inside curly braces `{}` are generally only visible within those braces.",
      "3": "To make a variable accessible in a larger block, it needs to be declared in that larger block."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 27,
    "subtopic_id": 1,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `PotionRegistry` attempts to extract an `essenceValue` from a `masterPotion` which is a `String` object. However, directly casting a `String` to an `int` is not allowed in Java, causing a compilation error. Fix the code to assign a numerical `essenceValue` correctly.",
      "code": "public class PotionRegistry {\n    public static void main(String[] args) {\n        Object masterPotion = \"Elixir of Life\";\n        int essenceValue = (int) masterPotion;\n        System.out.println(\"Potion Essence: \" + essenceValue);\n    }\n}",
      "expected_output": [
        "Potion Essence: 75"
      ],
      "hidden_test_case": "",
      "explanation": "The fundamental error is attempting to directly cast a `String` object (which \"Elixir of Life\" is) to an `int` primitive type using `(int) masterPotion`. Java does not allow this direct, incompatible conversion. `Object` is a supertype, but it doesn't magically enable type conversions. If `essenceValue` is intended to be a numerical representation of the potion's essence, it must be assigned a numerical literal or derived from a numerical source. The fix shows assigning the numerical value directly, as `masterPotion` as an `Object` holding a `String` cannot yield an `int` through casting."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Remember that `Object` is a very general type; it doesn't mean you can arbitrarily convert its contained value to any other type.",
      "2": "Strings represent text, not raw numbers, even if they *look* like numbers. Direct casting from `String` to `int` is not allowed.",
      "3": "Consider the actual type of data `essenceValue` is meant to hold and assign it directly, or use parsing if the intent was to extract a number from a string."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 28,
    "subtopic_id": 1,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `ScrollArchive` manages `ancientScrolls`. Inside an `if` block, a new variable with the same name `ancientScrolls` is declared, unintentionally shadowing the outer variable and preventing its update. Fix the code to ensure the outer `ancientScrolls` variable is correctly modified.",
      "code": "public class ScrollArchive {\n    public static void main(String[] args) {\n        int ancientScrolls = 50;\n        \n        if (ancientScrolls > 40) {\n            int ancientScrolls = 20;\n            System.out.println(\"Vault Scrolls: \" + ancientScrolls);\n        }\n        System.out.println(\"Total Ancient Scrolls: \" + ancientScrolls);\n    }\n}",
      "expected_output": [
        "Vault Scrolls: 20",
        "Total Ancient Scrolls: 20"
      ],
      "hidden_test_case": "",
      "explanation": "The error is a classic case of **variable shadowing**. Inside the `if` block, `int ancientScrolls = 20;` declares a *new*, local variable also named `ancientScrolls`, which *shadows* (hides) the outer `ancientScrolls` variable within that specific `if` block. Therefore, the outer `ancientScrolls` (which remained `50`) was never updated. The fix involves removing the `int` keyword from the line inside the `if` block, turning it into a simple reassignment (`ancientScrolls = 20;`) that correctly modifies the outer variable."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Variables declared inside a block (like an `if` statement's curly braces) are distinct from variables with the same name declared in an outer block.",
      "2": "If you want to modify an existing variable from an outer scope, you should not redeclare it with the data type keyword (`int`, `String`, etc.).",
      "3": "Observe where the `int` keyword is used for `ancientScrolls` inside the `if` block."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 29,
    "subtopic_id": 1,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `FateInscriber` records a `fateMessage` that is intended to be unchangeable after its initial inscription. However, the code attempts to reassign `fateMessage`, which should not be allowed for a constant. Fix the code to declare `fateMessage` as a constant and prevent its reassignment.",
      "code": "public class FateInscriber {\n    public static void main(String[] args) {\n        String fateMessage = \"Prophecy of Dawn\";\n        System.out.println(\"Initial Fate: \" + fateMessage);\n        \n        fateMessage = \"Prophecy of Dusk\";\n        System.out.println(\"Altered Fate: \" + fateMessage);\n    }\n}",
      "expected_output": [
        "Initial Fate: Prophecy of Dawn",
        "Altered Fate (unchanged): Prophecy of Dawn"
      ],
      "hidden_test_case": "",
      "explanation": "The problem implies that `fateMessage` *should* be a constant, but `String fateMessage = \"Prophecy of Dawn\";` only declares a regular variable, which can be reassigned. The `final` keyword in Java is used to declare a constant; once a `final` variable is initialized, its value cannot be changed. The fix involves adding the `final` keyword to the declaration: `final String fateMessage = \"Prophecy of Dawn\";`. To achieve the desired immutable behavior, the line attempting to reassign `fateMessage` must then be removed or commented out, as it would cause a compilation error with `final`. The expected output reflects the `final` value not changing."
    },
    "difficulty": "hard",
    "hints": {
      "1": "There's a special keyword in Java to ensure a variable's value cannot be changed after initialization.",
      "2": "Think about variables whose values are fixed or immutable.",
      "3": "The goal is to enforce \"one time assignment\" for `fateMessage`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 30,
    "subtopic_id": 1,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "An `EnergyManifestation` ritual calculates `manifestedEnergy` from `initialCharge` and `energyFactor`. However, the code incorrectly casts `energyFactor` prematurely, leading to a loss of decimal precision in the `manifestedEnergy` calculation. Fix the code to preserve floating-point precision in the calculation.",
      "code": "public class EnergyManifestation {\n    public static void main(String[] args) {\n        int initialCharge = 7;\n        double energyFactor = 2.5;\n        int manifestedEnergy = initialCharge * (int)energyFactor;\n        System.out.println(\"Manifested Energy: \" + manifestedEnergy);\n    }\n}",
      "expected_output": [
        "Manifested Energy: 17.5"
      ],
      "hidden_test_case": "",
      "explanation": "The original code explicitly cast `energyFactor` to `int` (`(int)energyFactor`), which truncated `2.5` to `2`. Then, `initialCharge * 2` resulted in `14`, an integer. Even if `manifestedEnergy` was a `double`, the damage to precision was already done by the cast. To retain precision, the multiplication should happen between at least one floating-point number, and the result should be stored in a floating-point type (`double` or `float`). By removing the unnecessary cast and declaring `manifestedEnergy` as `double`, Java's type promotion rules ensure the calculation `7 * 2.5` yields `17.5`, which is then correctly stored."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Integer arithmetic (even with a cast to integer) will always produce an integer result, losing decimals.",
      "2": "To retain decimal precision in a calculation involving different numeric types, the result must be stored in a type capable of holding decimals.",
      "3": "Consider Java's rules for *type promotion* in arithmetic operations."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 31,
    "subtopic_id": 1,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `GlyphIndexer` system generates unique IDs for magical glyphs by combining a `prefix` with a `code`. The `glyphIdentifier` variable is intended to store this combined text. Complete the declaration of `glyphIdentifier` to correctly store the combined text.",
      "code": "public class GlyphIndexer {\n    public static void main(String[] args) {\n        int code = 42;\n        String prefix = \"Code \";\n        ??? glyphIdentifier = prefix + code;\n        System.out.println(\"Glyph ID: \" + glyphIdentifier);\n    }\n}",
      "choices": [
        "String",
        "int",
        "double",
        "char"
      ],
      "answer": [
        "String"
      ],
      "explanation": "The result of `prefix + code` (string concatenation) is a `String`. Therefore, `glyphIdentifier` must be declared as a `String` type to correctly store this combined textual value. The blank requires the data type for the `glyphIdentifier` variable."
    },
    "difficulty": "easy",
    "hints": {
      "1": "When a `String` is combined with a number using `+`, the result is always a `String`.",
      "2": "What data type is needed to hold a sequence of characters like \"Code 42\"?",
      "3": "The blank needs a keyword to declare the variable's type."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 32,
    "subtopic_id": 1,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `FireballSpell` is being prepared, and its `spellPower` needs to be declared to hold an integer value. Complete the declaration of the `spellPower` variable.",
      "code": "public class FireballSpell {\n    public static void main(String[] args) {\n        ??? spellPower = 15;\n        System.out.println(\"Fireball Power: \" + spellPower);\n    }\n}",
      "choices": [
        "int",
        "String",
        "double",
        "char"
      ],
      "answer": [
        "int"
      ],
      "explanation": "The variable `spellPower` is intended to hold a whole number (`15`). The `int` data type is used in Java to store integer (whole number) values. Therefore, `int` is the correct keyword to complete the declaration."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The variable `spellPower` is meant to hold a whole number.",
      "2": "Consider the data type for integer (whole number) values in Java.",
      "3": "What keyword is used before the variable name to declare its type?"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 33,
    "subtopic_id": 1,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `NewIncantation` is discovered and its `spellName` needs to be declared to store the text of the incantation. Complete the declaration of the `spellName` variable.",
      "code": "public class NewIncantation {\n    public static void main(String[] args) {\n        ??? spellName = \"Whisper of Aether\";\n        System.out.println(\"New Spell: \" + spellName);\n    }\n}",
      "choices": [
        "char",
        "boolean",
        "String",
        "int"
      ],
      "answer": [
        "String"
      ],
      "explanation": "The value `\"Whisper of Aether\"` is a literal string, a sequence of characters. In Java, the `String` class is used to represent text. Therefore, `String` is the correct data type to declare `spellName` to hold this value."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The value assigned (`\"Whisper of Aether\"`) is a sequence of characters.",
      "2": "Recall the data type specifically designed for storing text in Java.",
      "3": "Notice the use of double quotes for the value."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 34,
    "subtopic_id": 1,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `RelicStatusMonitor` tracks whether a relic is active. The `isActive` variable needs to be declared as a boolean and initialized to `true`. Complete the declaration and initialization.",
      "code": "public class RelicStatusMonitor {\n    public static void main(String[] args) {\n        boolean ??? = ???;\n        System.out.println(\"Relic Active: \" + isActive);\n    }\n}",
      "choices": [
        "isActive",
        "false",
        "true",
        "relicState"
      ],
      "answer": [
        "isActive",
        "true"
      ],
      "explanation": "The `System.out.println()` statement clearly shows that the variable to be declared should be named `isActive`. The scenario specifies that the relic should initially be set to `true`. Therefore, the correct completion is `isActive = true;`."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The print statement indicates the variable should be named `isActive`.",
      "2": "The scenario states the relic's initial status should be `true`.",
      "3": "Remember how boolean values are written in Java."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 35,
    "subtopic_id": 1,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `RuneCreator` assigns a single symbol to `runeSymbol`. Complete the declaration and initialization of `runeSymbol` to store the character 'F'.",
      "code": "public class RuneCreator {\n    public static void main(String[] args) {\n        ??? = ???;\n        System.out.println(\"Rune Symbol: \" + runeSymbol);\n    }\n}",
      "choices": [
        "char runeSymbol",
        "String runeSymbol",
        "'F'",
        "\"F\""
      ],
      "answer": [
        "char runeSymbol",
        "'F'"
      ],
      "explanation": "The variable `runeSymbol` is meant to store a single character, `'F'`. The `char` data type is used for single characters in Java, and character literals are enclosed in single quotes. Therefore, `char runeSymbol` and `'F'` are the correct completions."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The variable `runeSymbol` should hold a single character.",
      "2": "Recall the data type used for single characters in Java.",
      "3": "How are single character literals typically enclosed in Java code?"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 36,
    "subtopic_id": 1,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `PotionVolumeTracker` measures the `potionVolume`. The `potionVolume` variable needs to be declared to store a decimal value. Complete the declaration.",
      "code": "public class PotionVolumeTracker {\n    public static void main(String[] args) {\n        ??? potionVolume = 7.25;\n        System.out.println(\"Potion Volume: \" + potionVolume);\n    }\n}",
      "choices": [
        "int",
        "float",
        "long",
        "double"
      ],
      "answer": [
        "double"
      ],
      "explanation": "The value `7.25` is a decimal number (a floating-point literal). In Java, `double` is the default and most commonly used data type for floating-point numbers due to its higher precision. While `float` could also store it (with an `f` suffix), `double` is the direct and generally preferred type for such literals."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The value `7.25` contains a decimal point.",
      "2": "Recall the data type that typically handles floating-point numbers with high precision.",
      "3": "Floating-point literals in Java are `double` by default unless specified otherwise."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 37,
    "subtopic_id": 1,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `ScrollEvaluator` checks the condition of a magical scroll. The `scrollCondition` variable needs to be declared and initialized to hold a character representing its status, and `isPristine` needs to be declared as a boolean.",
      "code": "public class ScrollEvaluator {\n    public static void main(String[] args) {\n        ??? scrollCondition = ???;\n        boolean isPristine;\n\n        if (scrollCondition == '0') {\n            isPristine = true;\n        } else {\n            isPristine = false;\n        }\n        System.out.println(\"Scroll Condition: \" + scrollCondition);\n        System.out.println(\"Is Pristine: \" + isPristine);\n    }\n}",
      "choices": [
        "char",
        "String",
        "'0'",
        "0"
      ],
      "answer": [
        "char",
        "'0'"
      ],
      "explanation": "The `scrollCondition` variable is meant to store a single character, as implied by its comparison with `'0'`. Therefore, `char` is the correct primitive type. To assign the character `0` as a literal, it must be enclosed in single quotes (`'0'`)."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The variable `scrollCondition` is expected to hold a single character.",
      "2": "The value `0` should be treated as a character, not a number.",
      "3": "How do you denote a character literal in Java?"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 38,
    "subtopic_id": 1,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `GolemCrafter` system manages the `golemWeight`. The `golemWeight` variable needs to be declared as a `float` to store a specific floating-point literal. Complete the declaration.",
      "code": "public class GolemCrafter {\n    public static void main(String[] args) {\n        ??? = 500.0f;\n        System.out.println(\"Golem Weight: \" + golemWeight);\n    }\n}",
      "choices": [
        "double golemWeight",
        "float golemWeight",
        "int golemWeight",
        "long golemWeight"
      ],
      "answer": [
        "float golemWeight"
      ],
      "explanation": "The literal `500.0f` is explicitly a `float` literal due to the `f` suffix. Without this suffix, `500.0` would be treated as a `double` by default. To correctly declare a variable that can hold this specific type of floating-point number, the `float` data type must be used."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Notice the `f` suffix on the numerical literal.",
      "2": "This suffix explicitly designates the literal as a specific primitive floating-point type.",
      "3": "The variable name is `golemWeight`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 39,
    "subtopic_id": 1,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `ChargeCalculator` determines the `arcaneCharge` based on `baseCharge` and a `multiplier`. Complete the declaration of `arcaneCharge` to correctly store the result of the multiplication.",
      "code": "public class ChargeCalculator {\n    public static void main(String[] args) {\n        int baseCharge = 25;\n        int multiplier = 3;\n        ??? = baseCharge * multiplier;\n        System.out.println(\"Arcane Charge: \" + arcaneCharge);\n    }\n}",
      "choices": [
        "arcaneCharge",
        "int arcaneCharge",
        "double arcaneCharge",
        "String arcaneCharge"
      ],
      "answer": [
        "int arcaneCharge"
      ],
      "explanation": "The expression `baseCharge * multiplier` (`25 * 3`) results in `75`, which is an integer. Therefore, `int` is the appropriate primitive data type for `arcaneCharge`. The blank requires both the type and the variable name, so `int arcaneCharge` is the correct completion."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The result of `int * int` multiplication is always an `int`.",
      "2": "The missing part requires both the type and name for the `arcaneCharge` variable.",
      "3": "Ensure the chosen type can hold a whole number."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 40,
    "subtopic_id": 1,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `GolemTracker` records a `locationCode` based on an `asciiValue`. Complete the declaration and type casting to correctly convert the integer `asciiValue` into a `char` for `locationCode`.",
      "code": "public class GolemTracker {\n    public static void main(String[] args) {\n        int asciiValue = 90;\n        ??? = ???;\n        System.out.println(\"Golem Location: \" + locationCode);\n    }\n}",
      "choices": [
        "char locationCode",
        "int locationCode",
        "(char) asciiValue",
        "asciiValue"
      ],
      "answer": [
        "char locationCode",
        "(char) asciiValue"
      ],
      "explanation": "The `locationCode` is intended to be a character, derived from an integer ASCII value. The `char` primitive type (choice a) is used for characters. To convert an `int` to a `char` explicitly, a type cast `(char)` is required, applying it to `asciiValue` (choice c). Thus, `char locationCode = (char) asciiValue;` correctly initializes the variable."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The `locationCode` is intended to be a character.",
      "2": "An integer (`asciiValue`) needs to be converted to a character explicitly.",
      "3": "Recall the syntax for explicit type casting."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 41,
    "subtopic_id": 1,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `ManaOverflowMonitor` tracks a large `manaReservoir` and sets a `warningFlag` based on `additionalMana` that might cause an overflow. Complete the declaration of `manaReservoir` and ensure `warningFlag` is assigned in all conditional paths.",
      "code": "public class ManaOverflowMonitor {\n    public static void main(String[] args) {\n        ??? manaReservoir = 5000000000L;\n        int additionalMana = 1000000000;\n        boolean warningFlag;\n\n        if (additionalMana > (Integer.MAX_VALUE - (int)manaReservoir)) {\n             ??? = true;\n        } else {\n             ??? = false;\n        }\n        \n        System.out.println(\"Mana Reservoir: \" + manaReservoir);\n        System.out.println(\"Warning Flag: \" + warningFlag);\n    }\n}",
      "choices": [
        "long",
        "int",
        "warningFlag",
        "isWarning"
      ],
      "answer": [
        "long",
        "warningFlag",
        "warningFlag"
      ],
      "explanation": "1. `manaReservoir` needs to store `5000000000L`, which is a `long` literal. Therefore, `long` is the correct data type.\n2. The `warningFlag` is a local boolean variable that needs to be definitively assigned a value before it's printed. The blanks in both the `if` and `else` branches are responsible for this assignment. They should both use the variable name `warningFlag`."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The value `5000000000L` is too large for an `int`.",
      "2": "The `warningFlag` variable needs to be assigned a value in both `if` and `else` branches.",
      "3": "The blank in the `if` and `else` blocks should refer to the already declared boolean variable."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 42,
    "subtopic_id": 1,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "An `AlchemistMixture` calculates a `volatileMixture` from `baseConcentration`. The `volatileMixture` must be a `float`, and `stableStatus` is determined by its value. Complete the declarations and the assignment for `stableStatus` in the `else` block.",
      "code": "public class AlchemistMixture {\n    public static void main(String[] args) {\n        double baseConcentration = 1.0 / 3.0;\n        ??? volatileMixture = (float) (baseConcentration * 3.0);\n        boolean stableStatus;\n\n        if (volatileMixture == 1.0f) {\n            stableStatus = true;\n        } else {\n            ??? = false;\n        }\n        \n        System.out.println(\"Mixture Purity: \" + volatileMixture);\n        System.out.println(\"Stable Status: \" + stableStatus);\n    }\n}",
      "choices": [
        "float",
        "volatileMixture",
        "double",
        "stableStatus"
      ],
      "answer": [
        "float",
        "stableStatus"
      ],
      "explanation": "1. The problem states that `volatileMixture` must be a `float`. The expression `(float) (baseConcentration * 3.0)` correctly calculates `(1.0/3.0) * 3.0` (which is `0.999...`), then casts this `double` result to `float`.\n2. The `stableStatus` boolean variable needs to be assigned a value in both the `if` and `else` branches of the conditional statement to satisfy Java's definite assignment rules. The blank in the `else` block should refer to the `stableStatus` variable itself."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The first blank needs the data type for `volatileMixture`, which must be a `float`.",
      "2": "The result of `baseConcentration * 3.0` is a `double`. How do you assign a `double` result to a `float` variable?",
      "3": "The `stableStatus` variable needs to be assigned a value in all conditional paths."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 43,
    "subtopic_id": 1,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "An `OathInscriber` manages `oathText` and `hasBeenSworn` status. The `oathText` is intended to be a constant, and `hasBeenSworn` is set based on its length. Complete the `final` declaration for `oathText` and the assignment for `hasBeenSworn`.",
      "code": "public class OathInscriber {\n    public static void main(String[] args) {\n        ??? String oathText = \"By ancient magic, I swear.\";\n        boolean hasBeenSworn = false;\n\n        if (oathText.length() > 20) {\n            ??? = true;\n        }\n\n        System.out.println(\"Oath: \" + oathText);\n        System.out.println(\"Sworn: \" + hasBeenSworn);\n    }\n}",
      "choices": [
        "final",
        "static",
        "hasBeenSworn",
        "isSworn"
      ],
      "answer": [
        "final",
        "hasBeenSworn"
      ],
      "explanation": "1. To make `oathText` a constant that cannot be changed after initialization, the `final` keyword must be placed before its declaration.\n2. The blank inside the `if` block is assigning a value to the `hasBeenSworn` variable, so its name `hasBeenSworn` should be placed there."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The `oathText` is meant to be permanent. What keyword makes a variable immutable?",
      "2": "The boolean variable `hasBeenSworn` is updated inside the `if` block.",
      "3": "What should be placed in that blank?"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 44,
    "subtopic_id": 1,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `SentinelSystem` manages `sentinelEnergy`, `shieldStatus`, and `dangerProtocol`. `sentinelEnergy` is an integer. `shieldStatus` and `dangerProtocol` are set conditionally in an `if-else` structure. Complete the declaration of `sentinelEnergy` and the assignments for `shieldStatus` and `dangerProtocol` in the `else` block.",
      "code": "public class SentinelSystem {\n    public static void main(String[] args) {\n        ??? sentinelEnergy = 120;\n        String shieldStatus;\n        boolean dangerProtocol;\n\n        if (sentinelEnergy > 100) {\n            shieldStatus = \"Shields Online.\";\n            dangerProtocol = false;\n        } else {\n            ??? = \"Shields Offline.\";\n            ??? = true;\n        }\n        \n        System.out.println(\"Energy: \" + sentinelEnergy);\n        System.out.println(\"Status: \" + shieldStatus);\n        System.out.println(\"Protocol: \" + dangerProtocol);\n    }\n}",
      "choices": [
        "int",
        "dangerProtocol",
        "shieldStatus",
        "boolean"
      ],
      "answer": [
        "int",
        "shieldStatus",
        "dangerProtocol"
      ],
      "explanation": "1. `sentinelEnergy` stores a whole number (`120`), so `int` is the correct data type for its declaration.\n2. In the `else` block, the first blank assigns a string literal `\"Shields Offline.\"`, so the variable name `shieldStatus` should fill this blank.\n3. The second blank in the `else` block assigns a boolean literal `true`, so the variable name `dangerProtocol` should fill this blank. This ensures `dangerProtocol` is initialized in both `if` and `else` paths."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The `sentinelEnergy` variable stores a whole number.",
      "2": "The blank in the `else` block that assigns a string value should be the `shieldStatus` variable.",
      "3": "The blank that assigns a boolean value in the `else` block should be the `dangerProtocol` variable."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 45,
    "subtopic_id": 1,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "An `ElementalOrb` monitors `currentTemperature` and determines `statusReport` and `dangerLevel`. `currentTemperature` is a decimal, and `dangerLevel` is an integer. Complete the declarations and the assignment for `dangerLevel` in the `else` block.",
      "code": "public class ElementalOrb {\n    public static void main(String[] args) {\n        ??? currentTemperature = 95.0;\n        String statusReport = \"Orb operating normally.\";\n        ??? dangerLevel;\n\n        if (currentTemperature > 90.0) {\n            statusReport = \"WARNING: Overheating!\";\n            dangerLevel = 3;\n        } else {\n            ??? = 1;\n        }\n\n        System.out.println(\"Temperature: \" + currentTemperature);\n        System.out.println(\"Report: \" + statusReport);\n        System.out.println(\"Danger Level: \" + dangerLevel);\n    }\n}",
      "choices": [
        "int",
        "dangerLevel",
        "double",
        "String",
        "boolean"
      ],
      "answer": [
        "double",
        "int",
        "dangerLevel"
      ],
      "explanation": "1. `currentTemperature` needs to store a decimal value (`95.0`), so `double` is the correct data type for its declaration.\n2. `dangerLevel` needs to hold whole numbers (`3` or `1`), so `int` is the correct data type for its declaration.\n3. `dangerLevel` is a local variable used after an `if-else` block, so it must be initialized in *all* branches to satisfy Java's \"definitely assigned\" rule. The blank in the `else` block assigns a value to the `dangerLevel` variable."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The `currentTemperature` is a decimal value.",
      "2": "`dangerLevel` needs to hold whole numbers and must be initialized across all conditional paths.",
      "3": "The blank in the `else` block should assign a value to the already declared `dangerLevel` variable."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 46,
    "subtopic_id": 2,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `MagicCounter` tracks arcane energy. The `energyCount` is initially set, then increased by 1. Your task is to trace the code and determine the final `Energy Count` that is printed.",
      "code": "public class MagicCounter {\n    public static void main(String[] args) {\n        int energyCount = 5;\n        energyCount = energyCount + 1;\n        System.out.println(\"Energy Count: \" + energyCount);\n    }\n}",
      "choices": [
        "Energy Count: 5",
        "Energy Count: 6",
        "Energy Count: 1",
        "Error"
      ],
      "answer": [
        "Energy Count: 6"
      ],
      "explanation": "The `int energyCount = 5;` line initializes `energyCount` to `5`. Then, `energyCount = energyCount + 1;` adds `1` to `energyCount`, making its new value `6`. Finally, `System.out.println(\"Energy Count: \" + energyCount);` prints \"Energy Count: 6\"."
    },
    "difficulty": "easy",
    "hints": {
      "1": "Follow the variable's value from its initialization.",
      "2": "The `+ 1` operation adds one to the current value.",
      "3": "The `println` statement displays the value after the operation."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 47,
    "subtopic_id": 2,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `TorchMonitor` tracks the state of a magical torch. The `torchLit` boolean is initially `false`, but a condition checks if `5 > 3`. Your task is to trace the code and determine the final `Torch Lit` status.",
      "code": "public class TorchMonitor {\n    public static void main(String[] args) {\n        boolean torchLit = false;\n        if (5 > 3) {\n            torchLit = true;\n        }\n        System.out.println(\"Torch Lit: \" + torchLit);\n    }\n}",
      "choices": [
        "Torch Lit: false",
        "Torch Lit: true",
        "Error",
        "Nothing"
      ],
      "answer": [
        "Torch Lit: true"
      ],
      "explanation": "The `boolean torchLit = false;` line initializes `torchLit` to `false`. The `if (5 > 3)` condition evaluates to `true` (since `5` is indeed greater than `3`). Therefore, the code inside the `if` block, `torchLit = true;`, is executed, changing `torchLit` to `true`. Finally, `System.out.println(\"Torch Lit: \" + torchLit);` prints \"Torch Lit: true\"."
    },
    "difficulty": "easy",
    "hints": {
      "1": "Evaluate the condition inside the `if` statement.",
      "2": "If the condition is true, the code inside the `if` block executes.",
      "3": "The final `println` shows the most recent value of `torchLit`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 48,
    "subtopic_id": 2,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `RuneWriter` inscribes magical runes. The `runeCharacter` is assigned a single character. Your task is to trace the code and determine the `Rune` that is printed.",
      "code": "public class RuneWriter {\n    public static void main(String[] args) {\n        char runeCharacter = 'G';\n        System.out.println(\"Rune: \" + runeCharacter);\n    }\n}",
      "choices": [
        "Rune: G",
        "G",
        "Rune: runeCharacter",
        "Error"
      ],
      "answer": [
        "Rune: G"
      ],
      "explanation": "The `char runeCharacter = 'G';` line declares a character variable `runeCharacter` and assigns it the literal character `'G'`. The `System.out.println(\"Rune: \" + runeCharacter);` statement concatenates the string \"Rune: \" with the value of `runeCharacter`, resulting in the output \"Rune: G\"."
    },
    "difficulty": "easy",
    "hints": {
      "1": "A `char` variable stores a single character.",
      "2": "The `+` operator concatenates a string literal and the variable's value.",
      "3": "The character itself, not its ASCII value, is printed by default."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 49,
    "subtopic_id": 2,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `PotionVolume` system measures liquid volumes. The `liquidVolume` is assigned a decimal value. Your task is to trace the code and determine the exact `Volume` that is printed.",
      "code": "public class PotionVolume {\n    public static void main(String[] args) {\n        double liquidVolume = 12.345;\n        System.out.println(\"Volume: \" + liquidVolume + \" liters\");\n    }\n}",
      "choices": [
        "Volume: 12 liters",
        "Volume: 12.345 liters",
        "12.345",
        "Error"
      ],
      "answer": [
        "Volume: 12.345 liters"
      ],
      "explanation": "The `double liquidVolume = 12.345;` line declares `liquidVolume` as a `double` and initializes it with `12.345`. The `System.out.println()` statement then concatenates the string literal \"Volume: \", the value of `liquidVolume`, and the string literal \" liters\". This results in the precise output \"Volume: 12.345 liters\"."
    },
    "difficulty": "easy",
    "hints": {
      "1": "A `double` variable retains decimal precision.",
      "2": "String concatenation (`+`) combines all parts into a single output string.",
      "3": "The literal text and the variable's value will be printed as they appear."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 50,
    "subtopic_id": 2,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `BlastCalculator` determines the force of a magical blast. The `forceMagnitude` is calculated by multiplying `baseForce` and a `multiplier`. Your task is to trace the code and determine the final `Force Magnitude` that is printed.",
      "code": "public class BlastCalculator {\n    public static void main(String[] args) {\n        int baseForce = 10;\n        int multiplier = 3;\n        int forceMagnitude = baseForce * multiplier;\n        System.out.println(\"Force Magnitude: \" + forceMagnitude);\n    }\n}",
      "choices": [
        "Force Magnitude: 10",
        "Force Magnitude: 3",
        "Force Magnitude: 30",
        "Error"
      ],
      "answer": [
        "Force Magnitude: 30"
      ],
      "explanation": "The `int baseForce = 10;` and `int multiplier = 3;` lines initialize the respective variables. The `int forceMagnitude = baseForce * multiplier;` line calculates `10 * 3`, which is `30`, and assigns this result to `forceMagnitude`. Finally, `System.out.println(\"Force Magnitude: \" + forceMagnitude);` prints \"Force Magnitude: 30\"."
    },
    "difficulty": "easy",
    "hints": {
      "1": "Follow the multiplication operation.",
      "2": "The result of `baseForce * multiplier` is assigned to `forceMagnitude`.",
      "3": "The final `println` displays this calculated value."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 51,
    "subtopic_id": 2,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `PotionDilution` system calculates `potencyValue` and determines if a `stabilizerNeeded` based on it. Your task is to trace the code and determine the final `Potency` and `Stabilizer Needed` status.",
      "code": "public class PotionDilution {\n    public static void main(String[] args) {\n        int baseConcentration = 100;\n        double dilutionFactor = 0.5;\n        boolean stabilizerNeeded = true;\n\n        double potencyValue = baseConcentration * dilutionFactor;\n\n        if (potencyValue < 60.0) {\n            stabilizerNeeded = false;\n        }\n\n        System.out.println(\"Final Potency: \" + potencyValue);\n        System.out.println(\"Stabilizer Needed: \" + stabilizerNeeded);\n    }\n}",
      "choices": [
        "Final Potency: 50.0",
        "Final Potency: 100.0",
        "Stabilizer Needed: false",
        "Stabilizer Needed: true"
      ],
      "answer": [
        "Final Potency: 50.0",
        "Stabilizer Needed: false"
      ],
      "explanation": "1. `baseConcentration` is `100`, `dilutionFactor` is `0.5`, `stabilizerNeeded` is `true`.\n2. `double potencyValue = baseConcentration * dilutionFactor;` calculates `100 * 0.5 = 50.0`. So, `potencyValue` becomes `50.0`.\n3. `if (potencyValue < 60.0)`: `50.0 < 60.0` is `true`.\n    * `stabilizerNeeded = false;` updates `stabilizerNeeded` to `false`.\n4. The first `System.out.println()` prints \"Final Potency: 50.0\".\n5. The second `System.out.println()` prints \"Stabilizer Needed: false\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Perform the multiplication to find `potencyValue` first, noting that an `int` multiplied by a `double` results in a `double`.",
      "2": "Evaluate the `if` condition using the calculated `potencyValue` to determine the final state of `stabilizerNeeded`.",
      "3": "Both `println` statements will output the final state of their respective variables."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 52,
    "subtopic_id": 2,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `RuneWeaver` processes `runeCode`s and `modifier`s, determining `activationStatus` based on potential integer overflow. Your task is to trace the code and determine the final `Rune Code` and `Activation Status`.",
      "code": "public class RuneWeaver {\n    public static void main(String[] args) {\n        int runeCode = 2000000000;\n        long modifier = 500000000L;\n        boolean activationStatus = false;\n\n        runeCode = (int) (runeCode + modifier);\n\n        if (runeCode < 0) {\n            activationStatus = true;\n        }\n\n        System.out.println(\"Final Rune Code: \" + runeCode);\n        System.out.println(\"Activation Status: \" + activationStatus);\n    }\n}",
      "choices": [
        "Final Rune Code: 2500000000",
        "Final Rune Code: -1794967296",
        "Activation Status: false",
        "Activation Status: true"
      ],
      "answer": [
        "Final Rune Code: -1794967296",
        "Activation Status: true"
      ],
      "explanation": "1. `runeCode` is `2,000,000,000`, `modifier` is `500,000,000L`, `activationStatus` is `false`.\n2. `runeCode = (int) (runeCode + modifier);` attempts to calculate `2,000,000,000 + 500,000,000 = 2,500,000,000`.\n3. However, `2,500,000,000` exceeds the maximum value an `int` can hold (`2,147,483,647`). When this sum is cast back to `int`, it results in an **integer overflow**, causing the value to wrap around to the minimum negative value. `2,500,000,000 - 2^32` (or `2,500,000,000 - 4,294,967,296` for unsigned interpretation, or more simply, `2,500,000,000 - 2 * 2,147,483,648` then wrap) results in `-1794967296`. So, `runeCode` becomes `-1794967296`.\n4. `if (runeCode < 0)`: `-1794967296 < 0` is `true`.\n    * `activationStatus = true;` updates `activationStatus` to `true`.\n5. The first `System.out.println()` prints \"Final Rune Code: -1794967296\".\n6. The second `System.out.println()` prints \"Activation Status: true\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Be aware of integer overflow. Adding a large `long` to an `int` might exceed the `int`'s maximum value.",
      "2": "An `int` in Java has a maximum value of `2,147,483,647`. What happens if `2,000,000,000 + 500,000,000` is forced back into an `int`?",
      "3": "Evaluate the `if` condition carefully based on the final (potentially overflowed) `runeCode`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 53,
    "subtopic_id": 2,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `CelestialCartographer` calculates `celestialCoordinate` and determines if a `starFound` based on floating-point comparison. Your task is to trace the code and determine the final `Final Coordinate` and `Star Found` status.",
      "code": "public class CelestialCartographer {\n    public static void main(String[] args) {\n        float baseDistance = 1000.0f;\n        float accuracyFactor = 0.0001f;\n        boolean starFound = false;\n\n        float celestialCoordinate = baseDistance * accuracyFactor;\n\n        if (celestialCoordinate == 0.1f) {\n            starFound = true;\n        }\n\n        System.out.println(\"Final Coordinate: \" + celestialCoordinate);\n        System.out.println(\"Star Found: \" + starFound);\n    }\n}",
      "choices": [
        "Final Coordinate: 0.1",
        "Final Coordinate: 0.10000001",
        "Star Found: false",
        "Star Found: true"
      ],
      "answer": [
        "Final Coordinate: 0.10000001",
        "Star Found: false"
      ],
      "explanation": "1. `baseDistance` is `1000.0f`, `accuracyFactor` is `0.0001f`, `starFound` is `false`.\n2. `float celestialCoordinate = baseDistance * accuracyFactor;` computes `0.1f`. However, due to the nature of floating-point representation, `0.1` often cannot be perfectly represented in binary, leading to a slight precision error (e.g., stored as `0.10000001`).\n3. `if (celestialCoordinate == 0.1f)`: Because of this tiny precision error, `celestialCoordinate` is *not* exactly equal to `0.1f`. Therefore, this condition evaluates to `false`.\n    * `starFound` remains `false`.\n4. The first `System.out.println()` prints \"Final Coordinate: 0.10000001\" (or a similar slightly imprecise value).\n5. The second `System.out.println()` prints \"Star Found: false\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Understand that floating-point arithmetic (especially with `float`) can introduce tiny inaccuracies.",
      "2": "Direct comparison (`==`) of floating-point numbers (`float` or `double`) is often unreliable due to these inaccuracies.",
      "3": "Perform the multiplication to get `celestialCoordinate` and then carefully evaluate the `if` condition."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 54,
    "subtopic_id": 2,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `WardActivator` system strengthens magical wards. `wardStrength` is updated, potentially causing a byte overflow, which then affects whether a `spellBlocked`. Your task is to trace the code and determine the final `Ward Strength` and `Spell Blocked` status.",
      "code": "public class WardActivator {\n    public static void main(String[] args) {\n        byte wardStrength = 120;\n        int incomingSpellPower = 10;\n        boolean spellBlocked = false;\n\n        wardStrength = (byte) (wardStrength + incomingSpellPower);\n\n        if (wardStrength < 0) {\n            spellBlocked = true;\n        }\n\n        System.out.println(\"Final Ward Strength: \" + wardStrength);\n        System.out.println(\"Spell Blocked: \" + spellBlocked);\n    }\n}",
      "choices": [
        "Final Ward Strength: 130",
        "Final Ward Strength: -126",
        "Spell Blocked: false",
        "Spell Blocked: true"
      ],
      "answer": [
        "Final Ward Strength: -126",
        "Spell Blocked: true"
      ],
      "explanation": "1. `wardStrength` is `120`, `incomingSpellPower` is `10`, `spellBlocked` is `false`.\n2. `wardStrength = (byte) (wardStrength + incomingSpellPower);` calculates `120 + 10 = 130`.\n3. However, `130` exceeds the maximum value a `byte` can hold (`127`). When `130` is cast back to `byte`, it results in a **byte overflow**. The value \"wraps around\" from `127` to `-128`, then continues counting up from there (`127 -> -128 -> -127 -> ...`). `130` becomes `-126` after wrapping. So, `wardStrength` becomes `-126`.\n4. `if (wardStrength < 0)`: `-126 < 0` is `true`.\n    * `spellBlocked = true;` updates `spellBlocked` to `true`.\n5. The first `System.out.println()` prints \"Final Ward Strength: -126\".\n6. The second `System.out.println()` prints \"Spell Blocked: true\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Recall the maximum positive value a `byte` can hold in Java.",
      "2": "Consider what happens when you add a number that pushes a `byte` beyond its maximum positive limit.",
      "3": "The `if` condition explicitly checks for a negative result, which is a common indicator of a `byte` overflow."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 55,
    "subtopic_id": 2,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `MagicCommunicator` translates numerical codes into characters. `signalCharacter` is cast from `characterCode`, then conditionally modified. Your task is to trace the code and determine the final `Signal Character` and `Signal Received` status.",
      "code": "public class MagicCommunicator {\n    public static void main(String[] args) {\n        int characterCode = 65;\n        char signalCharacter = (char) characterCode;\n        boolean signalReceived = false;\n\n        if (signalCharacter == 'A') {\n            signalReceived = true;\n        } else {\n            signalCharacter = 'Z';\n        }\n\n        System.out.println(\"Signal Character: \" + signalCharacter);\n        System.out.println(\"Signal Received: \" + signalReceived);\n    }\n}",
      "choices": [
        "Signal Character: A",
        "Signal Character: Z",
        "Signal Received: false",
        "Signal Received: true"
      ],
      "answer": [
        "Signal Character: A",
        "Signal Received: true"
      ],
      "explanation": "1. `characterCode` is `65`, `signalCharacter` is initialized by casting `65` to `char`, making `signalCharacter` `'A'`. `signalReceived` is `false`.\n2. `if (signalCharacter == 'A')`: `'A' == 'A'` is `true`.\n    * `signalReceived = true;` updates `signalReceived` to `true`.\n3. The `else` block is skipped.\n4. The first `System.out.println()` prints \"Signal Character: A\".\n5. The second `System.out.println()` prints \"Signal Received: true\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Remember that `char` can represent characters using their numerical (ASCII/Unicode) codes.",
      "2": "The `(char)` cast converts the integer code to its corresponding character.",
      "3": "Carefully evaluate the `if` condition to determine the `signalReceived` status and potential character change."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 56,
    "subtopic_id": 2,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `RunicConverter` processes `manaInput` and `conversionFactor`, potentially causing a `short` overflow that triggers an `overflowWarning` and sets a `diagnosticCode`. Your task is to trace the code and determine the final `Aetheric Flow`, `Overflow Warning`, and `Diagnostic Code`.",
      "code": "public class RunicConverter {\n    public static void main(String[] args) {\n        short manaInput = 32700;\n        byte conversionFactor = 100;\n        boolean overflowWarning = false;\n        char diagnosticCode = 'A';\n\n        short aethericFlow = (short) (manaInput + conversionFactor);\n        \n        if (aethericFlow < 0) {\n            overflowWarning = true;\n            diagnosticCode = 'X';\n        } else {\n            diagnosticCode = 'O';\n        }\n        \n        aethericFlow = (short) (aethericFlow / 5);\n\n        System.out.println(\"Final Aetheric Flow: \" + aethericFlow);\n        System.out.println(\"Overflow Warning: \" + overflowWarning);\n        System.out.println(\"Diagnostic Code: \" + diagnosticCode);\n    }\n}",
      "choices": [
        "Final Aetheric Flow: 32100",
        "Final Aetheric Flow: -6547",
        "Overflow Warning: true",
        "Diagnostic Code: X"
      ],
      "answer": [
        "Final Aetheric Flow: -6547",
        "Overflow Warning: true",
        "Diagnostic Code: X"
      ],
      "explanation": "1. `manaInput` is `32700`, `conversionFactor` is `100`.\n2. `short aethericFlow = (short) (manaInput + conversionFactor);` calculates `32700 + 100 = 32800`. This exceeds `short`'s maximum (`32767`), causing a **short overflow**. `32800` wraps around to `-32736`. So `aethericFlow` becomes `-32736`.\n3. `if (aethericFlow < 0)`: `-32736 < 0` is `true`.\n    * `overflowWarning = true;` updates `overflowWarning` to `true`.\n    * `diagnosticCode = 'X';` updates `diagnosticCode` to `'X'`.\n4. `aethericFlow = (short) (aethericFlow / 5);` calculates `-32736 / 5 = -6547.2`. Integer division truncates to `-6547`. So `aethericFlow` becomes `-6547`.\n5. The first `System.out.println()` prints \"Final Aetheric Flow: -6547\".\n6. The second `System.out.println()` prints \"Overflow Warning: true\".\n7. The third `System.out.println()` prints \"Diagnostic Code: X\"."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Recall the maximum value for a `short` data type (32767) and consider what happens when a value exceeds it.",
      "2": "Carefully evaluate the `if` condition based on the potentially overflowed `aethericFlow` to determine `overflowWarning` and `diagnosticCode`.",
      "3": "Don't forget the final integer division operation and how it affects the `aethericFlow`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 57,
    "subtopic_id": 2,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `StardustRefinery` calculates `stardustWeight` from `rawMaterial` and `conversionRate`, then determines `refinementComplete` and `magicalEssencePresent` based on floating-point comparisons. Your task is to trace the code and determine the `Final Stardust Weight`, `Refinement Complete` status, and `Magical Essence Present` status.",
      "code": "public class StardustRefinery {\n    public static void main(String[] args) {\n        float rawMaterial = 100.0f;\n        double conversionRate = 0.005;\n        boolean refinementComplete = false;\n        boolean magicalEssencePresent = false;\n\n        double stardustWeight = rawMaterial * conversionRate;\n\n        if (stardustWeight > 0.5f) {\n            refinementComplete = true;\n        }\n\n        if (refinementComplete && stardustWeight < 0.6) {\n            magicalEssencePresent = true;\n        }\n        \n        System.out.println(\"Final Stardust Weight: \" + stardustWeight);\n        System.out.println(\"Refinement Complete: \" + refinementComplete);\n        System.out.println(\"Magical Essence Present: \" + magicalEssencePresent);\n    }\n}",
      "choices": [
        "Final Stardust Weight: 0.5000000000000001",
        "Refinement Complete: true",
        "Magical Essence Present: true",
        "Final Stardust Weight: 0.5"
      ],
      "answer": [
        "Final Stardust Weight: 0.5000000000000001",
        "Refinement Complete: true",
        "Magical Essence Present: true"
      ],
      "explanation": "1. `rawMaterial` is `100.0f`, `conversionRate` is `0.005`.\n2. `double stardustWeight = rawMaterial * conversionRate;` calculates `100.0f * 0.005`. The `float` is promoted to `double`, and the result is `0.5`. Due to floating-point representation, it's often stored as `0.5000000000000001`.\n3. `if (stardustWeight > 0.5f)`: `0.5000000000000001` (double) is indeed greater than `0.5f` (float). So this condition evaluates to `true`.\n    * `refinementComplete = true;` updates `refinementComplete` to `true`.\n4. `if (refinementComplete && stardustWeight < 0.6)`: `true && (0.5 < 0.6)` is `true && true`, which evaluates to `true`.\n    * `magicalEssencePresent = true;` updates `magicalEssencePresent` to `true`.\n5. All three `System.out.println()` statements print the final values."
    },
    "difficulty": "hard",
    "hints": {
      "1": "When a `float` and `double` are involved in an operation, the result typically promotes to `double` for precision.",
      "2": "Be extremely cautious with direct comparisons (`==`, `>`, `<`) involving floating-point numbers due to potential precision issues. `0.5f` might not be the same as `0.5` (double).",
      "3": "Trace the boolean variables carefully through all conditional statements."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 58,
    "subtopic_id": 2,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `SecurityEnchantment` system evaluates `entryCode` and `maxAttempts` to determine if `isLocked` and `lockStatus`. `entryCode` is cast to an `int`, potentially causing an overflow. Your task is to trace the code and determine the `Final Entry Code`, `System Locked` status, and `Lock Status Message`.",
      "code": "public class SecurityEnchantment {\n    public static void main(String[] args) {\n        long entryCode = 123456789123L;\n        int maxAttempts = 5;\n        boolean isLocked = true;\n        String lockStatus = \"Secure\";\n\n        byte remainingAttempts = (byte) (maxAttempts - 1);\n\n        if (entryCode % 2 == 0) {\n            isLocked = false;\n        } else {\n            lockStatus = \"Breach Detected\";\n        }\n        \n        if (remainingAttempts < 5 && isLocked) {\n            lockStatus = \"Emergency Lockdown\";\n        }\n\n        System.out.println(\"Final Entry Code: \" + (int)entryCode);\n        System.out.println(\"System Locked: \" + isLocked);\n        System.out.println(\"Lock Status Message: \" + lockStatus);\n    }\n}",
      "choices": [
        "Final Entry Code: 123456789123",
        "Final Entry Code: 1539151595",
        "System Locked: true",
        "Lock Status Message: Emergency Lockdown"
      ],
      "answer": [
        "Final Entry Code: 1539151595",
        "System Locked: true",
        "Lock Status Message: Emergency Lockdown"
      ],
      "explanation": "1. Variables are initialized: `entryCode = 123456789123L`, `maxAttempts = 5`, `isLocked = true`, `lockStatus = \"Secure\"`.\n2. `byte remainingAttempts = (byte) (maxAttempts - 1);` calculates `5 - 1 = 4`, casts to `byte`, so `remainingAttempts` is `4`.\n3. `if (entryCode % 2 == 0)`: `123456789123` is an odd number, so `entryCode % 2` is `1`. `1 == 0` is `false`. The `else` block executes.\n    * `lockStatus = \"Breach Detected\";` updates `lockStatus` to \"Breach Detected\". `isLocked` remains `true`.\n4. `if (remainingAttempts < 5 && isLocked)`: `4 < 5` is `true`, AND `isLocked` (`true`) is `true`. The condition `true && true` is `true`. The block is entered.\n    * `lockStatus = \"Emergency Lockdown\";` updates `lockStatus` to \"Emergency Lockdown\".\n5. **Output 1**: `System.out.println(\"Final Entry Code: \" + (int)entryCode);` The `long` value `123456789123L` is cast to `int`, causing an **integer overflow**. The result is `1539151595`.\n6. **Output 2**: `System.out.println(\"System Locked: \" + isLocked);` prints \"System Locked: true\".\n7. **Output 3**: `System.out.println(\"Lock Status Message: \" + lockStatus);` prints \"Lock Status Message: Emergency Lockdown\"."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Pay attention to the final `System.out.println` for `entryCode` which explicitly casts a `long` to an `int`. Consider the impact of this conversion on a large number.",
      "2": "Evaluate `entryCode % 2` to determine if the `long` code is even or odd, which affects `isLocked` and `lockStatus`.",
      "3": "Trace `isLocked` and `lockStatus` through both `if` conditions sequentially."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 59,
    "subtopic_id": 2,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `ChronomancerCalibrator` adjusts `timeWarpFactor` and calculates `stabilityRating`. Conditional logic determines if the system `calibratedSuccessfully` based on precise floating-point comparisons. Your task is to trace the code and determine the `Final Time Warp Factor`, `Stability Rating`, and `Calibrated Successfully` status.",
      "code": "public class ChronomancerCalibrator {\n    public static void main(String[] args) {\n        double initialWarp = 1.0 / 3.0;\n        double adjustment = 0.0000000001;\n        int stabilityThreshold = 5;\n        boolean calibratedSuccessfully = false;\n\n        double timeWarpFactor = initialWarp * 3.0 + adjustment;\n        \n        int stabilityRating = (int) (timeWarpFactor * stabilityThreshold);\n\n        if (timeWarpFactor == 1.0) {\n            calibratedSuccessfully = true;\n        } else if (timeWarpFactor > 1.0 - 0.0000001) {\n            calibratedSuccessfully = true;\n        }\n\n        System.out.println(\"Final Time Warp Factor: \" + timeWarpFactor);\n        System.out.println(\"Stability Rating: \" + stabilityRating);\n        System.out.println(\"Calibrated Successfully: \" + calibratedSuccessfully);\n    }\n}",
      "choices": [
        "Final Time Warp Factor: 0.9999999999",
        "Final Time Warp Factor: 1.0000000001",
        "Stability Rating: 5",
        "Calibrated Successfully: true"
      ],
      "answer": [
        "Final Time Warp Factor: 1.0000000000999999",
        "Stability Rating: 5",
        "Calibrated Successfully: true"
      ],
      "explanation": "1. `initialWarp` is `1.0 / 3.0` (approximately `0.3333333333333333`).\n2. `timeWarpFactor = initialWarp * 3.0 + adjustment;` calculates `0.3333333333333333 * 3.0` which is `0.9999999999999999`. Adding `0.0000000001` makes `timeWarpFactor` approximately `1.0000000000999999`.\n3. `stabilityRating = (int) (timeWarpFactor * stabilityThreshold);` calculates `(int) (5.0000000004999995)`. Casting to `int` truncates, so `stabilityRating` becomes `5`.\n4. `if (timeWarpFactor == 1.0)`: `1.0000000000999999 == 1.0` is `false` due to floating-point imprecision.\n5. `else if (timeWarpFactor > 1.0 - 0.0000001)`: `1.0000000000999999 > 0.9999999` is `true`.\n    * `calibratedSuccessfully = true;` updates `calibratedSuccessfully` to `true`.\n6. The `System.out.println()` statements display the final values: `timeWarpFactor` (e.g., `1.0000000001`), `stabilityRating` (`5`), and `calibratedSuccessfully` (`true`)."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Understand that division of integers can produce repeating decimals, and floating-point arithmetic might not be perfectly precise.",
      "2": "Direct comparison (`==`) of `double` values is often unreliable; `if-else if` conditions might use a tolerance.",
      "3": "Trace the exact numerical values through each calculation and comparison, including type conversions and truncation."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 60,
    "subtopic_id": 2,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "An `OracleEngine` predicts destiny based on `initialScore` and `modifier`, leading to a `destinyScore` that may overflow. `omenType` and `prophecyFulfilled` are set conditionally. Your task is to trace the code and determine the `Final Destiny Score`, `Omen Type`, and `Prophecy Fulfilled` status.",
      "code": "public class OracleEngine {\n    public static void main(String[] args) {\n        byte initialScore = 125;\n        short modifier = 10;\n        char omenType = '?';\n        boolean prophecyFulfilled = false;\n\n        byte destinyScore = (byte) (initialScore + modifier);\n\n        if (destinyScore < 0) {\n            omenType = '!';\n            prophecyFulfilled = true;\n        } else if (destinyScore > 100) {\n            omenType = '+';\n        } else {\n            omenType = '.';\n        }\n        \n        if (!prophecyFulfilled) {\n            omenType = '#';\n        }\n\n        System.out.println(\"Final Destiny Score: \" + destinyScore);\n        System.out.println(\"Omen Type: \" + omenType);\n        System.out.println(\"Prophecy Fulfilled: \" + prophecyFulfilled);\n    }\n}",
      "choices": [
        "Final Destiny Score: 135",
        "Final Destiny Score: -121",
        "Omen Type: !",
        "Prophecy Fulfilled: true"
      ],
      "answer": [
        "Final Destiny Score: -121",
        "Omen Type: !",
        "Prophecy Fulfilled: true"
      ],
      "explanation": "1. Variables initialized: `initialScore = 125`, `modifier = 10`.\n2. `byte destinyScore = (byte) (initialScore + modifier);` calculates `125 + 10 = 135`. `135` exceeds `byte` max (`127`), causing an **overflow**. `135` wraps around to `-121`. So, `destinyScore` is `-121`.\n3. `if (destinyScore < 0)`: `-121 < 0` is `true`. The block is entered.\n    * `omenType = '!';` updates `omenType` to `'!'`.\n    * `prophecyFulfilled = true;` updates `prophecyFulfilled` to `true`.\n4. `if (!prophecyFulfilled)`: `!true` is `false`. This block is skipped.\n5. **Output 1**: `System.out.println(\"Final Destiny Score: \" + destinyScore);` prints \"Final Destiny Score: -121\".\n6. **Output 2**: `System.out.println(\"Omen Type: \" + omenType);` prints \"Omen Type: !\"'.\n7. **Output 3**: `System.out.println(\"Prophecy Fulfilled: \" + prophecyFulfilled);` prints \"Prophecy Fulfilled: true\"."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Carefully calculate the `destinyScore`, remembering the `byte` data type's range (`-128` to `127`) and how overflow occurs.",
      "2": "Trace `omenType` and `prophecyFulfilled` through the first `if-else if-else` chain based on the `destinyScore`.",
      "3": "Then, evaluate the final `if (!prophecyFulfilled)` condition to see if `omenType` is *further* modified."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 61,
    "subtopic_id": 2,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `ViscosityTester` measures `arcaneViscosity`. The `elixirDensity` variable is declared as a `float`, but the literal value assigned to it is treated as a `double` by default, causing a potential loss of precision. Fix the code to ensure the `float` variable correctly stores the decimal value.",
      "code": "public class ViscosityTester {\n    public static void main(String[] args) {\n        float arcaneViscosity = 3.14;\n        System.out.println(\"Arcane Viscosity: \" + arcaneViscosity);\n    }\n}",
      "expected_output": [
        "Arcane Viscosity: 3.14"
      ],
      "hidden_test_case": "",
      "explanation": "In Java, floating-point literals (numbers with decimal points like `3.14`) are treated as `double` by default. Attempting to assign a `double` literal directly to a `float` variable without casting or explicit `f` suffix causes a \"possible lossy conversion\" error. The fix is to add the `f` (or `F`) suffix to the literal (`3.14f`), explicitly marking it as a `float` literal."
    },
    "difficulty": "easy",
    "hints": {
      "1": "By default, decimal numbers in Java are treated as a specific precision type.",
      "2": "If you want a decimal number to be explicitly a `float`, it needs a special marker.",
      "3": "Look for a simple way to tell Java \"this is a `float`, not a `double`.\""
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 62,
    "subtopic_id": 2,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `DustCollector` tracks `crystalDust`. The literal value assigned to `crystalDust` is too large for an `int` variable, leading to a compilation error. Fix the code to correctly store this large integer value.",
      "code": "public class DustCollector {\n    public static void main(String[] args) {\n        int crystalDust = 3000000000;\n        System.out.println(\"Crystal Dust: \" + crystalDust);\n    }\n}",
      "expected_output": [
        "Crystal Dust: 3000000000"
      ],
      "hidden_test_case": "",
      "explanation": "The literal `3000000000` is too large to fit into an `int` variable, leading to a compilation error. `long` is the primitive data type used for larger integer values. Additionally, to explicitly tell Java that a large integer literal should be treated as a `long`, the `L` (or `l`) suffix must be appended to the number. The fix changes the type to `long` and adds the `L` suffix."
    },
    "difficulty": "easy",
    "hints": {
      "1": "An `int` has a defined maximum positive value (approx. 2.1 billion).",
      "2": "If a whole number literal exceeds this `int` limit, it's considered a different type.",
      "3": "Adding a specific suffix to a large integer literal can explicitly tell Java its intended type."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 63,
    "subtopic_id": 2,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `CharmController` sets the `activeState` of a magical charm. However, an integer value is assigned to a `boolean` variable, causing a type mismatch. Fix the code to correctly set the `activeState`.",
      "code": "public class CharmController {\n    public static void main(String[] args) {\n        boolean activeState = 1;\n        System.out.println(\"Charm Active: \" + activeState);\n    }\n}",
      "expected_output": [
        "Charm Active: true"
      ],
      "hidden_test_case": "",
      "explanation": "In Java, `boolean` variables can only store the literal values `true` or `false`. Attempting to assign an integer (`1`) to a `boolean` variable results in a type mismatch compilation error. The fix is to assign the correct boolean literal, `true` (or `false`), to `activeState`."
    },
    "difficulty": "easy",
    "hints": {
      "1": "Boolean variables can only store one of two specific literal values.",
      "2": "Unlike some other languages, Java does not treat numbers (like 0 or 1) as boolean equivalents.",
      "3": "Recall the exact keywords for boolean truth values."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 64,
    "subtopic_id": 2,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `RuneSketcher` creates runes. A `char` variable `letterRune` is intended to store a single character, but a string literal is assigned to it, leading to a type mismatch. Fix the code to correctly assign the character 'X' to `letterRune`.",
      "code": "public class RuneSketcher {\n    public static void main(String[] args) {\n        char letterRune = \"X\";\n        System.out.println(\"Letter Rune: \" + letterRune);\n    }\n}",
      "expected_output": [
        "Letter Rune: X"
      ],
      "hidden_test_case": "",
      "explanation": "In Java, a `char` literal must be enclosed in single quotes (`' '`), while double quotes (`\" \"`) are used for `String` literals. Attempting to assign a `String` literal to a `char` variable results in a type mismatch. The fix is to change the double quotes to single quotes for the character literal."
    },
    "difficulty": "easy",
    "hints": {
      "1": "In Java, there's a strict difference between a single character and a string of characters.",
      "2": "Literal characters are enclosed by a specific type of quote.",
      "3": "Double quotes are typically for sequences of characters."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 65,
    "subtopic_id": 2,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "An `ImpGathering` system counts `impsPresent`. A `byte` variable is used, but the literal value `130` is outside its valid range, causing a compilation error. Fix the code to correctly assign a value within the `byte`'s range.",
      "code": "public class ImpGathering {\n    public static void main(String[] args) {\n        byte impsPresent = 130;\n        System.out.println(\"Imps Present: \" + impsPresent);\n    }\n}",
      "expected_output": [
        "Imps Present: 120"
      ],
      "hidden_test_case": "",
      "explanation": "The `byte` data type in Java has a range from `-128` to `127`. The literal `130` exceeds this range. Java implicitly treats integer literals as `int`s by default, and `130` (as an `int`) cannot be directly assigned to a `byte` without a lossy conversion. The simplest fix is to change the value to something within the valid `byte` range, such as `120`."
    },
    "difficulty": "easy",
    "hints": {
      "1": "Recall the maximum positive value a `byte` can store.",
      "2": "If a literal integer exceeds the `byte` range, Java treats it as an `int` by default, leading to a type mismatch when assigned to a `byte`.",
      "3": "The goal is to provide a valid `byte` literal."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 66,
    "subtopic_id": 2,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `CrystalChargeCalibrator` measures `rawCharge` as a `double` and tries to assign it to an `int` variable `chargeLevel`, causing a compilation error due to potential data loss. Fix the code to correctly store the `chargeLevel` while preserving precision where intended.",
      "code": "public class CrystalChargeCalibrator {\n    public static void main(String[] args) {\n        double rawCharge = 15.7;\n        int chargeLevel = rawCharge;\n        System.out.println(\"Crystal Charge: \" + chargeLevel);\n    }\n}",
      "expected_output": [
        "Crystal Charge: 15.7"
      ],
      "hidden_test_case": "",
      "explanation": "The variable `rawCharge` is a `double` (a decimal number). Attempting to assign its value directly to an `int` variable (`chargeLevel`) causes a \"possible lossy conversion\" compilation error, as the fractional part (`.7`) would be lost. To retain the full precision of the charge level, `chargeLevel` must be declared as a `double` (or `float`, if less precision is acceptable and space is a concern)."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Remember that `int` variables can only store whole numbers.",
      "2": "Assigning a `double` to an `int` without explicit conversion will cause a compilation error due to potential data loss.",
      "3": "Consider the data type that precisely stores decimal values."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 67,
    "subtopic_id": 2,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `GoblinManager` counts `goblinMinions`. Adding `newArrivals` to `goblinMinions` exceeds the `byte`'s maximum range, causing an overflow. Fix the code to correctly store the total count of goblin minions.",
      "code": "public class GoblinManager {\n    public static void main(String[] args) {\n        byte goblinMinions = 120;\n        int newArrivals = 30;\n        goblinMinions = (byte) (goblinMinions + newArrivals);\n        System.out.println(\"Total Goblin Minions: \" + goblinMinions);\n    }\n}",
      "expected_output": [
        "Total Goblin Minions: 150"
      ],
      "hidden_test_case": "",
      "explanation": "The sum `goblinMinions + newArrivals` (`120 + 30 = 150`) exceeds the maximum positive value a `byte` can hold (`127`). When `150` is cast back to `byte` using `(byte)`, it causes an overflow, resulting in `-106`. To correctly store `150`, a larger integer type like `short` (range -32,768 to 32,767) is appropriate. The fix changes `goblinMinions` to `short` and adjusts the cast."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Recall the range of a `byte` data type (up to `127`).",
      "2": "The sum `120 + 30 = 150` exceeds the `byte` limit.",
      "3": "Consider a slightly larger integer primitive type that can comfortably hold `150`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 68,
    "subtopic_id": 2,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "An `ElementalRitual` sets `elementsAligned` based on `fireEnergy`. However, boolean literals (`true`/`false`) are incorrectly assigned to a `String` variable, causing a type mismatch. Fix the code to correctly store the `elementsAligned` status.",
      "code": "public class ElementalRitual {\n    public static void main(String[] args) {\n        int fireEnergy = 100;\n        String elementsAligned;\n\n        if (fireEnergy > 90) {\n            elementsAligned = true;\n        } else {\n            elementsAligned = false;\n        }\n        System.out.println(\"Elements Aligned: \" + elementsAligned);\n    }\n}",
      "expected_output": [
        "Elements Aligned: true"
      ],
      "hidden_test_case": "",
      "explanation": "The values `true` and `false` are boolean literals. Attempting to assign these to a `String` variable (`elementsAligned`) results in a type mismatch compilation error. The fix is to change the data type of `elementsAligned` from `String` to `boolean`, allowing it to correctly store the logical state."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The values `true` and `false` are specific to a certain primitive type.",
      "2": "A `String` holds sequences of characters, not logical states directly.",
      "3": "Look at the type of data being assigned to `elementsAligned`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 69,
    "subtopic_id": 2,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `RuneDecoder` attempts to decode a `rune` by assigning an integer ASCII value to a `char` variable. This causes a compilation error due to type conversion rules. Fix the code to correctly convert the integer value to its corresponding `char`.",
      "code": "public class RuneDecoder {\n    public static void main(String[] args) {\n        char decodedRune = 70;\n        System.out.println(\"Decoded Rune: \" + decodedRune);\n    }\n}",
      "expected_output": [
        "Decoded Rune: F"
      ],
      "hidden_test_case": "",
      "explanation": "Although `char` values are internally represented by integer codes (ASCII/Unicode), directly assigning an `int` literal to a `char` variable can result in a \"possible lossy conversion\" error if the `int` value is outside the `char` range (0 to 65535). Even if it's within range, explicit casting `(char)` is often required to clarify the intent of conversion. The fix adds the `(char)` cast, telling the compiler to explicitly convert the integer `70` to its character representation ('F')."
    },
    "difficulty": "medium",
    "hints": {
      "1": "While `char` values are backed by numbers, direct assignment of an `int` literal might be ambiguous or cause a compiler error for potential loss of data (if the int value is out of char range).",
      "2": "There's a way to explicitly tell Java to treat a number as a character.",
      "3": "What's the common mechanism for converting one data type to another?"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 70,
    "subtopic_id": 2,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `SpellTimer` records `spellCastTime`. The variable is a `float`, but the literal assigned is a `double` by default, leading to a compilation error due to potential precision loss. Fix the code to correctly assign the decimal value to the `float` variable.",
      "code": "public class SpellTimer {\n    public static void main(String[] args) {\n        float spellCastTime = 0.123456789;\n        System.out.println(\"Spell Cast Time: \" + spellCastTime);\n    }\n}",
      "expected_output": [
        "Spell Cast Time: 0.12345679"
      ],
      "hidden_test_case": "",
      "explanation": "In Java, a floating-point literal like `0.123456789` is by default treated as a `double`. Assigning a `double` to a `float` directly can cause a \"possible lossy conversion\" error because `double` has higher precision than `float`. The common fix is to explicitly make the literal a `float` by adding the `f` suffix (`0.123456789f`). Alternatively, the variable `spellCastTime` could be declared as a `double` if higher precision is desired."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Remember that decimal literals (`0.123...`) are `double` by default in Java.",
      "2": "Assigning a `double` to a `float` can result in a compilation error if not handled.",
      "3": "Consider adding a specific suffix to the numerical literal to designate it as a `float`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 71,
    "subtopic_id": 2,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `CosmicDustCollector` calculates `totalDustAccumulated` using large `long` values. However, their sum exceeds the maximum capacity of a `long`, causing an integer overflow. Fix the code to correctly handle and store this extremely large sum.",
      "code": "import java.math.BigInteger;\n\npublic class CosmicDustCollector {\n    public static void main(String[] args) {\n        long initialDust = 9000000000000000000L;\n        long newDust = 2000000000000000000L;\n        long totalDustAccumulated = initialDust + newDust;\n        System.out.println(\"Total Dust Accumulated: \" + totalDustAccumulated);\n    }\n}",
      "expected_output": [
        "Total Dust Accumulated: 11000000000000000000"
      ],
      "hidden_test_case": "",
      "explanation": "The sum of `initialDust` and `newDust` (`11 x 10^18`) exceeds the maximum value a `long` primitive can store (`9,223,372,036,854,775,807`). This results in an **integer overflow**, causing `totalDustAccumulated` to wrap around to a negative number or an incorrect positive value. For calculations involving numbers larger than `long.MAX_VALUE`, Java's `java.math.BigInteger` class (a non-primitive type, but crucial for handling numbers beyond primitive limits) must be used. The fix involves converting the `long` literals to `BigInteger` objects and performing the addition using `BigInteger`'s `add()` method."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Recall the maximum value that a `long` primitive can hold (approx. 9.2 x 10^18).",
      "2": "The sum of the two given `long` literals (`9 x 10^18 + 2 x 10^18 = 11 x 10^18`) clearly exceeds this limit.",
      "3": "When primitive types cannot hold a value, Java offers a special class for arbitrary-precision arithmetic."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 72,
    "subtopic_id": 2,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "An `ElementalConduitMonitor` tracks `currentEnergy`. Multiplying `currentEnergy` (an `int`) by `drainFactor` (a `double`) then assigning the result back to an `int` without proper casting causes a compilation error. Fix the code to correctly calculate and store the `currentEnergy`.",
      "code": "public class ElementalConduitMonitor {\n    public static void main(String[] args) {\n        int currentEnergy = 50;\n        double drainFactor = 0.6;\n        boolean emergencyShutdown = false;\n\n        currentEnergy = (int) currentEnergy * drainFactor;\n        \n        if (currentEnergy < 0) {\n            emergencyShutdown = true;\n        }\n        System.out.println(\"Current Energy: \" + currentEnergy);\n        System.out.println(\"Emergency Shutdown: \" + emergencyShutdown);\n    }\n}",
      "expected_output": [
        "Current Energy: 30",
        "Emergency Shutdown: false"
      ],
      "hidden_test_case": "",
      "explanation": "The original code `currentEnergy = (int) currentEnergy * drainFactor;` attempts to cast `currentEnergy` (which is already an `int`) and then multiply by `drainFactor`. However, the result of `int * double` is a `double`. Trying to assign this `double` result back to an `int` variable (`currentEnergy`) without casting the *entire expression* causes a compilation error (possible lossy conversion). The fix is to ensure the multiplication `currentEnergy * drainFactor` occurs first, and *then* the entire `double` result is explicitly cast to `int` for assignment: `currentEnergy = (int) (currentEnergy * drainFactor);`. This correctly calculates `30.0` and truncates it to `30`, and `emergencyShutdown` remains `false` as `30` is not less than `0`."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The `(int)` cast has higher precedence than multiplication unless parentheses change it.",
      "2": "Multiplying an `int` by a `double` will promote the `int` to `double` for the calculation.",
      "3": "If you want the entire result of an expression involving `double` to be an `int`, the cast needs to apply to the *entire expression*."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 73,
    "subtopic_id": 2,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "An `OracleSystem` sets a `prophecyOutcome` based on whether an `omenRevealed`. The `prophecyOutcome` variable is local and might not be initialized if the `if` condition is `false`, causing a compilation error. Fix the code to ensure `prophecyOutcome` is always initialized.",
      "code": "public class OracleSystem {\n    public static void main(String[] args) {\n        int initialMana = 100;\n        boolean omenRevealed = false;\n        String prophecyOutcome;\n\n        if (initialMana > 90) {\n            omenRevealed = true;\n        }\n\n        if (omenRevealed) {\n            prophecyOutcome = \"Great fortune awaits!\";\n        }\n        \n        System.out.println(\"Prophecy: \" + prophecyOutcome);\n    }\n}",
      "expected_output": [
        "Prophecy: Great fortune awaits!"
      ],
      "hidden_test_case": "",
      "explanation": "The `prophecyOutcome` variable is a local variable. Java requires all local variables to be explicitly initialized before they are used. In the original code, if `omenRevealed` were `false` (e.g., if `initialMana` was less than or equal to `90`), `prophecyOutcome` would never be assigned a value before being used in `System.out.println()`, leading to a \"variable might not have been initialized\" error. The fix is to provide a default initialization value (e.g., `\"Future is uncertain.\"`) when `prophecyOutcome` is declared, guaranteeing it always has a value."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Java's \"definitely assigned\" rule for local variables is very strict.",
      "2": "Even if a condition *seems* like it will always be true or false, the compiler checks all possible execution paths.",
      "3": "Consider providing a default or initial value at the point of declaration to satisfy the compiler."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 74,
    "subtopic_id": 2,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `SpellResultDecoder` attempts to convert a `numericalResult` (an `int`) into a `char` for `spellResultCode`. Directly assigning an `int` to a `char` (especially a negative `int`) causes a compilation error. Fix the code to correctly convert the numerical result to a `char`.",
      "code": "public class SpellResultDecoder {\n    public static void main(String[] args) {\n        int numericalResult = -50;\n        char spellResultCode = numericalResult;\n        System.out.println(\"Spell Result Code: \" + spellResultCode);\n    }\n}",
      "expected_output": [
        "Spell Result Code: "
      ],
      "hidden_test_case": "",
      "explanation": "Directly assigning an `int` value (especially a negative one like `-50`) to a `char` variable is a \"possible lossy conversion\" and causes a compilation error. While `char` is an unsigned 16-bit integer type internally (0 to 65535), `int` is signed 32-bit. To explicitly convert an `int` to a `char`, a cast `(char)` is required. When a negative `int` is cast to `char`, its bits are reinterpreted, resulting in a positive `char` value (e.g., `-50` becomes `65486`). This character might be unprintable, often displayed as a replacement character ()."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The `char` data type represents Unicode characters, which have an integer value range from 0 to 65535.",
      "2": "Assigning an `int` directly to a `char` can be problematic if the `int` is negative or very large, requiring explicit conversion.",
      "3": "Consider how Java handles integer values that don't fit into a `char` when explicitly cast."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 75,
    "subtopic_id": 2,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "An `ArcaneForceCalculator` determines `arcaneForce` from `baseStrength` (float) and `fluxFactor` (double). Assigning the `double` result of their multiplication directly to a `float` causes a compilation error due to precision loss. Fix the code to correctly store `arcaneForce` as a `float`.",
      "code": "public class ArcaneForceCalculator {\n    public static void main(String[] args) {\n        float baseStrength = 100.5f;\n        double fluxFactor = 0.3333333333333333;\n        float arcaneForce = baseStrength * fluxFactor;\n        System.out.println(\"Arcane Force: \" + arcaneForce);\n    }\n}",
      "expected_output": [
        "Arcane Force: 33.500004"
      ],
      "hidden_test_case": "",
      "explanation": "The expression `baseStrength * fluxFactor` involves a `float` and a `double`. Java's type promotion rules dictate that the `float` (`baseStrength`) will be promoted to a `double` for the calculation, resulting in a `double` value. Attempting to assign this `double` result directly back to a `float` variable (`arcaneForce`) causes a \"possible lossy conversion\" compilation error. To fix this, you must explicitly cast the entire result of the multiplication to `float` using `(float)`. This tells Java that you are aware of and accept the potential loss of precision. (Alternatively, changing `arcaneForce` to `double` would also resolve the error, but the prompt implies a `float` is desired)."
    },
    "difficulty": "hard",
    "hints": {
      "1": "When a `float` and `double` are involved in an arithmetic operation, Java performs `type promotion` to the higher precision type.",
      "2": "The result of the multiplication (`baseStrength * fluxFactor`) will be of the higher precision type.",
      "3": "Assigning a higher precision value to a lower precision variable without explicit handling causes a \"possible lossy conversion\" error."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 76,
    "subtopic_id": 2,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `ManaPool` system tracks its `manaCapacity`. The `manaCapacity` variable needs to be declared to hold a whole number. Complete the declaration.",
      "code": "public class ManaPool {\n    public static void main(String[] args) {\n        ??? manaCapacity = 100;\n        System.out.println(\"Mana Capacity: \" + manaCapacity);\n    }\n}",
      "choices": [
        "boolean",
        "int",
        "char",
        "double"
      ]
    },
    "difficulty": "easy",
    "hints": {
      "1": "The value `100` is a whole number.",
      "2": "Recall the Java primitive type used for integers.",
      "3": "The variable name is `manaCapacity`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 77,
    "subtopic_id": 2,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `CharmGuardian` activates a `protectionCharm`. The `protectionCharmActive` variable needs to be declared as a boolean and initialized to `true`. Complete the declaration and initialization.",
      "code": "public class CharmGuardian {\n    public static void main(String[] args) {\n        boolean ??? = ???;\n        System.out.println(\"Protection Charm Active: \" + protectionCharmActive);\n    }\n}",
      "choices": [
        "int protectionCharmActive",
        "boolean protectionCharmActive",
        "false",
        "true"
      ]
    },
    "difficulty": "easy",
    "hints": {
      "1": "The variable should store a `true` or `false` value.",
      "2": "The scenario explicitly states the initial state.",
      "3": "Identify the correct type and literal for logical states."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 78,
    "subtopic_id": 2,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `MapPlotter` draws symbols on a magical map. The `mapSymbol` variable needs to be declared and initialized to hold the character '@'. Complete the declaration and initialization.",
      "code": "public class MapPlotter {\n    public static void main(String[] args) {\n        ??? = ???;\n        System.out.println(\"Map Symbol: \" + mapSymbol);\n    }\n}",
      "choices": [
        "char mapSymbol",
        "String mapSymbol",
        "'@'",
        "\"@\""
      ],
      "answer": [
        "char mapSymbol",
        "'@'"
      ],
      "explanation": "The variable `mapSymbol` is meant to store a single character, `'@'`. The `char` primitive data type is used for single characters, and character literals are enclosed in single quotes. Therefore, `char mapSymbol` and `'@'` are the correct completions."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The variable is meant to hold a *single* character.",
      "2": "Recall the primitive type for single characters.",
      "3": "How are single character literals written in Java?"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 79,
    "subtopic_id": 2,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `PotionBrewer` measures `potionVolume`. The `potionVolume` variable needs to be declared to store a decimal value. Complete the declaration.",
      "code": "public class PotionBrewer {\n    public static void main(String[] args) {\n        ??? potionVolume = 5.75;\n        System.out.println(\"Potion Volume: \" + potionVolume);\n    }\n}",
      "choices": [
        "int",
        "float",
        "long",
        "double"
      ],
      "answer": [
        "double"
      ],
      "explanation": "The value `5.75` is a decimal number. In Java, `double` is the default and recommended primitive data type for floating-point numbers due to its higher precision. Therefore, `double` is the correct keyword to complete the declaration for `potionVolume`."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The value `5.75` has a decimal point.",
      "2": "Recall the most commonly used Java primitive type for precise decimal numbers.",
      "3": "Decimal literals like `5.75` are treated as this type by default."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 80,
    "subtopic_id": 2,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "An `ImpScout` counts `impsSeen`. The `impsSeen` variable needs to be declared to store a small whole number efficiently. Complete the declaration.",
      "code": "public class ImpScout {\n    public static void main(String[] args) {\n        ??? impsSeen = 15;\n        System.out.println(\"Imps Seen: \" + impsSeen);\n    }\n}",
      "choices": [
        "int",
        "short",
        "byte",
        "long"
      ],
      "answer": [
        "byte"
      ],
      "explanation": "The value `15` is a small whole number. The `byte` primitive data type is the most memory-efficient integer type in Java, capable of storing values from `-128` to `127`. Since `15` falls well within this range, `byte` is the most appropriate choice for `impsSeen`."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The number `15` is a very small integer.",
      "2": "Recall the Java primitive type designed for the smallest range of whole numbers.",
      "3": "This type uses only 8 bits of memory."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 81,
    "subtopic_id": 2,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "An `ArcaneArchitecture` spell constructs magical spires. The `numberOfSpires` variable needs to be declared to store a medium-sized whole number. Complete the declaration.",
      "code": "public class ArcaneArchitecture {\n    public static void main(String[] args) {\n        ??? = 30000;\n        System.out.println(\"Number of Spires: \" + numberOfSpires);\n    }\n}",
      "choices": [
        "int numberOfSpires",
        "short numberOfSpires",
        "long numberOfSpires",
        "byte numberOfSpires"
      ],
      "answer": [
        "short numberOfSpires"
      ],
      "explanation": "The number `30000` is an integer that exceeds the range of a `byte` (`-128` to `127`) but fits within the range of a `short` (`-32,768` to `32,767`). While `int` or `long` would also work, `short` is the most memory-efficient primitive type that can correctly store this value."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The number `30000` is a whole number, but too large for a `byte`.",
      "2": "Consider the primitive integer type that is larger than `byte` but smaller than `int`.",
      "3": "This type is typically 16-bit."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 82,
    "subtopic_id": 2,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `ScrollEvaluator` checks a magical scroll's condition. The `scrollCondition` variable needs to be declared and initialized as a `char` with the character '0', and `isPristine` needs to be declared as a boolean.",
      "code": "public class ScrollEvaluator {\n    public static void main(String[] args) {\n        ??? scrollCondition = ???;\n        boolean isPristine;\n\n        if (scrollCondition == '0') {\n            isPristine = true;\n        } else {\n            isPristine = false;\n        }\n        System.out.println(\"Scroll Condition: \" + scrollCondition);\n        System.out.println(\"Is Pristine: \" + isPristine);\n    }\n}",
      "choices": [
        "char",
        "String",
        "'0'",
        "0"
      ],
      "answer": [
        "char",
        "'0'"
      ],
      "explanation": "The `scrollCondition` variable is meant to store a single character, as implied by its comparison with `'0'`. Therefore, `char` is the correct primitive type. To assign the character `0` as a literal, it must be enclosed in single quotes (`'0'`)."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The variable `scrollCondition` is expected to hold a single character.",
      "2": "The value `0` should be treated as a character, not a number.",
      "3": "How do you denote a character literal in Java?"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 83,
    "subtopic_id": 2,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `GolemCrafter` creates golems with a specific `golemWeight`. The `golemWeight` variable needs to be declared as a `float` to store a floating-point literal ending with 'f'. Complete the declaration.",
      "code": "public class GolemCrafter {\n    public static void main(String[] args) {\n        ??? = 500.0f;\n        System.out.println(\"Golem Weight: \" + golemWeight);\n    }\n}",
      "choices": [
        "double golemWeight",
        "float golemWeight",
        "int golemWeight",
        "long golemWeight"
      ],
      "answer": [
        "float golemWeight"
      ],
      "explanation": "The literal `500.0f` is explicitly a `float` literal due to the `f` suffix. Without this suffix, `500.0` would be treated as a `double` by default. To correctly declare a variable that can hold this specific type of floating-point number, the `float` data type must be used."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Notice the `f` suffix on the numerical literal.",
      "2": "This suffix explicitly designates the literal as a specific primitive floating-point type.",
      "3": "The variable name is `golemWeight`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 84,
    "subtopic_id": 2,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `ChargeCalculator` determines the `arcaneCharge` based on `baseCharge` and a `multiplier`. Complete the declaration of `arcaneCharge` to correctly store the result of the multiplication.",
      "code": "public class ChargeCalculator {\n    public static void main(String[] args) {\n        int baseCharge = 25;\n        int multiplier = 3;\n        ??? = baseCharge * multiplier;\n        System.out.println(\"Arcane Charge: \" + arcaneCharge);\n    }\n}",
      "choices": [
        "arcaneCharge",
        "int arcaneCharge",
        "double arcaneCharge",
        "String arcaneCharge"
      ],
      "answer": [
        "int arcaneCharge"
      ],
      "explanation": "The expression `baseCharge * multiplier` (`25 * 3`) results in `75`, which is an integer. Therefore, `int` is the appropriate primitive data type for `arcaneCharge`. The blank requires both the type and the variable name, so `int arcaneCharge` is the correct completion."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The result of `int * int` multiplication is always an `int`.",
      "2": "The missing part requires both the type and name for the `arcaneCharge` variable.",
      "3": "Ensure the chosen type can hold a whole number."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 85,
    "subtopic_id": 2,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `GolemTracker` records a `locationCode` based on an `asciiValue`. Complete the declaration and type casting to correctly convert the integer `asciiValue` into a `char` for `locationCode`.",
      "code": "public class GolemTracker {\n    public static void main(String[] args) {\n        int asciiValue = 90;\n        ??? = ???;\n        System.out.println(\"Golem Location: \" + locationCode);\n    }\n}",
      "choices": [
        "char locationCode",
        "int locationCode",
        "(char) asciiValue",
        "asciiValue"
      ],
      "answer": [
        "char locationCode",
        "(char) asciiValue"
      ],
      "explanation": "The `locationCode` is intended to be a character, derived from an integer ASCII value. The `char` primitive type (choice a) is used for characters. To convert an `int` to a `char` explicitly, a type cast `(char)` is required, applying it to `asciiValue` (choice c). Thus, `char locationCode = (char) asciiValue;` correctly initializes the variable."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The `locationCode` is intended to be a character.",
      "2": "An integer (`asciiValue`) needs to be converted to a character explicitly.",
      "3": "Recall the syntax for explicit type casting."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 86,
    "subtopic_id": 2,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `ManaOverflowMonitor` tracks a large `manaReservoir` and sets a `warningFlag` based on `additionalMana` that might cause an overflow. Complete the declaration of `manaReservoir` and ensure `warningFlag` is assigned in all conditional paths.",
      "code": "public class ManaOverflowMonitor {\n    public static void main(String[] args) {\n        ??? manaReservoir = 5000000000L;\n        int additionalMana = 1000000000;\n        boolean warningFlag;\n\n        if (additionalMana > (Integer.MAX_VALUE - (int)manaReservoir)) {\n             ??? = true;\n        } else {\n             ??? = false;\n        }\n        \n        System.out.println(\"Mana Reservoir: \" + manaReservoir);\n        System.out.println(\"Warning Flag: \" + warningFlag);\n    }\n}",
      "choices": [
        "long",
        "int",
        "warningFlag",
        "isWarning"
      ],
      "answer": [
        "long",
        "warningFlag",
        "warningFlag"
      ],
      "explanation": "1. `manaReservoir` needs to store `5000000000L`, which is a `long` literal. Therefore, `long` is the correct data type.\n2. The `warningFlag` is a local boolean variable that needs to be definitively assigned a value before it's printed. The blanks in both the `if` and `else` branches are responsible for this assignment. They should both use the variable name `warningFlag`."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The value `5000000000L` is too large for an `int`.",
      "2": "The `warningFlag` variable needs to be assigned a value in both `if` and `else` branches.",
      "3": "The blank in the `if` and `else` blocks should refer to the already declared boolean variable."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 87,
    "subtopic_id": 2,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "An `AlchemistMixture` calculates a `volatileMixture` from `baseConcentration`. The `volatileMixture` must be a `float`, and `stableStatus` is determined by its value. Complete the declarations and the assignment for `stableStatus` in the `else` block.",
      "code": "public class AlchemistMixture {\n    public static void main(String[] args) {\n        double baseConcentration = 1.0 / 3.0;\n        ??? volatileMixture = (float) (baseConcentration * 3.0);\n        boolean stableStatus;\n\n        if (volatileMixture == 1.0f) {\n            stableStatus = true;\n        } else {\n            ??? = false;\n        }\n        \n        System.out.println(\"Mixture Purity: \" + volatileMixture);\n        System.out.println(\"Stable Status: \" + stableStatus);\n    }\n}",
      "choices": [
        "float",
        "volatileMixture",
        "double",
        "stableStatus"
      ],
      "answer": [
        "float",
        "stableStatus"
      ],
      "explanation": "1. The problem states that `volatileMixture` must be a `float`. The expression `(float) (baseConcentration * 3.0)` correctly calculates `(1.0/3.0) * 3.0` (which is `0.999...`), then casts this `double` result to `float`.\n2. The `stableStatus` boolean variable needs to be assigned a value in both the `if` and `else` branches of the conditional statement to satisfy Java's definite assignment rules. The blank in the `else` block should refer to the `stableStatus` variable itself."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The first blank needs the data type for `volatileMixture`, which must be a `float`.",
      "2": "The result of `baseConcentration * 3.0` is a `double`. How do you assign a `double` result to a `float` variable?",
      "3": "The `stableStatus` variable needs to be assigned a value in all conditional paths."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 88,
    "subtopic_id": 2,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "An `OathInscriber` manages `oathText` and `hasBeenSworn` status. The `oathText` is intended to be a constant, and `hasBeenSworn` is set based on its length. Complete the `final` declaration for `oathText` and the assignment for `hasBeenSworn`.",
      "code": "public class OathInscriber {\n    public static void main(String[] args) {\n        ??? String oathText = \"By ancient magic, I swear.\";\n        boolean hasBeenSworn = false;\n\n        if (oathText.length() > 20) {\n            ??? = true;\n        }\n\n        System.out.println(\"Oath: \" + oathText);\n        System.out.println(\"Sworn: \" + hasBeenSworn);\n    }\n}",
      "choices": [
        "final",
        "static",
        "hasBeenSworn",
        "isSworn"
      ],
      "answer": [
        "final",
        "hasBeenSworn"
      ],
      "explanation": "1. To make `oathText` a constant that cannot be changed after initialization, the `final` keyword must be placed before its declaration.\n2. The blank inside the `if` block is assigning a value to the `hasBeenSworn` variable, so its name `hasBeenSworn` should be placed there."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The `oathText` is meant to be permanent. What keyword makes a variable immutable?",
      "2": "The boolean variable `hasBeenSworn` is updated inside the `if` block.",
      "3": "What should be placed in that blank?"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 89,
    "subtopic_id": 2,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `SentinelSystem` manages `sentinelEnergy`, `shieldStatus`, and `dangerProtocol`. `sentinelEnergy` is an integer. `shieldStatus` and `dangerProtocol` are set conditionally in an `if-else` structure. Complete the declaration of `sentinelEnergy` and the assignments for `shieldStatus` and `dangerProtocol` in the `else` block.",
      "code": "public class SentinelSystem {\n    public static void main(String[] args) {\n        ??? sentinelEnergy = 120;\n        String shieldStatus;\n        boolean dangerProtocol;\n\n        if (sentinelEnergy > 100) {\n            shieldStatus = \"Shields Online.\";\n            dangerProtocol = false;\n        } else {\n            ??? = \"Shields Offline.\";\n            ??? = true;\n        }\n        \n        System.out.println(\"Energy: \" + sentinelEnergy);\n        System.out.println(\"Status: \" + shieldStatus);\n        System.out.println(\"Protocol: \" + dangerProtocol);\n    }\n}",
      "choices": [
        "int",
        "dangerProtocol",
        "shieldStatus",
        "boolean"
      ],
      "answer": [
        "int",
        "shieldStatus",
        "dangerProtocol"
      ],
      "explanation": "1. `sentinelEnergy` stores a whole number (`120`), so `int` is the correct data type for its declaration.\n2. In the `else` block, the first blank assigns a string literal `\"Shields Offline.\"`, so the variable name `shieldStatus` should fill this blank.\n3. The second blank in the `else` block assigns a boolean literal `true`, so the variable name `dangerProtocol` should fill this blank. This ensures `dangerProtocol` is initialized in both `if` and `else` paths."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The `sentinelEnergy` variable stores a whole number.",
      "2": "The blank in the `else` block that assigns a string value should be the `shieldStatus` variable.",
      "3": "The blank that assigns a boolean value in the `else` block should be the `dangerProtocol` variable."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 90,
    "subtopic_id": 2,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `GlyphCalculator` calculates `glyphValue` from `initialFragment` and `enhancementFactor`, then determines `glyphStatus` based on `glyphValue`. Complete the declaration of `glyphValue` and the assignment for `glyphStatus` in the `else` block.",
      "code": "public class GlyphCalculator {\n    public static void main(String[] args) {\n        byte initialFragment = 120;\n        short enhancementFactor = 200;\n        ??? = initialFragment + enhancementFactor;\n        char glyphStatus;\n\n        if (glyphValue > 255) {\n            glyphStatus = '!';\n        } else {\n            ??? = (char) glyphValue;\n        }\n        \n        System.out.println(\"Glyph Value: \" + glyphValue);\n        System.out.println(\"Glyph Status: \" + glyphStatus);\n    }\n}",
      "choices": [
        "int glyphValue",
        "short glyphValue",
        "glyphStatus",
        "char glyphStatus",
        "(byte)"
      ],
      "answer": [
        "int glyphValue",
        "glyphStatus"
      ],
      "explanation": "1. The sum `initialFragment + enhancementFactor` (`120 + 200 = 320`) exceeds the maximum range of both `byte` (127) and `short` (32767). To correctly store this sum without overflow, `int` is the appropriate data type for `glyphValue`. Java will automatically promote `byte` and `short` to `int` for the calculation.\n2. In the `else` block, the blank is assigning a value to the `glyphStatus` variable, which is of `char` type. The correct variable name is `glyphStatus`."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The sum of `initialFragment` and `enhancementFactor` (`120 + 200 = 320`) exceeds the range of both `byte` and `short`.",
      "2": "The `glyphValue` needs to hold this sum without overflow.",
      "3": "The blank in the `else` block should assign a value to the `glyphStatus` variable, which is a character type."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 91,
    "subtopic_id": 3,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `SimpleSpellScroll` system records `spellName`. Your task is to trace the code and determine the exact `Spell Name` that is printed by the system.",
      "code": "public class SimpleSpellScroll {\n    public static void main(String[] args) {\n        String spellName = \"Lumos\";\n        System.out.println(\"Spell Name: \" + spellName);\n    }\n}",
      "choices": [
        "Lumos",
        "Spell Name: Lumos",
        "spellName",
        "Error"
      ],
      "answer": [
        "Spell Name: Lumos"
      ],
      "explanation": "The `String spellName = \"Lumos\";` line declares a `String` variable `spellName` and assigns it the text `\"Lumos\"`. The `System.out.println(\"Spell Name: \" + spellName);` line then combines the literal string \"Spell Name: \" with the value of `spellName`, printing \"Spell Name: Lumos\"."
    },
    "difficulty": "easy",
    "hints": {
      "1": "Identify the value stored in the `spellName` variable.",
      "2": "The `+` operator combines text strings.",
      "3": "The output will combine the literal \"Spell Name: \" with the content of `spellName`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 92,
    "subtopic_id": 3,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `PotionIngredients` system tracks ingredients in an array. Your task is to trace the code and determine the count of the `First Ingredient` that is printed by the system.",
      "code": "public class PotionIngredients {\n    public static void main(String[] args) {\n        int[] ingredients = {10, 5, 20};\n        System.out.println(\"First Ingredient Count: \" + ingredients[0]);\n    }\n}",
      "choices": [
        "First Ingredient Count: 10",
        "10",
        "First Ingredient Count: 0",
        "Error"
      ],
      "answer": [
        "First Ingredient Count: 10"
      ],
      "explanation": "The line `int[] ingredients = {10, 5, 20};` declares an array named `ingredients` and initializes it with three integer values. Array indices start from `0`. So, `ingredients[0]` refers to the first element, which is `10`. The `System.out.println()` statement then prints \"First Ingredient Count: \" concatenated with the value of `ingredients[0]`, resulting in \"First Ingredient Count: 10\"."
    },
    "difficulty": "easy",
    "hints": {
      "1": "Arrays in Java are zero-indexed, meaning the first element is at index 0.",
      "2": "Identify which value is at the specified index.",
      "3": "The `+` operator combines the string and the array element's value."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 93,
    "subtopic_id": 3,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `PhraseComparer` checks if two `magicPhrase`s are identical. Your task is to trace the code and determine if the phrases are considered `Identical` based on Java's `String` comparison rules.",
      "code": "public class PhraseComparer {\n    public static void main(String[] args) {\n        String magicPhrase1 = \"Abra Cadabra\";\n        String magicPhrase2 = \"Abra Cadabra\";\n        boolean areIdentical = (magicPhrase1 == magicPhrase2);\n        System.out.println(\"Phrases Identical: \" + areIdentical);\n    }\n}",
      "choices": [
        "Phrases Identical: true",
        "Phrases Identical: false",
        "Error",
        "Abra Cadabra"
      ],
      "answer": [
        "Phrases Identical: true"
      ],
      "explanation": "When comparing `String` literals that have the exact same sequence of characters (like `\"Abra Cadabra\"`), Java's compiler often performs a trick called \"string interning.\" This means it stores only one copy of that literal in memory and makes both `magicPhrase1` and `magicPhrase2` variables point to that *exact same object*. Because they are referencing the same object in memory, `magicPhrase1 == magicPhrase2` evaluates to `true`. This behavior is specific to *literals*; for strings created dynamically (e.g., `new String(\"...\")`), `==` would typically be `false`."
    },
    "difficulty": "easy",
    "hints": {
      "1": "For `String` literals, Java often performs \"string interning\" (reusing the same object for identical literals).",
      "2": "The `==` operator for non-primitive types compares memory addresses.",
      "3": "Consider if both variables point to the exact same object in memory due to interning."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 94,
    "subtopic_id": 3,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `CreatureList` tracks magical creatures in an array. The first creature in the list is reassigned. Your task is to trace the code and determine the `First Creature` after the update.",
      "code": "public class CreatureList {\n    public static void main(String[] args) {\n        String[] magicalCreatures = {\"Dragon\", \"Griffin\", \"Unicorn\"};\n        magicalCreatures[0] = \"Phoenix\";\n        System.out.println(\"First Creature: \" + magicalCreatures[0]);\n    }\n}",
      "choices": [
        "First Creature: Dragon",
        "First Creature: Phoenix",
        "Phoenix",
        "Error"
      ],
      "answer": [
        "First Creature: Phoenix"
      ],
      "explanation": "The `String[] magicalCreatures` array is initialized with \"Dragon\" at index `0`. The line `magicalCreatures[0] = \"Phoenix\";` then directly reassigns the element at index `0`, changing it from \"Dragon\" to \"Phoenix\". When `System.out.println()` executes, it prints the updated value, which is \"Phoenix\"."
    },
    "difficulty": "easy",
    "hints": {
      "1": "Arrays are mutable, meaning their elements can be changed after creation.",
      "2": "The assignment `magicalCreatures[0] = \"Phoenix\";` directly overwrites the previous value.",
      "3": "The `println` statement displays the most recent value at that index."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 95,
    "subtopic_id": 3,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `SpellRecorder` tracks `spellSequence` and determines its length. Your task is to trace the code and determine the `Sequence Length` that is printed.",
      "code": "public class SpellRecorder {\n    public static void main(String[] args) {\n        String spellSequence = \"Incendio\";\n        System.out.println(\"Sequence Length: \" + spellSequence.length());\n    }\n}",
      "choices": [
        "8",
        "Sequence Length: 8",
        "0",
        "Sequence Length: Incendio"
      ],
      "answer": [
        "Sequence Length: 8"
      ],
      "explanation": "The `String spellSequence = \"Incendio\";` line initializes `spellSequence` to the text \"Incendio\". The `spellSequence.length()` method is then called on this string. \"Incendio\" has 8 characters, so `.length()` returns `8`. Finally, `System.out.println(\"Sequence Length: \" + 8);` prints \"Sequence Length: 8\"."
    },
    "difficulty": "easy",
    "hints": {
      "1": " `String` objects have built-in methods (spells) like `.length()`.",
      "2": "The `.length()` method returns the number of characters in the string.",
      "3": "The `+` operator combines the literal string with the numerical result of the method."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 96,
    "subtopic_id": 3,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "An `ElementalIncantation` system combines `element` and `action` into an `elementalIncantation`. Your task is to trace the code and determine the final `Incantation` and its `Length`.",
      "code": "public class ElementalIncantation {\n    public static void main(String[] args) {\n        String element = \"Fire\";\n        String action = \"Blast\";\n        String elementalIncantation = element + \" \" + action;\n        \n        System.out.println(\"Incantation: \" + elementalIncantation);\n        System.out.println(\"Length: \" + elementalIncantation.length());\n    }\n}",
      "choices": [
        "Incantation: Fire",
        "Incantation: Fire Blast",
        "Length: 9",
        "Length: 10"
      ],
      "answer": [
        "Incantation: Fire Blast",
        "Length: 9"
      ],
      "explanation": "1. `element` is \"Fire\", `action` is \"Blast\".\n2. `elementalIncantation = element + \" \" + action;` concatenates \"Fire\", a space, and \"Blast\", resulting in `elementalIncantation` being \"Fire Blast\".\n3. The first `System.out.println()` prints \"Incantation: Fire Blast\".\n4. The `elementalIncantation.length()` method counts the characters in \"Fire Blast\" (4 for \"Fire\" + 1 for space + 5 for \"Blast\"), resulting in `9`.\n5. The second `System.out.println()` prints \"Length: 9\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Observe how the `+` operator behaves when combining multiple `String`s and spaces.",
      "2": "Count all characters, including spaces, in the final concatenated string to determine its length.",
      "3": "Each `System.out.println()` statement produces a separate line of output."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 97,
    "subtopic_id": 3,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `PotionInventoryTracker` tracks `potionStock` in an array. The count of the second potion is updated. Your task is to trace the code and determine the `Initial Second Potion` count and the `Final Second Potion` count after the update.",
      "code": "public class PotionInventoryTracker {\n    public static void main(String[] args) {\n        int[] potionStock = {5, 10, 15};\n        System.out.println(\"Initial Second Potion: \" + potionStock[1]);\n        \n        potionStock[1] = potionStock[1] - 3;\n        \n        System.out.println(\"Final Second Potion: \" + potionStock[1]);\n    }\n}",
      "choices": [
        "Initial Second Potion: 5",
        "Initial Second Potion: 10",
        "Final Second Potion: 7",
        "Final Second Potion: 10"
      ],
      "answer": [
        "Initial Second Potion: 10",
        "Final Second Potion: 7"
      ],
      "explanation": "1. `int[] potionStock = {5, 10, 15};` initializes the array. The second element (`potionStock[1]`) is `10`.\n2. The first `System.out.println()` prints \"Initial Second Potion: 10\".\n3. `potionStock[1] = potionStock[1] - 3;` updates `potionStock[1]` to `10 - 3 = 7`.\n4. The second `System.out.println()` prints \"Final Second Potion: 7\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Arrays are zero-indexed: `potionStock[1]` refers to the second element.",
      "2": "Trace the value of `potionStock[1]` through both the initial print and the subsequent calculation.",
      "3": "The `potionStock[1] = potionStock[1] - 3;` line updates the array element directly."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 98,
    "subtopic_id": 3,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `MirrorSpell` creates `newSpellImage` from an `originalSpell`. Your task is to trace the code and determine if their content and object references are `Identical`.",
      "code": "public class MirrorSpell {\n    public static void main(String[] args) {\n        String originalSpell = \"Reflect\";\n        String newSpellImage = new String(\"Reflect\");\n        \n        System.out.println(\"Content Match: \" + originalSpell.equals(newSpellImage));\n        System.out.println(\"Object Identical: \" + (originalSpell == newSpellImage));\n    }\n}",
      "choices": [
        "Content Match: false",
        "Content Match: true",
        "Object Identical: false",
        "Object Identical: true"
      ],
      "answer": [
        "Content Match: true",
        "Object Identical: false"
      ],
      "explanation": "1. `String originalSpell = \"Reflect\";` creates a `String` literal.\n2. `String newSpellImage = new String(\"Reflect\");` explicitly creates a *new* `String` object in memory, even though its content is identical to `originalSpell`.\n3. `originalSpell.equals(newSpellImage)` compares the *content* (\"Reflect\" vs. \"Reflect\"), which is `true`. The first `System.out.println()` prints \"Content Match: true\".\n4. `originalSpell == newSpellImage` compares their memory *references*. Since `newSpellImage` was created with `new`, it resides at a different memory location than `originalSpell`. Therefore, this comparison is `false`. The second `System.out.println()` prints \"Object Identical: false\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The `.equals()` method compares the *content* of `String` objects.",
      "2": "The `==` operator for non-primitive types compares memory *references* (do they point to the exact same object?).",
      "3": "The `new String(\"Reflect\")` explicitly creates a *new* object in memory."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 99,
    "subtopic_id": 3,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `CursedItemRegistry` lists `cursedItems` in an array. The first item is destroyed by setting its reference to `null`. Your task is to trace the code and determine the `Third Item` initially and the `First Item After Destruction`.",
      "code": "public class CursedItemRegistry {\n    public static void main(String[] args) {\n        String[] cursedItems = {\"Amulet\", \"Orb\", \"Tome\"};\n        System.out.println(\"Third Item: \" + cursedItems[2]);\n        \n        cursedItems[0] = null;\n        \n        System.out.println(\"First Item After Destruction: \" + cursedItems[0]);\n    }\n}",
      "choices": [
        "Third Item: Orb",
        "Third Item: Tome",
        "First Item After Destruction: Amulet",
        "First Item After Destruction: null"
      ],
      "answer": [
        "Third Item: Tome",
        "First Item After Destruction: null"
      ],
      "explanation": "1. `String[] cursedItems = {\"Amulet\", \"Orb\", \"Tome\"};` initializes the array.\n2. The first `System.out.println()` prints \"Third Item: \" concatenated with `cursedItems[2]`, which is \"Tome\".\n3. `cursedItems[0] = null;` sets the first element of the array to `null`, meaning it no longer refers to the \"Amulet\" object.\n4. The second `System.out.println()` prints \"First Item After Destruction: \" concatenated with `cursedItems[0]`, which is now `null`."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Arrays are zero-indexed: `cursedItems[2]` refers to the third element.",
      "2": "Assigning `null` to an array element effectively removes its reference to an object, marking that slot as empty.",
      "3": "The `println` statements show the value *at the moment of execution*."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 100,
    "subtopic_id": 3,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `MagicMessenger` decodes a `cipherMessage`. Your task is to trace the code and determine its `First Letter` and whether it `Starts with 'ARCANE'`.",
      "code": "public class MagicMessenger {\n    public static void main(String[] args) {\n        String cipherMessage = \"ARCANE SCROLL\";\n        \n        char firstLetter = cipherMessage.charAt(0);\n        boolean startsWithArcane = cipherMessage.startsWith(\"ARCANE\");\n        \n        System.out.println(\"First Letter: \" + firstLetter);\n        System.out.println(\"Starts with 'ARCANE': \" + startsWithArcane);\n    }\n}",
      "choices": [
        "First Letter: A",
        "First Letter: R",
        "Starts with 'ARCANE': false",
        "Starts with 'ARCANE': true"
      ],
      "answer": [
        "First Letter: A",
        "Starts with 'ARCANE': true"
      ],
      "explanation": "1. `String cipherMessage = \"ARCANE SCROLL\";` initializes the string.\n2. `cipherMessage.charAt(0)` returns the character at index 0, which is `'A'`.\n3. `cipherMessage.startsWith(\"ARCANE\")` checks if \"ARCANE SCROLL\" starts with \"ARCANE\". This is `true`.\n4. The first `System.out.println()` prints \"First Letter: A\".\n5. The second `System.out.println()` prints \"Starts with 'ARCANE': true\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": "`charAt(0)` retrieves the character at the very beginning of a string (index 0).",
      "2": "The `startsWith()` method checks if a string begins with the specified prefix.",
      "3": "String comparisons are case-sensitive."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 101,
    "subtopic_id": 3,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "An `ElementalSigil` combines parts of a `baseCode` into a `sigilCode`. It also updates an `enchantmentGlyphs` array and checks for a `matchFound` with a `targetGlyph`. Your task is to trace the code and determine the `Final Sigil Code`, `First Enchantment Glyph`, and `Match Found (Reference)` status.",
      "code": "public class ElementalSigil {\n    public static void main(String[] args) {\n        String baseCode = \"FIRE-AETHER\";\n        String sigilCode = baseCode.substring(0, 4) + \"!\" + baseCode.substring(5, baseCode.length());\n        \n        String[] enchantmentGlyphs = {\"Alpha\", \"Beta\", \"Gamma\"};\n        String targetGlyph = new String(\"Alpha\");\n        \n        enchantmentGlyphs[0] = enchantmentGlyphs[1].toUpperCase();\n        \n        boolean matchFound = (targetGlyph == enchantmentGlyphs[0]);\n        \n        System.out.println(\"Final Sigil Code: \" + sigilCode);\n        System.out.println(\"First Enchantment Glyph: \" + enchantmentGlyphs[0]);\n        System.out.println(\"Match Found (Reference): \" + matchFound);\n    }\n}",
      "choices": [
        "Final Sigil Code: FIRE!AETHER",
        "First Enchantment Glyph: Alpha",
        "First Enchantment Glyph: BETA",
        "Match Found (Reference): false"
      ],
      "answer": [
        "Final Sigil Code: FIRE!AETHER",
        "First Enchantment Glyph: BETA",
        "Match Found (Reference): false"
      ],
      "explanation": "1. `String baseCode = \"FIRE-AETHER\";`\n2. `sigilCode = baseCode.substring(0, 4) + \"!\" + baseCode.substring(5, baseCode.length());` concatenates to \"FIRE!AETHER\". So, `sigilCode` is \"FIRE!AETHER\".\n3. `String[] enchantmentGlyphs = {\"Alpha\", \"Beta\", \"Gamma\"};`\n4. `String targetGlyph = new String(\"Alpha\");` creates a new object.\n5. `enchantmentGlyphs[0] = enchantmentGlyphs[1].toUpperCase();` gets \"Beta\" from `enchantmentGlyphs[1]`, converts to \"BETA\", and assigns to `enchantmentGlyphs[0]`.\n6. `boolean matchFound = (targetGlyph == enchantmentGlyphs[0]);` compares `targetGlyph` (a new \"Alpha\" object) to `enchantmentGlyphs[0]` (\"BETA\" object). These are different objects at different addresses, so `==` is `false`.\n7. The `System.out.println()` statements display the final values."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Trace the `sigilCode` by performing the `substring` and concatenation operations step-by-step.",
      "2": "Follow the modification to `enchantmentGlyphs[0]`, especially the `.toUpperCase()` method.",
      "3": "Remember that `==` for `String` objects compares memory addresses (references), and `new String()` always creates a *new* object."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 102,
    "subtopic_id": 3,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `LoreProcessor` processes `ancientLore` using various `String` methods, and checks for `loreFound` in an `archiveEntries` array. Your task is to trace the code and determine the `Processed Lore`, `Arcane Fact Length`, and `Lore Found in Archive` status.",
      "code": "public class LoreProcessor {\n    public static void main(String[] args) {\n        String ancientLore = \"  Whispers of the PAST  \";\n        String arcaneFact = ancientLore.trim().replace(\"PAST\", \"FUTURE\").toLowerCase();\n        \n        String[] archiveEntries = new String[2];\n        archiveEntries[0] = \"First Lore\";\n        archiveEntries[1] = null;\n        \n        boolean loreFound = (archiveEntries[1] != null && archiveEntries[1].equals(\"Second Lore\"));\n        \n        arcaneFact = arcaneFact.substring(0, 8);\n        \n        System.out.println(\"Processed Lore: \" + ancientLore);\n        System.out.println(\"Arcane Fact Length: \" + arcaneFact.length());\n        System.out.println(\"Lore Found in Archive: \" + loreFound);\n    }\n}",
      "choices": [
        "Processed Lore: Whispers of the PAST",
        "Arcane Fact Length: 8",
        "Arcane Fact Length: 22",
        "Lore Found in Archive: false"
      ],
      "answer": [
        "Processed Lore:   Whispers of the PAST  ",
        "Arcane Fact Length: 8",
        "Lore Found in Archive: false"
      ],
      "explanation": "1. `String ancientLore = \"  Whispers of the PAST  \";` initializes `ancientLore`. This original value is printed.\n2. `String arcaneFact = ancientLore.trim().replace(\"PAST\", \"FUTURE\").toLowerCase();`\n    * `.trim()`: \"Whispers of the PAST\"\n    * `.replace(\"PAST\", \"FUTURE\")`: \"Whispers of the FUTURE\"\n    * `.toLowerCase()`: \"whispers of the future\"\n    So, `arcaneFact` is \"whispers of the future\".\n3. `arcaneFact = arcaneFact.substring(0, 8);` updates `arcaneFact` to \"whispers\" (first 8 characters).\n4. `archiveEntries[1]` is `null`.\n5. `boolean loreFound = (archiveEntries[1] != null && archiveEntries[1].equals(\"Second Lore\"));`\n    * `archiveEntries[1] != null` evaluates to `null != null`, which is `false`.\n    * Due to short-circuiting of `&&`, the second part (`archiveEntries[1].equals(...)`) is *not* evaluated, preventing a `NullPointerException`. So, `loreFound` is `false`.\n6. `System.out.println(\"Processed Lore: \" + ancientLore);` prints the original value of `ancientLore`.\n7. `System.out.println(\"Arcane Fact Length: \" + arcaneFact.length());` prints \"Arcane Fact Length: 8\" (length of \"whispers\").\n8. The `System.out.println()` statements display the final values."
    },
    "difficulty": "hard",
    "hints": {
      "1": " `ancientLore.trim()` removes leading/trailing spaces, and `.replace()` and `.toLowerCase()` modify the string content.",
      "2": "The `arcaneFact` variable is updated twice (`trim/replace/toLowerCase` then `substring`).",
      "3": "Carefully evaluate the condition `(archiveEntries[1] != null && archiveEntries[1].equals(\\\"Second Lore\\\"))`. What is `archiveEntries[1]`'s value? What does `&&` do if the first part is false?"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 103,
    "subtopic_id": 3,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `GrandIllusion` spell manipulates `illusionText` and `backupText`, and activates `stageLights` in an array. Your task is to trace the code and determine the `Final Illusion Text`, `Total Active Lights`, and `Text Is Empty` status.",
      "code": "public class GrandIllusion {\n    public static void main(String[] args) {\n        String illusionText = \"Grand Show\";\n        String backupText = \"Magic\";\n        boolean[] stageLights = new boolean[3];\n\n        illusionText = illusionText.replace(\"Grand\", \"\").trim();\n        backupText = backupText + \"!\";\n\n        stageLights[0] = true;\n        stageLights[2] = true;\n\n        if (illusionText.isEmpty()) {\n            stageLights[1] = true;\n        }\n\n        boolean textIsEmpty = illusionText.isEmpty();\n\n        System.out.println(\"Final Illusion Text: \" + illusionText);\n        System.out.println(\"Total Active Lights: \" + ( (stageLights[0] ? 1 : 0) + (stageLights[1] ? 1 : 0) + (stageLights[2] ? 1 : 0) ) );\n        System.out.println(\"Text Is Empty: \" + textIsEmpty);\n    }\n}",
      "choices": [
        "Final Illusion Text: Grand Show",
        "Total Active Lights: 2",
        "Text Is Empty: false",
        "Final Illusion Text: Show"
      ],
      "answer": [
        "Total Active Lights: 2",
        "Text Is Empty: false",
        "Final Illusion Text: Show"
      ],
      "explanation": "1. `illusionText` starts as \"Grand Show\". `illusionText.replace(\"Grand\", \"\").trim()` first becomes \" Show\" (replace), then \"Show\" (trim). So `illusionText` is \"Show\".\n2. `backupText` becomes \"Magic!\".\n3. `stageLights` is `{false, false, false}`. Then `stageLights[0] = true;` makes it `{true, false, false}`. `stageLights[2] = true;` makes it `{true, false, true}`.\n4. `if (illusionText.isEmpty())`: \"Show\".isEmpty() is `false`. So, the `if` block is skipped; `stageLights[1]` remains `false`.\n5. `boolean textIsEmpty = illusionText.isEmpty();` : \"Show\".isEmpty() is `false`. So `textIsEmpty` is `false`.\n6. **Output 1**: `System.out.println(\"Final Illusion Text: \" + illusionText);` prints \"Final Illusion Text: Show\".\n7. **Output 2**: `System.out.println(\"Total Active Lights: \" + (...) );` sums (`1 + 0 + 1 = 2`). Prints \"Total Active Lights: 2\".\n8. **Output 3**: `System.out.println(\"Text Is Empty: \" + textIsEmpty);` prints \"Text Is Empty: false\"."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Trace `illusionText` through its `replace` and `trim` operations.",
      "2": "Evaluate the `if (illusionText.isEmpty())` condition and its impact on `stageLights[1]`.",
      "3": "Sum the boolean states of `stageLights` (true=1, false=0) to find the \"Total Active Lights\"."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 104,
    "subtopic_id": 3,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "An `OraclePrediction` processes a `prophecy` string, modifying it and checking for a `targetWord`. It also updates an `omens` array. Your task is to trace the code and determine the `Modified Prophecy`, `Omen Char Count (Prophecy)`, and `Condition Met` status.",
      "code": "public class OraclePrediction {\n    public static void main(String[] args) {\n        String prophecy = \"A NEW ERA BEGINS\";\n        String[] omens = {\"Eclipse\", \"Comet\", \"Starfall\"};\n        boolean conditionMet = false;\n\n        prophecy = prophecy.replace(\" \", \"_\").toLowerCase();\n        \n        omens[1] = \"Celestial\";\n        \n        String targetWord = new String(\"a_new\");\n        if (prophecy.startsWith(targetWord)) {\n            conditionMet = true;\n        }\n\n        System.out.println(\"Modified Prophecy: \" + prophecy);\n        System.out.println(\"Omen Char Count (Prophecy): \" + (prophecy.length() - prophecy.replace(\"o\", \"\").length()));\n        System.out.println(\"Condition Met: \" + conditionMet);\n    }\n}",
      "choices": [
        "Modified Prophecy: A NEW ERA BEGINS",
        "Modified Prophecy: a_new_era_begins",
        "Omen Char Count (Prophecy): 2",
        "Condition Met: true"
      ],
      "answer": [
        "Modified Prophecy: a_new_era_begins",
        "Omen Char Count (Prophecy): 2",
        "Condition Met: true"
      ],
      "explanation": "1. `prophecy` starts as \"A NEW ERA BEGINS\".\n2. `prophecy = prophecy.replace(\" \", \"_\").toLowerCase();` transforms `prophecy` to \"a_new_era_begins\".\n3. `omens[1]` becomes \"Celestial\".\n4. `targetWord` is `new String(\"a_new\")`.\n5. `if (prophecy.startsWith(targetWord))`: `\"a_new_era_begins\".startsWith(\"a_new\")` is `true`.\n    * `conditionMet = true;` updates `conditionMet` to `true`.\n6. `System.out.println(\"Modified Prophecy: \" + prophecy);` prints \"Modified Prophecy: a_new_era_begins\".\n7. `System.out.println(\"Omen Char Count (Prophecy): \" + (prophecy.length() - prophecy.replace(\"o\", \"\").length()));` calculates `16 - 14 = 2` (count of 'o's).\n8. `System.out.println(\"Condition Met: \" + conditionMet);` prints \"Condition Met: true\"."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Trace `prophecy` through `replace` and `toLowerCase` methods.",
      "2": "The \"Omen Char Count\" calculates the number of times a specific character appears (in this case, 'o').",
      "3": "`startsWith()` is case-sensitive, and `new String()` creates a new object, but `startsWith` compares content."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 105,
    "subtopic_id": 3,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "An `InventoryManager` initializes an array of `artifactNames` and conditionally sets a `masterKey` to `null`. Your task is to trace the code and determine the `Inventory Size`, `Last Artifact`, and `Master Key Status`.",
      "code": "public class InventoryManager {\n    public static void main(String[] args) {\n        String[] artifactNames = new String[3];\n        artifactNames[0] = \"Sword of Truth\";\n        artifactNames[2] = \"Shield of Light\";\n        \n        String masterKey = \"Ancient Rune\";\n        String searchTarget = \"Sword of Truth\";\n        \n        if (artifactNames[0].equals(searchTarget)) {\n            masterKey = null;\n        }\n        \n        int keyLength = 0;\n        if (masterKey != null) {\n            keyLength = masterKey.length();\n        }\n\n        System.out.println(\"Inventory Size: \" + artifactNames.length);\n        System.out.println(\"Last Artifact: \" + artifactNames[2]);\n        System.out.println(\"Master Key Status: \" + masterKey);\n    }\n}",
      "choices": [
        "Inventory Size: 2",
        "Last Artifact: Shield of Light",
        "Inventory Size: 3",
        "Master Key Status: null"
      ],
      "answer": [
        "Last Artifact: Shield of Light",
        "Inventory Size: 3",
        "Master Key Status: null"
      ],
      "explanation": "1. `String[] artifactNames = new String[3];` creates an array of size 3. `artifactNames[0]` is \"Sword of Truth\", `artifactNames[1]` is `null` (default for `String[]`), `artifactNames[2]` is \"Shield of Light\".\n2. `if (artifactNames[0].equals(searchTarget))`: \"Sword of Truth\".equals(\"Sword of Truth\") is `true`.\n    * `masterKey = null;` updates `masterKey` to `null`.\n3. The `keyLength` calculation is skipped because `masterKey` is `null`.\n4. **Output 1**: `System.out.println(\"Inventory Size: \" + artifactNames.length);` prints \"Inventory Size: 3\".\n5. **Output 2**: `System.out.println(\"Last Artifact: \" + artifactNames[2]);` prints \"Last Artifact: Shield of Light\".\n6. **Output 3**: `System.out.println(\"Master Key Status: \" + masterKey);` prints \"Master Key Status: null\"."
    },
    "difficulty": "hard",
    "hints": {
      "1": "An array's `length` property gives its total size, not just the number of filled elements.",
      "2": "`artifactNames[2]` accesses the element at index 2 (the third element).",
      "3": "Trace `masterKey` carefully: it is initially a string, but its value can change to `null` based on a condition."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 106,
    "subtopic_id": 3,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `SpellScrollComparer` checks if two `spellScroll`s are identical. However, the code incorrectly uses `==` to compare `String` objects, leading to an inaccurate result. Fix the code to correctly compare the content of the spell scrolls.",
      "code": "public class SpellScrollComparer {\n    public static void main(String[] args) {\n        String spellScroll1 = \"Fireball\";\n        String spellScroll2 = new String(\"Fireball\");\n        \n        if (spellScroll1.equals(spellScroll2)) { // Correct: Use .equals() for content comparison\n            System.out.println(\"Scrolls are identical.\");\n        } else {\n            System.out.println(\"Scrolls are different.\");\n        }\n    }\n}",
      "expected_output": [
        "Scrolls are identical."
      ],
      "hidden_test_case": "",
      "explanation": "The `==` operator, when used with objects (including `String`s that are not just literals and interned), compares their memory addresses (references). `spellScroll1` points to a `String` literal in the string pool, while `spellScroll2` points to a *new* `String` object created on the heap, even though their content is identical. Therefore, `spellScroll1 == spellScroll2` evaluates to `false`. To compare the actual textual content of `String` objects, the `.equals()` method must be used."
    },
    "difficulty": "easy",
    "hints": {
      "1": "For non-primitive types like `String`, the `==` operator checks if two variables point to the *exact same object* in memory.",
      "2": "If you want to compare what's *inside* the objects (their text content), you need a different method.",
      "3": " `new String(\"...\")` always creates a brand new object."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 107,
    "subtopic_id": 3,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `PotionShelf` is being set up, but the `potionBottles` array is declared without being initialized, causing a `NullPointerException` when trying to add a potion. Fix the code to correctly initialize the array.",
      "code": "public class PotionShelf {\n    public static void main(String[] args) {\n        String[] potionBottles = new String[3]; // Correct: Initialize the array with a size\n        potionBottles[0] = \"Healing Potion\";\n        System.out.println(\"First Potion: \" + potionBottles[0]);\n    }\n}",
      "expected_output": [
        "First Potion: Healing Potion"
      ],
      "hidden_test_case": "",
      "explanation": "The original code declares `potionBottles` as an array variable (`String[] potionBottles;`), but it does not actually create the array object in memory. Attempting to access or assign elements (`potionBottles[0]`) on a variable that points to `null` (because it's uninitialized) results in a `NullPointerException` at runtime. The fix is to initialize the array using the `new` keyword and specify its size, for example, `new String[3]`."
    },
    "difficulty": "easy",
    "hints": {
      "1": "Declaring an array variable (e.g., `String[]`) only says \"this variable will point to an array.\" It doesn't actually create the list itself.",
      "2": "You need the `new` keyword to create the actual array object in memory and specify its size.",
      "3": "Imagine having an empty shelf that can hold bottles, but no actual shelf has been built yet."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 108,
    "subtopic_id": 3,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `ScrollChecker` attempts to determine the length of a `spellScroll` that is initialized as `null`. Calling `.length()` on a `null` variable causes a `NullPointerException`. Fix the code to assign a valid `String` to `spellScroll`.",
      "code": "public class ScrollChecker {\n    public static void main(String[] args) {\n        String spellScroll = \"Incendio\"; // Correct: Assign a non-null String\n        System.out.println(\"Spell Length: \" + spellScroll.length());\n    }\n}",
      "expected_output": [
        "Spell Length: 8"
      ],
      "hidden_test_case": "",
      "explanation": "The `spellScroll` variable is initialized to `null`, meaning it does not refer to any actual `String` object in memory. Attempting to call a method like `.length()` on a `null` reference results in a `NullPointerException` at runtime. The fix is to assign `spellScroll` to an actual `String` object (e.g., `\"Incendio\"`) before calling its methods."
    },
    "difficulty": "easy",
    "hints": {
      "1": "A `NullPointerException` typically means you're trying to do something with a variable that points to \"nothing\" (`null`).",
      "2": "Methods like `.length()` can only be called on actual objects, not on `null`.",
      "3": "Assign a valid `String` literal to `spellScroll` to make it point to a real object."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 109,
    "subtopic_id": 3,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `PortalJumper` system manages `portalDestinations` in an array. The array is declared with a size of 2, but the code attempts to access an element at index 2, which is out of bounds. Fix the code to access a valid array index.",
      "code": "public class PortalJumper {\n    public static void main(String[] args) {\n        String[] portalDestinations = new String[3]; // Correct: Increase array size\n        portalDestinations[0] = \"Elysium\";\n        portalDestinations[2] = \"Astral Plane\"; // Correct: Assign to the newly valid index\n        System.out.println(\"Next Portal: \" + portalDestinations[2]);\n    }\n}",
      "expected_output": [
        "Next Portal: Astral Plane"
      ],
      "hidden_test_case": "",
      "explanation": "The `portalDestinations` array is initialized with a size of `2`, meaning its valid indices are `0` and `1`. Attempting to access `portalDestinations[2]` (which is the third element) results in an `ArrayIndexOutOfBoundsException` at runtime. The fix is to either increase the array's size to at least `3` (e.g., `new String[3]`) to make index `2` valid, and then assign a value to it, or change the index being accessed to `0` or `1`."
    },
    "difficulty": "easy",
    "hints": {
      "1": "If an array has size `N`, its valid indices range from `0` to `N-1`.",
      "2": "Attempting to access an index outside this range causes an `ArrayIndexOutOfBoundsException`.",
      "3": "Either increase the array's capacity or access an existing index."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 110,
    "subtopic_id": 3,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `RuneModifier` attempts to change a character within a `runePhrase` directly. However, `String` objects are immutable in Java, so their characters cannot be modified directly. Fix the code to correctly create a modified `String`.",
      "code": "public class RuneModifier {\n    public static void main(String[] args) {\n        String runePhrase = \"MAGIC\";\n        runePhrase = 'X' + runePhrase.substring(1); // Correct: Create new String and reassign\n        System.out.println(\"Modified Rune: \" + runePhrase);\n    }\n}",
      "expected_output": [
        "Modified Rune: XAGIC"
      ],
      "hidden_test_case": "",
      "explanation": " `String` objects in Java are immutable, meaning their content cannot be changed once created. The line `runePhrase.charAt(0) = 'X';` attempts to directly modify a character within the existing `runePhrase` object, which is illegal and causes a compilation error. To achieve the effect of changing a character, a new `String` must be created with the desired modification (e.g., concatenating the new character `'X'` with the rest of the `runePhrase` from index 1 onwards using `substring(1)`), and then `runePhrase` is reassigned to point to this new `String`."
    },
    "difficulty": "easy",
    "hints": {
      "1": " `String` objects in Java are special: once created, their internal sequence of characters cannot be altered.",
      "2": "Methods like `charAt()` return a value, but they don't allow you to change the `String` itself.",
      "3": "To \"change\" a `String`, you actually create a *new* `String` that contains the desired modifications, and then reassign your variable to point to this new `String`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 111,
    "subtopic_id": 3,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "An `ArcaneIDGenerator` attempts to `trim` leading/trailing spaces from a `magicWord`. However, `String` methods like `trim()` return a new `String` rather than modifying the original, so the changes are lost. Fix the code to correctly apply the trimming.",
      "code": "public class ArcaneIDGenerator {\n    public static void main(String[] args) {\n        String magicWord = \"  Alakazam  \";\n        magicWord = magicWord.trim(); // Correct: Reassign magicWord to the trimmed String\n        System.out.println(\"Cleaned Word: '\" + magicWord + \"'\");\n    }\n}",
      "expected_output": [
        "Cleaned Word: 'Alakazam'"
      ],
      "hidden_test_case": "",
      "explanation": "The `String` object `magicWord` is immutable. The `.trim()` method does not modify the `magicWord` object itself; instead, it returns a *new* `String` object with leading and trailing whitespace removed. The original code discards this new, cleaned `String`. The fix is to reassign the `magicWord` variable to the result of `magicWord.trim()`, so it points to the new, cleaned `String` object."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Remember that `String` objects in Java are immutable; their content cannot change.",
      "2": "Methods like `trim()`, `toUpperCase()`, `replace()` *return a new `String`* with the modifications.",
      "3": "To apply the changes, you must reassign the variable to point to this new `String` object."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 112,
    "subtopic_id": 3,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `SpiritSummoner` attempts to place a spirit in a `summoningCircle` array that has been declared but not initialized, resulting in a `NullPointerException`. Fix the code to correctly initialize the array before use.",
      "code": "public class SpiritSummoner {\n    public static void main(String[] args) {\n        String[] summoningCircle = new String[5]; // Correct: Initialize the array with a size\n        summoningCircle[0] = \"Lesser Spirit\";\n        System.out.println(\"Spirit in Circle: \" + summoningCircle[0]);\n    }\n}",
      "expected_output": [
        "Spirit in Circle: Lesser Spirit"
      ],
      "hidden_test_case": "",
      "explanation": "The `String[] summoningCircle;` line declares the array variable but does not create the actual array object in memory. Without `new String[size]`, `summoningCircle` is `null`. Attempting to access an element (like `summoningCircle[0]`) on a `null` array causes a `NullPointerException` at runtime. The fix is to explicitly create the array object with a size, for example, `new String[5]`."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Declaring an array variable (e.g., `String[]`) only says \"this variable will point to an array.\" It doesn't create the list itself.",
      "2": "You need the `new` keyword followed by the type and size (`new Type[size]`) to create the actual array object.",
      "3": "Attempting to put something into a non-existent container will lead to a `NullPointerException`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 113,
    "subtopic_id": 3,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `TomeReader` tries to determine if an `ancientTome` is readable by checking its length. However, `ancientTome` is `null`, causing a `NullPointerException`. Fix the code to safely handle `null` values before attempting to call methods on them.",
      "code": "public class TomeReader {\n    public static void main(String[] args) {\n        String ancientTome = null;\n        if (ancientTome != null && ancientTome.length() > 0) { // Correct: Add null check with short-circuiting AND\n            System.out.println(\"Tome is readable.\");\n        } else {\n            System.out.println(\"Tome not found or empty.\"); // Corrected output message\n        }\n    }\n}",
      "expected_output": [
        "Tome not found or empty."
      ],
      "hidden_test_case": "",
      "explanation": "The `ancientTome` variable is explicitly set to `null`. Attempting to call the `.length()` method on a `null` reference immediately causes a `NullPointerException`. The fix involves adding a `null` check (`ancientTome != null`) before attempting to access `.length()`. By using `&&` (logical AND), Java employs short-circuiting: if `ancientTome != null` is `false`, the second part of the condition (`ancientTome.length() > 0`) is never evaluated, preventing a `NullPointerException`."
    },
    "difficulty": "medium",
    "hints": {
      "1": "A `NullPointerException` means you're trying to perform an action on something that doesn't exist (`null`).",
      "2": "Always check if a non-primitive variable is `null` before trying to use its methods (e.g., `variable != null`).",
      "3": "The `&&` (logical AND) operator is useful for combining conditions, as it \"short-circuits.\""
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 114,
    "subtopic_id": 3,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `SpellAssignment` system compares two spell scrolls. The `spellScroll1` (a literal) and `newSpell` (created with `new String()`) have identical content, but using `==` to compare them incorrectly reports them as different. Fix the code to compare their content correctly.",
      "code": "public class SpellAssignment {\n    public static void main(String[] args) {\n        String spellScroll1 = \"Incendio\";\n        String newSpell = new String(\"Incendio\");\n        \n        if (spellScroll1.equals(newSpell)) { // Correct: Use .equals() for content comparison\n            System.out.println(\"Spells are identical in content.\");\n        } else {\n            System.out.println(\"Spells are different.\");\n        }\n    }\n}",
      "expected_output": [
        "Spells are identical in content."
      ],
      "hidden_test_case": "",
      "explanation": "The original code attempts to compare the textual content of `spellScroll1` and `newSpell` using the `==` operator. However, `spellScroll1` (a string literal) and `newSpell` (a `String` object created with `new`) typically point to different memory locations, even though their content is identical. Therefore, `spellScroll1 == newSpell` evaluates to `false`. To correctly compare the textual content, the `.equals()` method must be used."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Remember that `==` for non-primitive types (like `String`) compares memory locations (references).",
      "2": "`\"Incendio\"` (literal) and `new String(\"Incendio\")` (object created with `new`) usually reside at different memory locations.",
      "3": "If you want to check if the *text inside* two `String` variables is the same, there's a specific method for that."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 115,
    "subtopic_id": 3,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `MapRegionsTracker` records `mapRegions` in an array. The code attempts to print the `mapRegions.length` by accessing an out-of-bounds index, causing an `ArrayIndexOutOfBoundsException`. Fix the code to correctly print the total size of the array.",
      "code": "public class MapRegionsTracker {\n    public static void main(String[] args) {\n        String[] mapRegions = new String[5];\n        mapRegions[0] = \"Forest\";\n        mapRegions[1] = \"Mountain\";\n        \n        System.out.println(\"Total Map Regions: \" + mapRegions.length); // Correct: Use .length property\n    }\n}",
      "expected_output": [
        "Total Map Regions: 5"
      ],
      "hidden_test_case": "",
      "explanation": "The original code attempts to get the total number of map regions by accessing `mapRegions[5]`. However, for an array of size 5, valid indices are from 0 to 4. Accessing index 5 results in an `ArrayIndexOutOfBoundsException`. To get the total size (or length) of an array, its `.length` property should be used (e.g., `mapRegions.length`)."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Arrays have a special property (not a method) that directly tells you their declared size.",
      "2": "Accessing `array[index]` attempts to retrieve an element, not the array's total capacity.",
      "3": "Remember `N-1` for the last valid index."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 116,
    "subtopic_id": 3,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `SpellParameterProcessor` attempts to process a `param1` string that might become `null`. Calling `String` methods like `substring()` on a `null` variable causes a `NullPointerException`. Fix the code to safely handle `null` values before processing the string.",
      "code": "public class SpellParameterProcessor {\n    public static void main(String[] args) {\n        String param1 = \"   Cleanse   \";\n        param1 = param1.trim();\n        param1 = null;\n        \n        String finalParameter;\n        if (param1 != null) { // Correct: Add null check\n            finalParameter = param1.substring(0, 7).toUpperCase();\n        } else {\n            finalParameter = \"NULL_PARAM\"; // Correct: Assign default value if null\n        }\n        \n        String param2 = \"Purify\"; // param2 needs to be initialized\n        \n        if (finalParameter.equals(param2)) {\n            System.out.println(\"Parameters Match: \" + finalParameter);\n        } else {\n            System.out.println(\"Parameters Mismatch.\");\n        }\n    }\n}",
      "expected_output": [
        "Parameters Mismatch."
      ],
      "hidden_test_case": "",
      "explanation": "The original code explicitly sets `param1` to `null`. Attempting to call `.substring()` or `.toUpperCase()` on a `null` reference (which `param1` becomes) immediately causes a `NullPointerException`. The fix involves adding a `null` check (`if (param1 != null)`) before attempting to use methods on `param1`. If `param1` is `null`, a default value like `\"NULL_PARAM\"` is assigned to `finalParameter`, preventing the crash and allowing the program to continue gracefully."
    },
    "difficulty": "hard",
    "hints": {
      "1": "A `NullPointerException` means a method is called on a variable that points to `null` (nothing).",
      "2": "Always check if a non-primitive variable is `null` before trying to use its methods (e.g., `variable != null`).",
      "3": "Consider a way to assign a safe default value if the variable is indeed `null`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 117,
    "subtopic_id": 3,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `RuneProcessor` attempts to `trim` and `replace` parts of `runeText`. However, `String` methods do not modify the original string, causing the final `runeText` to be incorrect. Fix the code to correctly apply these `String` transformations.",
      "code": "public class RuneProcessor {\n    public static void main(String[] args) {\n        String runeText = \"  Ancient Power Runes  \";\n        \n        runeText = runeText.trim(); // Correct: Reassign runeText to trimmed version\n        runeText = runeText.replace(\"Power\", \"Magic\"); // Correct: Reassign runeText to replaced version\n        String finalRuneText = runeText.substring(0, 12);\n        \n        System.out.println(\"Final Rune Text: \" + finalRuneText);\n    }\n}",
      "expected_output": [
        "Final Rune Text: Ancient Mag"
      ],
      "hidden_test_case": "",
      "explanation": " `String` objects in Java are immutable. This means methods like `trim()` and `replace()` do not modify the `runeText` object directly. Instead, they return *new* `String` objects with the modifications. The original code discards these new `String` objects because their return values are not assigned back to `runeText`. Consequently, `runeText` remains \"  Ancient Power Runes  \" throughout these operations. The fix is to reassign `runeText` to the result of each method call (`runeText = runeText.trim();` and `runeText = runeText.replace(\"Power\", \"Magic\");`) to chain the transformations correctly."
    },
    "difficulty": "hard",
    "hints": {
      "1": " `String` methods like `trim()`, `replace()`, `substring()`, `toUpperCase()`, `toLowerCase()` *do not change the original `String` object*.",
      "2": "These methods *return a brand new `String` object* that contains the modified sequence of characters.",
      "3": "To apply the changes, you must explicitly reassign the `String` variable to point to this new `String` object returned by the method."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 118,
    "subtopic_id": 3,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "An `ArtifactInventory` stores `artifactTitles` in an array. By default, `String` array elements are `null`, not empty strings. The code incorrectly checks for empty strings and then attempts to call `.length()` on a `null` element, causing a `NullPointerException`. Fix the code to correctly handle `null` and empty string checks.",
      "code": "public class ArtifactInventory {\n    public static void main(String[] args) {\n        String[] artifactTitles = new String[3];\n        \n        if (artifactTitles[0] == null) { // Correct: Check for null\n            System.out.println(\"First slot is null.\"); // Corrected message\n        } else {\n            System.out.println(\"First slot is not null or empty string.\");\n        }\n        \n        // Correct: Add null check before calling .length()\n        if (artifactTitles[1] != null) {\n            System.out.println(\"Second slot length: \" + artifactTitles[1].length());\n        } else {\n            System.out.println(\"Second slot is null, no length.\"); // Handle null case\n        }\n    }\n}",
      "expected_output": [
        "First slot is null.",
        "Second slot is null, no length."
      ],
      "hidden_test_case": "",
      "explanation": "When `new String[3]` is called, the elements of `artifactTitles` are initialized to `null`, not `\"\"` (empty string).\n1. `artifactTitles[0] == \"\"` (null == \"\") evaluates to `false`, so it prints \"First slot is not an empty string or null.\".\n2. `System.out.println(\"Second slot length: \" + artifactTitles[1].length());` attempts to call `.length()` on `artifactTitles[1]`, which is `null`. This results in a `NullPointerException`.\n\nThe fix addresses two issues:\n* Correctly identifies that default `String` array elements are `null`.\n* Adds `null` checks (`artifactTitles[1] != null`) before calling methods like `.length()` on array elements that might be `null`, thus preventing `NullPointerException`s and allowing for proper handling of `null` slots. The `if` condition for `artifactTitles[0]` is expanded to differentiate between `null` and `\"\"`."
    },
    "difficulty": "hard",
    "hints": {
      "1": "When an array of non-primitive types (like `String[]`) is created, its elements are automatically initialized to their default value, which is `null` for object types. They are *not* initialized to empty strings (`\"\"`).",
      "2": "Comparing `null` with `\"\"` using `==` will be `false`. Calling `.equals()` on `null` will cause a `NullPointerException`.",
      "3": "Always check for `null` before trying to use methods on a potentially `null` array element."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 119,
    "subtopic_id": 3,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `ScrollReplication` system compares `masterScroll` (literal) and `replicaScroll1` (literal) with `replicaScroll2` (new `String` object). The code incorrectly uses `==` for content comparison, leading to `identicalObjects` being `false` when content is the same. Fix the code to correctly compare `String` content across different `String` object types.",
      "code": "public class ScrollReplication {\n    public static void main(String[] args) {\n        String masterScroll = \"Ancient Rune\";\n        String replicaScroll1 = \"Ancient Rune\";\n        String replicaScroll2 = new String(\"Ancient Rune\");\n        \n        boolean identicalObjects = (replicaScroll1 == replicaScroll2); // This is fine as a check for reference identity\n        boolean contentMatches = masterScroll.equals(replicaScroll2); // Correct: Use .equals() for content comparison\n        \n        System.out.println(\"Are Objects Identical: \" + identicalObjects);\n        System.out.println(\"Does Content Match: \" + contentMatches);\n    }\n}",
      "expected_output": [
        "Are Objects Identical: false",
        "Does Content Match: true"
      ],
      "hidden_test_case": "",
      "explanation": "1. **`identicalObjects`**: `replicaScroll1 == replicaScroll2` correctly uses `==` for reference comparison. `replicaScroll1` (a literal) and `replicaScroll2` (created with `new String()`) point to different memory locations, so `identicalObjects` is `false`.\n2. **`contentMatches`**: The original `masterScroll == replicaScroll1` is `true` due to string interning. However, to correctly illustrate `String` content comparison with `new String()` objects (which is the more complex scenario), the fix changes the comparison to `masterScroll.equals(replicaScroll2)`. This uses the `.equals()` method to compare the actual textual content, resulting in `true`."
    },
    "difficulty": "hard",
    "hints": {
      "1": "For `String` objects, `==` compares whether two variables point to the *exact same memory location*.",
      "2": " `new String(\"...\")` *always* creates a new object in memory, even if the content is the same as an existing literal.",
      "3": "To compare the actual sequence of characters (the content) of `String` objects, you must use a specific method."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 120,
    "subtopic_id": 3,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `SpellbookManager` tracks `spellbookPages`. Assigning `null` to an element should not change the array's total size, but the code incorrectly calculates the `Remaining Pages` based on this assumption. Fix the code to correctly report the fixed `Total Slots` of the array.",
      "code": "public class SpellbookManager {\n    public static void main(String[] args) {\n        String[] spellbookPages = {\"Page 1\", \"Page 2\", \"Page 3\"};\n        \n        spellbookPages[1] = null;\n        \n        System.out.println(\"Total Slots (fixed): \" + spellbookPages.length); // Correct: Use .length property\n    }\n}",
      "expected_output": [
        "Total Slots (fixed): 3"
      ],
      "hidden_test_case": "",
      "explanation": "Arrays in Java are objects with a fixed size. Assigning `null` to an element (`spellbookPages[1] = null;`) simply means that array slot no longer points to a `String` object; it does *not* change the array's fundamental size or its `.length` property. The original code incorrectly assumes that setting an element to `null` reduces the array's length, leading to an inaccurate output. The fix demonstrates that `spellbookPages.length` will always remain `3`, regardless of individual elements being `null`."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Arrays in Java have a fixed size once they are created.",
      "2": "Assigning `null` to an element in an array simply makes that slot \"empty\" but does not change the array's overall `.length`.",
      "3": "The `.length` property of an array always reflects its initially declared capacity."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 121,
    "subtopic_id": 3,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `GrandSpellcaster` is preparing a grand spell. The `grandSpell` variable needs to be declared to store the text of this mighty incantation. Complete the declaration and initialization.",
      "code": "public class GrandSpellcaster {\n    public static void main(String[] args) {\n        ??? = ???;\n        System.out.println(\"Grand Spell: \" + grandSpell);\n    }\n}",
      "choices": [
        "String grandSpell",
        "\"Mighty Incantation\"",
        "char grandSpell",
        "'Mighty Incantation'"
      ],
      "answer": [
        "String grandSpell",
        "\"Mighty Incantation\""
      ],
      "explanation": "The variable `grandSpell` is assigned the text `\"Mighty Incantation\"`. In Java, the `String` class is used to represent text. Therefore, `String grandSpell` completes the variable's type and name, and `\"Mighty Incantation\"` completes its initial value."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The variable `grandSpell` is intended to hold a sequence of characters (text).",
      "2": "Recall the non-primitive data type used for storing text in Java.",
      "3": "How are text literal values (strings) typically enclosed in Java?"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 122,
    "subtopic_id": 3,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `PotionRegistry` creates and names different brews. The `brewNames` variable needs to be declared as an array to hold `String` objects. Complete the array declaration.",
      "code": "public class PotionRegistry {\n    public static void main(String[] args) {\n        ??? = new String[3];\n        brewNames[0] = \"Healing Brew\";\n        System.out.println(\"First Brew: \" + brewNames[0]);\n    }\n}",
      "choices": [
        "String[] brewNames",
        "String brewNames",
        "int[] brewNames",
        "brewNames"
      ],
      "answer": [
        "String[] brewNames"
      ],
      "explanation": "The variable `brewNames` is intended to be an array that holds `String` objects, as indicated by `new String[3]`. The correct syntax for declaring such an array variable is `String[] brewNames`."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The variable `brewNames` is intended to be a collection (list) of strings.",
      "2": "Recall the syntax for declaring an array variable.",
      "3": "The type of elements in the array are `String`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 123,
    "subtopic_id": 3,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `TomeReader` displays the title of an enchanted tome. The `enchantedTomeTitle` variable holds the title. Complete the print statement to correctly display the value of the variable.",
      "code": "public class TomeReader {\n    public static void main(String[] args) {\n        String enchantedTomeTitle = \"Whispers of Eldoria\";\n        System.out.println(\"Tome Title: \" + ???);\n    }\n}",
      "choices": [
        "\"enchantedTomeTitle\"",
        "enchantedTomeTitle",
        "title",
        "enchantedTome"
      ],
      "answer": [
        "enchantedTomeTitle"
      ],
      "explanation": "The variable storing the tome's title is named `enchantedTomeTitle`. To print its value, the variable name itself should be used directly in the `System.out.println()` statement. Using `\"` around it would print the literal name \"enchantedTomeTitle\" instead of its content."
    },
    "difficulty": "easy",
    "hints": {
      "1": "You need to reference the variable itself, not a string literal of its name.",
      "2": "The variable to be printed is already declared and initialized.",
      "3": "The `+` operator will concatenate the literal string with the variable's value."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 124,
    "subtopic_id": 3,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `DungeonMaster` manages `creatureNames` in an array. The array is initialized with specific creature names. Complete the declaration of the `creatureNames` array.",
      "code": "public class DungeonMaster {\n    public static void main(String[] args) {\n        ??? = {\"Goblin\", \"Orc\"};\n        System.out.println(\"First Creature: \" + creatureNames[0]);\n    }\n}",
      "choices": [
        "String creatureNames",
        "String[] creatureNames",
        "int[] creatureNames",
        "creatureNames"
      ],
      "answer": [
        "String[] creatureNames"
      ],
      "explanation": "The values provided (`{\"Goblin\", \"Orc\"}`) are an array initializer for an array of `String` objects. Therefore, `String[] creatureNames` is the correct way to declare and initialize this array variable."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The values `{\"Goblin\", \"Orc\"}` clearly indicate an array of strings.",
      "2": "Recall the syntax for declaring an array variable.",
      "3": "The missing part needs both the type and the name of the array."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 125,
    "subtopic_id": 3,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `ProphecyReader` needs to determine the length of `prophecyText`. Complete the method call to correctly get the length of the string.",
      "code": "public class ProphecyReader {\n    public static void main(String[] args) {\n        String prophecyText = \"The Future is Unwritten.\";\n        System.out.println(\"Prophecy Length: \" + prophecyText.???);\n    }\n}",
      "choices": [
        "size()",
        "length()",
        "count()",
        "length"
      ],
      "answer": [
        "length()"
      ],
      "explanation": "The `.length()` method is a built-in `String` method that returns the number of characters in the string. It's the correct way to get the length of `prophecyText`."
    },
    "difficulty": "easy",
    "hints": {
      "1": " `String` objects have a specific method to determine their length.",
      "2": "This method's name usually reflects \"how long\" something is.",
      "3": "It typically ends with `()`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 126,
    "subtopic_id": 3,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `SpellScrollComparer` checks if two spell scrolls (`scroll1` and `scroll2`) have identical content. Complete the method call and its argument to perform this content comparison.",
      "code": "public class SpellScrollComparer {\n    public static void main(String[] args) {\n        String scroll1 = \"Fireball\";\n        String scroll2 = new String(\"Fireball\");\n\n        if (scroll1.???(???)) {\n            System.out.println(\"Spell scrolls have identical content.\");\n        } else {\n            System.out.println(\"Spell scrolls have different content.\");\n        }\n    }\n}",
      "choices": [
        "equals",
        "==",
        "scroll2",
        "isEqual",
        "scroll1",
        "compareTo"
      ],
      "answer": [
        "equals",
        "scroll2"
      ],
      "explanation": "To compare the actual content of two `String` objects, the `.equals()` method must be used. So, `equals` (choice a) is the correct method call. The argument to the `equals()` method is the other `String` object being compared, which is `scroll2` (choice c)."
    },
    "difficulty": "medium",
    "hints": {
      "1": "For non-primitive types like `String`, `==` compares memory locations, not content.",
      "2": "There's a specific `String` method designed for content comparison.",
      "3": "The blank within the parentheses is the `String` object you want to compare `scroll1` against."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 127,
    "subtopic_id": 3,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `FamiliarRegistry` creates an array `familiarNames` to store names of magical familiars. Complete the array declaration and the keyword to create a new array instance.",
      "code": "public class FamiliarRegistry {\n    public static void main(String[] args) {\n        ??? = ??? new String[4];\n        System.out.println(\"Array Size: \" + familiarNames.length);\n        System.out.println(\"First Slot: \" + familiarNames[0]);\n    }\n}",
      "choices": [
        "String[] familiarNames",
        "String familiarNames",
        "new",
        "null",
        "familiarNames",
        "allocate"
      ],
      "answer": [
        "String[] familiarNames",
        "new"
      ],
      "explanation": "The variable `familiarNames` is an array of `String` objects. `String[] familiarNames` (choice a) correctly declares this array variable. To create the actual array object in memory and specify its size, the `new` keyword (choice c) is used before `new String[4]`."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The first blank needs the type and name for an array variable.",
      "2": "The second blank is the keyword used to create a new object instance in Java.",
      "3": "The array is meant to hold `String`s and have a size of 4."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 128,
    "subtopic_id": 3,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `RuneExtractor` retrieves a `middleRune` from a `secretSpell` string at a specific index. Complete the `String` method call and its argument to extract the character at index 3.",
      "code": "public class RuneExtractor {\n    public static void main(String[] args) {\n        String secretSpell = \"ABRACADABRA\";\n        char middleRune = secretSpell.???(???);\n        System.out.println(\"Middle Rune: \" + middleRune);\n    }\n}",
      "choices": [
        "getChar",
        "charAt",
        "3",
        "4",
        "index",
        "substring"
      ],
      "answer": [
        "charAt",
        "3"
      ],
      "explanation": "The `charAt()` method (choice b) is used to retrieve a single character from a `String` at a specified index. To get the character at index 3, the argument `3` (choice c) should be passed to the method."
    },
    "difficulty": "medium",
    "hints": {
      "1": "There's a specific `String` method to get a character at a given position.",
      "2": "Remember that `String` indices start from `0`. So, index `3` refers to the fourth character.",
      "3": "The method name usually includes \"char\" and \"at\"."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 129,
    "subtopic_id": 3,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "An `ArtifactMonitor` tracks `artifactStatuses` in an array. The status of the first artifact needs to be updated to \"Inactive\". Complete the array index and the literal value for the assignment.",
      "code": "public class ArtifactMonitor {\n    public static void main(String[] args) {\n        String[] artifactStatuses = {\"Active\", \"Dormant\", \"Broken\"};\n        artifactStatuses[???] = ???;\n        System.out.println(\"First Artifact Status: \" + artifactStatuses[0]);\n    }\n}",
      "choices": [
        "0",
        "1",
        "\"Inactive\"",
        "null",
        "artifactStatuses",
        "status"
      ],
      "answer": [
        "0",
        "\"Inactive\""
      ],
      "explanation": "Arrays in Java are zero-indexed, so the first element is at index `0` (choice a). The problem states the status needs to be updated to \"Inactive\", so `\"Inactive\"` (choice c) is the correct `String` literal to assign to that index."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The problem states the *first* artifact's status needs to be changed.",
      "2": "Recall the array index for the first element.",
      "3": "The new value is a specific string representing the status."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 130,
    "subtopic_id": 3,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "An `OptionalScrollCheck` evaluates an `optionalScrollName` which might be `null`. Before accessing its length, a `null` check is needed. Complete the `if` condition to safely check if `optionalScrollName` is not `null`.",
      "code": "public class OptionalScrollCheck {\n    public static void main(String[] args) {\n        String optionalScrollName = null;\n\n        if (??? != null) {\n            System.out.println(\"Scroll Name Length: \" + optionalScrollName.length());\n        } else {\n            System.out.println(\"No scroll present.\");\n        }\n    }\n}",
      "choices": [
        "optionalScrollName",
        "optional",
        "scrollName",
        "length()",
        "true",
        "false"
      ],
      "answer": [
        "optionalScrollName"
      ],
      "explanation": "To prevent a `NullPointerException` when attempting to call a method like `.length()` on `optionalScrollName`, it's essential to first check if `optionalScrollName` is not `null`. Therefore, `optionalScrollName` (choice a) is the correct variable name to complete the `if` condition `optionalScrollName != null`."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The `if` condition needs to check the variable itself.",
      "2": "The variable to be checked is `optionalScrollName`.",
      "3": "The comparison `!= null` checks if a non-primitive variable points to an object."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 131,
    "subtopic_id": 3,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `SpellTransformer` applies a series of transformations to `masterSpellName` (trimming, replacing, and converting to uppercase). A `derivedSpellName` also needs to be declared. Complete the declaration of `derivedSpellName` and the `String` methods for transformation.",
      "code": "public class SpellTransformer {\n    public static void main(String[] args) {\n        String masterSpellName = \"  Arcane Blast  \";\n        ??? derivedSpellName = \"Elemental\";\n        \n        masterSpellName = masterSpellName.???();\n        masterSpellName = masterSpellName.???(\"Blast\", \"Force\");\n        masterSpellName = masterSpellName.???();\n        \n        System.out.println(\"Transformed Spell: \" + masterSpellName);\n        System.out.println(\"Derived Spell: \" + derivedSpellName);\n    }\n}",
      "choices": [
        "trim",
        "toUpperCase",
        "String",
        "toLowerCase",
        "replace",
        "MasterSpellName",
        "replaceAll",
        "substring"
      ],
      "answer": [
        "String",
        "trim",
        "replace",
        "toUpperCase"
      ],
      "explanation": "1. `String` (choice c) is the correct data type for `derivedSpellName`.\n2. `.trim()` (choice a) is the `String` method used to remove leading and trailing whitespace.\n3. `.replace()` (choice e) is the `String` method used to replace occurrences of a target sequence with a replacement.\n4. `.toUpperCase()` (choice b) is the `String` method used to convert all characters in a string to uppercase."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The first blank needs the type for `derivedSpellName`.",
      "2": "The first method call is about removing leading/trailing spaces.",
      "3": "The second method call is about finding and replacing a specific part of the string."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 132,
    "subtopic_id": 3,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "An `ArchiveScanner` processes an `archiveLog` array which contains `String` entries, some of which may be `null`. It determines if a `logEntry` is `valid` (not null). Complete the array declaration, the `isEntryValid` boolean declaration, and the `null` check condition.",
      "code": "public class ArchiveScanner {\n    public static void main(String[] args) {\n        ??? archiveLog = {\"Event A\", null, \"Event C\"};\n        \n        String logEntry = archiveLog[1];\n        \n        ??? isEntryValid;\n        \n        if (logEntry ??? ???) {\n            isEntryValid = true;\n        }\n        else {\n            isEntryValid = false;\n        }\n        \n        System.out.println(\"Second Log Entry Length: \" + (isEntryValid ? logEntry.length() : 0));\n        System.out.println(\"Entry Valid: \" + isEntryValid);\n    }\n}",
      "choices": [
        "String[]",
        "int[]",
        "null",
        "!=",
        "isEntryValid",
        "boolean",
        "==",
        "logEntry"
      ],
      "answer": [
        "String[]",
        "boolean",
        "!=",
        "null"
      ],
      "explanation": "1. `String[]` (choice a) is the correct data type for `archiveLog` as it's an array initialized with `String` literals.\n2. `boolean` (choice f) is the correct type for `isEntryValid` as it will hold a `true` or `false` value.\n3. The condition `logEntry != null` (choice d and c) correctly checks if `logEntry` is not pointing to `null`, which is essential before calling methods like `length()`."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The first blank needs the type for an array that stores strings.",
      "2": "The third blank requires the type for `isEntryValid`.",
      "3": "The fourth and fifth blanks form the `null` check condition (`logEntry` is or is not `null`)."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 133,
    "subtopic_id": 3,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `SentinelArray` tracks `sentinelPowers`. The array is initialized with integer values, and a `recalibrationNeeded` flag is set based on the power level. Complete the array declaration, the `recalibrationNeeded` boolean declaration, and the assignments in the `if-else` block.",
      "code": "public class SentinelArray {\n    public static void main(String[] args) {\n        ??? sentinelPowers = new int[4];\n        \n        sentinelPowers[0] = 50;\n        sentinelPowers[3] = 80;\n        \n        ??? recalibrationNeeded;\n        \n        if (sentinelPowers[3] < 100) { \n            recalibrationNeeded = ???; // Blank 3: Value\n        } else {\n            recalibrationNeeded = ???; // Blank 4: Value\n        }\n        \n        System.out.println(\"Last Sentinel Power: \" + sentinelPowers[3]);\n        System.out.println(\"Recalibration Needed: \" + recalibrationNeeded);\n    }\n}",
      "choices": [
        "int[] sentinelPowers",
        "sentinelPowers",
        "boolean recalibrationNeeded",
        "recalibrationNeeded",
        "false",
        "true",
        "short[]",
        "power"
      ],
      "answer": [
        "int[] sentinelPowers",
        "boolean recalibrationNeeded",
        "true",
        "false"
      ],
      "explanation": "1. `int[] sentinelPowers` (choice a) is the correct declaration for an integer array.\n2. `boolean recalibrationNeeded` (choice c) is the correct declaration for a boolean variable.\n3. Since `sentinelPowers[3]` is `80`, the condition `80 < 100` is `true`. Thus, the `if` block executes, and `recalibrationNeeded` should be set to `true`.\n4. The `else` block (choice e) handles the `false` case for the condition."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The first blank needs the type and name for an array that stores integer power levels.",
      "2": "The second blank needs the type and name for the `recalibrationNeeded` boolean flag.",
      "3": "Evaluate the `if` condition with `sentinelPowers[3]` to determine which boolean value (`true` or `false`) will be assigned in the `if` and `else` blocks."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 134,
    "subtopic_id": 3,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "An `AncientTomeStatus` tracks whether a `secretChapterFound`, the `pageCount`, and sets `tomeStatus` using a ternary operator. A `lastAccessedPage` is also recorded. Complete the declarations of `tomeStatus` and `lastAccessedPage`, and the final print statements.",
      "code": "public class AncientTomeStatus {\n    public static void main(String[] args) {\n        boolean secretChapterFound = true;\n        int pageCount = 250;\n        \n        ??? = secretChapterFound ? \"Revealed\" : \"Hidden\";\n        \n        ??? = 1492;\n        \n        System.out.println(\"Tome Status: \" + tomeStatus);\n        System.out.println(\"Last Accessed Page: \" + lastAccessedPage);\n        System.out.println(\"Page Count: \" + ???);\n        System.out.println(\"Is Secret Chapter Found: \" + ???);\n    }\n}",
      "choices": [
        "String tomeStatus",
        "int lastAccessedPage",
        "pageCount",
        "secretChapterFound",
        "boolean tomeStatus",
        "count",
        "long lastAccessedPage",
        "chapter"
      ],
      "answer": [
        "String tomeStatus",
        "int lastAccessedPage",
        "pageCount",
        "secretChapterFound"
      ],
      "explanation": "1. `String tomeStatus` (choice a) correctly declares the `String` variable `tomeStatus` that holds the result of the ternary operation.\n2. `int lastAccessedPage` (choice b) correctly declares the integer variable `lastAccessedPage`.\n3. The third blank in the `System.out.println()` statement should print the `pageCount` variable.\n4. The fourth blank in the `System.out.println()` statement should print the `secretChapterFound` variable."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The first blank declares a `String` variable and its name, based on a conditional expression.",
      "2": "The second blank declares an `int` variable and its name.",
      "3": "The last two blanks are for variables that should be printed to reveal their values."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 135,
    "subtopic_id": 3,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "An `ArcaneSymbolArray` initializes an array of `char`s. A `isValidSet` flag is determined by checking specific elements. A `finalSymbol` is also extracted from the array. Complete the array declaration, the `isValidSet` boolean declaration, the `finalSymbol` declaration, and the array index for `finalSymbol`.",
      "code": "public class ArcaneSymbolArray {\n    public static void main(String[] args) {\n        ??? = new char[3];\n        arcaneSymbols[0] = 'X';\n        arcaneSymbols[1] = (char) 70;\n        arcaneSymbols[2] = 'Z';\n        \n        ???;\n        \n        if (arcaneSymbols[0] == 'X' && arcaneSymbols[1] == 'F') {\n            isValidSet = true;\n        } else {\n            isValidSet = false;\n        }\n        \n        ??? = arcaneSymbols[???];\n        \n        System.out.println(\"Final Symbol: \" + finalSymbol);\n        System.out.println(\"Is Valid Set: \" + isValidSet);\n    }\n}",
      "choices": [
        "char[] arcaneSymbols",
        "boolean isValidSet",
        "char finalSymbol",
        "2",
        "int[] arcaneSymbols",
        "String finalSymbol",
        "0",
        "1"
      ],
      "answer": [
        "char[] arcaneSymbols",
        "boolean isValidSet",
        "char finalSymbol",
        "2"
      ],
      "explanation": "1. `char[] arcaneSymbols` (choice a) correctly declares the array of characters.\n2. `boolean isValidSet` (choice b) correctly declares the boolean variable.\n3. `char finalSymbol` (choice c) declares the `char` variable `finalSymbol`.\n4. The last element of a 3-element array (indices 0, 1, 2) is at index `2`."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The first blank needs the type and name for an array that stores characters.",
      "2": "The second blank declares a boolean variable.",
      "3": "The third blank declares a `char` variable that will hold one of the array elements."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 136,
    "subtopic_id": 4,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `StolenGoodsReport` system calculates the `totalStolenGoods` by adding values from two separate reports. Your task is to trace the code and determine the final `Total Stolen Goods` that is printed.",
      "code": "public class StolenGoodsReport {\n    public static void main(String[] args) {\n        int report1Value = 1500;\n        int report2Value = 750;\n        int totalStolenGoods = report1Value + report2Value;\n        System.out.println(\"Total Stolen Goods: $\" + totalStolenGoods);\n    }\n}",
      "choices": [
        "Total Stolen Goods: $1500",
        "Total Stolen Goods: $750",
        "Total Stolen Goods: $2250",
        "Error"
      ],
      "answer": [
        "Total Stolen Goods: $2250"
      ],
      "explanation": "The `report1Value` is `1500` and `report2Value` is `750`. The line `int totalStolenGoods = report1Value + report2Value;` adds these two values: `1500 + 750 = 2250`. This result is then assigned to `totalStolenGoods`. Finally, `System.out.println()` prints \"Total Stolen Goods: $2250\"."
    },
    "difficulty": "easy",
    "hints": {
      "1": "Identify the operation being performed on `report1Value` and `report2Value`.",
      "2": "Perform the addition.",
      "3": "The `+` operator combines the string literal with the numerical result."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 137,
    "subtopic_id": 4,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "An `AlibiChecker` system determines `alibiHoursRemaining` by subtracting `hoursAccountedFor` from `initialAlibiHours`. Your task is to trace the code and determine the final `Alibi Hours Remaining`.",
      "code": "public class AlibiChecker {\n    public static void main(String[] args) {\n        int initialAlibiHours = 24;\n        int hoursAccountedFor = 18;\n        int alibiHoursRemaining = initialAlibiHours - hoursAccountedFor;\n        System.out.println(\"Alibi Hours Remaining: \" + alibiHoursRemaining);\n    }\n}",
      "choices": [
        "Alibi Hours Remaining: 24",
        "Alibi Hours Remaining: 18",
        "Alibi Hours Remaining: 6",
        "Error"
      ],
      "answer": [
        "Alibi Hours Remaining: 6"
      ],
      "explanation": " `initialAlibiHours` is `24` and `hoursAccountedFor` is `18`. The line `int alibiHoursRemaining = initialAlibiHours - hoursAccountoredFor;` calculates `24 - 18 = 6`. This result is assigned to `alibiHoursRemaining`. Finally, `System.out.println()` prints \"Alibi Hours Remaining: 6\"."
    },
    "difficulty": "easy",
    "hints": {
      "1": "Identify the operation being performed on the two hour variables.",
      "2": "Perform the subtraction.",
      "3": "The `println` statement displays the final calculated value."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 138,
    "subtopic_id": 4,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `ThreatAssessment` system calculates `threatLevel` by multiplying `suspectsConfirmed` by a `dangerFactor`. Your task is to trace the code and determine the `Current Threat Level`.",
      "code": "public class ThreatAssessment {\n    public static void main(String[] args) {\n        int suspectsConfirmed = 5;\n        int dangerFactor = 10;\n        int threatLevel = suspectsConfirmed * dangerFactor;\n        System.out.println(\"Current Threat Level: \" + threatLevel);\n    }\n}",
      "choices": [
        "Current Threat Level: 5",
        "Current Threat Level: 10",
        "Current Threat Level: 50",
        "Error"
      ],
      "answer": [
        "Current Threat Level: 50"
      ],
      "explanation": " `suspectsConfirmed` is `5` and `dangerFactor` is `10`. The line `int threatLevel = suspectsConfirmed * dangerFactor;` calculates `5 * 10 = 50`. This result is assigned to `threatLevel`. Finally, `System.out.println()` prints \"Current Threat Level: 50\"."
    },
    "difficulty": "easy",
    "hints": {
      "1": "Identify the multiplication operator.",
      "2": "Perform the multiplication.",
      "3": "The final `println` displays the result after the multiplication."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 139,
    "subtopic_id": 4,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "An `EvidenceDistribution` system calculates `itemsPerDetective` by dividing `totalEvidenceItems` among `detectivesAssigned`. Your task is to trace the code and determine the `Items Per Detective`.",
      "code": "public class EvidenceDistribution {\n    public static void main(String[] args) {\n        int totalEvidenceItems = 27;\n        int detectivesAssigned = 5;\n        int itemsPerDetective = totalEvidenceItems / detectivesAssigned;\n        System.out.println(\"Items Per Detective: \" + itemsPerDetective);\n    }\n}",
      "choices": [
        "Items Per Detective: 5.4",
        "Items Per Detective: 5",
        "Items Per Detective: 2",
        "Error"
      ],
      "answer": [
        "Items Per Detective: 5"
      ],
      "explanation": " `totalEvidenceItems` is `27` and `detectivesAssigned` is `5`. The line `int itemsPerDetective = totalEvidenceItems / detectivesAssigned;` calculates `27 / 5`. Since both are integers, Java performs integer division, which results in `5` (the remainder `2` is discarded). This result is assigned to `itemsPerDetective`. Finally, `System.out.println()` prints \"Items Per Detective: 5\"."
    },
    "difficulty": "easy",
    "hints": {
      "1": "Both `totalEvidenceItems` and `detectivesAssigned` are integers.",
      "2": "Recall that integer division (`/`) truncates (discards) any decimal part.",
      "3": "Calculate the division and then format the output."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 140,
    "subtopic_id": 4,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `BombSquad` system calculates the `timeRemaining` in a cycle using the modulo operator. Your task is to trace the code and determine the `Time Remaining in Cycle`.",
      "code": "public class BombSquad {\n    public static void main(String[] args) {\n        int totalMinutes = 65;\n        int cycleMinutes = 10;\n        int timeRemaining = totalMinutes % cycleMinutes;\n        System.out.println(\"Time Remaining in Cycle: \" + timeRemaining + \" minutes\");\n    }\n}",
      "choices": [
        "Time Remaining in Cycle: 65 minutes",
        "Time Remaining in Cycle: 6 minutes",
        "Time Remaining in Cycle: 5 minutes",
        "Error"
      ],
      "answer": [
        "Time Remaining in Cycle: 5 minutes"
      ],
      "explanation": " `totalMinutes` is `65` and `cycleMinutes` is `10`. The line `int timeRemaining = totalMinutes % cycleMinutes;` calculates the remainder when `65` is divided by `10`. `65 / 10` is `6` with a remainder of `5`. This `5` is assigned to `timeRemaining`. Finally, `System.out.println()` prints \"Time Remaining in Cycle: 5 minutes\"."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The `%` operator calculates the remainder of a division.",
      "2": "Divide `totalMinutes` by `cycleMinutes` and note the remainder.",
      "3": "The `println` statement combines the string with the calculated remainder."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 141,
    "subtopic_id": 4,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `CrimeSceneAnalyst` calculates `expectedRounds` and `casingsPerCrimeScene` using multiple arithmetic operations. Your task is to trace the code and determine the `Expected Rounds` and `Casings Per Crime Scene`.",
      "code": "public class CrimeSceneAnalyst {\n    public static void main(String[] args) {\n        int bulletCasings = 5;\n        int magazineCapacity = 10;\n        int crimeScenes = 2;\n\n        int expectedRounds = magazineCapacity * crimeScenes + bulletCasings;\n        int casingsPerCrimeScene = bulletCasings / crimeScenes;\n        \n        System.out.println(\"Expected Rounds: \" + expectedRounds);\n        System.out.println(\"Casings Per Crime Scene: \" + casingsPerCrimeScene);\n    }\n}",
      "choices": [
        "Expected Rounds: 20",
        "Expected Rounds: 25",
        "Casings Per Crime Scene: 2.5",
        "Casings Per Crime Scene: 2"
      ],
      "answer": [
        "Expected Rounds: 25",
        "Casings Per Crime Scene: 2"
      ],
      "explanation": "1. `bulletCasings` is `5`, `magazineCapacity` is `10`, `crimeScenes` is `2`.\n2. `expectedRounds = magazineCapacity * crimeScenes + bulletCasings;` first calculates `10 * 2 = 20` (multiplication), then `20 + 5 = 25` (addition). So, `expectedRounds` is `25`.\n3. `casingsPerCrimeScene = bulletCasings / crimeScenes;` calculates `5 / 2`. Since both are integers, it performs integer division, which results in `2` (the remainder is discarded).\n4. The first `System.out.println()` prints \"Expected Rounds: 25\".\n5. The second `System.out.println()` prints \"Casings Per Crime Scene: 2\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Remember the order of operations: multiplication and division happen before addition and subtraction.",
      "2": "Pay attention to the data types for division. If both operands are integers, the result will also be an integer.",
      "3": "Each `System.out.println()` statement produces a distinct output."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 142,
    "subtopic_id": 4,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "An `EvidenceProcessor` calculates `analyzedWeight` and `samplesLeft` using division and modulo operators with mixed data types. Your task is to trace the code and determine the `Analyzed Weight` and `Samples Left`.",
      "code": "public class EvidenceProcessor {\n    public static void main(String[] args) {\n        int totalWeight = 50;\n        double samplingFactor = 2.5;\n        int sampleSize = 7;\n\n        double analyzedWeight = totalWeight / samplingFactor;\n        int samplesLeft = totalWeight % sampleSize;\n        \n        System.out.println(\"Analyzed Weight: \" + analyzedWeight);\n        System.out.println(\"Samples Left: \" + samplesLeft);\n    }\n}",
      "choices": [
        "Analyzed Weight: 20",
        "Analyzed Weight: 20.0",
        "Samples Left: 1",
        "Samples Left: 7"
      ],
      "answer": [
        "Analyzed Weight: 20.0",
        "Samples Left: 1"
      ],
      "explanation": "1. `totalWeight` is `50`, `samplingFactor` is `2.5`, `sampleSize` is `7`.\n2. `analyzedWeight = totalWeight / samplingFactor;` calculates `50 / 2.5`. The `int` `totalWeight` is promoted to `double`, so `50.0 / 2.5 = 20.0`. `analyzedWeight` is `20.0`.\n3. `samplesLeft = totalWeight % sampleSize;` calculates the remainder of `50 / 7`. `50 / 7` is `7` with a remainder of `1`. So, `samplesLeft` is `1`.\n4. The first `System.out.println()` prints \"Analyzed Weight: 20.0\".\n5. The second `System.out.println()` prints \"Samples Left: 1\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": "When an `int` is divided by a `double`, the `int` promotes to `double`, and the result is a `double`.",
      "2": "The modulo operator (`%`) gives the remainder of a division.",
      "3": "Trace each calculation independently to avoid mixing results."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 143,
    "subtopic_id": 4,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `FinancialAudit` tracks `initialFunds` and `totalTransactions`. Funds are adjusted by `expense` and `incomeAdded`, and transactions are incremented. Your task is to trace the code and determine the final `Funds` and `Total Transactions`.",
      "code": "public class FinancialAudit {\n    public static void main(String[] args) {\n        int initialFunds = 1000;\n        int expense = 200;\n        int incomeAdded = 150;\n        int totalTransactions = 0;\n\n        initialFunds -= expense;\n        initialFunds += incomeAdded;\n        totalTransactions++;\n        totalTransactions++;\n        \n        System.out.println(\"Final Funds: $\" + initialFunds);\n        System.out.println(\"Total Transactions: \" + totalTransactions);\n    }\n}",
      "choices": [
        "Final Funds: $800",
        "Final Funds: $950",
        "Total Transactions: 1",
        "Total Transactions: 2"
      ],
      "answer": [
        "Final Funds: $950",
        "Total Transactions: 2"
      ],
      "explanation": "1. `initialFunds` starts at `1000`, `totalTransactions` at `0`.\n2. `initialFunds -= expense;` becomes `1000 - 200 = 800`. `initialFunds` is now `800`.\n3. `initialFunds += incomeAdded;` becomes `800 + 150 = 950`. `initialFunds` is now `950`.\n4. `totalTransactions++;` increments `totalTransactions` to `1`.\n5. `totalTransactions++;` increments `totalTransactions` to `2`.\n6. The first `System.out.println()` prints \"Final Funds: $950\".\n7. The second `System.out.println()` prints \"Total Transactions: 2\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": " `x -= y` is a shorthand for `x = x - y`.",
      "2": " `x += y` is a shorthand for `x = x + y`.",
      "3": " `x++` is a shorthand for `x = x + 1`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 144,
    "subtopic_id": 4,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `ProfilerReport` calculates `firstScore` using a complex expression with casting, then determines a `remainderCheck`. Your task is to trace the code and determine the `First Score After Ops` and `Remainder Check`.",
      "code": "public class ProfilerReport {\n    public static void main(String[] args) {\n        int firstScore = 15;\n        double multiplier = 2.5;\n        int divisor = 4;\n\n        firstScore = (int) ((firstScore + 5) * multiplier);\n        int remainderCheck = firstScore % divisor;\n        \n        System.out.println(\"First Score After Ops: \" + firstScore);\n        System.out.println(\"Remainder Check: \" + remainderCheck);\n    }\n}",
      "choices": [
        "First Score After Ops: 15",
        "First Score After Ops: 50",
        "Remainder Check: 0",
        "Remainder Check: 2"
      ],
      "answer": [
        "First Score After Ops: 50",
        "Remainder Check: 2"
      ],
      "explanation": "1. `firstScore` is `15`, `multiplier` is `2.5`, `divisor` is `4`.\n2. `firstScore = (int) ((firstScore + 5) * multiplier);`\n    * `(firstScore + 5)` calculates `15 + 5 = 20`.\n    * `20 * multiplier` calculates `20 * 2.5 = 50.0`.\n    * `(int)50.0` casts to `50`. So `firstScore` is `50`.\n3. `remainderCheck = firstScore % divisor;` calculates `50 % 4`. `50 / 4` is `12` with a remainder of `2`. So, `remainderCheck` is `2`.\n4. The first `System.out.println()` prints \"First Score After Ops: 50\".\n5. The second `System.out.println()` prints \"Remainder Check: 2\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Parentheses dictate the order of operations before multiplication.",
      "2": "Multiplying an `int` by a `double` results in a `double`; the `(int)` cast truncates.",
      "3": "The modulo operator (`%`) calculates the remainder."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 145,
    "subtopic_id": 4,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `PhotoAnalyst` calculates `exposureSettings` and then reassigns `aperture`. Your task is to trace the code and determine the `Final Exposure Settings` and `Aperture After Reassignment`.",
      "code": "public class PhotoAnalyst {\n    public static void main(String[] args) {\n        double lightConditions = 100.0;\n        int aperture = 5;\n        \n        double exposureSettings = lightConditions / aperture - 10;\n        \n        System.out.println(\"Final Exposure Settings: \" + exposureSettings);\n        \n        aperture = 7;\n        \n        System.out.println(\"Aperture After Reassignment: \" + aperture);\n    }\n}",
      "choices": [
        "Final Exposure Settings: 10.0",
        "Final Exposure Settings: 20.0",
        "Aperture After Reassignment: 5",
        "Aperture After Reassignment: 7"
      ],
      "answer": [
        "Final Exposure Settings: 10.0",
        "Aperture After Reassignment: 7"
      ],
      "explanation": "1. `lightConditions` is `100.0`, `aperture` is `5`.\n2. `exposureSettings = lightConditions / aperture - 10;`\n    * `lightConditions / aperture` calculates `100.0 / 5.0` (aperture promotes to double), resulting in `20.0`.\n    * `20.0 - 10` calculates `10.0`. So, `exposureSettings` is `10.0`.\n3. The first `System.out.println()` prints \"Final Exposure Settings: 10.0\".\n4. `aperture = 7;` reassigns `aperture` to `7`.\n5. The second `System.out.println()` prints \"Aperture After Reassignment: 7\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Division happens before subtraction.",
      "2": "An integer (`aperture`) will promote to a `double` when used with a `double` (`lightConditions`).",
      "3": "The variable `aperture` is reassigned *after* it's used to calculate `exposureSettings`. Track its value for the second `println`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 146,
    "subtopic_id": 4,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `SurveillanceLog` calculates `totalTimeAnalyzed`, `timeDifference`, and `cycleCount` using a mix of integer and floating-point arithmetic with various operators. Your task is to trace the code and determine the `Total Time Analyzed`, `Time Difference`, and `Cycle Count`.",
      "code": "public class SurveillanceLog {\n    public static void main(String[] args) {\n        int initialHours = 100;\n        double footageMultiplier = 0.5;\n        byte agentsInField = 3;\n        \n        double totalTimeAnalyzed = (initialHours / agentsInField) * footageMultiplier + 5.0;\n        \n        int timeDifference = (int) (initialHours - (agentsInField * 10.0));\n        \n        int cycleCount = (int) totalTimeAnalyzed % 10;\n        \n        System.out.println(\"Total Time Analyzed: \" + totalTimeAnalyzed);\n        System.out.println(\"Time Difference: \" + timeDifference);\n        System.out.println(\"Cycle Count: \" + cycleCount);\n    }\n}",
      "choices": [
        "Total Time Analyzed: 21.5",
        "Time Difference: 70",
        "Cycle Count: 1",
        "Total Time Analyzed: 16.5"
      ],
      "answer": [
        "Total Time Analyzed: 21.5",
        "Time Difference: 70",
        "Cycle Count: 1"
      ],
      "explanation": "1. `initialHours = 100`, `footageMultiplier = 0.5`, `agentsInField = 3`.\n2. `totalTimeAnalyzed = (initialHours / agentsInField) * footageMultiplier + 5.0;`\n    * `initialHours / agentsInField`: `100 / 3` (integer division) = `33`.\n    * `33 * footageMultiplier`: `33 * 0.5` (int promotes to double) = `16.5`.\n    * `16.5 + 5.0` = `21.5`. So, `totalTimeAnalyzed` is `21.5`.\n3. `timeDifference = (int) (initialHours - (agentsInField * 10.0));`\n    * `agentsInField * 10.0`: `3 * 10.0` (int promotes to double) = `30.0`.\n    * `initialHours - 30.0`: `100 - 30.0` (int promotes to double) = `70.0`.\n    * `(int)70.0`: casts to `70`. So, `timeDifference` is `70`.\n4. `cycleCount = (int) totalTimeAnalyzed % 10;`\n    * `(int) totalTimeAnalyzed`: `(int)21.5` = `21`.\n    * `21 % 10`: `21 / 10` is 2 with remainder `1`. So, `cycleCount` is `1`.\n5. All three `System.out.println()` statements display the final values."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Remember integer division: `100 / 3` will discard the decimal.",
      "2": "Follow the type promotion rules: when an `int` interacts with a `double`, the result is a `double`.",
      "3": "Parentheses dictate precedence. Perform operations inside them first."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 147,
    "subtopic_id": 4,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `BombCalibrator` calculates `detonationTiming`, `fuseStatus`, and `signalLossFactor` using various arithmetic operations with different primitive types, including a `byte` that may overflow. Your task is to trace the code and determine the `Final Detonation Timing`, `Fuse Status`, and `Signal Loss Factor`.",
      "code": "public class BombCalibrator {\n    public static void main(String[] args) {\n        float wireLength1 = 10.5f;\n        double wireLength2 = 2.5;\n        int pulseFrequency = 3;\n        byte safetyOverride = 5;\n\n        double detonationTiming = (wireLength1 + wireLength2) * pulseFrequency;\n        \n        int fuseStatus = (int) (detonationTiming % safetyOverride);\n        \n        safetyOverride = (byte) (safetyOverride + 125);\n        \n        float signalLossFactor = wireLength1 / safetyOverride;\n        \n        System.out.println(\"Final Detonation Timing: \" + detonationTiming);\n        System.out.println(\"Fuse Status: \" + fuseStatus);\n        System.out.println(\"Signal Loss Factor: \" + signalLossFactor);\n    }\n}",
      "choices": [
        "Final Detonation Timing: 39.0",
        "Fuse Status: 4",
        "Signal Loss Factor: -0.083333336",
        "Signal Loss Factor: 0.083333336"
      ],
      "answer": [
        "Final Detonation Timing: 39.0",
        "Fuse Status: 4",
        "Signal Loss Factor: -0.083333336"
      ],
      "explanation": "1. `wireLength1 = 10.5f`, `wireLength2 = 2.5`, `pulseFrequency = 3`, `safetyOverride = 5`.\n2. `detonationTiming = (wireLength1 + wireLength2) * pulseFrequency;`\n    * `wireLength1 + wireLength2`: `10.5f + 2.5d` (float promotes to double) = `13.0d`.\n    * `13.0d * 3` (int promotes to double) = `39.0d`. So, `detonationTiming` is `39.0`.\n3. `fuseStatus = (int) (detonationTiming % safetyOverride);`\n    * `(int)detonationTiming`: `(int)39.0` = `39`.\n    * `39 % 5` = `4`. So, `fuseStatus` is `4`.\n4. `safetyOverride = (byte) (safetyOverride + 125);`\n    * `5 + 125 = 130`.\n    * `(byte)130` causes a **byte overflow** (130 > 127). `130` wraps around to `-126`. So, `safetyOverride` is `-126`.\n5. `float signalLossFactor = wireLength1 / safetyOverride;`\n    * `wireLength1` is `10.5f`. `safetyOverride` (`-126`) promotes to `float`.\n    * `10.5f / -126.0f` = approximately `-0.083333336`. So, `signalLossFactor` is `-0.083333336`.\n6. All three `System.out.println()` statements display the final values."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Adding a `float` and `double` results in a `double`.",
      "2": "The modulo operator (`%`) works on integer operands; ensure the `detonationTiming` is cast before the modulo.",
      "3": "Watch out for `byte` overflow: `5 + 125` will exceed `byte`'s max value."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 148,
    "subtopic_id": 4,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `FinancialAuditSystem` calculates `netProfit`, `taxLiability`, and `refundRemainder` from large `long` and `int` values, involving potential overflows and type promotions. Your task is to trace the code and determine these final values.",
      "code": "public class FinancialAuditSystem {\n    public static void main(String[] args) {\n        long period1Profit = 950000000L;\n        long period2Profit = 500000000L;\n        int expenses = 200000000;\n        \n        long netProfit = period1Profit + period2Profit - expenses;\n        \n        int taxRate = 20;\n        int taxLiability = (int) (netProfit * taxRate / 100);\n        \n        int totalCustomers = 3;\n        int refundRemainder = taxLiability % totalCustomers;\n        \n        System.out.println(\"Net Profit: \" + netProfit);\n        System.out.println(\"Tax Liability: \" + taxLiability);\n        System.out.println(\"Refund Remainder: \" + refundRemainder);\n    }\n}",
      "choices": [
        "Net Profit: 1500000000",
        "Tax Liability: 250000000",
        "Refund Remainder: 1",
        "Net Profit: 1250000000"
      ],
      "answer": [
        "Tax Liability: 250000000",
        "Refund Remainder: 1",
        "Net Profit: 1250000000"
      ],
      "explanation": "1. `period1Profit = 950000000L`, `period2Profit = 500000000L`, `expenses = 200000000`.\n2. `long netProfit = period1Profit + period2Profit - expenses;`\n    * `950000000L + 500000000L = 1450000000L`.\n    * `1450000000L - 200000000` (int promotes to long) = `1250000000L`. So, `netProfit` is `1250000000L`.\n3. `int taxLiability = (int) (netProfit * taxRate / 100);`\n    * `netProfit * taxRate`: `1250000000L * 20` (int promotes to long) = `25000000000L`.\n    * `25000000000L / 100` (int promotes to long) = `250000000L`.\n    * `(int)250000000L`: casts to `250000000`. This value fits in `int`. So, `taxLiability` is `250000000`.\n4. `int refundRemainder = taxLiability % totalCustomers;`\n    * `250000000 % 3`. The sum of digits of `250000000` is `7`. `7 % 3 = 1`. So, `refundRemainder` is `1`.\n5. All three `System.out.println()` statements display the final values."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Perform `long` arithmetic first; the result will also be a `long`.",
      "2": "Be careful when casting the result of a `long` calculation to an `int` (`taxLiability`); ensure the value fits within `int`'s range.",
      "3": "The modulo operator (`%`) calculates the remainder after integer division."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 149,
    "subtopic_id": 4,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `BallisticsAnalyst` calculates `adjustedVelocity`, `targetAdjustedDistance`, and `hitChancePercentage` using a mix of float, double, and int operations with various type promotions. Your task is to trace the code and determine these final values.",
      "code": "public class BallisticsAnalyst {\n    public static void main(String[] args) {\n        float bulletVelocity = 350.5f;\n        double windDeflection = 0.05;\n        int targetDistance = 1000;\n        \n        double adjustedVelocity = bulletVelocity - (windDeflection * 10.0f);\n        \n        int targetAdjustedDistance = targetDistance / 300 * 10;\n        \n        double hitChancePercentage = (adjustedVelocity / bulletVelocity) * 100.0;\n        \n        System.out.println(\"Final Bullet Velocity: \" + adjustedVelocity);\n        System.out.println(\"Target Adjusted Distance: \" + targetAdjustedDistance);\n        System.out.println(\"Hit Chance Percentage: \" + hitChancePercentage);\n    }\n}",
      "choices": [
        "Final Bullet Velocity: 350.0",
        "Target Adjusted Distance: 30",
        "Hit Chance Percentage: 100.0",
        "Hit Chance Percentage: 99.85748"
      ],
      "answer": [
        "Final Bullet Velocity: 350.0",
        "Target Adjusted Distance: 30",
        "Hit Chance Percentage: 99.85734664764622"
      ],
      "explanation": "1. `bulletVelocity = 350.5f`, `windDeflection = 0.05`, `targetDistance = 1000`.\n2. `double adjustedVelocity = bulletVelocity - (windDeflection * 10.0f);`\n    * `windDeflection * 10.0f`: `0.05d * 10.0f` (float promotes to double) = `0.5d`.\n    * `bulletVelocity - 0.5d`: `350.5f - 0.5d` (float promotes to double) = `350.0d`. So, `adjustedVelocity` is `350.0`.\n3. `int targetAdjustedDistance = targetDistance / 300 * 10;`\n    * `targetDistance / 300`: `1000 / 300` (integer division) = `3`.\n    * `3 * 10` = `30`. So, `targetAdjustedDistance` is `30`.\n4. `double hitChancePercentage = (adjustedVelocity / bulletVelocity) * 100.0;`\n    * `adjustedVelocity / bulletVelocity`: `350.0d / 350.5f` (float promotes to double) = `0.9985734664764622`.\n    * `0.9985734664764622 * 100.0` = `99.85734664764622`. So, `hitChancePercentage` is `99.85734664764622`.\n5. All three `System.out.println()` statements display the final values."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Trace `adjustedVelocity` remembering that `float` promotes to `double` when operating with a `double`.",
      "2": "Perform the integer division for `targetAdjustedDistance` carefully before multiplication.",
      "3": "Calculate `hitChancePercentage` with full `double` precision, then consider the expected decimal output."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 150,
    "subtopic_id": 4,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `CovertRouteTracker` determines `routeDistance`, `elapsedTime`, and `deviationFactor` from various integer and floating-point values, including operations that cause a `byte` overflow. Your task is to trace the code and determine these final values.",
      "code": "public class CovertRouteTracker {\n    public static void main(String[] args) {\n        int startPoint = 100;\n        int endPoint = -20;\n        float speedFactor = 2.5f;\n        byte checkpoints = 7;\n\n        int routeDistance = (startPoint - endPoint) / checkpoints;\n        \n        double elapsedTime = routeDistance * speedFactor + (startPoint % checkpoints);\n        \n        byte deviationFactor = (byte) (checkpoints * speedFactor);\n        deviationFactor += (byte) (endPoint / 5);\n        \n        System.out.println(\"Final Route Distance: \" + routeDistance);\n        System.out.println(\"Elapsed Time: \" + elapsedTime);\n        System.out.println(\"Deviation Factor: \" + deviationFactor);\n    }\n}",
      "choices": [
        "Final Route Distance: 17",
        "Elapsed Time: 44.5",
        "Deviation Factor: 13",
        "Deviation Factor: 17"
      ],
      "answer": [
        "Final Route Distance: 17",
        "Elapsed Time: 44.5",
        "Deviation Factor: 13"
      ],
      "explanation": "1. `startPoint = 100`, `endPoint = -20`, `speedFactor = 2.5f`, `checkpoints = 7`.\n2. `int routeDistance = (startPoint - endPoint) / checkpoints;`\n    * `(100 - (-20))` = `120`.\n    * `120 / 7` (integer division) = `17`. So, `routeDistance` is `17`.\n3. `double elapsedTime = routeDistance * speedFactor + (startPoint % checkpoints);`\n    * `routeDistance * speedFactor`: `17 * 2.5f` (int promotes to float) = `42.5f`.\n    * `startPoint % checkpoints`: `100 % 7` = `2` (100 / 7 is 14 with remainder 2).\n    * `42.5f + 2` (int promotes to float) = `44.5f`. So, `elapsedTime` is `44.5`.\n4. `byte deviationFactor = (byte) (checkpoints * speedFactor);`\n    * `checkpoints * speedFactor`: `7 * 2.5f` (int promotes to float) = `17.5f`.\n    * `(byte)17.5f`: casts to `17` (truncates). So, `deviationFactor` is `17`.\n5. `deviationFactor += (byte) (endPoint / 5);`\n    * `endPoint / 5`: `-20 / 5` (integer division) = `-4`.\n    * `(byte)-4` is `-4`.\n    * `deviationFactor += -4`: `17 + (-4)` = `13`. So, `deviationFactor` is `13`.\n6. All three `System.out.println()` statements display the final values."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Subtraction of a negative number becomes addition (e.g., `100 - (-20)`).",
      "2": "Follow type promotion: `int * float` results in `float`, then `float + int` results in `float`.",
      "3": "Carefully trace the `byte` variable and its updates, including the cast and potential final overflow."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 151,
    "subtopic_id": 4,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `StakeoutLogger` tracks `totalStakeoutHours` by combining `shift1Hours` and `shift2Hours`. However, the code incorrectly uses subtraction instead of addition. Fix the code to calculate the correct total hours.",
      "code": "public class StakeoutLogger {\n    public static void main(String[] args) {\n        int shift1Hours = 8;\n        int shift2Hours = 4;\n        int totalStakeoutHours = shift1Hours + shift2Hours; // Correct: Use addition\n        System.out.println(\"Total Stakeout Hours: \" + totalStakeoutHours);\n    }\n}",
      "expected_output": [
        "Total Stakeout Hours: 12"
      ],
      "hidden_test_case": "",
      "explanation": "The original code used the subtraction operator (`-`) instead of the addition operator (`+`). To find the total hours, the two values need to be added together. Replacing `-` with `+` correctly calculates `8 + 4 = 12`."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The goal is to find the *total* hours.",
      "2": "Which arithmetic operator performs addition?",
      "3": "Look for the operation symbol between `shift1Hours` and `shift2Hours`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 152,
    "subtopic_id": 4,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `SuspectTracker` determines `activeSuspects` by reducing `initialSuspects` by `clearedSuspects`. However, the code incorrectly uses multiplication instead of subtraction. Fix the code to calculate the correct number of active suspects.",
      "code": "public class SuspectTracker {\n    public static void main(String[] args) {\n        int initialSuspects = 10;\n        int clearedSuspects = 3;\n        int activeSuspects = initialSuspects - clearedSuspects; // Correct: Use subtraction\n        System.out.println(\"Active Suspects: \" + activeSuspects);\n    }\n}",
      "expected_output": [
        "Active Suspects: 7"
      ],
      "hidden_test_case": "",
      "explanation": "The original code used the multiplication operator (`*`) instead of the subtraction operator (`-`). To find the remaining suspects, the `clearedSuspects` need to be subtracted from `initialSuspects`. Replacing `*` with `-` correctly calculates `10 - 3 = 7`."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The goal is to find the number of suspects *remaining* after some are cleared.",
      "2": "Which arithmetic operator reduces a quantity?",
      "3": "Look at the symbol between `initialSuspects` and `clearedSuspects`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 153,
    "subtopic_id": 4,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "An `EvidenceDistributor` calculates `itemsPerContainer` by dividing `evidenceItems` among `containers`. However, the code performs integer division, losing decimal precision. Fix the code to obtain a floating-point result for `itemsPerContainer`.",
      "code": "public class EvidenceDistributor {\n    public static void main(String[] args) {\n        int evidenceItems = 15;\n        int containers = 4;\n        double itemsPerContainer = (double) evidenceItems / containers; // Correct: Cast to double for floating-point division\n        System.out.println(\"Items Per Container: \" + itemsPerContainer);\n    }\n}",
      "expected_output": [
        "Items Per Container: 3.75"
      ],
      "hidden_test_case": "",
      "explanation": "The original code performs integer division (`15 / 4 = 3`) because both `evidenceItems` and `containers` are `int`s. This causes the decimal part (`.75`) to be lost. To achieve floating-point division and retain precision, at least one of the operands must be cast to a floating-point type (`double` or `float`). Casting `evidenceItems` to `double` (`(double)evidenceItems`) before division forces the entire operation to be floating-point. The result `3.75` can then be correctly stored in a `double` variable."
    },
    "difficulty": "easy",
    "hints": {
      "1": "Division between two integers will always result in an integer (any decimal part is truncated).",
      "2": "To get a floating-point result from division, at least one of the operands must be a floating-point type (`double` or `float`).",
      "3": "Consider explicitly converting one of the numbers to a decimal type before division."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 154,
    "subtopic_id": 4,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `FingerprintAnalyzer` calculates `fingerprintRemainder` from `totalPrints` and `labCapacity`. However, the code incorrectly uses multiplication instead of the modulo operator. Fix the code to calculate the correct remainder.",
      "code": "public class FingerprintAnalyzer {\n    public static void main(String[] args) {\n        int totalPrints = 22;\n        int labCapacity = 5;\n        int fingerprintRemainder = totalPrints % labCapacity; // Correct: Use modulo operator\n        System.out.println(\"Fingerprint Remainder: \" + fingerprintRemainder);\n    }\n}",
      "expected_output": [
        "Fingerprint Remainder: 2"
      ],
      "hidden_test_case": "",
      "explanation": "The original code used the multiplication operator (`*`) instead of the modulo operator (`%`). The modulo operator (`%`) is used to find the remainder of a division (`22 / 5` is `4` with a remainder of `2`). Replacing `*` with `%` correctly calculates `22 % 5 = 2`."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The goal is to find what's left over after one number is divided by another, not their product.",
      "2": "Which arithmetic operator gives you the remainder?",
      "3": "Look for the operation symbol between `totalPrints` and `labCapacity`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 155,
    "subtopic_id": 4,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "An `ExpenseReport` calculates `netExpenses` by combining `itemsPurchased` and `serviceFees`. However, the code incorrectly uses addition instead of subtraction. Fix the code to calculate the correct net expenses.",
      "code": "public class ExpenseReport {\n    public static void main(String[] args) {\n        double itemsPurchased = 500.0;\n        double serviceFees = 75.5;\n        double netExpenses = itemsPurchased - serviceFees; // Correct: Use subtraction\n        System.out.println(\"Net Expenses: $\" + netExpenses);\n    }\n}",
      "expected_output": [
        "Net Expenses: $424.5"
      ],
      "hidden_test_case": "",
      "explanation": "The original code used the addition operator (`+`) instead of the subtraction operator (`-`). To find the net expenses, the `serviceFees` need to be subtracted from `itemsPurchased`. Replacing `+` with `-` correctly calculates `500.0 - 75.5 = 424.5`."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The goal is to find the *net* expenses, which implies a reduction.",
      "2": "Which arithmetic operator calculates a difference?",
      "3": "Look for the operation symbol between `itemsPurchased` and `serviceFees`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 156,
    "subtopic_id": 4,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `ForensicCalculator` determines `evidenceScore` from `cluesFound`, `witnessStatements`, and `importanceFactor`. The code has an operator precedence issue, leading to an incorrect score. Fix the code to correctly calculate the `evidenceScore` by summing `cluesFound` and `witnessStatements` first.",
      "code": "public class ForensicCalculator {\n    public static void main(String[] args) {\n        int cluesFound = 10;\n        int witnessStatements = 2;\n        int importanceFactor = 5;\n        int evidenceScore = (cluesFound + witnessStatements) * importanceFactor; // Correct: Add parentheses for precedence\n        System.out.println(\"Evidence Score: \" + evidenceScore);\n    }\n}",
      "expected_output": [
        "Evidence Score: 60"
      ],
      "hidden_test_case": "",
      "explanation": "The original code `cluesFound + witnessStatements * importanceFactor` evaluates `witnessStatements * importanceFactor` first (`2 * 5 = 10`), then adds `cluesFound` (`10 + 10 = 20`). The intended order was to sum `cluesFound` and `witnessStatements` first. To override Java's default operator precedence and force the addition to occur first, parentheses `()` must be used around `cluesFound + witnessStatements`. This makes the calculation `(10 + 2) * 5 = 12 * 5 = 60`."
    },
    "difficulty": "medium",
    "hints": {
      "1": "In arithmetic operations, multiplication (`*`) and division (`/`) generally take precedence over addition (`+`) and subtraction (`-`).",
      "2": "If you want addition to happen first, you need a way to group those operations.",
      "3": "Think about how you'd explicitly define the order of calculations in mathematics."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 157,
    "subtopic_id": 4,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "An `InterrogationEvaluator` calculates `interrogationScore` by dividing `totalConfessions` by `suspectsQuestioned`. The code performs integer division, losing decimal precision. Fix the code to obtain a floating-point result for `interrogationScore`.",
      "code": "public class InterrogationEvaluator {\n    public static void main(String[] args) {\n        int totalConfessions = 7;\n        int suspectsQuestioned = 3;\n        double interrogationScore = (double) totalConfessions / suspectsQuestioned; // Correct: Cast to double for floating-point division\n        System.out.println(\"Interrogation Score: \" + interrogationScore);\n    }\n}",
      "expected_output": [
        "Interrogation Score: 2.3333333333333335"
      ],
      "hidden_test_case": "",
      "explanation": "The original code performs integer division (`7 / 3 = 2`) because both `totalConfessions` and `suspectsQuestioned` are `int`s. This loses the decimal precision. To get a floating-point result, at least one of the operands must be a `double` or `float`. Casting `totalConfessions` to `double` (`(double)totalConfessions`) before division forces the operation to be floating-point, and the result is stored in a `double` variable (`interrogationScore`), retaining its decimal value."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Division between two integers will result in a whole number, discarding any fractional part.",
      "2": "To obtain a decimal result from a division, at least one of the numbers involved must be a floating-point type (`double` or `float`).",
      "3": "Consider explicitly converting one of the integer variables to a `double` before performing the division."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 158,
    "subtopic_id": 4,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `CaseAssigner` updates `caseID` using a compound multiplication assignment. However, operator precedence causes the addition `2 + 1` to happen first, leading to an incorrect `caseID` value. Fix the code to ensure the multiplication `* 2` happens before the `+ 1`.",
      "code": "public class CaseAssigner {\n    public static void main(String[] args) {\n        int caseID = 10;\n        caseID = caseID * 2 + 1; // Correct: Explicitly write out the operations\n        System.out.println(\"Final Case ID: \" + caseID);\n    }\n}",
      "expected_output": [
        "Final Case ID: 21"
      ],
      "hidden_test_case": "",
      "explanation": "The original code `caseID *= 2 + 1;` is equivalent to `caseID = caseID * (2 + 1);`. This means `2 + 1` is evaluated first (`3`), and then `caseID` is multiplied by `3` (`10 * 3 = 30`). The intended calculation was `(caseID * 2) + 1`. The fix is to explicitly write out the arithmetic expression `caseID = caseID * 2 + 1;`, which correctly follows the precedence (multiplication first, then addition), resulting in `10 * 2 + 1 = 20 + 1 = 21`."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Compound assignment operators like `*=`, `/=`, `+=`, `-=` have specific rules about what happens on the right-hand side.",
      "2": "The expression `2 + 1` on the right-hand side of `*=` will be evaluated as `3` *before* multiplication.",
      "3": "To ensure the desired order of operations (`* 2` then `+ 1`), you might need to break down the compound assignment or use parentheses."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 159,
    "subtopic_id": 4,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `CoordinateLogger` calculates `averageCoord` from `xCoord` and `yCoord`. However, the current code performs integer division before casting to `double`, losing precision. Fix the code to ensure floating-point division for an accurate `averageCoord`.",
      "code": "public class CoordinateLogger {\n    public static void main(String[] args) {\n        int xCoord = 10;\n        int yCoord = 3;\n        double averageCoord = (double) xCoord / yCoord; // Correct: Cast to double before division\n        System.out.println(\"Average Coordinate: \" + averageCoord);\n    }\n}",
      "expected_output": [
        "Average Coordinate: 3.3333333333333335"
      ],
      "hidden_test_case": "",
      "explanation": "The original code `(double) (xCoord / yCoord)` first performs integer division `xCoord / yCoord` (`10 / 3 = 3`), truncating the decimal part. Only *then* is the integer result `3` cast to `double` (`3.0`), leading to a loss of precision. To ensure floating-point division, the cast to `double` must be applied to at least one of the operands *before* the division occurs. `(double) xCoord / yCoord` correctly promotes `xCoord` to `double` before division, making the entire division operation floating-point and retaining the decimals."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The `()` around `xCoord / yCoord` mean that division is completed *before* the cast to `double`.",
      "2": "If both operands in a division are integers, the result of that division is always an integer.",
      "3": "To ensure floating-point division, the cast to `double` needs to affect at least one operand *before* the division happens."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 160,
    "subtopic_id": 4,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `CrimeSceneChecker` determines if an `evidenceID` is even. The code incorrectly uses the division operator (`/`) instead of the modulo operator (`%`), leading to an inaccurate check. Fix the code to correctly identify if `evidenceID` is even.",
      "code": "public class CrimeSceneChecker {\n    public static void main(String[] args) {\n        int evidenceID = 14;\n        if (evidenceID % 2 == 0) { // Correct: Use modulo operator\n            System.out.println(\"Evidence ID is even.\");\n        } else {\n            System.out.println(\"Evidence ID is odd.\");\n        }\n    }\n}",
      "expected_output": [
        "Evidence ID is even."
      ],
      "hidden_test_case": "",
      "explanation": "The original code uses the division operator (`/`) to try and determine if `evidenceID` is even. `evidenceID / 2` calculates `14 / 2 = 7`. `7 == 0` is `false`, so it would incorrectly print \"Evidence ID is odd.\" The correct operator for finding the remainder of a division is the modulo operator (`%`). `14 % 2` correctly evaluates to `0`, so `0 == 0` is `true`, and it prints \"Evidence ID is even.\""
    },
    "difficulty": "medium",
    "hints": {
      "1": "The standard division operator (`/`) performs division, not remainder calculation.",
      "2": "An even number has a remainder of `0` when divided by `2`.",
      "3": "Which specific arithmetic operator is designed to return the remainder of a division?"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 161,
    "subtopic_id": 4,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `CaseFileGenerator` calculates a `caseFileNumber` from `incidentCount` and `districtID`. The sum of these `int` values exceeds the `int`'s maximum capacity, causing an integer overflow. Fix the code to correctly store this large `caseFileNumber`.",
      "code": "public class CaseFileGenerator {\n    public static void main(String[] args) {\n        int incidentCount = 2000000000;\n        int districtID = 500000000;\n        long caseFileNumber = (long)incidentCount + districtID; // Correct: Cast one operand to long\n        System.out.println(\"Case File Number: \" + caseFileNumber);\n    }\n}",
      "expected_output": [
        "Case File Number: 2500000000"
      ],
      "hidden_test_case": "",
      "explanation": "The sum of `incidentCount` (`2,000,000,000`) and `districtID` (`500,000,000`) is `2,500,000,000`. This value exceeds the maximum capacity of an `int` (which is `2,147,483,647`). When this sum is assigned to an `int` variable, it causes an **integer overflow**, resulting in an incorrect negative value. To correctly store such a large number, the `long` data type (which can hold values up to approximately 9.2 x 10^18) must be used for both the literals (by adding `L` suffix) and the `caseFileNumber` variable."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Recall the maximum positive value an `int` can store (approximately 2.1 billion).",
      "2": "Adding two large `int`s can result in a sum that exceeds this limit, causing an \"overflow\" where the number wraps around to a negative value.",
      "3": "Consider the primitive integer type that has a much larger capacity for whole numbers."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 162,
    "subtopic_id": 4,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `BallisticsCalculator` calculates `projectileImpactPoint` using `float` variables. Due to the limited precision of `float`, the final calculation is inaccurate. Fix the code to ensure maximum precision for `projectileImpactPoint`.",
      "code": "public class BallisticsCalculator {\n    public static void main(String[] args) {\n        double launchAngle = 45.0;\n        double gravityEffect = 9.8;\n        double windCorrection = 0.000123;\n        \n        double projectileImpactPoint = launchAngle / gravityEffect - windCorrection; // Correct: Use double for all variables and result\n        System.out.println(\"Projectile Impact Point: \" + projectileImpactPoint);\n    }\n}",
      "expected_output": [
        "Projectile Impact Point: 4.588049693877551"
      ],
      "hidden_test_case": "",
      "explanation": "The `float` data type offers less precision (32-bit) compared to `double` (64-bit). In calculations involving multiple floating-point operations, using `float` can lead to cumulative precision loss, resulting in an inaccurate final value. To ensure maximum precision for `projectileImpactPoint`, all variables and literals involved in its calculation should be of the `double` type. This forces all intermediate calculations to use double precision, preserving accuracy."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The `float` data type provides single precision, which can lead to inaccuracies in complex or sensitive calculations.",
      "2": "The `double` data type offers double precision, providing much higher accuracy for decimal numbers.",
      "3": "To ensure full precision, all floating-point literals and variables involved in the calculation should be of the higher precision type."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 163,
    "subtopic_id": 4,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "An `AlibiTimer` calculates `criticalTimeOffset` using division that results in a decimal, but the code performs integer division before multiplication, losing precision. Fix the code to ensure floating-point precision in the division.",
      "code": "public class AlibiTimer {\n    public static void main(String[] args) {\n        int crimeHour = 10;\n        int alibiWindow = 3;\n        double offsetMultiplier = 0.75;\n        \n        double criticalTimeOffset = ((double) alibiWindow / 2) * offsetMultiplier; // Correct: Cast to double before division\n        System.out.println(\"Critical Time Offset: \" + criticalTimeOffset);\n    }\n}",
      "expected_output": [
        "Critical Time Offset: 1.125"
      ],
      "hidden_test_case": "",
      "explanation": "The original code `(alibiWindow / 2)` performs integer division (`3 / 2 = 1`), truncating the decimal part. This integer result `1` is then multiplied by `offsetMultiplier` (`1 * 0.75 = 0.75`), leading to an incorrect final value. To ensure floating-point precision in the division, one of the operands in `alibiWindow / 2` must be explicitly cast to `double` (e.g., `(double)alibiWindow`). This forces floating-point division (`3.0 / 2 = 1.5`), and the subsequent multiplication maintains that precision."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The expression `alibiWindow / 2` will perform integer division because both `alibiWindow` and `2` are integers.",
      "2": "This integer division (e.g., `3 / 2 = 1`) happens *before* the result is multiplied by `offsetMultiplier`.",
      "3": "To get a floating-point result for the division, at least one operand must be a floating-point type *before* the division occurs."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 164,
    "subtopic_id": 4,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "An `InterrogationFeedback` system calculates `feedbackRemainder` using the modulo operator on a negative `feedbackCode`. In Java, the result of modulo with a negative dividend is negative, leading to an unexpected remainder. Fix the code to always yield a non-negative remainder.",
      "code": "public class InterrogationFeedback {\n    public static void main(String[] args) {\n        int feedbackCode = -7;\n        int divisor = 3;\n        int feedbackRemainder = (feedbackCode % divisor + divisor) % divisor; // Correct: Adjust for non-negative remainder\n        System.out.println(\"Feedback Remainder: \" + feedbackRemainder);\n    }\n}",
      "expected_output": [
        "Feedback Remainder: 2"
      ],
      "hidden_test_case": "",
      "explanation": "In Java, the result of the modulo operator (`%`) takes the sign of the dividend (the left operand). So, `-7 % 3` evaluates to `-1` (because `-7 = -3 * 2 - 1`). If the goal is to always have a non-negative remainder (as in standard mathematical modular arithmetic), an adjustment is needed for negative results. The common fix is `(feedbackCode % divisor + divisor) % divisor`. This ensures that even if `feedbackCode % divisor` is negative, adding `divisor` makes it positive before the final modulo operation, resulting in a non-negative remainder (e.g., `(-1 + 3) % 3 = 2 % 3 = 2`)."
    },
    "difficulty": "hard",
    "hints": {
      "1": "In Java, the sign of the result of the modulo operator (`%`) is the same as the sign of the *dividend* (the left-hand operand).",
      "2": "For a negative `feedbackCode` like `-7`, `-7 % 3` will be `-1`.",
      "3": "If you need a strictly non-negative remainder (like in true mathematical modulo), an extra step is required for negative results."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 165,
    "subtopic_id": 4,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `ProgressTracker` updates `caseProgress` using a compound multiplication assignment. However, operator precedence causes the addition `5 + 1` to occur before the multiplication with `caseProgress`, leading to an incorrect final value. Fix the code to ensure `caseProgress` is multiplied by `2` and then `1` is added.",
      "code": "public class ProgressTracker {\n    public static void main(String[] args) {\n        int caseProgress = 10;\n        caseProgress = caseProgress * 2 + 1; // Correct: Explicitly write out the operations\n        System.out.println(\"Final Case Progress: \" + caseProgress);\n    }\n}",
      "expected_output": [
        "Final Case Progress: 51"
      ],
      "hidden_test_case": "",
      "explanation": "The original code `caseProgress *= 5 + 1;` is equivalent to `caseProgress = caseProgress * (5 + 1);`. This means `5 + 1` is evaluated first (resulting in `6`), and then `caseProgress` is multiplied by `3` (`10 * 3 = 30`). The intended calculation was `(caseProgress * 2) + 1`. The fix is to explicitly write out the arithmetic expression `caseProgress = caseProgress * 2 + 1;`, which correctly follows the precedence (multiplication first, then addition), resulting in `10 * 2 + 1 = 20 + 1 = 21`."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Compound assignment operators like `*= X + Y` are shorthand for `variable = variable * (X + Y)`.",
      "2": "The entire expression on the right side of the compound operator is evaluated *first*, based on its own precedence rules.",
      "3": "To ensure the desired order of operations (`* 2` then `+ 1`), you might need to break down the compound assignment or use parentheses."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 166,
    "subtopic_id": 4,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `LeadAggregator` combines `informantA` and `informantB` leads to get `activeLeads`. Complete the arithmetic operator to correctly sum these leads.",
      "code": "public class LeadAggregator {\n    public static void main(String[] args) {\n        int informantA = 7;\n        int informantB = 5;\n        int activeLeads = informantA ??? informantB;\n        System.out.println(\"Active Leads: \" + activeLeads);\n    }\n}",
      "choices": [
        "+",
        "-",
        "*",
        "/"
      ],
      "answer": [
        "+"
      ],
      "explanation": "To find the total sum of `informantA` and `informantB`, the addition operator `+` is required. `7 + 5` correctly calculates `12`."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The goal is to `total` the leads.",
      "2": "Which arithmetic operator performs addition?",
      "3": "The blank needs a single operation symbol."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 167,
    "subtopic_id": 4,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `CaseTracker` determines `openCases` by subtracting `closedCases` from `totalCases`. Complete the arithmetic operator to correctly find the number of `openCases`.",
      "code": "public class CaseTracker {\n    public static void main(String[] args) {\n        int totalCases = 20;\n        int closedCases = 8;\n        int openCases = totalCases ??? closedCases;\n        System.out.println(\"Open Cases: \" + openCases);\n    }\n}",
      "choices": [
        "+",
        "-",
        "*",
        "/"
      ],
      "answer": [
        "-"
      ],
      "explanation": "To find the number of `openCases`, the `closedCases` need to be subtracted from `totalCases`. The subtraction operator `-` is used for this purpose. `20 - 8` correctly calculates `12`."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The goal is to find the number of cases that are still `open`.",
      "2": "Which arithmetic operator performs subtraction?",
      "3": "The blank needs a single operation symbol."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 168,
    "subtopic_id": 4,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `ProfileMultiplier` estimates `totalProfiles` by multiplying `suspectProfiles` by a `duplicateFactor`. Complete the arithmetic operator to correctly scale the profiles.",
      "code": "public class ProfileMultiplier {\n    public static void main(String[] args) {\n        int suspectProfiles = 6;\n        int duplicateFactor = 3;\n        int totalProfiles = suspectProfiles ??? duplicateFactor;\n        System.out.println(\"Total Profiles: \" + totalProfiles);\n    }\n}",
      "choices": [
        "+",
        "-",
        "*",
        "/"
      ],
      "answer": [
        "*"
      ],
      "explanation": "To find the `totalProfiles` by accounting for duplicates, `suspectProfiles` and `duplicateFactor` need to be multiplied. The multiplication operator `*` is used for this purpose. `6 * 3` correctly calculates `18`."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The goal is to find the `total` number of profiles when accounting for duplicates.",
      "2": "Which arithmetic operator performs multiplication?",
      "3": "The blank needs a single operation symbol."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 169,
    "subtopic_id": 4,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `ResourceAllocator` distributes `sharedResources` among `teamMembers`. Complete the arithmetic operator to correctly calculate `resourcesPerMember`.",
      "code": "public class ResourceAllocator {\n    public static void main(String[] args) {\n        int sharedResources = 25;\n        int teamMembers = 5;\n        int resourcesPerMember = sharedResources ??? teamMembers;\n        System.out.println(\"Resources Per Member: \" + resourcesPerMember);\n    }\n}",
      "choices": [
        "+",
        "-",
        "*",
        "/"
      ],
      "answer": [
        "/"
      ],
      "explanation": "To find `resourcesPerMember`, `sharedResources` need to be divided by `teamMembers`. The division operator `/` is used for this purpose. `25 / 5` correctly calculates `5`."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The goal is to distribute resources `per member`.",
      "2": "Which arithmetic operator performs division?",
      "3": "The blank needs a single operation symbol."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 170,
    "subtopic_id": 4,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `TaggingSystem` calculates `remainingTags` after `evidenceCount` is divided into sheets, each holding `tagsPerSheet`. Complete the arithmetic operator to correctly find the remainder.",
      "code": "public class TaggingSystem {\n    public static void main(String[] args) {\n        int evidenceCount = 17;\n        int tagsPerSheet = 5;\n        int remainingTags = evidenceCount ??? tagsPerSheet;\n        System.out.println(\"Remaining Tags: \" + remainingTags);\n    }\n}",
      "choices": [
        "+",
        "-",
        "*",
        "%"
      ],
      "answer": [
        "%"
      ],
      "explanation": "To find the `remainingTags` after dividing `evidenceCount` by `tagsPerSheet`, the modulo operator `%` is used. `17 % 5` correctly calculates `2` (17 divided by 5 is 3 with a remainder of 2)."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The goal is to find what's \"left over\" or the `remainder` after division.",
      "2": "Which arithmetic operator specifically gives you the remainder?",
      "3": "The blank needs a single operation symbol."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 171,
    "subtopic_id": 4,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "An `ActivityProfiler` calculates an `activityScore` by multiplying `incidents` by `days`, then adding a `bonus`. Complete the arithmetic operators to correctly calculate the `activityScore`.",
      "code": "public class ActivityProfiler {\n    public static void main(String[] args) {\n        int incidents = 5;\n        int days = 10;\n        int bonus = 20;\n        int activityScore = incidents ??? days ??? bonus;\n        System.out.println(\"Activity Score: \" + activityScore);\n    }\n}",
      "choices": [
        "*",
        "+",
        "/",
        "( )",
        "-",
        "%"
      ],
      "answer": [
        "*",
        "+"
      ],
      "explanation": "To calculate `activityScore`, `incidents` should be multiplied by `days`, and then `bonus` should be added. The multiplication operator `*` (choice a) performs the multiplication, and the addition operator `+` (choice b) performs the addition. Since multiplication has higher precedence than addition, parentheses are not strictly needed here to achieve `(incidents * days) + bonus`. `5 * 10 + 20` calculates `50 + 20 = 70`."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The calculation involves both multiplication and addition.",
      "2": "Recall the default order of operations (precedence) for arithmetic operators.",
      "3": "Consider how numbers and operators combine to form a score."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 172,
    "subtopic_id": 4,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `CrimeRateCalculator` determines `averageCrimeRate` by dividing `totalCrimes` by `reportingPeriods`. Complete the type cast and the arithmetic operator to ensure a floating-point result for the average.",
      "code": "public class CrimeRateCalculator {\n    public static void main(String[] args) {\n        int totalCrimes = 17;\n        int reportingPeriods = 5;\n        double averageCrimeRate = (??? totalCrimes) ??? reportingPeriods;\n        System.out.println(\"Average Crime Rate: \" + averageCrimeRate);\n    }\n}",
      "choices": [
        "int",
        "double",
        "/",
        "*",
        "+",
        "%"
      ],
      "answer": [
        "double",
        "/"
      ],
      "explanation": "To ensure floating-point division and retain decimal precision, `totalCrimes` must be explicitly cast to `double` using `(double)` (choice b) before the division. The division operator `/` (choice c) is used to perform the division. This results in `(double)17 / 5` calculating `3.4`."
    },
    "difficulty": "medium",
    "hints": {
      "1": "To get a decimal result from division involving integers, at least one operand must be converted to a floating-point type.",
      "2": "The blank before `totalCrimes` needs a type conversion operator.",
      "3": "The blank after `totalCrimes` needs the division operator."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 173,
    "subtopic_id": 4,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `BudgetTracker` adjusts `caseBudget` by subtracting `investigationCosts` and adding `reimbursement`. Complete the compound assignment operators to reflect these changes efficiently.",
      "code": "public class BudgetTracker {\n    public static void main(String[] args) {\n        int caseBudget = 500;\n        int investigationCosts = 150;\n        int reimbursement = 75;\n\n        caseBudget ??? investigationCosts;\n        caseBudget ??? reimbursement;\n        System.out.println(\"Remaining Budget: $\" + caseBudget);\n    }\n}",
      "choices": [
        "+",
        "-",
        "*",
        "+=",
        "-=",
        "/="
      ],
      "answer": [
        "-=",
        "+="
      ],
      "explanation": "To subtract `investigationCosts` from `caseBudget` and reassign the result, the compound subtraction assignment operator `-=` (choice e) is used. To add `reimbursement` to `caseBudget` and reassign the result, the compound addition assignment operator `+=` (choice d) is used."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The `investigationCosts` are `subtracted` from the budget. Which compound operator performs subtraction and assignment?",
      "2": "The `reimbursement` is `added` to the budget. Which compound operator performs addition and assignment?",
      "3": "Each blank requires a compound assignment operator."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 174,
    "subtopic_id": 4,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `CipherAnalyzer` determines a `patternRemainder` by finding the remainder of `cipherSequence` divided by `segmentSize`. Complete the arithmetic operator to correctly calculate the remainder.",
      "code": "public class CipherAnalyzer {\n    public static void main(String[] args) {\n        int cipherSequence = 47;\n        int segmentSize = 10;\n        int patternRemainder = cipherSequence ??? segmentSize;\n        System.out.println(\"Pattern Remainder: \" + patternRemainder);\n    }\n}",
      "choices": [
        "+",
        "-",
        "*",
        "/",
        "%",
        "=="
      ],
      "answer": [
        "%"
      ],
      "explanation": "To find the `patternRemainder` when `cipherSequence` is divided by `segmentSize`, the modulo operator `%` is used. `47 % 10` calculates `7` (47 divided by 10 is 4 with a remainder of 7)."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The goal is to find the `remainder` of a division.",
      "2": "Which arithmetic operator specifically returns the remainder?",
      "3": "The blank requires a single operation symbol."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 175,
    "subtopic_id": 4,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `ProfileCombiner` calculates `totalProfiles` by summing `knownProfiles` and `newProfiles`, then multiplying by `securityMultiplier`. Complete the arithmetic operators to correctly combine these values.",
      "code": "public class ProfileCombiner {\n    public static void main(String[] args) {\n        int knownProfiles = 12;\n        int newProfiles = 3;\n        int securityMultiplier = 2;\n        int totalProfiles = (knownProfiles ??? newProfiles) ??? securityMultiplier;\n        System.out.println(\"Total Profiles: \" + totalProfiles);\n    }\n}",
      "choices": [
        "+",
        "-",
        "*",
        "/",
        "( )",
        "%="
      ],
      "answer": [
        "+",
        "*"
      ],
      "explanation": "To calculate `totalProfiles`, `knownProfiles` and `newProfiles` are first added using the `+` operator (choice a), and then their sum is multiplied by `securityMultiplier` using the `*` operator (choice c). The parentheses correctly enforce the order of operations. `(12 + 3) * 2` calculates `15 * 2 = 30`."
    },
    "difficulty": "medium",
    "hints": {
      "1": "First, `knownProfiles` and `newProfiles` should be summed.",
      "2": "Then, that sum should be multiplied by `securityMultiplier`.",
      "3": "Consider the operators needed for addition and multiplication."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 176,
    "subtopic_id": 4,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `SafeCracker` processes `cipherPart1`, `cipherPart2`, and a `modifier` to determine a `combinationValueRemainder` and a `finalCalc`. Complete the declarations and operators for these complex arithmetic operations.",
      "code": "public class SafeCracker {\n    public static void main(String[] args) {\n        int cipherPart1 = 10;\n        int cipherPart2 = 5;\n        int modifier = 3;\n        \n        ??? combinationValueRemainder;\n        \n        int intermediateResult = (cipherPart1 + cipherPart2) ??? 2;\n        \n        combinationValueRemainder = intermediateResult ??? modifier;\n        \n        int finalCalc = (intermediateResult + modifier) ??? (cipherPart1 - cipherPart2);\n        \n        System.out.println(\"Combination Value Remainder: \" + combinationValueRemainder);\n        System.out.println(\"Final Calculation: \" + finalCalc);\n    }\n}",
      "choices": [
        "int combinationValueRemainder",
        "/",
        "%",
        "*",
        "+",
        "-",
        "long combinationValueRemainder",
        "value"
      ],
      "answer": [
        "int combinationValueRemainder",
        "/",
        "%",
        "*"
      ],
      "explanation": "1. `int combinationValueRemainder` (choice a) declares the integer variable for the remainder.\n2. The blank after `(cipherPart1 + cipherPart2)` needs the division operator `/` (choice b) to divide the sum by 2.\n3. The blank for the `combinationValueRemainder` assignment needs the modulo operator `%` (choice c) to find the remainder of `intermediateResult` divided by `modifier`.\n4. The blank for `finalCalc` needs the multiplication operator `*` (choice d) to multiply the sum of `intermediateResult` and `modifier` by the difference of `cipherPart1` and `cipherPart2`."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The first blank declares the result variable for a remainder.",
      "2": "The expression involves dividing a sum by `2` and then performing a modulo operation with `modifier`.",
      "3": "The last blank involves a multiplication (`*`) to get the `finalCalc`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 177,
    "subtopic_id": 4,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "An `AuditReport` calculates `netBalance` and updates `totalRevenue` based on `feesIncurred` and `periods`. An `auditCode` is also determined. Complete the declarations and various arithmetic and compound assignment operators.",
      "code": "public class AuditReport {\n    public static void main(String[] args) {\n        long totalRevenue = 1000000000L;\n        int feesIncurred = 50000000;\n        int periods = 5;\n        \n        ??? netBalance = totalRevenue ??? feesIncurred;\n        \n        totalRevenue ???= feesIncurred / periods;\n        \n        int auditCode = (int) (netBalance ??? feesIncurred);\n        \n        auditCode ???= 200;\n        \n        System.out.println(\"Final Net Balance: \" + netBalance);\n        System.out.println(\"Total Revenue After Adjust: \" + totalRevenue);\n        System.out.println(\"Final Audit Code: \" + auditCode);\n    }\n}",
      "choices": [
        "long",
        "double",
        "-",
        "+",
        "/=",
        "%=",
        "*",
        "+="
      ],
      "answer": [
        "long",
        "-",
        "/=",
        "*",
        "+="
      ],
      "explanation": "1. `long` (choice a) is the correct type for `netBalance` to hold large values. `-` (choice c) is used for subtraction.\n2. `/=` (choice e) is the compound division assignment operator.\n3. `*` (choice g) is the multiplication operator for `auditCode` calculation.\n4. `+=` (choice h) is the compound addition assignment operator."
    },
    "difficulty": "hard",
    "hints": {
      "1": "`netBalance` needs to store a large integer value, found by subtracting `feesIncurred` from `totalRevenue`.",
      "2": "`totalRevenue` is being adjusted by a division of `feesIncurred` by `periods`. Which compound assignment performs division and assignment?",
      "3": "The `auditCode` calculation needs an operator that performs multiplication."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 178,
    "subtopic_id": 4,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `FieldAgentLog` tracks `timeOnTarget` and `distanceCovered`. `timeOnTarget` is calculated with division and multiplication, and `distanceCovered` is adjusted using compound assignments. Complete the declarations and operators for these calculations.",
      "code": "public class FieldAgentLog {\n    public static void main(String[] args) {\n        int initialTime = 10;\n        int observationPeriods = 3;\n        float accuracyFactor = 0.5f;\n        \n        ??? timeOnTarget = ( (float)initialTime / observationPeriods) ??? accuracyFactor;\n        \n        int distanceCovered = 500;\n        \n        distanceCovered ???= 100;\n        distanceCovered ???= 2;\n        \n        System.out.println(\"Time On Target: \" + timeOnTarget);\n        System.out.println(\"Distance Covered: \" + distanceCovered);\n    }\n}",
      "choices": [
        "float",
        "double",
        "*",
        "/",
        "+=",
        "-=",
        "/=",
        "*="
      ],
      "answer": [
        "float",
        "*",
        "-=",
        "/="
      ],
      "explanation": "1. `float` (choice a) is the correct type for `timeOnTarget` since it's derived from `(float)initialTime / observationPeriods` which promotes to `float`, and then multiplied by a `float`.\n2. `*` (choice c) is the multiplication operator for `timeOnTarget` calculation.\n3. `-=` (choice f) is the compound subtraction assignment operator for `distanceCovered`.\n4. `/=` (choice g) is the compound division assignment operator for `distanceCovered`."
    },
    "difficulty": "hard",
    "hints": {
      "1": " `timeOnTarget` needs to be a floating-point type, and the result of the division is multiplied by `accuracyFactor`.",
      "2": "The first blank needs the type for `timeOnTarget`.",
      "3": " `distanceCovered` is first reduced by `100`, then divided by `2` using compound assignments."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 179,
    "subtopic_id": 4,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `SecurityProtocol` calculates `protocolCode` and `alertLevel` from base values, modifiers, and modulo operations, involving compound assignments. Complete the declaration and various arithmetic and compound assignment operators.",
      "code": "public class SecurityProtocol {\n    public static void main(String[] args) {\n        int baseCode = 2100000000;\n        int modifier = 100000000;\n        int moduloValue = 7;\n        \n        ??? protocolCode = (int) ( (long)baseCode ??? modifier );\n        \n        int alertLevel = protocolCode % moduloValue;\n        \n        alertLevel ???= 10;\n        alertLevel = (alertLevel ??? 5) % 3;\n        \n        System.out.println(\"Protocol Code: \" + protocolCode);\n        System.out.println(\"Alert Level: \" + alertLevel);\n    }\n}",
      "choices": [
        "long",
        "+",
        "*",
        "-",
        "+=",
        "/",
        "%",
        "protocol"
      ],
      "answer": [
        "+",
        "+=",
        "-",
        "%"
      ],
      "explanation": "1. The blank for `protocolCode` calculation needs the addition operator `+` (choice b) to sum `baseCode` and `modifier`.\n2. The blank for `alertLevel += 10;` needs the compound addition assignment operator `+=` (choice e).\n3. The blank in `(alertLevel ??? 5)` needs the subtraction operator `-` (choice d) to subtract 5.\n4. The final blank in `(alertLevel - 5) ??? 3` needs the modulo operator `%` (choice g) to find the remainder."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The `protocolCode` calculation needs an operator to sum `baseCode` and `modifier`.",
      "2": "The `alertLevel` is first increased by `10` using a compound assignment.",
      "3": "Then, `alertLevel` is further adjusted by subtracting `5` and finding the remainder when divided by `3`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 180,
    "subtopic_id": 4,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `ForensicReport` calculates `evidenceWeight`, `sampleCount`, and `reportID` using a mix of primitive types, operators, and compound assignments, involving potential overflow for `reportID`. Complete the declarations and various arithmetic and compound assignment operators.",
      "code": "public class ForensicReport {\n    public static void main(String[] args) {\n        double initialWeight = 50.0;\n        float density = 0.75f;\n        int analysisRuns = 10;\n        \n        ??? evidenceWeight = (float) (initialWeight ??? density);\n        \n        int sampleCount = 20;\n        sampleCount ???= analysisRuns;\n        \n        byte reportID = 120;\n        reportID ???= analysisRuns;\n        \n        reportID = (byte) (reportID ??? 2);\n        \n        System.out.println(\"Evidence Weight: \" + evidenceWeight);\n        System.out.println(\"Sample Count: \" + sampleCount);\n        System.out.println(\"Report ID: \" + reportID);\n    }\n}",
      "choices": [
        "float",
        "*",
        "/=",
        "+=",
        "%=",
        "+",
        "-",
        "report"
      ],
      "answer": [
        "float",
        "*",
        "/=",
        "+=",
        "%="
      ],
      "explanation": "1. The blank for `evidenceWeight` needs the multiplication operator `*` (choice b) to calculate `initialWeight * density`.\n2. The blank for `sampleCount` needs the compound division assignment operator `/=` (choice c) to divide `sampleCount` by `analysisRuns`.\n3. The first blank for `reportID` needs the compound addition assignment operator `+=` (choice d) to add `analysisRuns` to `reportID`. This will cause an overflow (`120 + 10 = 130` -> `-126`).\n4. The final blank for `reportID` needs the modulo operator `%` (choice e) to find the remainder of `reportID` divided by `2`."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The `evidenceWeight` is calculated by multiplying `initialWeight` and `density`.",
      "2": "`sampleCount` is updated by dividing by `analysisRuns` using a compound assignment.",
      "3": "`reportID` is first increased by `analysisRuns` using a compound assignment, and then a modulo operation is performed on it."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 181,
    "subtopic_id": 5,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `CaseFileOpener` initializes a `caseID`. Your task is to trace the code and determine the `New Case ID` that is printed.",
      "code": "public class CaseFileOpener {\n    public static void main(String[] args) {\n        int caseID = 101;\n        System.out.println(\"New Case ID: \" + caseID);\n    }\n}",
      "choices": [
        "New Case ID: 0",
        "New Case ID: 101",
        "caseID",
        "Error"
      ],
      "answer": [
        "New Case ID: 101"
      ],
      "explanation": "The line `int caseID = 101;` uses the simple assignment operator `=` to give the `caseID` variable an initial value of `101`. The `System.out.println()` then prints this value."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The `=` operator assigns the value on the right to the variable on the left.",
      "2": "The `caseID` variable is directly initialized with a value.",
      "3": "The `println` statement displays the current value of the variable."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 182,
    "subtopic_id": 5,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `LeadTracker` system updates `leadsCount` by adding a value using a compound assignment. Your task is to trace the code and determine the final `Current Leads` count.",
      "code": "public class LeadTracker {\n    public static void main(String[] args) {\n        int leadsCount = 5;\n        leadsCount += 3;\n        System.out.println(\"Current Leads: \" + leadsCount);\n    }\n}",
      "choices": [
        "Current Leads: 5",
        "Current Leads: 3",
        "Current Leads: 8",
        "Error"
      ],
      "answer": [
        "Current Leads: 8"
      ],
      "explanation": "The `leadsCount` variable starts at `5`. The line `leadsCount += 3;` is equivalent to `leadsCount = leadsCount + 3;`, which calculates `5 + 3 = 8`. This new value is assigned back to `leadsCount`. Finally, `System.out.println()` prints \"Current Leads: 8\"."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The `+=` operator is a shorthand for adding a value to a variable and then assigning the result back to that variable.",
      "2": "Perform the addition: `leadsCount` + 3.",
      "3": "The `println` statement displays the final value."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 183,
    "subtopic_id": 5,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `BudgetMonitor` tracks `investigationBudget`. Travel expenses are deducted using a compound assignment. Your task is to trace the code and determine the `Remaining Budget`.",
      "code": "public class BudgetMonitor {\n    public static void main(String[] args) {\n        double investigationBudget = 500.0;\n        double travelExpense = 75.5;\n        investigationBudget -= travelExpense;\n        System.out.println(\"Remaining Budget: $\" + investigationBudget);\n    }\n}",
      "choices": [
        "Remaining Budget: $500.0",
        "Remaining Budget: $75.5",
        "Remaining Budget: $424.5",
        "Error"
      ],
      "answer": [
        "Remaining Budget: $424.5"
      ],
      "explanation": "The `investigationBudget` starts at `500.0`. The line `investigationBudget -= travelExpense;` is equivalent to `investigationBudget = investigationBudget - travelExpense;`, which calculates `500.0 - 75.5 = 424.5`. This new value is assigned back to `investigationBudget`. Finally, `System.out.println()` prints \"Remaining Budget: $424.5\"."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The `-=` operator is a shorthand for subtracting a value from a variable and then assigning the result back to that variable.",
      "2": "Perform the subtraction: `investigationBudget` - `travelExpense`.",
      "3": "The `println` statement displays the final value."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 184,
    "subtopic_id": 5,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `PopulationEstimator` scales `suspectPopulation` using a compound multiplication assignment. Your task is to trace the code and determine the `Estimated Suspect Population`.",
      "code": "public class PopulationEstimator {\n    public static void main(String[] args) {\n        int suspectPopulation = 10;\n        suspectPopulation *= 2;\n        System.out.println(\"Estimated Suspect Population: \" + suspectPopulation);\n    }\n}",
      "choices": [
        "Estimated Suspect Population: 10",
        "Estimated Suspect Population: 2",
        "Estimated Suspect Population: 20",
        "Error"
      ],
      "answer": [
        "Estimated Suspect Population: 20"
      ],
      "explanation": "The `suspectPopulation` variable starts at `10`. The line `suspectPopulation *= 2;` is equivalent to `suspectPopulation = suspectPopulation * 2;`, which calculates `10 * 2 = 20`. This new value is assigned back to `suspectPopulation`. Finally, `System.out.println()` prints \"Estimated Suspect Population: 20\"."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The `*=` operator is a shorthand for multiplying a variable by a value and then assigning the result back.",
      "2": "Perform the multiplication: `suspectPopulation` * 2.",
      "3": "The `println` statement displays the final value."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 185,
    "subtopic_id": 5,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `PhotoAllocator` distributes `evidencePhotos` among `analysts` using a compound division assignment. Your task is to trace the code and determine the `Photos Per Analyst`.",
      "code": "public class PhotoAllocator {\n    public static void main(String[] args) {\n        int evidencePhotos = 15;\n        int analysts = 3;\n        evidencePhotos /= analysts;\n        System.out.println(\"Photos Per Analyst: \" + evidencePhotos);\n    }\n}",
      "choices": [
        "Photos Per Analyst: 15",
        "Photos Per Analyst: 3",
        "Photos Per Analyst: 5",
        "Error"
      ],
      "answer": [
        "Photos Per Analyst: 5"
      ],
      "explanation": "The `evidencePhotos` variable starts at `15`. The line `evidencePhotos /= analysts;` is equivalent to `evidencePhotos = evidencePhotos / analysts;`, which calculates `15 / 3 = 5`. This new value is assigned back to `evidencePhotos`. Finally, `System.out.println()` prints \"Photos Per Analyst: 5\"."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The `/=` operator is a shorthand for dividing a variable by a value and then assigning the result back.",
      "2": "Perform the division: `evidencePhotos` / `analysts`.",
      "3": "The `println` statement displays the final value."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 186,
    "subtopic_id": 5,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `BudgetAuditor` tracks `caseBudget` and `totalExpenses`. Funds are adjusted by `cost` and `reimbursement`, and expenses are tallied using compound assignments. Your task is to trace the code and determine the final `Budget` and `Total Expenses`.",
      "code": "public class BudgetAuditor {\n    public static void main(String[] args) {\n        double caseBudget = 1000.0;\n        double cost = 150.0;\n        double reimbursement = 75.0;\n        double totalExpenses = 0.0;\n\n        caseBudget -= cost;\n        totalExpenses += cost;\n        caseBudget += reimbursement;\n        \n        System.out.println(\"Final Budget: $\" + caseBudget);\n        System.out.println(\"Total Expenses: $\" + totalExpenses);\n    }\n}",
      "choices": [
        "Final Budget: $850.0",
        "Final Budget: $925.0",
        "Total Expenses: $75.0",
        "Total Expenses: $150.0"
      ],
      "answer": [
        "Final Budget: $925.0",
        "Total Expenses: $150.0"
      ],
      "explanation": "1. `caseBudget` starts at `1000.0`, `totalExpenses` at `0.0`.\n2. `caseBudget -= cost;` updates `caseBudget` to `1000.0 - 150.0 = 850.0`.\n3. `totalExpenses += cost;` updates `totalExpenses` to `0.0 + 150.0 = 150.0`.\n4. `caseBudget += reimbursement;` updates `caseBudget` to `850.0 + 75.0 = 925.0`.\n5. The first `System.out.println()` prints \"Final Budget: $925.0\".\n6. The second `System.out.println()` prints \"Total Expenses: $150.0\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Trace `caseBudget` and `totalExpenses` independently through each assignment line.",
      "2": " `x -= y` means `x = x - y`.",
      "3": " `x += y` means `x = x + y`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 187,
    "subtopic_id": 5,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `CrimeSeverityProfiler` calculates `crimeSeverityIndex` and `investigatorBonus` using compound assignments and arithmetic operations. Your task is to trace the code and determine the `Final Crime Severity Index` and `Investigator Bonus`.",
      "code": "public class CrimeSeverityProfiler {\n    public static void main(String[] args) {\n        int criminalHistory = 7;\n        double baseSeverity = 1.5;\n        double investigatorBonus = 100.0;\n\n        baseSeverity *= criminalHistory;\n        double crimeSeverityIndex = baseSeverity;\n\n        investigatorBonus /= (criminalHistory % 3 + 1);\n        \n        System.out.println(\"Final Crime Severity Index: \" + crimeSeverityIndex);\n        System.out.println(\"Investigator Bonus: $\" + investigatorBonus);\n    }\n}",
      "choices": [
        "Final Crime Severity Index: 10",
        "Final Crime Severity Index: 10.5",
        "Investigator Bonus: $33.333333333333336",
        "Investigator Bonus: $50.0"
      ],
      "answer": [
        "Final Crime Severity Index: 10.5",
        "Investigator Bonus: $50.0"
      ],
      "explanation": "1. `criminalHistory` is `7`, `baseSeverity` is `1.5`, `investigatorBonus` is `100.0`.\n2. `baseSeverity *= criminalHistory;` updates `baseSeverity` to `1.5 * 7 = 10.5`.\n3. `double crimeSeverityIndex = baseSeverity;` assigns the current value of `baseSeverity` (`10.5`) to `crimeSeverityIndex`.\n4. `investigatorBonus /= (criminalHistory % 3 + 1);`\n    * `criminalHistory % 3`: `7 % 3 = 1`.\n    * `1 + 1 = 2`.\n    * `investigatorBonus /= 2`: `100.0 / 2 = 50.0`. So, `investigatorBonus` is `50.0`.\n5. The first `System.out.println()` prints \"Final Crime Severity Index: 10.5\".\n6. The second `System.out.println()` prints \"Investigator Bonus: $50.0\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": " `x *= y` is a shorthand for `x = x * y`.",
      "2": " `x /= y` is a shorthand for `x = x / y`.",
      "3": "Remember operator precedence: parentheses first, then modulo, then addition, then division."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 188,
    "subtopic_id": 5,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `MissionAllocator` manages `squadVehicles` and tracks `missionProgress`. Vehicles are deployed, and progress is incremented and adjusted based on remaining vehicles. Your task is to trace the code and determine the `Remaining Vehicles` and `Current Mission Progress`.",
      "code": "public class MissionAllocator {\n    public static void main(String[] args) {\n        int squadVehicles = 10;\n        int vehiclesDeployed = 3;\n        int missionProgress = 0;\n\n        squadVehicles -= vehiclesDeployed;\n        missionProgress++;\n        missionProgress += (squadVehicles - 5);\n        \n        System.out.println(\"Remaining Vehicles: \" + squadVehicles);\n        System.out.println(\"Current Mission Progress: \" + missionProgress);\n    }\n}",
      "choices": [
        "Remaining Vehicles: 7",
        "Remaining Vehicles: 10",
        "Current Mission Progress: 1",
        "Current Mission Progress: 3"
      ],
      "answer": [
        "Remaining Vehicles: 7",
        "Current Mission Progress: 3"
      ],
      "explanation": "1. `squadVehicles` starts at `10`, `missionProgress` at `0`.\n2. `squadVehicles -= vehiclesDeployed;` updates `squadVehicles` to `10 - 3 = 7`.\n3. `missionProgress++;` increments `missionProgress` to `1`.\n4. `missionProgress += (squadVehicles - 5);`\n    * `squadVehicles - 5`: `7 - 5 = 2`.\n    * `missionProgress += 2`: `1 + 2 = 3`. So, `missionProgress` is `3`.\n5. The first `System.out.println()` prints \"Remaining Vehicles: 7\".\n6. The second `System.out.println()` prints \"Current Mission Progress: 3\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Trace `squadVehicles` through its subtraction assignment.",
      "2": "Trace `missionProgress` through its increment (`++`) and then the compound addition (`+=`).",
      "3": "Evaluate the expression inside the parentheses for `missionProgress += ...` first."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 189,
    "subtopic_id": 5,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "An `EvidenceLabeler` applies a `batchSize` multiplier and then a `divisor` modulo to a `baseID`. Your task is to trace the code and determine the final `ID` and `Remainder Status`.",
      "code": "public class EvidenceLabeler {\n    public static void main(String[] args) {\n        int baseID = 50;\n        int batchSize = 3;\n        int divisor = 7;\n        \n        baseID *= batchSize;\n        int finalID = baseID;\n        \n        baseID %= divisor;\n        int remainderStatus = baseID;\n        \n        System.out.println(\"Final ID: \" + finalID);\n        System.out.println(\"Remainder Status: \" + remainderStatus);\n    }\n}",
      "choices": [
        "Final ID: 150",
        "Final ID: 50",
        "Remainder Status: 1",
        "Remainder Status: 3"
      ],
      "answer": [
        "Final ID: 150",
        "Remainder Status: 3"
      ],
      "explanation": "1. `baseID` starts at `50`.\n2. `baseID *= batchSize;` updates `baseID` to `50 * 3 = 150`.\n3. `int finalID = baseID;` assigns the current value of `baseID` (`150`) to `finalID`.\n4. `baseID %= divisor;` updates `baseID` to `150 % 7 = 3`.\n5. `int remainderStatus = baseID;` assigns the current value of `baseID` (`3`) to `remainderStatus`.\n6. The first `System.out.println()` prints \"Final ID: 150\".\n7. The second `System.out.println()` prints \"Remainder Status: 3\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": " `x *= y` updates `x` by multiplying it with `y`.",
      "2": " `x %= y` updates `x` by assigning the remainder of `x / y`.",
      "3": "Note that `finalID` takes its value *before* `baseID` undergoes the modulo operation."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 190,
    "subtopic_id": 5,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `SecretBudgetAdjuster` manages `secretOperationBudget` by applying a `multiplier` and deducting a `fixedExpense`. Your task is to trace the code and determine the `Adjusted Budget` (before final expense) and the `Final Budget`.",
      "code": "public class SecretBudgetAdjuster {\n    public static void main(String[] args) {\n        double secretOperationBudget = 5000.0;\n        double multiplier = 0.5;\n        double fixedExpense = 100.0;\n\n        secretOperationBudget *= multiplier;\n        double adjustedBudget = secretOperationBudget;\n\n        secretOperationBudget -= fixedExpense;\n        double finalBudget = secretOperationBudget;\n        \n        System.out.println(\"Adjusted Budget (Before Final Expense): $\" + adjustedBudget);\n        System.out.println(\"Final Budget: $\" + finalBudget);\n    }\n}",
      "choices": [
        "Adjusted Budget (Before Final Expense): $2500.0",
        "Adjusted Budget (Before Final Expense): $5000.0",
        "Final Budget: $2400.0",
        "Final Budget: $2600.0"
      ],
      "answer": [
        "Adjusted Budget (Before Final Expense): $2500.0",
        "Final Budget: $2400.0"
      ],
      "explanation": "1. `secretOperationBudget` starts at `5000.0`.\n2. `secretOperationBudget *= multiplier;` updates `secretOperationBudget` to `5000.0 * 0.5 = 2500.0`.\n3. `double adjustedBudget = secretOperationBudget;` assigns `2500.0` to `adjustedBudget`.\n4. `secretOperationBudget -= fixedExpense;` updates `secretOperationBudget` to `2500.0 - 100.0 = 2400.0`.\n5. `double finalBudget = secretOperationBudget;` assigns `2400.0` to `finalBudget`.\n6. The first `System.out.println()` prints \"Adjusted Budget (Before Final Expense): $2500.0\".\n7. The second `System.out.println()` prints \"Final Budget: $2400.0\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": " `secretOperationBudget` is updated multiple times; trace its value precisely.",
      "2": " `adjustedBudget` captures `secretOperationBudget`'s value *after* the multiplication but *before* the subtraction.",
      "3": " `finalBudget` captures `secretOperationBudget`'s value *after all* operations."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 191,
    "subtopic_id": 5,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `SuspectProfiler` adjusts `initialRating` and `offenseScore` using pre/post-increment/decrement and compound assignments, then determines a `riskIndicator`. Your task is to trace the code and determine the `Final Rating`, `Offense Threshold`, and `Risk Indicator`.",
      "code": "public class SuspectProfiler {\n    public static void main(String[] args) {\n        int initialRating = 100;\n        int offenseScore = 20;\n        byte profileIterations = 3;\n        boolean riskIndicator = false;\n\n        initialRating /= profileIterations++;\n        \n        int finalRating = initialRating;\n        \n        offenseScore %= --profileIterations;\n        \n        int offenseThreshold = offenseScore;\n        \n        finalRating -= offenseScore * 2;\n        \n        if (finalRating % 2 != 0) {\n            riskIndicator = true;\n        }\n        \n        System.out.println(\"Final Rating: \" + finalRating);\n        System.out.println(\"Offense Threshold: \" + offenseThreshold);\n        System.out.println(\"Risk Indicator: \" + riskIndicator);\n    }\n}",
      "choices": [
        "Final Rating: 29",
        "Offense Threshold: 2",
        "Risk Indicator: true",
        "Final Rating: 33"
      ],
      "answer": [
        "Final Rating: 29",
        "Offense Threshold: 2",
        "Risk Indicator: true"
      ],
      "explanation": "1. `initialRating = 100`, `offenseScore = 20`, `profileIterations = 3`.\n2. `initialRating /= profileIterations++;`\n    * `initialRating /= 3` (`100 / 3` integer division) = `33`. `initialRating` is `33`.\n    * `profileIterations++` increments `profileIterations` to `4` (after use).\n3. `int finalRating = initialRating;` `finalRating` is `33`.\n4. `offenseScore %= --profileIterations;`\n    * `--profileIterations` decrements `profileIterations` to `3` (before use).\n    * `offenseScore %= 3`: `20 % 3 = 2`. `offenseScore` is `2`.\n5. `int offenseThreshold = offenseScore;` `offenseThreshold` is `2`.\n6. `finalRating -= offenseScore * 2;`\n    * `offenseScore * 2`: `2 * 2 = 4`.\n    * `finalRating -= 4`: `33 - 4 = 29`. `finalRating` is `29`.\n7. `if (finalRating % 2 != 0)`: `29 % 2 = 1`. `1 != 0` is `true`.\n    * `riskIndicator = true;` `riskIndicator` is `true`.\n8. All three `System.out.println()` statements display the final values."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Distinguish between pre-increment/decrement (`++x`, `--x`) and post-increment/decrement (`x++`, `x--`). Pre-operations change the value *before* use, post-operations *after*.",
      "2": "Trace `profileIterations` carefully as it affects multiple calculations.",
      "3": "Compound assignments and modulo operations should be done sequentially."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 192,
    "subtopic_id": 5,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `ForensicAccountant` audits `suspiciousAccount` funds, calculating `auditFlag` and `balanceStatus`. The calculations involve compound assignments, modulo operations, and conditional logic. Your task is to trace the code and determine the `Final Balance`, `Audit Alert`, and `Balance Status`.",
      "code": "public class ForensicAccountant {\n    public static void main(String[] args) {\n        double suspiciousAccount = 1000.75;\n        double transactionFee = 25.50;\n        int auditFlag = 0;\n        boolean balanceStatus = false;\n\n        suspiciousAccount -= transactionFee;\n        suspiciousAccount /= 2.0;\n\n        auditFlag += (int) (suspiciousAccount % 100);\n        \n        String auditAlert = (auditFlag > 50) ? \"HIGH\" : \"LOW\";\n        \n        if (suspiciousAccount < 500.0 && auditAlert.equals(\"HIGH\")) {\n            balanceStatus = true;\n        }\n        \n        System.out.println(\"Final Balance: \" + suspiciousAccount);\n        System.out.println(\"Audit Alert: \" + auditAlert);\n        System.out.println(\"Balance Status: \" + balanceStatus);\n    }\n}",
      "choices": [
        "Final Balance: 487.625",
        "Audit Alert: HIGH",
        "Balance Status: true",
        "Final Balance: 975.25"
      ],
      "answer": [
        "Final Balance: 487.625",
        "Audit Alert: HIGH",
        "Balance Status: true"
      ],
      "explanation": "1. `suspiciousAccount = 1000.75`, `transactionFee = 25.50`, `auditFlag = 0`.\n2. `suspiciousAccount -= transactionFee;` updates `suspiciousAccount` to `1000.75 - 25.50 = 975.25`.\n3. `suspiciousAccount /= 2.0;` updates `suspiciousAccount` to `975.25 / 2.0 = 487.625`. \n4. `auditFlag += (int) (suspiciousAccount % 100);`\n    * `suspiciousAccount % 100`: `487.625 % 100` (double converted to int for modulo, truncating to 487) = `487 % 100 = 87`.\n    * `auditFlag += 87`: `0 + 87 = 87`. `auditFlag` is `87`.\n5. `String auditAlert = (auditFlag > 50) ? \"HIGH\" : \"LOW\";` `87 > 50` is `true`. `auditAlert` is \"HIGH\". \n6. `if (suspiciousAccount < 500.0 && auditAlert.equals(\"HIGH\"))`\n    * `487.625 < 500.0` is `true`.\n    * `auditAlert.equals(\"HIGH\")` is `\"HIGH\".equals(\"HIGH\")`, which is `true`.\n    * `true && true` is `true`.\n    * `balanceStatus = true;` `balanceStatus` is `true`. \n7. All three `System.out.println()` statements display the final values."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Trace `suspiciousAccount` through its compound subtraction and division, retaining decimal precision.",
      "2": "`auditFlag` uses a compound addition with a modulo result, requiring `(int)` cast.",
      "3": "The ternary operator determines `auditAlert`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 193,
    "subtopic_id": 5,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `CrossReferenceSystem` calculates `reportCode`, `finalReportID`, `confidenceRating`, and `statusMessage` using various compound assignments, pre/post-increments, and conditional logic. Your task is to trace the code and determine the `Final Report ID`, `Confidence Rating`, and `Status Message`.",
      "code": "public class CrossReferenceSystem {\n    public static void main(String[] args) {\n        int reportCode = 200;\n        float evidenceLevel = 0.5f;\n        int baseConfidence = 10;\n        String statusMessage = \"PENDING\";\n\n        reportCode /= --baseConfidence;\n        \n        float finalReportID = reportCode;\n        \n        int confidenceRating = (int) (finalReportID * (baseConfidence++));\n        \n        confidenceRating %= 50;\n        \n        if (confidenceRating > 45) {\n            statusMessage += \" VERIFIED\";\n        } else {\n            statusMessage += \" UNVERIFIED\";\n        }\n\n        System.out.println(\"Final Report ID: \" + finalReportID);\n        System.out.println(\"Confidence Rating: \" + confidenceRating);\n        System.out.println(\"Status Message: \" + statusMessage);\n    }\n}",
      "choices": [
        "Final Report ID: 22.0",
        "Confidence Rating: 198",
        "Confidence Rating: 48",
        "Status Message: PENDING VERIFIED"
      ],
      "answer": [
        "Final Report ID: 22.0",
        "Confidence Rating: 48",
        "Status Message: PENDING VERIFIED"
      ],
      "explanation": "1. `reportCode = 200`, `baseConfidence = 10`, `statusMessage = \"PENDING\"`.\n2. `reportCode /= --baseConfidence;`\n    * `--baseConfidence` decrements `baseConfidence` to `9` (before use).\n    * `reportCode /= 9`: `200 / 9` (integer division) = `22`. `reportCode` is `22`.\n3. `float finalReportID = reportCode;` `finalReportID` is `22.0f`. \n4. `int confidenceRating = (int) (finalReportID * (baseConfidence++));`\n    * `baseConfidence++`: `9` (used then incremented to `10`).\n    * `finalReportID * 9`: `22.0f * 9` = `198.0f`.\n    * `(int)198.0f`: `198`. `confidenceRating` is `198`.\n5. `confidenceRating %= 50;` `198 % 50` = `48`. `confidenceRating` is `48`. \n6. `if (confidenceRating > 45)`: `48 > 45` is `true`.\n    * `statusMessage += \" VERIFIED\";` appends, so `statusMessage` is \"PENDING VERIFIED\". \n7. All three `System.out.println()` statements display the final values."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Trace `reportCode` through division by a pre-decremented value.",
      "2": "Follow `confidenceRating` through multiplication by a post-incremented value, and then a modulo operation.",
      "3": "The `if` condition determines the final appended string to `statusMessage`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 194,
    "subtopic_id": 5,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `VeteranDetectiveEvaluator` calculates `finalRiskFactor` and `complexScoreAudit`, then sets a `caseStatusIndicator` based on potential `byte` and `int` overflows. Your task is to trace the code and determine the `Final Risk Factor`, `Complex Score Audit`, and `Case Status Indicator`.",
      "code": "public class VeteranDetectiveEvaluator {\n    public static void main(String[] args) {\n        byte suspectRiskFactor = 120;\n        int baseComplexity = 2000000000;\n        float adjustmentValue = 0.5f;\n        boolean caseStatusIndicator = false;\n\n        suspectRiskFactor += 10;\n        \n        int finalRiskFactor = suspectRiskFactor;\n        \n        baseComplexity += (int) (baseComplexity * adjustmentValue);\n        \n        double complexScoreAudit = baseComplexity;\n        \n        if (finalRiskFactor < 0 && complexScoreAudit < 0) {\n            caseStatusIndicator = true;\n        }\n        \n        System.out.println(\"Final Risk Factor: \" + finalRiskFactor);\n        System.out.println(\"Complex Score Audit: \" + complexScoreAudit);\n        System.out.println(\"Case Status Indicator: \" + caseStatusIndicator);\n    }\n}",
      "choices": [
        "Final Risk Factor: 130",
        "Final Risk Factor: -126",
        "Complex Score Audit: -1294967296.0",
        "Case Status Indicator: true"
      ],
      "answer": [
        "Final Risk Factor: -126",
        "Complex Score Audit: -1294967296.0",
        "Case Status Indicator: true"
      ],
      "explanation": "1. `suspectRiskFactor = 120`, `baseComplexity = 2000000000`.\n2. `suspectRiskFactor += 10;` calculates `120 + 10 = 130`. This causes **byte overflow** (130 > 127), so `suspectRiskFactor` becomes `-126`.\n3. `int finalRiskFactor = suspectRiskFactor;` `finalRiskFactor` is `-126`.\n4. `baseComplexity += (int) (baseComplexity * adjustmentValue);`\n    * `baseComplexity * adjustmentValue`: `2000000000 * 0.5f` (int promotes to float, then to double due to assignment to double result which is cast back to int) = `1000000000.0d`.\n    * `baseComplexity += 1000000000`: `2000000000 + 1000000000 = 3000000000`. This causes **int overflow**, so `baseComplexity` becomes `-1294967296`.\n5. `double complexScoreAudit = baseComplexity;` `complexScoreAudit` is `-1294967296.0`.\n6. `if (finalRiskFactor < 0 && complexScoreAudit < 0)`: `-126 < 0` is `true`, AND `-1294967296.0 < 0` is `true`. Condition is `true`.\n    * `caseStatusIndicator = true;` `caseStatusIndicator` is `true`.\n7. All three `System.out.println()` statements display the final values."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Pay close attention to `suspectRiskFactor += 10` and its potential `byte` overflow.",
      "2": "The `baseComplexity += ...` involves `int` multiplication by `float`, which can lead to `int` overflow when `int`s are added and then assigned back.",
      "3": "Evaluate the `if` condition with both negative results to determine `caseStatusIndicator`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 195,
    "subtopic_id": 5,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `ForensicAccountant` audits `suspiciousAccount` funds, calculating `auditFlag` and `balanceStatus`. The calculations involve compound assignments, modulo operations, and conditional logic. Your task is to trace the code and determine the `Final Balance`, `Audit Alert`, and `Balance Status`.",
      "code": "public class ForensicAccountant {\n    public static void main(String[] args) {\n        double suspiciousAccount = 1000.75;\n        double transactionFee = 25.50;\n        int auditFlag = 0;\n        boolean balanceStatus = false;\n\n        suspiciousAccount -= transactionFee;\n        suspiciousAccount /= 2.0;\n\n        auditFlag += (int) (suspiciousAccount % 100);\n        \n        String auditAlert = (auditFlag > 50) ? \"HIGH\" : \"LOW\";\n        \n        if (suspiciousAccount < 500.0 && auditAlert.equals(\"HIGH\")) {\n            balanceStatus = true;\n        }\n        \n        System.out.println(\"Final Balance: \" + suspiciousAccount);\n        System.out.println(\"Audit Alert: \" + auditAlert);\n        System.out.println(\"Balance Status: \" + balanceStatus);\n    }\n}",
      "choices": [
        "Final Balance: 487.625",
        "Audit Alert: HIGH",
        "Balance Status: true",
        "Final Balance: 975.25"
      ],
      "answer": [
        "Final Balance: 487.625",
        "Audit Alert: HIGH",
        "Balance Status: true"
      ],
      "explanation": "1. `suspiciousAccount = 1000.75`, `transactionFee = 25.50`, `auditFlag = 0`.\n2. `suspiciousAccount -= transactionFee;` updates `suspiciousAccount` to `1000.75 - 25.50 = 975.25`.\n3. `suspiciousAccount /= 2.0;` updates `suspiciousAccount` to `975.25 / 2.0 = 487.625`. \n4. `auditFlag += (int) (suspiciousAccount % 100);`\n    * `suspiciousAccount % 100`: `487.625 % 100` (double converted to int for modulo, truncating to 487) = `487 % 100 = 87`.\n    * `auditFlag += 87`: `0 + 87 = 87`. `auditFlag` is `87`.\n5. `String auditAlert = (auditFlag > 50) ? \"HIGH\" : \"LOW\";` `87 > 50` is `true`. `auditAlert` is \"HIGH\". \n6. `if (suspiciousAccount < 500.0 && auditAlert.equals(\"HIGH\"))`\n    * `487.625 < 500.0` is `true`.\n    * `auditAlert.equals(\"HIGH\")` is `\"HIGH\".equals(\"HIGH\")`, which is `true`.\n    * `true && true` is `true`.\n    * `balanceStatus = true;` `balanceStatus` is `true`. \n7. All three `System.out.println()` statements display the final values."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Trace `suspiciousAccount` through its compound subtraction and division, retaining decimal precision.",
      "2": "`auditFlag` uses a compound addition with a modulo result, requiring `(int)` cast.",
      "3": "The ternary operator determines `auditAlert`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 196,
    "subtopic_id": 5,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `StakeoutLogger` tracks `totalStakeoutHours` by combining `shift1Hours` and `shift2Hours`. However, the code incorrectly uses subtraction instead of addition. Fix the code to calculate the correct total hours.",
      "code": "public class StakeoutLogger {\n    public static void main(String[] args) {\n        int shift1Hours = 8;\n        int shift2Hours = 4;\n        int totalStakeoutHours = shift1Hours + shift2Hours; // Correct: Use addition\n        System.out.println(\"Total Stakeout Hours: \" + totalStakeoutHours);\n    }\n}",
      "expected_output": [
        "Total Stakeout Hours: 12"
      ],
      "hidden_test_case": "",
      "explanation": "The original code used the subtraction operator (`-`) instead of the addition operator (`+`). To find the total hours, the two values need to be added together. Replacing `-` with `+` correctly calculates `8 + 4 = 12`."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The goal is to find the *total* hours.",
      "2": "Which arithmetic operator performs addition?",
      "3": "Look for the operation symbol between `shift1Hours` and `shift2Hours`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 197,
    "subtopic_id": 5,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `SuspectTracker` determines `activeSuspects` by reducing `initialSuspects` by `clearedSuspects`. However, the code incorrectly uses multiplication instead of subtraction. Fix the code to calculate the correct number of active suspects.",
      "code": "public class SuspectTracker {\n    public static void main(String[] args) {\n        int initialSuspects = 10;\n        int clearedSuspects = 3;\n        int activeSuspects = initialSuspects - clearedSuspects; // Correct: Use subtraction\n        System.out.println(\"Active Suspects: \" + activeSuspects);\n    }\n}",
      "expected_output": [
        "Active Suspects: 7"
      ],
      "hidden_test_case": "",
      "explanation": "The original code used the multiplication operator (`*`) instead of the subtraction operator (`-`). To find the remaining suspects, the `clearedSuspects` need to be subtracted from `initialSuspects`. Replacing `*` with `-` correctly calculates `10 - 3 = 7`."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The goal is to find the number of suspects *remaining* after some are cleared.",
      "2": "Which arithmetic operator reduces a quantity?",
      "3": "Look at the symbol between `initialSuspects` and `clearedSuspects`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 198,
    "subtopic_id": 5,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "An `EvidenceDistributor` calculates `itemsPerContainer` by dividing `evidenceItems` among `containers`. However, the code performs integer division, losing decimal precision. Fix the code to obtain a floating-point result for `itemsPerContainer`.",
      "code": "public class EvidenceDistributor {\n    public static void main(String[] args) {\n        int evidenceItems = 15;\n        int containers = 4;\n        double itemsPerContainer = (double) evidenceItems / containers; // Correct: Cast to double for floating-point division\n        System.out.println(\"Items Per Container: \" + itemsPerContainer);\n    }\n}",
      "expected_output": [
        "Items Per Container: 3.75"
      ],
      "hidden_test_case": "",
      "explanation": "The original code performs integer division (`15 / 4 = 3`) because both `evidenceItems` and `containers` are `int`s. This causes the decimal part (`.75`) to be lost. To achieve floating-point division and retain precision, at least one of the operands must be cast to a floating-point type (`double` or `float`). Casting `evidenceItems` to `double` (`(double)evidenceItems`) before division forces the entire operation to be floating-point. The result `3.75` can then be correctly stored in a `double` variable."
    },
    "difficulty": "easy",
    "hints": {
      "1": "Division between two integers will always result in an integer (any decimal part is truncated).",
      "2": "To get a floating-point result from division, at least one of the operands must be a floating-point type (`double` or `float`).",
      "3": "Consider explicitly converting one of the numbers to a decimal type before division."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 199,
    "subtopic_id": 5,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `FingerprintAnalyzer` calculates `fingerprintRemainder` from `totalPrints` and `labCapacity`. However, the code incorrectly uses multiplication instead of the modulo operator. Fix the code to calculate the correct remainder.",
      "code": "public class FingerprintAnalyzer {\n    public static void main(String[] args) {\n        int totalPrints = 22;\n        int labCapacity = 5;\n        int fingerprintRemainder = totalPrints % labCapacity; // Correct: Use modulo operator\n        System.out.println(\"Fingerprint Remainder: \" + fingerprintRemainder);\n    }\n}",
      "expected_output": [
        "Fingerprint Remainder: 2"
      ],
      "hidden_test_case": "",
      "explanation": "The original code used the multiplication operator (`*`) instead of the modulo operator (`%`). The modulo operator (`%`) is used to find the remainder of a division (`22 / 5` is `4` with a remainder of `2`). Replacing `*` with `%` correctly calculates `22 % 5 = 2`."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The goal is to find what's left over after one number is divided by another, not their product.",
      "2": "Which arithmetic operator gives you the remainder?",
      "3": "Look for the operation symbol between `totalPrints` and `labCapacity`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 200,
    "subtopic_id": 5,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `CodeAnalyzer` attempts to calculate a remainder from `serialCode` using the modulo operator, but the result is discarded, and `serialCode` remains unchanged. Fix the code to correctly update `serialCode` with the remainder.",
      "code": "public class CodeAnalyzer {\n    public static void main(String[] args) {\n        int serialCode = 37;\n        serialCode %= 10; // Correct: Use compound modulo assignment\n        System.out.println(\"Pattern Check: \" + serialCode);\n    }\n}",
      "expected_output": [
        "Pattern Check: 7"
      ],
      "hidden_test_case": "",
      "explanation": "The original code `serialCode % 10;` calculates `37 % 10 = 7` but discards this result. `serialCode` remains `37`. To find the remainder of `serialCode` divided by `10` and reassign the updated value back to it, the compound modulo assignment operator `%=` is required (`serialCode %= 10;` is equivalent to `serialCode = serialCode % 10;`)."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The expression `serialCode % 10` computes a value, but that value needs to be stored.",
      "2": "To find the remainder of a division and update a variable simultaneously, a compound assignment operator is needed.",
      "3": "Look for the shorthand operator that combines modulo and assignment."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 201,
    "subtopic_id": 5,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `BudgetReducer` updates `surveillanceBudget` by subtracting `dailyRate` multiplied by `daysWatched`. The code causes a compilation error due to implicit casting from `double` to `int` in the compound assignment. Fix the code to correctly update the budget.",
      "code": "public class BudgetReducer {\n    public static void main(String[] args) {\n        int surveillanceBudget = 1000;\n        double dailyRate = 50.5;\n        int daysWatched = 3;\n        surveillanceBudget = (int)(surveillanceBudget - (dailyRate * daysWatched)); // Correct: Explicitly cast result to int\n        System.out.println(\"Remaining Budget: $\" + surveillanceBudget);\n    }\n}",
      "expected_output": [
        "Remaining Budget: $848"
      ],
      "hidden_test_case": "",
      "explanation": "The original code attempts to subtract `dailyRate * daysWatched` (which is `50.5 * 3 = 151.5`, a `double`) from `surveillanceBudget` (an `int`) using the compound assignment `-=`. Java's rules for compound assignments perform the operation and then an implicit cast to the variable's type. However, for a `double` to `int` conversion, this implicit cast is not allowed without potential data loss, causing a compilation error. The fix explicitly performs the subtraction and then casts the *entire result* to an `int` (`(int)(surveillanceBudget - (dailyRate * daysWatched))`), effectively truncating `151.5` to `151` (when it's subtracted, this gives `1000-151.5 = 848.5`) and so `848` when cast back to int. The calculation is `1000 - (50.5 * 3) = 1000 - 151.5 = 848.5`. Casting `848.5` to `int` truncates it to `848`."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Compound assignment operators (like `-=`) implicitly perform an operation and then an assignment.",
      "2": "If the result of the arithmetic operation is of a wider type (e.g., `double`) than the variable (e.g., `int`), it's a \"possible lossy conversion.\"",
      "3": "You need to explicitly tell Java to convert the result to the narrower type, accepting any precision loss."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 202,
    "subtopic_id": 5,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "An `Interrogator` tracks `interrogationRounds`. The code attempts to use a post-increment (`++`) in an assignment that causes `interrogationRounds` to not update as expected. Fix the code to ensure `interrogationRounds` correctly increments.",
      "code": "public class Interrogator {\n    public static void main(String[] args) {\n        int interrogationRounds = 5;\n        interrogationRounds = ++interrogationRounds; // Correct: Use pre-increment\n        System.out.println(\"Current Rounds: \" + interrogationRounds);\n    }\n}",
      "expected_output": [
        "Current Rounds: 6"
      ],
      "hidden_test_case": "",
      "explanation": "The original code `interrogationRounds = interrogationRounds++;` creates a subtle logical flaw. The `interrogationRounds++` (post-increment) operation first uses the *current value* of `interrogationRounds` (`5`) for the right-hand side of the assignment. So, `interrogationRounds` is assigned `5`. *Then*, `interrogationRounds` is incremented to `6`. Effectively, the assignment overwrites the increment. The fix is to use `++interrogationRounds` (pre-increment), which increments `interrogationRounds` *before* its value is used in the assignment, ensuring the updated `6` is assigned. Alternatively, `interrogationRounds += 1;` or simply `interrogationRounds++;` (without reassigning from itself) are clearer and more common solutions."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The `x++` (post-increment) operator means \"use `x`'s current value *then* increment `x`.\"",
      "2": "In an assignment like `x = x++`, `x`'s original value is used for the right-hand side of the assignment *before* `x` itself is incremented.",
      "3": "To ensure the variable is incremented *and* its new value is assigned, consider pre-increment (`++x`) or the compound assignment `+= 1`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 203,
    "subtopic_id": 5,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `MissionBudgeter` calculates `missionFunds`. The compound assignment operator has an incorrect space, causing a syntax error. Fix the code to correctly multiply and assign `missionFunds`.",
      "code": "public class MissionBudgeter {\n    public static void main(String[] args) {\n        double missionFunds = 500.0;\n        double resourceFactor = 1.5;\n        missionFunds *= resourceFactor; // Correct: Remove space between * and =\n        System.out.println(\"Allocated Funds: $\" + missionFunds);\n    }\n}",
      "expected_output": [
        "Allocated Funds: $750.0"
      ],
      "hidden_test_case": "",
      "explanation": "The original code `missionFunds * = resourceFactor;` has an incorrect space between the `*` and `=` symbols. Compound assignment operators like `*=`, `+=`, `-=`, `/=`, `%=` must be written as a single token without any space. Removing the space (`missionFunds *= resourceFactor;`) correctly forms the compound multiplication assignment operator, allowing the code to compile and perform the intended calculation (`500.0 * 1.5 = 750.0`)."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The `*` and `=` symbols, when used together for multiplication and assignment, should not have a space between them.",
      "2": "This form is a single compound assignment operator.",
      "3": "Look for the shorthand operator that combines multiplication and assignment."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 204,
    "subtopic_id": 5,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "An `EvidenceWeightUpdater` updates `evidenceWeight` by adding `newSampleWeight`. The code causes a compilation error because adding a `double` to an `int` and implicitly casting back to `int` is not allowed. Fix the code to correctly update `evidenceWeight`.",
      "code": "public class EvidenceWeightUpdater {\n    public static void main(String[] args) {\n        int evidenceWeight = 100;\n        double newSampleWeight = 5.75;\n        evidenceWeight = (int)(evidenceWeight + newSampleWeight); // Correct: Explicitly cast result to int\n        System.out.println(\"Updated Weight: \" + evidenceWeight);\n    }\n}",
      "expected_output": [
        "Updated Weight: 105"
      ],
      "hidden_test_case": "",
      "explanation": "The compound assignment `evidenceWeight += newSampleWeight;` is equivalent to `evidenceWeight = evidenceWeight + newSampleWeight;`. In the expression `evidenceWeight + newSampleWeight` (`100 + 5.75`), `evidenceWeight` (int) is promoted to `double`, resulting in `105.75` (double). Attempting to assign this `double` back to `evidenceWeight` (int) implicitly results in a \"possible lossy conversion\" error. The fix requires explicitly casting the `double` result back to `int`: `evidenceWeight = (int) (evidenceWeight + newSampleWeight);`, which truncates `105.75` to `105`."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Compound assignment operators like `+=` implicitly perform an operation and then a cast back to the variable's type.",
      "2": "An implicit cast from a `double` to an `int` (which discards decimals) is not allowed by Java without explicit instruction.",
      "3": "You need to manually perform the addition and then explicitly cast the result to an `int`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 205,
    "subtopic_id": 5,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `ReportFinalizer` sets `reportStatus` based on `finalApproval`. The code attempts to assign a boolean value (`finalApproval`) directly to a `String` variable, causing a type mismatch. Fix the code to correctly update `reportStatus`.",
      "code": "public class ReportFinalizer {\n    public static void main(String[] args) {\n        boolean finalApproval = true;\n        String reportStatus = \"Draft\";\n        \n        if (finalApproval == true) {\n            reportStatus = \"Finalized\"; // Correct: Assign String literal\n        }\n        \n        System.out.println(\"Report Status: \" + reportStatus);\n    }\n}",
      "expected_output": [
        "Report Status: Finalized"
      ],
      "hidden_test_case": "",
      "explanation": "The original code attempts to assign the boolean variable `finalApproval` (which is `true`) directly to the `String` variable `reportStatus`. This results in a type mismatch compilation error because a `boolean` cannot be assigned directly to a `String`. The fix is to assign the `String` literal `\"Finalized\"` (enclosed in double quotes) to `reportStatus` when the condition is met."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The `reportStatus` variable is a `String`.",
      "2": "You are trying to assign a boolean value (`finalApproval`) directly to a `String` variable inside the `if` block.",
      "3": "Remember that `true` or `false` are boolean literals, not `String` literals. `String` literals are enclosed in double quotes."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 206,
    "subtopic_id": 5,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "An `EvidenceAggregator` calculates `fragmentCount` by adding `collectionRate` and multiplying by `labFactor`. However, operator precedence in the compound assignment leads to an incorrect sum. Fix the code to ensure `fragmentCount` is correctly calculated.",
      "code": "public class EvidenceAggregator {\n    public static void main(String[] args) {\n        int fragmentCount = 10;\n        int collectionRate = 2;\n        int labFactor = 5;\n        fragmentCount = (fragmentCount + collectionRate) * labFactor; // Correct: Use explicit parentheses\n        System.out.println(\"Total Fragments: \" + fragmentCount);\n    }\n}",
      "expected_output": [
        "Total Fragments: 60"
      ],
      "hidden_test_case": "",
      "explanation": "The original code `fragmentCount += collectionRate * labFactor;` is equivalent to `fragmentCount = fragmentCount + (collectionRate * labFactor);`. This evaluates `collectionRate * labFactor` first (`2 * 5 = 10`), then adds it to `fragmentCount` (`10 + 10 = 20`). The intended calculation was `(fragmentCount + collectionRate) * labFactor`. To achieve this, the addition `(fragmentCount + collectionRate)` must be grouped with parentheses, and the multiplication must be applied to that sum. This requires breaking down the compound assignment into a full assignment `fragmentCount = (fragmentCount + collectionRate) * labFactor;`, which yields `(10 + 2) * 5 = 12 * 5 = 60`."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Remember that `X += A * B` is equivalent to `X = X + (A * B)`. Multiplication (`*`) inside the expression on the right-hand side has higher precedence.",
      "2": "If you want an addition (e.g., `fragmentCount + collectionRate`) to occur *before* multiplication by `labFactor`, you need to explicitly group those operations.",
      "3": "Compound assignment operators are shorthands, but sometimes you need to break them down into full assignments with explicit parentheses to control precedence."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 207,
    "subtopic_id": 5,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "An `AssetAuditor` updates `currentAssets` by adding `newInvestments`. The code causes a compilation error because implicitly casting the `double` result of the addition back to an `int` is not allowed. Fix the code to correctly update `currentAssets`.",
      "code": "public class AssetAuditor {\n    public static void main(String[] args) {\n        int currentAssets = 1000;\n        double newInvestments = 150.75;\n        currentAssets = (int)(currentAssets + newInvestments); // Correct: Explicitly cast result to int\n        System.out.println(\"Total Assets: $\" + currentAssets);\n    }\n}",
      "expected_output": [
        "Total Assets: $1150"
      ],
      "hidden_test_case": "",
      "explanation": "The original code `currentAssets += newInvestments;` is equivalent to `currentAssets = currentAssets + newInvestments;`. In the expression `currentAssets + newInvestments` (`1000 + 150.75`), `currentAssets` (int) is promoted to `double`, resulting in `1150.75` (double). Attempting to assign this `double` back to `currentAssets` (int) implicitly results in a \"possible lossy conversion\" compilation error. The fix requires explicitly casting the `double` result back to `int`: `currentAssets = (int) (currentAssets + newInvestments);`, which truncates `1150.75` to `1150`."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Compound assignment operators like `+=` implicitly perform an operation and then a cast back to the variable's type.",
      "2": "Java does not allow an implicit (automatic) conversion from `double` to `int` if it means losing decimal places.",
      "3": "To proceed, you must explicitly tell Java to truncate the decimal by casting the entire arithmetic result to an `int`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 208,
    "subtopic_id": 5,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "An `InterrogationRounds` counter is updated using a post-increment (`roundCount++`) within an assignment that causes the variable to not reflect the increment immediately for the comparison. Fix the code to ensure `roundCount` is incremented *before* the comparison.",
      "code": "public class InterrogationRounds {\n    public static void main(String[] args) {\n        int roundCount = 5;\n        if (++roundCount < 6) { // Correct: Use pre-increment\n            System.out.println(\"Round still in progress: \" + roundCount);\n        } else {\n            System.out.println(\"Round completed: \" + roundCount);\n        }\n    }\n}",
      "expected_output": [
        "Round completed: 6"
      ],
      "hidden_test_case": "",
      "explanation": "The original code `if (roundCount++ < 6)` uses the post-increment operator. This means `roundCount`'s original value (`5`) is used in the comparison (`5 < 6`) first, which is `true`. *Then*, `roundCount` increments to `6`. So, it prints \"Round still in progress: 6\". The intended behavior is for the increment to happen *before* the comparison. The fix is to use the pre-increment operator `++roundCount`. This increments `roundCount` to `6` first, then uses `6` in the comparison (`6 < 6`), which is `false`. This leads to the `else` block being executed, printing \"Round completed: 6\"."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The `x++` (post-increment) operator means \"use `x`'s current value *then* increment `x`.\"",
      "2": "In an assignment like `x = x++`, `x`'s original value is used for the right-hand side of the assignment *before* `x` itself is incremented.",
      "3": "To ensure the variable is incremented *and* its new value is assigned, consider pre-increment (`++x`) or the compound assignment `+= 1`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 209,
    "subtopic_id": 5,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "An `InvestigationBudget` updates `totalBudget` using a compound multiplication assignment followed by division. However, operator precedence leads to an incorrect calculation. Fix the code to ensure `totalBudget` is correctly multiplied by `factor` and then divided by `days`.",
      "code": "public class InvestigationBudget {\n    public static void main(String[] args) {\n        double totalBudget = 1000.0;\n        double factor = 1.2;\n        int days = 5;\n        double bonus = 50.0;\n        \n        totalBudget = totalBudget * factor; // Correct: Explicit multiplication\n        totalBudget /= days; // Correct: Compound division\n        totalBudget += bonus;\n        System.out.println(\"Final Budget: $\" + totalBudget);\n    }\n}",
      "expected_output": [
        "Final Budget: $290.0"
      ],
      "hidden_test_case": "",
      "explanation": "The original code `totalBudget *= factor / days;` is equivalent to `totalBudget = totalBudget * (factor / days);`. This first calculates `factor / days` (`1.2 / 5 = 0.24`), then multiplies `totalBudget` by this result (`1000.0 * 0.24 = 240.0`). The intended order was to multiply `totalBudget` by `factor` *before* dividing by `days`. The fix requires breaking down the compound assignment into separate operations (`totalBudget = totalBudget * factor;` and then `totalBudget /= days;`), which correctly performs the calculation `(1000.0 * 1.2) / 5 + 50.0 = 1200.0 / 5 + 50.0 = 240.0 + 50.0 = 290.0`."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Remember that `X op= Y / Z` is equivalent to `X = X op (Y / Z)`. The division `Y / Z` is evaluated *before* the `op` with `X`.",
      "2": "If you intend for multiplication to happen before division, you might need to break down compound assignments or use explicit parentheses in the full expression.",
      "3": "The intended calculation is `(totalBudget * factor) / days + bonus`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 210,
    "subtopic_id": 5,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "An `AuditCodeUpdater` calculates `finalAuditCode` from `transactionCount` and `auditFactor`. The compound assignment has an operator precedence issue, causing subtraction `transactionCount - auditFactor` to occur before multiplication. Fix the code to ensure multiplication happens first.",
      "code": "public class AuditCodeUpdater {\n    public static void main(String[] args) {\n        int finalAuditCode = 100;\n        int transactionCount = 20;\n        int auditFactor = 5;\n        \n        finalAuditCode = (finalAuditCode * transactionCount) - auditFactor; // Correct: Explicit parentheses for precedence\n        \n        System.out.println(\"Final Audit Code: \" + finalAuditCode);\n    }\n}",
      "expected_output": [
        "Final Audit Code: 1995"
      ],
      "hidden_test_case": "",
      "explanation": "The original code `finalAuditCode *= transactionCount - auditFactor;` is equivalent to `finalAuditCode = finalAuditCode * (transactionCount - auditFactor);`. This means `transactionCount - auditFactor` (`20 - 5 = 15`) is evaluated first. Then, `finalAuditCode` is multiplied by `15` (`100 * 15 = 1500`). The intended calculation was `(finalAuditCode * transactionCount) - auditFactor`. The fix involves breaking down the compound assignment into a full assignment: `finalAuditCode = (finalAuditCode * transactionCount) - auditFactor;`, which correctly performs `(100 * 20) - 5 = 2000 - 5 = 1995`."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Compound assignment operators (e.g., `*=`) evaluate the entire expression on their right-hand side first, then apply the compound operation.",
      "2": " `X *= A - B` is equivalent to `X = X * (A - B)`. The subtraction `A - B` happens before the multiplication.",
      "3": "If you want multiplication to happen before subtraction, you need to explicitly group operations."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 211,
    "subtopic_id": 5,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `ReportInitializer` sets the initial `reportStatus`. Complete the simple assignment operator to correctly initialize `reportStatus` to \"Pending\".",
      "code": "public class ReportInitializer {\n    public static void main(String[] args) {\n        String reportStatus ??? \"Pending\";\n        System.out.println(\"Report Status: \" + reportStatus);\n    }\n}",
      "choices": [
        "=",
        "==",
        "+=",
        "-"
      ],
      "answer": [
        "="
      ],
      "explanation": "The simple assignment operator `=` is used to initialize or assign a value to a variable. In this case, it correctly sets `reportStatus` to \"Pending\"."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The goal is to give a variable its very first value.",
      "2": "Which operator is used for simple assignment?",
      "3": "The blank needs a single operation symbol."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 212,
    "subtopic_id": 5,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `ClueLogger` updates `cluesFound` by adding `5` to its current value. Complete the compound assignment operator to correctly add and assign the new total to `cluesFound`.",
      "code": "public class ClueLogger {\n    public static void main(String[] args) {\n        int cluesFound = 10;\n        cluesFound ??? 5;\n        System.out.println(\"Total Clues: \" + cluesFound);\n    }\n}",
      "choices": [
        "+",
        "-",
        "+=",
        "*="
      ],
      "answer": [
        "+="
      ],
      "explanation": "The `+=` operator is a compound assignment operator that adds the value on the right to the variable on the left and assigns the result back. So, `cluesFound += 5;` correctly updates `cluesFound` from `10` to `15`."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The goal is to add a value to `cluesFound` and immediately update `cluesFound` itself.",
      "2": "Which compound assignment operator combines addition and assignment?",
      "3": "The blank needs a single operation symbol."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 213,
    "subtopic_id": 5,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `BudgetReducer` adjusts `investigationBudget` by deducting `travelCost`. Complete the compound assignment operator to correctly subtract and assign the remaining budget.",
      "code": "public class BudgetReducer {\n    public static void main(String[] args) {\n        double investigationBudget = 1000.0;\n        double travelCost = 75.0;\n        investigationBudget ??? travelCost;\n        System.out.println(\"Remaining Budget: $\" + investigationBudget);\n    }\n}",
      "choices": [
        "+",
        "-",
        "-=",
        "/="
      ],
      "answer": [
        "-="
      ],
      "explanation": "The `-=` operator is a compound assignment operator that subtracts the value on the right from the variable on the left and assigns the result back. So, `investigationBudget -= travelCost;` correctly updates `investigationBudget` from `1000.0` to `925.0`."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The goal is to subtract a value from `investigationBudget` and immediately update `investigationBudget` itself.",
      "2": "Which compound assignment operator combines subtraction and assignment?",
      "3": "The blank needs a single operation symbol."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 214,
    "subtopic_id": 5,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `ThreatScaler` adjusts `threatLevel` by multiplying it by a `factor`. Complete the compound assignment operator to correctly scale the `threatLevel`.",
      "code": "public class ThreatScaler {\n    public static void main(String[] args) {\n        int threatLevel = 10;\n        int factor = 2;\n        threatLevel ??? factor;\n        System.out.println(\"Scaled Threat: \" + threatLevel);\n    }\n}",
      "choices": [
        "+",
        "-",
        "*",
        "*="
      ],
      "answer": [
        "*="
      ],
      "explanation": "The `*=` operator is a compound assignment operator that multiplies the variable on the left by the value on the right and assigns the result back. So, `threatLevel *= factor;` correctly updates `threatLevel` from `10` to `20`."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The goal is to multiply `threatLevel` by `factor` and immediately update `threatLevel` itself.",
      "2": "Which compound assignment operator combines multiplication and assignment?",
      "3": "The blank needs a single operation symbol."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 215,
    "subtopic_id": 5,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `PhotoAllocator` distributes `totalPhotos` among `numAnalysts`. Complete the compound assignment operator to correctly divide and assign the photos per analyst.",
      "code": "public class PhotoAllocator {\n    public static void main(String[] args) {\n        int totalPhotos = 18;\n        int numAnalysts = 3;\n        totalPhotos ??? numAnalysts;\n        System.out.println(\"Photos per Analyst: \" + totalPhotos);\n    }\n}",
      "choices": [
        "+",
        "-",
        "/",
        "/="
      ],
      "answer": [
        "/="
      ],
      "explanation": "The `/=` operator is a compound assignment operator that divides the variable on the left by the value on the right and assigns the result back. So, `totalPhotos /= numAnalysts;` correctly updates `totalPhotos` from `18` to `6`."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The goal is to divide `totalPhotos` by `numAnalysts` and immediately update `totalPhotos` itself.",
      "2": "Which compound assignment operator combines division and assignment?",
      "3": "The blank needs a single operation symbol."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 216,
    "subtopic_id": 5,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `BudgetAdjuster` manages `investigationBudget` by adding a `grantFund` and subtracting a `travelCost`. Complete the compound assignment operators to reflect these changes efficiently.",
      "code": "public class BudgetAdjuster {\n    public static void main(String[] args) {\n        double investigationBudget = 1000.0;\n        double grantFund = 250.0;\n        double travelCost = 120.0;\n\n        investigationBudget ??? grantFund;\n        investigationBudget ??? travelCost;\n        System.out.println(\"Adjusted Budget: $\" + investigationBudget);\n    }\n}",
      "choices": [
        "+",
        "-",
        "*",
        "+=",
        "-=",
        "/="
      ],
      "answer": [
        "+=",
        "-="
      ],
      "explanation": "To add `grantFund` to `investigationBudget` and reassign, the `+=` operator (choice d) is used. To subtract `travelCost` from `investigationBudget` and reassign, the `-=` operator (choice e) is used."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The `grantFund` is `added` to the budget, requiring a compound addition operator.",
      "2": "The `travelCost` is `subtracted` from the budget, requiring a compound subtraction operator.",
      "3": "Each blank needs a compound assignment operator."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 217,
    "subtopic_id": 5,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "An `EvidenceScaler` adjusts `evidenceMultiplier` by first multiplying by a `factor` and then dividing by a `divisor`. Complete the compound assignment operators for these sequential updates.",
      "code": "public class EvidenceScaler {\n    public static void main(String[] args) {\n        double evidenceMultiplier = 2.0;\n        double factor = 1.5;\n        int divisor = 3;\n\n        evidenceMultiplier ??? factor;\n        evidenceMultiplier ??? divisor;\n        System.out.println(\"Scaled Multiplier: \" + evidenceMultiplier);\n    }\n}",
      "choices": [
        "*",
        "/",
        "+",
        "*=",
        "/=",
        "%="
      ],
      "answer": [
        "*=",
        "/="
      ],
      "explanation": "To multiply `evidenceMultiplier` by `factor` and reassign, the `*=` operator (choice d) is used. To divide `evidenceMultiplier` by `divisor` and reassign, the `/=` operator (choice e) is used."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The `evidenceMultiplier` is first `increased by a factor` (multiplication).",
      "2": "Then, it's `divided by a divisor`.",
      "3": "Each blank needs a compound assignment operator."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 218,
    "subtopic_id": 5,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `SampleProcessor` processes `totalSamples` in batches. The remaining samples after a batch are determined using the modulo operator and updated in `totalSamples`. Complete the compound assignment operator.",
      "code": "public class SampleProcessor {\n    public static void main(String[] args) {\n        int totalSamples = 37;\n        int batchSize = 10;\n\n        totalSamples ??? batchSize;\n        System.out.println(\"Remaining Samples: \" + totalSamples);\n    }\n}",
      "choices": [
        "+",
        "-",
        "*",
        "/",
        "%",
        "%="
      ],
      "answer": [
        "%="
      ],
      "explanation": "To find the remainder of `totalSamples` divided by `batchSize` and reassign the result, the `%=` operator (choice f) is used. `37 % 10` calculates `7`, and `totalSamples` becomes `7`."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The goal is to find the `remainder` of a division and update `totalSamples`.",
      "2": "Which compound assignment operator combines modulo and assignment?",
      "3": "The blank needs a single compound assignment operator."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 219,
    "subtopic_id": 5,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `DailyReportLogger` tracks `dailyReports` filed. The `dailyReports` count is incremented by 1. Complete the compound assignment operator to efficiently update `dailyReports`.",
      "code": "public class DailyReportLogger {\n    public static void main(String[] args) {\n        int dailyReports = 5;\n        dailyReports ??? 1;\n        System.out.println(\"Daily Reports Filed: \" + dailyReports);\n    }\n}",
      "choices": [
        "+",
        "-",
        "*",
        "+=",
        "++",
        "--"
      ],
      "answer": [
        "+="
      ],
      "explanation": "The `+=` operator is a compound assignment operator that adds the value on the right to the variable on the left and assigns the result back. It's the most concise way to add 1 and reassign within the category of compound assignment operators (`dailyReports += 1;` is equivalent to `dailyReports = dailyReports + 1;`)."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The goal is to increase the variable by `1` and update it.",
      "2": "The blank requires a `compound assignment` operator, which combines an arithmetic operation with assignment.",
      "3": "Consider the operator that adds a value to a variable and assigns the new sum back."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 220,
    "subtopic_id": 5,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "An `AuditSystem` sets `reportStatus` based on `auditComplete`. Complete the declaration of `auditStatus` and its initial value, and the simple assignment operator to update it based on `auditComplete`.",
      "code": "public class AuditSystem {\n    public static void main(String[] args) {\n        boolean auditComplete = true;\n        ??? = ???;\n        \n        if (auditComplete) {\n            auditStatus ??? \"Approved\";\n        }\n        System.out.println(\"Audit Status: \" + auditStatus);\n    }\n}",
      "choices": [
        "auditStatus",
        "\"Pending\"",
        "String auditStatus",
        "boolean auditStatus",
        "=",
        "=="
      ],
      "answer": [
        "String auditStatus",
        "\"Pending\"",
        "="
      ],
      "explanation": "1. `String auditStatus` (choice c) correctly declares the `String` variable.\n2. `\"Pending\"` (choice b) is the `String` literal used to initialize `auditStatus`.\n3. The simple assignment operator `=` (choice e) is used to update `auditStatus` to \"Approved\" inside the `if` block."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The first blank needs the type and name for the `auditStatus` variable, which stores text.",
      "2": "The second blank initializes `auditStatus` to a specific string literal.",
      "3": "The third blank needs the operator for simple assignment (setting the new value)."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 221,
    "subtopic_id": 5,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "An `AuditTrail` tracks `transactionVolume` and determines `auditCompliance`. `transactionVolume` is updated using compound assignments, and `auditCompliance` is set based on a modulo check. Complete the `auditCompliance` declaration and the compound assignment operators.",
      "code": "public class AuditTrail {\n    public static void main(String[] args) {\n        int transactionVolume = 1000;\n        int newBatch = 250;\n        int auditors = 3;\n        ??? auditCompliance;\n\n        transactionVolume ??? newBatch;\n        transactionVolume ??? auditors;\n\n        auditCompliance = (transactionVolume ??? 2 == 0);\n        \n        System.out.println(\"Final Transaction Volume: \" + transactionVolume);\n        System.out.println(\"Audit Compliance: \" + auditCompliance);\n    }\n}",
      "choices": [
        "boolean",
        "+",
        "/",
        "*",
        "+=",
        "/=",
        "%",
        "-"
      ],
      "answer": [
        "boolean",
        "+=",
        "/=",
        "%"
      ],
      "explanation": "1. `boolean` (choice a) is the correct type for `auditCompliance`.\n2. `+=` (choice e) performs compound addition to add `newBatch` to `transactionVolume`.\n3. `/=` (choice f) performs compound division to divide `transactionVolume` by `auditors`.\n4. `%` (choice g) is the modulo operator, used to check if `transactionVolume` is even (`transactionVolume % 2 == 0`)."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The first blank declares a `boolean` variable.",
      "2": " `transactionVolume` first `adds` a `newBatch`, then `divides` by `auditors`. Use the correct compound assignment operators.",
      "3": "The last blank needs the arithmetic operator to check for an even number (remainder is 0)."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 222,
    "subtopic_id": 5,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "An `EvidenceFluctuation` system tracks `evidenceWeight` and determines `sampleStatus`. `evidenceWeight` is updated using compound assignments, and `sampleStatus` is set using a ternary operator. Complete the `sampleStatus` declaration, compound assignments, and the ternary operator symbol.",
      "code": "public class EvidenceFluctuation {\n    public static void main(String[] args) {\n        float evidenceWeight = 100.0f;\n        double purityFactor = 0.85;\n        int contaminantAmount = 5;\n        ??? sampleStatus;\n\n        evidenceWeight ??? purityFactor;\n        evidenceWeight ??? contaminantAmount;\n\n        sampleStatus = (evidenceWeight > 70.0f) ??? 'A' : 'F';\n        \n        System.out.println(\"Final Evidence Weight: \" + evidenceWeight);\n        System.out.println(\"Sample Status: \" + sampleStatus);\n    }\n}",
      "choices": [
        "char",
        "*=",
        "-=",
        "+",
        "/=",
        "?",
        "sampleStatus",
        "weight"
      ],
      "answer": [
        "char",
        "*=",
        "-=",
        "?"
      ],
      "explanation": "1. `char` (choice a) is the correct type for `sampleStatus`.\n2. `*=` (choice b) performs compound multiplication (100.0f * 0.85 = 85.0f).\n3. `-=` (choice c) performs compound subtraction (85.0f - 5 = 80.0f).\n4. `?` (choice f) is the ternary operator symbol, completing the conditional assignment."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The first blank declares a `char` variable.",
      "2": " `evidenceWeight` is first multiplied by `purityFactor`, then `contaminantAmount` is subtracted. Use compound assignment operators.",
      "3": "The last blank completes a ternary (conditional) assignment."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 223,
    "subtopic_id": 5,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `SuspectProfiler` tracks `suspectConfidence` and sets `profileStatus`. `suspectConfidence` is adjusted using compound assignments, and `profileStatus` is set using a ternary operator. Complete the declarations and various compound assignments.",
      "code": "public class SuspectProfiler {\n    public static void main(String[] args) {\n        int suspectConfidence = 100;\n        int penalty = 25;\n        int maxScale = 10;\n        ??? profileStatus;\n        \n        suspectConfidence ???= penalty;\n        suspectConfidence ???= maxScale;\n        \n        ??? = (suspectConfidence > 5) ? \"HIGH RISK\" : \"LOW RISK\";\n        \n        System.out.println(\"Final Confidence: \" + suspectConfidence);\n        System.out.println(\"Profile Status: \" + profileStatus);\n    }\n}",
      "choices": [
        "String",
        "int",
        "-=",
        "%=",
        "profileStatus",
        "status",
        "+",
        "/="
      ],
      "answer": [
        "String",
        "-=",
        "%=",
        "profileStatus"
      ],
      "explanation": "1. `String` (choice a) is the correct type for `profileStatus`.\n2. `-=` (choice c) performs compound subtraction.\n3. `%=` (choice d) performs compound modulo.\n4. `profileStatus` (choice e) is the variable being assigned the result of the ternary operation."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The first blank declares a `String` variable.",
      "2": " `suspectConfidence` is first `reduced by penalty`, then its `remainder when divided by maxScale` is found. Use compound assignment operators.",
      "3": "The last blank is the name of the variable being assigned the ternary result."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 224,
    "subtopic_id": 5,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `SecuritySystem` calculates `securityCode` and sets `securityStatus`. `securityCode` is derived from `baseValue`, `keyModifier`, and `shiftAmount`, involving type casting and arithmetic operations. `securityStatus` is determined by a modulo check. Complete the declarations and arithmetic operators.",
      "code": "public class SecuritySystem {\n    public static void main(String[] args) {\n        int baseValue = 100000;\n        int keyModifier = 50000;\n        int shiftAmount = 10000;\n        ??? securityCode;\n        ??? securityStatus;\n\n        securityCode = (int) ((long)baseValue ??? keyModifier ??? shiftAmount);\n        \n        securityStatus = (securityCode % 2 == 0) ? true : false;\n        \n        System.out.println(\"Final Security Code: \" + securityCode);\n        System.out.println(\"Security Status: \" + securityStatus);\n    }\n}",
      "choices": [
        "int",
        "boolean",
        "*",
        "+",
        "-",
        "/",
        "securityCode",
        "status"
      ],
      "answer": [
        "int",
        "boolean",
        "*",
        "+"
      ],
      "explanation": "1. `int` (choice a) is the correct data type for `securityCode`.\n2. `boolean` (choice b) is the correct data type for `securityStatus`.\n3. The calculation `(long)baseValue ??? keyModifier` needs multiplication (`*`, choice c).\n4. The calculation `(long)baseValue * keyModifier ??? shiftAmount` needs addition (`+`, choice d)."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The `securityCode` holds a whole number.",
      "2": "The `securityStatus` holds a `true`/`false` value.",
      "3": " `securityCode` is derived from `baseValue` multiplied by `keyModifier`, then `shiftAmount` is added. The order `*` then `+` is critical."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 225,
    "subtopic_id": 5,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `PacketAllocator` determines `finalAllocation` and `allocationStatus`. `packetCount` is adjusted using compound assignments, and `allocationStatus` is determined by a modulo check. Complete the declarations and various compound assignment operators.",
      "code": "public class PacketAllocator {\n    public static void main(String[] args) {\n        int packetCount = 150;\n        double distributionFactor = 0.5;\n        int safetyMargin = 10;\n        int dailyQuota = 7;\n        \n        ??? finalAllocation;\n        ??? allocationStatus;\n\n        packetCount ???= distributionFactor;\n        packetCount ???= safetyMargin;\n        \n        finalAllocation = packetCount;\n        allocationStatus = (finalAllocation % dailyQuota == 0);\n        \n        System.out.println(\"Final Allocation: \" + finalAllocation);\n        System.out.println(\"Allocation Status: \" + allocationStatus);\n    }\n}",
      "choices": [
        "int",
        "boolean",
        "*=",
        "-=",
        "/=",
        "%=",
        "finalAllocation",
        "status"
      ],
      "answer": [
        "int",
        "boolean",
        "*=",
        "-="
      ],
      "explanation": "1. `int` (choice a) is the correct type for `finalAllocation`.\n2. `boolean` (choice b) is the correct type for `allocationStatus`.\n3. `*=` (choice c) is the compound multiplication assignment operator. `packetCount` (int) is promoted to `double` for the calculation with `distributionFactor` (double), and the result is implicitly cast back to `int` for assignment (truncating if necessary). `150 * 0.5 = 75.0` -> `75`.\n4. `-=` (choice d) is the compound subtraction assignment operator. `75 - 10 = 65`. `packetCount` is `65`."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The first blank declares an `int` variable for `finalAllocation`.",
      "2": "The second blank declares a `boolean` variable for `allocationStatus`.",
      "3": " `packetCount` is first multiplied by `distributionFactor`. Use the compound assignment for multiplication."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 226,
    "subtopic_id": 5,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `FingerprintMatch` system compares `fingerprintCount` and `expectedPrints`. Your task is to trace the code and determine if the `Fingerprint Counts Match`.",
      "code": "public class FingerprintMatch {\n    public static void main(String[] args) {\n        int fingerprintCount = 10;\n        int expectedPrints = 10;\n        boolean countsMatch = (fingerprintCount == expectedPrints);\n        System.out.println(\"Fingerprint Counts Match: \" + countsMatch);\n    }\n}",
      "choices": [
        "Fingerprint Counts Match: true",
        "Fingerprint Counts Match: false",
        "Error",
        "10"
      ],
      "answer": [
        "Fingerprint Counts Match: true"
      ],
      "explanation": "The `fingerprintCount` (`10`) is compared to `expectedPrints` (`10`) using the `==` operator. Since both values are the same, `fingerprintCount == expectedPrints` evaluates to `true`. The `System.out.println()` then displays \"Fingerprint Counts Match: true\"."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The `==` operator checks if the values on both sides are identical.",
      "2": "Compare `fingerprintCount` to `expectedPrints`.",
      "3": "The result of a comparison operation is always `true` or `false`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 227,
    "subtopic_id": 5,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "An `AgeChecker` determines if a `suspectAge` is `underage` compared to `legalDrinkingAge`. Your task is to trace the code and determine if the `Suspect is Underage`.",
      "code": "public class AgeChecker {\n    public static void main(String[] args) {\n        int suspectAge = 20;\n        int legalDrinkingAge = 21;\n        boolean isUnderage = (suspectAge < legalDrinkingAge);\n        System.out.println(\"Suspect is Underage: \" + isUnderage);\n    }\n}",
      "choices": [
        "Suspect is Underage: true",
        "Suspect is Underage: false",
        "Error",
        "20"
      ],
      "answer": [
        "Suspect is Underage: true"
      ],
      "explanation": "The `suspectAge` (`20`) is compared to `legalDrinkingAge` (`21`) using the `<` operator. Since `20` is less than `21`, `suspectAge < legalDrinkingAge` evaluates to `true`. The `System.out.println()` then displays \"Suspect is Underage: true\"."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The `<` operator checks if the left value is strictly less than the right value.",
      "2": "Compare `suspectAge` to `legalDrinkingAge`.",
      "3": "The result of a comparison operation is always `true` or `false`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 228,
    "subtopic_id": 5,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `DispatchEvaluator` determines if a `crimeSceneDistance` is `tooFar` based on a `responseThreshold`. Your task is to trace the code and determine if the `Crime Scene Too Far` status.",
      "code": "public class DispatchEvaluator {\n    public static void main(String[] args) {\n        double crimeSceneDistance = 15.5;\n        double responseThreshold = 15.0;\n        boolean tooFar = (crimeSceneDistance > responseThreshold);\n        System.out.println(\"Crime Scene Too Far: \" + tooFar);\n    }\n}",
      "choices": [
        "Crime Scene Too Far: true",
        "Crime Scene Too Far: false",
        "Error",
        "15.5"
      ],
      "answer": [
        "Crime Scene Too Far: true"
      ],
      "explanation": "The `crimeSceneDistance` (`15.5`) is compared to `responseThreshold` (`15.0`) using the `>` operator. Since `15.5` is greater than `15.0`, `crimeSceneDistance > responseThreshold` evaluates to `true`. The `System.out.println()` then displays \"Crime Scene Too Far: true\"."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The `>` operator checks if the left value is strictly greater than the right value.",
      "2": "Compare `crimeSceneDistance` to `responseThreshold`.",
      "3": "The result of a comparison is always `true` or `false`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 229,
    "subtopic_id": 5,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `SuspectStatusChecker` determines if a `suspectStatus` is `notArrested` compared to \"Arrested\". Your task is to trace the code and determine if the `Suspect Not Arrested` status.",
      "code": "public class SuspectStatusChecker {\n    public static void main(String[] args) {\n        String suspectStatus = \"Detained\";\n        boolean notArrested = (suspectStatus != \"Arrested\");\n        System.out.println(\"Suspect Not Arrested: \" + notArrested);\n    }\n}",
      "choices": [
        "Suspect Not Arrested: true",
        "Suspect Not Arrested: false",
        "Error",
        "Detained"
      ],
      "answer": [
        "Suspect Not Arrested: true"
      ],
      "explanation": "The `suspectStatus` (`\"Detained\"`) is compared to `\"Arrested\"` using the `!=` operator. Since `\"Detained\"` is indeed not equal to `\"Arrested\"`, `suspectStatus != \"Arrested\"` evaluates to `true`. The `System.out.println()` then displays \"Suspect Not Arrested: true\"."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The `!=` operator checks if the values on both sides are *not* identical.",
      "2": "Compare `suspectStatus` to the literal \"Arrested\".",
      "3": "Remember that `String` literals are compared by content for `!=` and `==` due to interning."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 230,
    "subtopic_id": 5,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "An `EvidenceReliabilityChecker` determines if `evidenceReliability` meets a `minimumStandard`. Your task is to trace the code and determine if the `Evidence is Reliable`.",
      "code": "public class EvidenceReliabilityChecker {\n    public static void main(String[] args) {\n        int evidenceReliability = 7;\n        int minimumStandard = 7;\n        boolean isReliable = (evidenceReliability >= minimumStandard);\n        System.out.println(\"Evidence is Reliable: \" + isReliable);\n    }\n}",
      "choices": [
        "Evidence is Reliable: true",
        "Evidence is Reliable: false",
        "Error",
        "7"
      ],
      "answer": [
        "Evidence is Reliable: true"
      ],
      "explanation": "The `evidenceReliability` (`7`) is compared to `minimumStandard` (`7`) using the `>=` operator. Since `7` is greater than or equal to `7`, `evidenceReliability >= minimumStandard` evaluates to `true`. The `System.out.println()` then displays \"Evidence is Reliable: true\"."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The `>=` operator checks if the left value is greater than or equal to the right value.",
      "2": "Compare `evidenceReliability` to `minimumStandard`.",
      "3": "The result of a comparison is always `true` or `false`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 231,
    "subtopic_id": 5,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `ProfilerComparator` evaluates `suspectAge` against a `riskThreshold` and `knownAlias` against `profileName`. Your task is to trace the code and determine if `Age Meets Risk` and if `Alias is Exact Object Match`.",
      "code": "public class ProfilerComparator {\n    public static void main(String[] args) {\n        int suspectAge = 30;\n        double riskThreshold = 29.5;\n        String knownAlias = \"Shadow\";\n        String profileName = \"Shadow\";\n\n        boolean ageRiskMatch = (suspectAge > riskThreshold);\n        boolean aliasMatchesProfile = (knownAlias == profileName);\n        \n        System.out.println(\"Age Meets Risk: \" + ageRiskMatch);\n        System.out.println(\"Alias is Exact Object Match: \" + aliasMatchesProfile);\n    }\n}",
      "choices": [
        "Age Meets Risk: false",
        "Age Meets Risk: true",
        "Alias is Exact Object Match: false",
        "Alias is Exact Object Match: true"
      ],
      "answer": [
        "Age Meets Risk: true",
        "Alias is Exact Object Match: true"
      ],
      "explanation": "1. `suspectAge` is `30`, `riskThreshold` is `29.5`. `suspectAge > riskThreshold` compares `30` (promoted to `30.0`) to `29.5`. `30.0 > 29.5` is `true`. So, `ageRiskMatch` is `true`.\n2. `knownAlias` is `\"Shadow\"`, `profileName` is `\"Shadow\"`. Since both are `String` literals with identical content, Java performs string interning, making both variables point to the *same* `String` object in memory. Therefore, `knownAlias == profileName` evaluates to `true`.\n3. The first `System.out.println()` prints \"Age Meets Risk: true\".\n4. The second `System.out.println()` prints \"Alias is Exact Object Match: true\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": "When comparing an `int` and a `double`, the `int` is promoted to `double` for the comparison.",
      "2": "For `String` literals that are identical, Java often makes them refer to the same object in memory.",
      "3": "The `==` operator for non-primitive types compares memory addresses."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 232,
    "subtopic_id": 5,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `SuspectVerification` system checks `suspectHeight` against a `profileHeight` and `alibiDetails1` against `alibiDetails2`. Your task is to trace the code and determine if `Height Matches Profile` and if `Alibi Content Matches`.",
      "code": "public class SuspectVerification {\n    public static void main(String[] args) {\n        double suspectHeight = 6.2;\n        double profileHeight = 6.0;\n        String alibiDetails1 = \"At the club.\";\n        String alibiDetails2 = new String(\"At the club.\");\n\n        boolean heightMatches = (suspectHeight >= profileHeight);\n        boolean alibiContentMatch = (alibiDetails1.equals(alibiDetails2));\n        \n        System.out.println(\"Height Matches Profile: \" + heightMatches);\n        System.out.println(\"Alibi Content Matches: \" + alibiContentMatch);\n    }\n}",
      "choices": [
        "Height Matches Profile: false",
        "Height Matches Profile: true",
        "Alibi Content Matches: false",
        "Alibi Content Matches: true"
      ],
      "answer": [
        "Height Matches Profile: true",
        "Alibi Content Matches: true"
      ],
      "explanation": "1. `suspectHeight` is `6.2`, `profileHeight` is `6.0`. `suspectHeight >= profileHeight` compares `6.2` to `6.0`. `6.2 >= 6.0` is `true`. So, `heightMatches` is `true`.\n2. `alibiDetails1` is `\"At the club.\"`, `alibiDetails2` is `new String(\"At the club.\")`. Even though they are different objects in memory (due to `new String()`), their content is identical. The `.equals()` method compares content, so `alibiDetails1.equals(alibiDetails2)` evaluates to `true`.\n3. The first `System.out.println()` prints \"Height Matches Profile: true\".\n4. The second `System.out.println()` prints \"Alibi Content Matches: true\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The `>=` operator checks if the left value is greater than or equal to the right value.",
      "2": "The `.equals()` method for `String` objects compares their actual content.",
      "3": "Even if `alibiDetails2` is a new object, `equals()` will still return true if the text is the same."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 233,
    "subtopic_id": 5,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `CaseStatusEvaluator` checks `clueCount` against `minimumRequired` and `caseID` against `0`. Your task is to trace the code and determine if `Enough Clues Found` and if the `Case ID is Valid`.",
      "code": "public class CaseStatusEvaluator {\n    public static void main(String[] args) {\n        int clueCount = 8;\n        int minimumRequired = 10;\n        int caseID = 101;\n\n        boolean enoughClues = (clueCount >= minimumRequired);\n        boolean isIDValid = (caseID != 0);\n        \n        System.out.println(\"Enough Clues Found: \" + enoughClues);\n        System.out.println(\"Is Case ID Valid: \" + isIDValid);\n    }\n}",
      "choices": [
        "Enough Clues Found: true",
        "Enough Clues Found: false",
        "Is Case ID Valid: true",
        "Is Case ID Valid: false"
      ],
      "answer": [
        "Enough Clues Found: false",
        "Is Case ID Valid: true"
      ],
      "explanation": "1. `clueCount` is `8`, `minimumRequired` is `10`. `clueCount >= minimumRequired` compares `8` to `10`. `8 >= 10` is `false`. So, `enoughClues` is `false`.\n2. `caseID` is `101`. `caseID != 0` compares `101` to `0`. `101 != 0` is `true`. So, `isIDValid` is `true`.\n3. The first `System.out.println()` prints \"Enough Clues Found: false\".\n4. The second `System.out.println()` prints \"Is Case ID Valid: true\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The `>=` operator checks for \"greater than or equal to.\"",
      "2": "The `!=` operator checks for \"not equal to.\"",
      "3": "Evaluate both comparisons based on the given values."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 234,
    "subtopic_id": 5,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `DispatchPriority` system checks `callPriority` and `responseTime`. Your task is to trace the code and determine if the `Call is High Priority` and if the `Response is Fast`.",
      "code": "public class DispatchPriority {\n    public static void main(String[] args) {\n        int callPriority = 5;\n        double responseTime = 1.8;\n\n        boolean isHighPriority = (callPriority == 5);\n        boolean isFastResponse = (responseTime < 2.0);\n        \n        System.out.println(\"Call is High Priority: \" + isHighPriority);\n        System.out.println(\"Response is Fast: \" + isFastResponse);\n    }\n}",
      "choices": [
        "Call is High Priority: true",
        "Call is High Priority: false",
        "Response is Fast: true",
        "Response is Fast: false"
      ],
      "answer": [
        "Call is High Priority: true",
        "Response is Fast: true"
      ],
      "explanation": "1. `callPriority` is `5`. `callPriority == 5` compares `5` to `5`. This is `true`. So, `isHighPriority` is `true`.\n2. `responseTime` is `1.8`. `responseTime < 2.0` compares `1.8` to `2.0`. `1.8 < 2.0` is `true`. So, `isFastResponse` is `true`.\n3. The first `System.out.println()` prints \"Call is High Priority: true\".\n4. The second `System.out.println()` prints \"Response is Fast: true\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The `==` operator checks for exact equality.",
      "2": "The `<` operator checks for strictly less than.",
      "3": "Evaluate both comparisons based on the values provided."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 235,
    "subtopic_id": 5,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "An `EvidenceValidator` checks `evidenceWeight` against `minWeightRequired` and `suspectID` against `0`. Your task is to trace the code and determine if `Weight Meets Standard` and if the `Suspect ID is Valid`.",
      "code": "public class EvidenceValidator {\n    public static void main(String[] args) {\n        double evidenceWeight = 1.0;\n        double minWeightRequired = 1.0;\n        int suspectID = 0;\n        \n        boolean weightMeetsStandard = (evidenceWeight >= minWeightRequired);\n        boolean isSuspectIDValid = (suspectID != 0);\n        \n        System.out.println(\"Weight Meets Standard: \" + weightMeetsStandard);\n        System.out.println(\"Suspect ID is Valid: \" + isSuspectIDValid);\n    }\n}",
      "choices": [
        "Weight Meets Standard: false",
        "Weight Meets Standard: true",
        "Suspect ID is Valid: false",
        "Suspect ID is Valid: true"
      ],
      "answer": [
        "Weight Meets Standard: true",
        "Suspect ID is Valid: false"
      ],
      "explanation": "1. `evidenceWeight` is `1.0`, `minWeightRequired` is `1.0`. `evidenceWeight >= minWeightRequired` compares `1.0` to `1.0`. This is `true`. So, `weightMeetsStandard` is `true`.\n2. `suspectID` is `0`. `suspectID != 0` compares `0` to `0`. This is `false`. So, `isSuspectIDValid` is `false`.\n3. The first `System.out.println()` prints \"Weight Meets Standard: true\".\n4. The second `System.out.println()` prints \"Suspect ID is Valid: false\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The `>=` operator checks for \"greater than or equal to.\"",
      "2": "The `!=` operator checks for \"not equal to.\"",
      "3": "Evaluate both comparisons based on the values provided."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 236,
    "subtopic_id": 5,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `ForensicCrossReference` compares `dnaSampleID`s and `fingerprintMatchPercentage` to determine `exactIDMatch`, `highConfidenceMatch`, and `auditRequired`. Your task is to trace the code and determine these boolean statuses.",
      "code": "public class ForensicCrossReference {\n    public static void main(String[] args) {\n        long dnaSampleID1 = 123456789123L;\n        long dnaSampleID2 = 123456789123L;\n        double fingerprintMatchPercentage = 99.99999999999999;\n        double threshold = 100.0;\n\n        boolean exactIDMatch = (dnaSampleID1 == dnaSampleID2);\n        \n        boolean highConfidenceMatch = (fingerprintMatchPercentage >= threshold);\n        \n        boolean auditRequired = (exactIDMatch || fingerprintMatchPercentage != threshold);\n        \n        System.out.println(\"Exact ID Match: \" + exactIDMatch);\n        System.out.println(\"High Confidence Match: \" + highConfidenceMatch);\n        System.out.println(\"Audit Required: \" + auditRequired);\n    }\n}",
      "choices": [
        "Exact ID Match: true",
        "High Confidence Match: true",
        "High Confidence Match: false",
        "Audit Required: true"
      ],
      "answer": [
        "Exact ID Match: true",
        "High Confidence Match: false",
        "Audit Required: true"
      ],
      "explanation": "1. `dnaSampleID1` and `dnaSampleID2` are identical `long` values. `exactIDMatch = (dnaSampleID1 == dnaSampleID2)` is `true`.\n2. `fingerprintMatchPercentage` is `99.99999999999999`, `threshold` is `100.0`. Due to inherent floating-point precision, `99.99999999999999` is not exactly `100.0`. `fingerprintMatchPercentage >= threshold` is `false`.\n3. `auditRequired = (exactIDMatch || fingerprintMatchPercentage != threshold);` evaluates `(true || (99.99999999999999 != 100.0))`. `99.99999999999999 != 100.0` is `true`. So `true || true` is `true`.\n4. **Outputs:** `Exact ID Match: true`, `High Confidence Match: false`, `Audit Required: true`."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Comparing `long` values with `==` is straightforward. The `fingerprintMatchPercentage` is a `double` and comparison with `threshold` is tricky due to precision.",
      "2": "Floating-point numbers (like `double`) can have tiny internal inaccuracies, making direct `==` or `>=` comparisons with seemingly equal values unreliable.",
      "3": "Evaluate the logical `OR` (`||`) operator. If the first operand is `true`, the second one isn't even checked."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 237,
    "subtopic_id": 5,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `SuspectInterview` evaluates `responseTime` and `alibiEvidence` to determine `responseTimely`, `strongEvidence`, and `finalVerdict`. The code involves floating-point comparison and `null` checks for strings. Your task is to trace the code and determine these boolean statuses.",
      "code": "public class SuspectInterview {\n    public static void main(String[] args) {\n        int interviewMinutes = 15;\n        float preparationFactor = 0.5f;\n        double strictDeadline = 7.5;\n        String alibiEvidence = null;\n        \n        float suspectResponseTime = interviewMinutes / preparationFactor;\n        \n        boolean responseTimely = (suspectResponseTime <= strictDeadline);\n        \n        boolean strongEvidence = (alibiEvidence != null && alibiEvidence.length() > 0);\n        \n        boolean finalVerdict = (responseTimely || strongEvidence);\n        \n        System.out.println(\"Response Timely: \" + responseTimely);\n        System.out.println(\"Strong Evidence: \" + strongEvidence);\n        System.out.println(\"Final Verdict: \" + finalVerdict);\n    }\n}",
      "choices": [
        "Response Timely: true",
        "Response Timely: false",
        "Strong Evidence: false",
        "Final Verdict: false"
      ],
      "answer": [
        "Response Timely: false",
        "Strong Evidence: false",
        "Final Verdict: false"
      ],
      "explanation": "1. `interviewMinutes = 15`, `preparationFactor = 0.5f`, `strictDeadline = 7.5`, `alibiEvidence = null`.\n2. `float suspectResponseTime = interviewMinutes / preparationFactor;` calculates `15 / 0.5f = 30.0f`.\n3. `boolean responseTimely = (suspectResponseTime <= strictDeadline);` compares `30.0f` (promoted to `double`) to `7.5d`. `30.0d <= 7.5d` is `false`. `responseTimely` is `false`.\n4. `boolean strongEvidence = (alibiEvidence != null && alibiEvidence.length() > 0);`\n    * `alibiEvidence != null` is `null != null`, which is `false`.\n    * Due to short-circuiting of `&&`, `alibiEvidence.length()` is *not* evaluated. `strongEvidence` is `false`.\n5. `boolean finalVerdict = (responseTimely || strongEvidence);` evaluates `false || false`, which is `false`. `finalVerdict` is `false`.\n6. **Outputs:** `Response Timely: false`, `Strong Evidence: false`, `Final Verdict: false`."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Perform the division for `suspectResponseTime`, noting `int` divided by `float` results in a `float`.",
      "2": "When comparing a `float` to a `double`, the `float` promotes to `double` for the comparison.",
      "3": "The `null` check `!= null` for `alibiEvidence` is critical before the `length()` call. Understand `&&` short-circuiting."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 238,
    "subtopic_id": 5,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `DispatchPrioritySystem` determines `isUrgentCall`, `requiresBackup`, and `dispatchDecision` based on `emergencyCallRank`, `callerProfile`, and `incidentSeverity` using logical operators with precedence. Your task is to trace the code and determine these boolean statuses.",
      "code": "public class DispatchPrioritySystem {\n    public static void main(String[] args) {\n        int emergencyCallRank = 8;\n        int callerProfile = 5;\n        int incidentSeverity = 7;\n        \n        boolean isUrgentCall = (emergencyCallRank >= 8 || incidentSeverity >= 9);\n        \n        boolean requiresBackup = (isUrgentCall && callerProfile >= 5 || incidentSeverity == 10);\n        \n        boolean dispatchDecision = (isUrgentCall && requiresBackup && callerProfile > 3);\n        \n        System.out.println(\"Is Urgent Call: \" + isUrgentCall);\n        System.out.println(\"Requires Backup: \" + requiresBackup);\n        System.out.println(\"Dispatch Decision: \" + dispatchDecision);\n    }\n}",
      "choices": [
        "Is Urgent Call: true",
        "Requires Backup: false",
        "Dispatch Decision: true",
        "Requires Backup: true"
      ],
      "answer": [
        "Is Urgent Call: true",
        "Requires Backup: true",
        "Dispatch Decision: true"
      ],
      "explanation": "1. `emergencyCallRank = 8`, `callerProfile = 5`, `incidentSeverity = 7`.\n2. `boolean isUrgentCall = (emergencyCallRank >= 8 || incidentSeverity >= 9);`\n    * `8 >= 8` is `true`.\n    * `7 >= 9` is `false`.\n    * `true || false` is `true`. `isUrgentCall` is `true`.\n3. `boolean requiresBackup = (isUrgentCall && callerProfile >= 5 || incidentSeverity == 10);`\n    * `isUrgentCall && callerProfile >= 5`: `true && (5 >= 5)` (`true && true`) is `true`.\n    * `incidentSeverity == 10`: `7 == 10` is `false`.\n    * `true || false` is `true`. `requiresBackup` is `true`.\n4. `boolean dispatchDecision = (isUrgentCall && requiresBackup && callerProfile > 3);`\n    * `isUrgentCall && requiresBackup`: `true && true` is `true`.\n    * `callerProfile > 3`: `5 > 3` is `true`.\n    * `true && true` is `true`. `dispatchDecision` is `true`.\n5. All three `System.out.println()` statements display the final values."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Evaluate `isUrgentCall` first: `emergencyCallRank >= 8 || incidentSeverity >= 9`.",
      "2": "Evaluate `requiresBackup`: remember `&&` has higher precedence than `||`. This means `(isUrgentCall && callerProfile >= 5)` is evaluated first, then `|| incidentSeverity == 10`.",
      "3": "Finally, evaluate `dispatchDecision` which uses `&&` exclusively."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 239,
    "subtopic_id": 5,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `CipherKeyValidator` processes `cipherKey1` and `cipherKey2` (derived from `cipherKey1` using string methods), and checks `keyStrength` against a `highStrengthThreshold`. Your task is to trace the code and determine if `Are Keys Identical (Ref)`, `Are Keys Same Content`, and `Is Strength High`.",
      "code": "public class CipherKeyValidator {\n    public static void main(String[] args) {\n        String cipherKey1 = \"SECURE_ALPHA\";\n        String cipherKey2 = cipherKey1.substring(0, 6).toLowerCase() + \"_beta\";\n        float keyStrength = 99.9999f;\n        float highStrengthThreshold = 100.0f;\n\n        boolean areKeysIdentical = (cipherKey1 == cipherKey2);\n        boolean areKeysSameContent = (cipherKey1.equals(cipherKey2));\n        boolean isStrengthHigh = (keyStrength > highStrengthThreshold);\n        \n        System.out.println(\"Are Keys Identical (Ref): \" + areKeysIdentical);\n        System.out.println(\"Are Keys Same Content: \" + areKeysSameContent);\n        System.out.println(\"Is Strength High: \" + isStrengthHigh);\n    }\n}\n",
      "choices": [
        "Are Keys Identical (Ref): false",
        "Are Keys Same Content: true",
        "Are Keys Same Content: false",
        "Is Strength High: false"
      ],
      "answer": [
        "Are Keys Identical (Ref): false",
        "Are Keys Same Content: false",
        "Is Strength High: false"
      ],
      "explanation": "1. `cipherKey1 = \"SECURE_ALPHA\"`.\n2. `cipherKey2 = cipherKey1.substring(0, 6).toLowerCase() + \"_beta\";`\n    * `substring(0, 6)`: \"SECURE\".\n    * `toLowerCase()`: \"secure\".\n    * `\"secure\" + \"_beta\"`: \"secure_beta\". So `cipherKey2` is \"secure_beta\".\n3. `boolean areKeysIdentical = (cipherKey1 == cipherKey2);` compares `\"SECURE_ALPHA\"` to `\"secure_beta\"`. They are different `String` objects and different content, so `false`.\n4. `boolean areKeysSameContent = (cipherKey1.equals(cipherKey2));` compares `\"SECURE_ALPHA\"` to `\"secure_beta\"`. Content is different, so `false`.\n5. `float keyStrength = 99.9999f`, `highStrengthThreshold = 100.0f`. `keyStrength > highStrengthThreshold` is `99.9999f > 100.0f`, which is `false`.\n6. **Outputs:** `Are Keys Identical (Ref): false`, `Are Keys Same Content: false`, `Is Strength High: false`."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Trace the creation of `cipherKey2` through its string methods.",
      "2": "Distinguish between `==` (reference comparison) and `.equals()` (content comparison) for `String` objects.",
      "3": "Evaluate the float comparison precisely: `99.9999f` vs `100.0f`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 240,
    "subtopic_id": 5,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A `SceneReconstruction` system determines `accuracyMeetsStandard`, `alibiConsistency`, and `finalVerdict` based on floating-point accuracy and time range checks. Your task is to trace the code and determine these boolean statuses.",
      "code": "public class SceneReconstruction {\n    public static void main(String[] args) {\n        double reconstructionAccuracy = 99.9999999;\n        float idealPrecision = 100.0f;\n        int alibiStartTime = 1000;\n        int alibiEndTime = 1100;\n        int crimeTime = 1030;\n\n        boolean accuracyMeetsStandard = (reconstructionAccuracy >= idealPrecision);\n        \n        boolean alibiConsistency = (crimeTime >= alibiStartTime && crimeTime <= alibiEndTime);\n        \n        boolean finalVerdict = (accuracyMeetsStandard && alibiConsistency);\n        \n        System.out.println(\"Accuracy Meets Standard: \" + accuracyMeetsStandard);\n        System.out.println(\"Alibi Consistency: \" + alibiConsistency);\n        System.out.println(\"Final Verdict: \" + finalVerdict);\n    }\n}",
      "choices": [
        "Accuracy Meets Standard: true",
        "Accuracy Meets Standard: false",
        "Alibi Consistency: true",
        "Final Verdict: false"
      ],
      "answer": [
        "Accuracy Meets Standard: false",
        "Alibi Consistency: true",
        "Final Verdict: false"
      ],
      "explanation": "1. `reconstructionAccuracy = 99.9999999`, `idealPrecision = 100.0f`.\n2. `boolean accuracyMeetsStandard = (reconstructionAccuracy >= idealPrecision);` compares `99.9999999` (double) to `100.0f` (float, promoted to double). Due to precision differences, `99.9999999` is *not* greater than or equal to `100.0`. So, `accuracyMeetsStandard` is `false`.\n3. `boolean alibiConsistency = (crimeTime >= alibiStartTime && crimeTime <= alibiEndTime);`\n    * `crimeTime >= alibiStartTime`: `1030 >= 1000` is `true`.\n    * `crimeTime <= alibiEndTime`: `1030 <= 1100` is `true`.\n    * `true && true` is `true`. So, `alibiConsistency` is `true`.\n4. `boolean finalVerdict = (accuracyMeetsStandard && alibiConsistency);` evaluates `false && true`, which is `false`. So, `finalVerdict` is `false`.\n5. **Outputs:** `Accuracy Meets Standard: false`, `Alibi Consistency: true`, `Final Verdict: false`."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Compare `reconstructionAccuracy` (double) to `idealPrecision` (float, which promotes to double). Be aware of floating-point precision issues.",
      "2": "Evaluate the `alibiConsistency` condition: it combines two comparisons with `&&`.",
      "3": "The `finalVerdict` is an `AND` of the first two boolean results."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 241,
    "subtopic_id": 5,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `SuspectMatcher` compares `suspectAlias` to `\"Phantom\"`. The code incorrectly uses the assignment operator `=` within the `if` condition, leading to a compilation error. Fix the code to correctly compare the content of the strings.",
      "code": "public class SuspectMatcher {\n    public static void main(String[] args) {\n        String suspectAlias = \"Shadow\";\n        if (suspectAlias.equals(\"Phantom\")) { // Correct: Use .equals() for content comparison\n            System.out.println(\"Suspect is Phantom.\");\n        } else {\n            System.out.println(\"Suspect is not Phantom.\");\n        }\n    }\n}",
      "expected_output": [
        "Suspect is not Phantom."
      ],
      "hidden_test_case": "",
      "explanation": "The original code `if (suspectAlias = \"Phantom\")` attempts to use the assignment operator `=` within the `if` condition. This is a common mistake; it actually tries to assign \"Phantom\" to `suspectAlias` (which would compile but often not work as intended for a String comparison inside an if) and then evaluate the result of that assignment. For content comparison of `String` objects, the `.equals()` method is required. The fix replaces `=` with `.equals()` to correctly check if the content of `suspectAlias` is \"Phantom\"."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The `=` operator assigns a value, it doesn't check for equality.",
      "2": "An `if` statement needs a condition that evaluates to `true` or `false`.",
      "3": "For `String` content comparison, a specific method is usually preferred over `==`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 242,
    "subtopic_id": 5,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `WitnessAgeChecker` determines if `witnessAge` is `exactly 25`. However, the code uses `>` operator, making it check for strictly greater than 25, leading to an incorrect output. Fix the code to correctly check for exact age.",
      "code": "public class WitnessAgeChecker {\n    public static void main(String[] args) {\n        int witnessAge = 25;\n        if (witnessAge == 25) { // Correct: Use == for exact equality\n            System.out.println(\"Witness is exactly 25.\"); // Corrected output message\n        } else {\n            System.out.println(\"Witness is not 25.\"); // Corrected output message\n        }\n    }\n}",
      "expected_output": [
        "Witness is exactly 25."
      ],
      "hidden_test_case": "",
      "explanation": "The original code `if (witnessAge > 25)` checks if `witnessAge` is strictly greater than `25`. Since `witnessAge` is `25`, this condition is `false`, leading to the `else` block. The intent was to check for exact equality. The fix is to use the `==` operator, which correctly evaluates `25 == 25` as `true`, leading to the desired output."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The `>` operator means \"strictly greater than.\"",
      "2": "The goal is to check for an *exact* match.",
      "3": "Which comparison operator checks if two values are precisely the same?"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 243,
    "subtopic_id": 5,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `CrimeRadiusChecker` determines if `crimeRadius` is `very close` (less than or equal to 5.0 miles). However, the code uses `<` operator, making it check for strictly less than 5.0, leading to an incorrect output. Fix the code to correctly include 5.0 miles in the \"very close\" category.",
      "code": "public class CrimeRadiusChecker {\n    public static void main(String[] args) {\n        double crimeRadius = 5.0;\n        if (crimeRadius <= 5.0) { // Correct: Use <= to include 5.0\n            System.out.println(\"Crime scene is very close.\");\n        } else {\n            System.out.println(\"Crime scene is farther.\"); // Corrected output message\n        }\n    }\n}",
      "expected_output": [
        "Crime scene is very close."
      ],
      "hidden_test_case": "",
      "explanation": "The original code `if (crimeRadius < 5.0)` checks if `crimeRadius` is strictly less than `5.0`. Since `crimeRadius` is exactly `5.0`, this condition is `false`, leading to the `else` block. The intent was to include `5.0` as \"very close.\" The fix is to use the `<=` operator, which correctly evaluates `5.0 <= 5.0` as `true`, leading to the desired output."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The `<` operator means \"strictly less than.\"",
      "2": "The goal is to include the boundary value (`5.0`) in the \"close\" category.",
      "3": "Which comparison operator means \"less than or equal to\"?"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 244,
    "subtopic_id": 5,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "An `AlibiVerification` system checks if `alibiTime` is `at or after` a `startTime`. However, the code uses `>` operator, making it check for strictly after start time, leading to an incorrect output. Fix the code to correctly include the `startTime` in the verification.",
      "code": "public class AlibiVerification {\n    public static void main(String[] args) {\n        int alibiTime = 1000;\n        int startTime = 1000;\n        if (alibiTime >= startTime) { // Correct: Use >= to include start time\n            System.out.println(\"Alibi is at or after start time.\");\n        }\n        else {\n            System.out.println(\"Alibi is before start time.\"); // Corrected output message\n        }\n    }\n}",
      "expected_output": [
        "Alibi is at or after start time."
      ],
      "hidden_test_case": "",
      "explanation": "The original code `if (alibiTime > startTime)` checks if `alibiTime` is strictly greater than `startTime`. Since `alibiTime` is exactly `startTime` (`1000`), this condition is `false`, leading to the `else` block. The intent was to include `startTime` in the true condition. The fix is to use the `>=` operator, which correctly evaluates `1000 >= 1000` as `true`, leading to the desired output."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The `>` operator means \"strictly greater than.\"",
      "2": "The goal is to include the `startTime` itself in the \"at or after\" category.",
      "3": "Which comparison operator means \"greater than or equal to\"?"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 245,
    "subtopic_id": 5,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `ReportIDValidator` checks if a `reportID` is `valid` (not equal to 0). However, the code incorrectly checks for equality to 0, leading to an incorrect output. Fix the code to correctly validate the `reportID`.",
      "code": "public class ReportIDValidator {\n    public static void main(String[] args) {\n        int reportID = 123;\n        if (reportID != 0) { // Correct: Use != for not equal to\n            System.out.println(\"Report ID is valid.\");\n        } else {\n            System.out.println(\"Report ID is invalid.\");\n        }\n    }\n}",
      "expected_output": [
        "Report ID is valid."
      ],
      "hidden_test_case": "",
      "explanation": "The original code `if (reportID == 0)` checks if `reportID` is exactly `0`. Since `reportID` is `123`, this condition is `false`, leading to the `else` block, incorrectly printing \"Report ID is invalid.\" The intent was to check if the ID is *not* `0`. The fix is to use the `!=` operator, which correctly evaluates `123 != 0` as `true`, leading to the desired output."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The `==` operator checks if two values are identical.",
      "2": "The goal is to verify if the `reportID` is *not* `0`.",
      "3": "Which comparison operator means \"not equal to\"?"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 246,
    "subtopic_id": 5,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "An `AlibiVerifier` compares `suspectAlibi` (literal) and `clubRecord` (new `String` object). The code incorrectly uses `==` for comparison, leading to an `Alibi is suspicious` output when content is identical. Fix the code to correctly compare the textual content.",
      "code": "public class AlibiVerifier {\n    public static void main(String[] args) {\n        String suspectAlibi = \"At the Club\";\n        String clubRecord = new String(\"At the Club\");\n        \n        if (suspectAlibi.equals(clubRecord)) { // Correct: Use .equals() for content comparison\n            System.out.println(\"Alibi is verified.\");\n        } else {\n            System.out.println(\"Alibi is suspicious.\");\n        }\n    }\n}",
      "expected_output": [
        "Alibi is verified."
      ],
      "hidden_test_case": "",
      "explanation": "The original code uses `==` to compare `suspectAlibi` and `clubRecord`. While `suspectAlibi` points to a string literal, `clubRecord` (created with `new String()`) points to a *different* object in memory, even though their contents are the same. Therefore, `suspectAlibi == clubRecord` evaluates to `false`. To correctly compare the textual content, the `.equals()` method is required, which returns `true` because \"At the Club\" is equal to \"At the Club\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": "For non-primitive types like `String`, the `==` operator compares memory *references* (do they point to the exact same object?).",
      "2": " `new String(\"...\")` *always* creates a new object in memory, even if its content is identical to another string.",
      "3": "To compare the *actual text* inside two `String` objects, a specific method must be used."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 247,
    "subtopic_id": 5,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `CollectionRateChecker` calculates `collectionRate` and attempts to check for exact equality with `0.3f`. Due to floating-point precision, this direct comparison may fail. Fix the code to robustly compare the `collectionRate` for practical equality.",
      "code": "public class CollectionRateChecker {\n    public static void main(String[] args) {\n        float totalItems = 3.0f;\n        float totalDays = 10.0f;\n        float collectionRate = totalItems / totalDays;\n        \n        if (Math.abs(collectionRate - 0.3f) < 0.000001f) { // Correct: Use epsilon comparison for floating-point equality\n            System.out.println(\"Collection rate is precise.\");\n        } else {\n            System.out.println(\"Collection rate has minor deviation.\");\n        }\n    }\n}",
      "expected_output": [
        "Collection rate is precise."
      ],
      "hidden_test_case": "",
      "explanation": "The calculation `3.0f / 10.0f` results in `0.3f`. However, due to the nature of floating-point representation, `0.3` often cannot be perfectly represented in binary, leading to a tiny precision error when stored. Therefore, `collectionRate == 0.3f` might evaluate to `false` even if mathematically they should be equal. The fix involves comparing `collectionRate` to `0.3f` within a small acceptable margin (epsilon) using `Math.abs(difference) < epsilon`, which robustly handles these precision issues."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Floating-point numbers (`float` and `double`) cannot always perfectly represent decimal values in binary, leading to tiny inaccuracies.",
      "2": "Direct equality (`==`) comparison with `float` or `double` is often unreliable for values that are results of calculations.",
      "3": "A common way to compare floating-point numbers for \"equality\" is to check if their difference is smaller than a very small acceptable margin (epsilon)."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 248,
    "subtopic_id": 5,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `WitnessEligibility` system checks if `witnessAge` is `18 or older`. However, the code uses `>` operator, leading to an incorrect output for a witness exactly 18. Fix the code to correctly include the age 18 in the eligible category.",
      "code": "public class WitnessEligibility {\n    public static void main(String[] args) {\n        int witnessAge = 18;\n        if (witnessAge >= 18) { // Correct: Use >= to include 18\n            System.out.println(\"Witness is eligible.\");\n        } else {\n            System.out.println(\"Witness is not eligible.\");\n        }\n    }\n}",
      "expected_output": [
        "Witness is eligible."
      ],
      "hidden_test_case": "",
      "explanation": "The original code `if (witnessAge > 18)` checks if `witnessAge` is strictly greater than `18`. Since `witnessAge` is `18`, this condition is `false`, leading to the `else` block. The intent was to include `18` as eligible. The fix is to use the `>=` operator, which correctly evaluates `18 >= 18` as `true`, leading to the desired output."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The `>` operator only checks if a value is strictly larger.",
      "2": "The phrase \"18 or older\" implies including the number `18` itself.",
      "3": "Which comparison operator means \"greater than or equal to\"?"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 249,
    "subtopic_id": 5,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "An `EvidenceTagSorter` compares `tagID1` and `tagID2`. The code uses `<` operator, making it check for strictly less than, leading to an incorrect output when IDs are the same. Fix the code to correctly categorize tags as `same as or before` another.",
      "code": "public class EvidenceTagSorter {\n    public static void main(String[] args) {\n        int tagID1 = 50;\n        int tagID2 = 50;\n        if (tagID1 <= tagID2) { // Correct: Use <= to include equality\n            System.out.println(\"Tag 1 comes before or is same as Tag 2.\");\n        } else {\n            System.out.println(\"Tag 1 comes after Tag 2.\"); // Corrected output message\n        }\n    }\n}",
      "expected_output": [
        "Tag 1 comes before or is same as Tag 2."
      ],
      "hidden_test_case": "",
      "explanation": "The original code `if (tagID1 < tagID2)` checks if `tagID1` is strictly less than `tagID2`. Since both IDs are `50`, this condition is `false`, leading to the `else` block. The intent was to include equality as part of the true condition (\"Tag 1 comes before or is same as Tag 2\"). The fix is to use the `<=` operator, which correctly evaluates `50 <= 50` as `true`, leading to the desired output."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The `<` operator means \"strictly less than.\"",
      "2": "The phrase \"less than or equal to\" implies including the case where values are identical.",
      "3": "Which comparison operator specifically includes equality in a \"less than\" check?"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 250,
    "subtopic_id": 5,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `SceneTemperatureChecker` calculates `sceneTemperature` and checks for exact equality with `25.0`. Due to potential floating-point inaccuracies, direct comparison might fail. Fix the code to robustly compare `sceneTemperature` for practical equality.",
      "code": "public class SceneTemperatureChecker {\n    public static void main(String[] args) {\n        double sceneTemperature = 200.0 / 8.0;\n        if (Math.abs(sceneTemperature - 25.0) < 0.0000001) { // Correct: Use epsilon comparison for floating-point equality\n            System.out.println(\"Temperature is exact.\");\n        } else {\n            System.out.println(\"Temperature has slight deviation.\");\n        }\n    }\n}",
      "expected_output": [
        "Temperature is exact."
      ],
      "hidden_test_case": "",
      "explanation": "The calculation `200.0 / 8.0` is mathematically `25.0`. However, due to how `double` (and `float`) numbers are represented in binary, direct equality (`==`) comparisons can fail if there are tiny, imperceptible precision differences. While `25.0` *is* perfectly representable in binary, this challenge tests the general rule. The robust way to compare floating-point numbers for practical equality is to check if their absolute difference is smaller than a very small positive number (epsilon, like `0.0000001`). The fix uses `Math.abs(sceneTemperature - 25.0) < 0.0000001`."
    },
    "difficulty": "medium",
    "hints": {
      "1": "While `200.0 / 8.0` is mathematically `25.0`, internal binary floating-point representation can sometimes introduce tiny, invisible inaccuracies.",
      "2": "Direct equality (`==`) comparison of `double` values is generally unreliable if the values are results of calculations.",
      "3": "Use the `Math.abs()` method to check if the absolute difference between two numbers is less than a very small \"epsilon\" value."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 251,
    "subtopic_id": 5,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `TransactionVerifier` compares `transactionAmount` (float) and `expectedAmount` (double). Due to different precision, a direct `==` comparison fails. Fix the code to robustly compare these floating-point amounts for practical equality.",
      "code": "public class TransactionVerifier {\n    public static void main(String[] args) {\n        float transactionAmount = 100.0f / 3.0f;\n        double expectedAmount = 100.0 / 3.0;\n        \n        if (Math.abs(transactionAmount - expectedAmount) < 0.000001) { // Correct: Use Math.abs with an epsilon\n            System.out.println(\"Amounts are an exact match.\");\n        } else {\n            System.out.println(\"Amounts have a slight discrepancy.\");\n        }\n    }\n}",
      "expected_output": [
        "Amounts are an exact match."
      ],
      "hidden_test_case": "",
      "explanation": "The calculation `100.0f / 3.0f` results in a `float` value (`33.333332f`), while `100.0 / 3.0` results in a more precise `double` value (`33.333333333333336d`). Even though they are conceptually the same number, their internal binary representations differ. Directly comparing them with `==` will return `false`. The fix involves using `Math.abs()` to check if the absolute difference between `transactionAmount` and `expectedAmount` is less than a very small \"epsilon\" value (e.g., `0.000001`), which correctly identifies them as practically equal."
    },
    "difficulty": "hard",
    "hints": {
      "1": "`float` provides less precision than `double`. Calculations involving `float`s can lead to different results than the same calculation with `double`s, even if mathematically identical.",
      "2": "Direct equality (`==`) comparisons between `float` and `double` values are highly unreliable due to these precision differences.",
      "3": "To accurately compare two floating-point numbers for practical equality, you should check if their absolute difference is extremely small."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 252,
    "subtopic_id": 5,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `SuspectIdentityVerifier` compares `suspectName` (literal) and `profileName` (created with `toUpperCase()`). The code uses `==` for String comparison and assigns `true` to `discrepancyFound` inside the `if` condition. Fix the code to correctly compare String content and ensure `discrepancyFound` is initialized and updated properly.",
      "code": "public class SuspectIdentityVerifier {\n    public static void main(String[] args) {\n        String suspectName = \"JOHN DOE\";\n        String profileName = \"John Doe\".toUpperCase();\n        boolean discrepancyFound; // Correct: Declare outside if-else\n        \n        if (suspectName.equals(profileName)) { // Correct: Use .equals() for content comparison\n            System.out.println(\"Identity verified.\");\n            discrepancyFound = false; // Correct: Assign in this branch\n        } else {\n            System.out.println(\"Identity suspicious.\");\n            discrepancyFound = true; // Correct: Assign in this branch\n        }\n        System.out.println(\"Discrepancy Found: \" + discrepancyFound);\n    }\n}",
      "expected_output": [
        "Identity verified.",
        "Discrepancy Found: false"
      ],
      "hidden_test_case": "",
      "explanation": "The original code has two problems:\n1.  **String comparison:** `suspectName` is a literal `\"JOHN DOE\"`, while `profileName` (`\"John Doe\".toUpperCase()`) creates a *new* `String` object, even though its content also becomes `\"JOHN DOE\"`. Using `==` compares their memory addresses, so `suspectName == profileName` evaluates to `false`. The fix is to use `.equals()` for content comparison.\n2.  **Uninitialized local variable:** `discrepancyFound` is declared *inside* the `if` and `else` blocks. This makes it a local variable within those blocks, and it's not accessible outside. Even if it were declared outside, Java's compiler requires it to be *definitely assigned* in all branches before use. The fix declares `discrepancyFound` outside the `if-else` block and assigns it in both branches, ensuring it's always initialized."
    },
    "difficulty": "hard",
    "hints": {
      "1": "For `String` objects, the `==` operator compares memory addresses, not the actual text content.",
      "2": "Methods like `.toUpperCase()` on a `String` often return a *new* `String` object.",
      "3": "To compare `String` content, always use the `.equals()` method."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 253,
    "subtopic_id": 5,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "An `EvidenceRangeChecker` verifies if `rawEvidenceLevel` is `between 50 and 100` (inclusive). The code incorrectly uses logical `OR` (`||`), making the range check too permissive. Fix the code to use the correct logical operator for a strict range check.",
      "code": "public class EvidenceRangeChecker {\n    public static void main(String[] args) {\n        int rawEvidenceLevel = 75;\n        int minLevel = 50;\n        int maxLevel = 100;\n        \n        if (rawEvidenceLevel >= minLevel && rawEvidenceLevel <= maxLevel) { // Correct: Use logical AND (&&)\n            System.out.println(\"Evidence level is valid.\");\n        } else {\n            System.out.println(\"Evidence level is invalid.\");\n        }\n    }\n}",
      "expected_output": [
        "Evidence level is valid."
      ],
      "hidden_test_case": "",
      "explanation": "The original code uses the logical `OR` (`||`) operator: `rawEvidenceLevel >= minLevel || rawEvidenceLevel <= maxLevel`. An `OR` condition is `true` if *any* of its parts are `true`. Since `rawEvidenceLevel` (`75`) is `true` for `75 >= 50`, the whole `OR` condition is `true`. However, for a range check \"between X and Y\", both conditions (`>= min` AND `<= max`) must hold simultaneously. The fix is to use the logical `AND` (`&&`) operator instead of `||`. `75 >= 50 && 75 <= 100` evaluates to `true && true`, which is `true`."
    },
    "difficulty": "hard",
    "hints": {
      "1": "To check if a value is *between* two limits (inclusive), both conditions (`>= min` and `<= max`) must be true.",
      "2": "The logical `OR` (`||`) operator means \"if at least one condition is true.\"",
      "3": "The logical `AND` (`&&`) operator means \"if both conditions are true.\""
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 254,
    "subtopic_id": 5,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "An `InterrogationResponseEvaluator` checks `responseTime` and `accuracyScore` for reliability. The code has issues with floating-point comparison and logical operator precedence, leading to an incorrect reliability assessment. Fix the code to ensure a precise and logically correct reliability check.",
      "code": "public class InterrogationResponseEvaluator {\n    public static void main(String[] args) {\n        float responseTime = 10.0f / 10.0f;\n        int accuracyScore = 90;\n        \n        if (Math.abs(responseTime - 1.0f) < 0.000001f && accuracyScore > 80 && accuracyScore <= 90) { // Correct: Use epsilon and correct logical operators/precedence\n            System.out.println(\"Response is reliable.\");\n        } else {\n            System.out.println(\"Response is unreliable.\");\n        }\n    }\n}",
      "expected_output": [
        "Response is reliable."
      ],
      "hidden_test_case": "",
      "explanation": "The original code has two problems:\n1.  **Floating-point comparison:** `responseTime == 1.0f` might fail due to subtle `float` precision issues, even though mathematically it's `1.0`. The fix uses an epsilon comparison `Math.abs(responseTime - 1.0f) < 0.000001f` for robustness.\n2.  **Logical precedence:** The condition `responseTime == 1.0f || accuracyScore > 80 && accuracyScore <= 90` is interpreted as `(responseTime == 1.0f) || (accuracyScore > 80 && accuracyScore <= 90)` due to `&&` having higher precedence than `||`. If `responseTime == 1.0f` is `true`, the rest of the condition isn't checked. The intended logic is that *all three* conditions (response time is effectively 1.0, and accuracy is within range) must be true. The fix uses `&&` as the primary connector and adds parentheses where necessary for clarity."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Direct equality (`==`) for `float` numbers (especially results of calculations) is often problematic. Use an epsilon comparison (`Math.abs(diff) < epsilon`).",
      "2": "The logical `||` (OR) has lower precedence than `&&` (AND). Without parentheses, `A || B && C` means `A || (B && C)`.",
      "3": "To ensure all parts of a complex reliability check are true, the main connecting operator should be logical `AND`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 255,
    "subtopic_id": 5,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "A `SuspectDossierMatcher` compares three `dossierID` strings. The code incorrectly uses `==` for `String` comparisons, leading to inaccurate results for string content that is identical but references are different. Fix the code to correctly compare the textual content of the dossier IDs.",
      "code": "public class SuspectDossierMatcher {\n    public static void main(String[] args) {\n        String dossierID1 = \"CASE-XYZ\";\n        String dossierID2 = new String(\"CASE-XYZ\");\n        String dossierID3 = \"CASE\" + \"-XYZ\";\n        \n        boolean isConfirmedSuspect = false;\n        \n        if (dossierID1.equals(dossierID2) || dossierID2.equals(dossierID3) || dossierID1.equals(dossierID3)) { // Correct: Use .equals() for all String content comparisons\n            isConfirmedSuspect = true;\n        }\n        \n        System.out.println(\"Is Confirmed Suspect: \" + isConfirmedSuspect);\n    }\n}",
      "expected_output": [
        "Is Confirmed Suspect: true"
      ],
      "hidden_test_case": "",
      "explanation": "The original code uses `==` for String comparisons.\n1. `dossierID1 == dossierID2`: `false` (literal vs. new object).\n2. `dossierID2 == dossierID3`: `false` (new object vs. concatenated literal, which gets interned).\n3. `dossierID1 == dossierID3`: `true` (both are string literals/interned constants, so they point to the same object).\n\nBecause `dossierID1 == dossierID3` is `true` in the `else if` (or because `dossierID1 == dossierID2` or `dossierID2 == dossierID3` are checked first), `isConfirmedSuspect` eventually becomes `true` anyway, but the logic is misleading if content comparison is the intent.\n\nThe fix emphasizes using `.equals()` for content comparison, which is the robust way to check if strings are textually identical regardless of how they were created or where they reside in memory. The corrected code combines all necessary content comparisons with `||` in a single `if` statement, ensuring `isConfirmedSuspect` is `true` if any pair has matching content."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The `==` operator for `String`s compares memory addresses. String literals (`\"abc\"`) often get interned (point to the same object), but `new String(\"abc\")` always creates a *new* object. Concatenated literals (`\"A\" + \"B\"`) might also be interned.",
      "2": "The `.equals()` method compares the actual *content* of `String` objects, regardless of where they are in memory.",
      "3": "To confirm a suspect based on *any* matching ID, use logical `OR` (`||`)."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 256,
    "subtopic_id": 6,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `CaseIDChecker` verifies if `currentCaseID` matches a specific value. Complete the comparison operator to correctly check for an exact match.",
      "code": "public class CaseIDChecker {\n    public static void main(String[] args) {\n        int currentCaseID = 101;\n        if (currentCaseID ??? 101) {\n            System.out.println(\"Case ID matches.\");\n        } else {\n            System.out.println(\"Case ID does not match.\");\n        }\n    }\n}",
      "choices": [
        "=",
        "==",
        ">",
        "<"
      ],
      "answer": [
        "=="
      ],
      "explanation": "To check if `currentCaseID` is exactly equal to `101`, the `==` operator is used. The condition `currentCaseID == 101` evaluates to `true`, leading to the \"Case ID matches.\" output."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The goal is to check for `exact equality`.",
      "2": "Which comparison operator explicitly checks if two values are the same?",
      "3": "The blank needs a single operation symbol."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 257,
    "subtopic_id": 6,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "An `AgeEligibility` system checks if a `suspectAge` is `an adult` (strictly greater than 18). Complete the comparison operator to correctly determine adult status.",
      "code": "public class AgeEligibility {\n    public static void main(String[] args) {\n        int suspectAge = 20;\n        if (suspectAge ??? 18) {\n            System.out.println(\"Suspect is an adult.\");\n        } else {\n            System.out.println(\"Suspect is not an adult.\");\n        }\n    }\n}",
      "choices": [
        "=",
        "==",
        ">",
        "<"
      ],
      "answer": [
        ">"
      ],
      "explanation": "To check if `suspectAge` is strictly greater than `18`, the `>` operator is used. The condition `suspectAge > 18` evaluates to `true`, leading to the \"Suspect is an adult.\" output."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The goal is to check if the age is `strictly more than` 18.",
      "2": "Which comparison operator means \"greater than\"?",
      "3": "The blank needs a single operation symbol."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 258,
    "subtopic_id": 6,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `PriorityChecker` assigns `high priority` if `casePriority` is `less than or equal to 3`. Complete the comparison operator to correctly classify case priority.",
      "code": "public class PriorityChecker {\n    public static void main(String[] args) {\n        int casePriority = 3;\n        if (casePriority ??? 3) {\n            System.out.println(\"Case has high priority.\");\n        }\n        else {\n            System.out.println(\"Case has standard priority.\");\n        }\n    }\n}",
      "choices": [
        "=",
        "==",
        ">",
        "<="
      ],
      "answer": [
        "<="
      ],
      "explanation": "To check if `casePriority` is less than or equal to `3`, the `<=` operator is used. The condition `casePriority <= 3` evaluates to `true` (since `3` is equal to `3`), leading to the \"Case has high priority.\" output."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The goal is to include the value `3` itself in the \"high priority\" category.",
      "2": "Which comparison operator means \"less than or equal to\"?",
      "3": "The blank needs a single operation symbol."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 259,
    "subtopic_id": 6,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "An `IDValidator` checks if a `reportedCaseID` is `valid` (not equal to 0). Complete the comparison operator to correctly validate the case ID.",
      "code": "public class IDValidator {\n    public static void main(String[] args) {\n        int reportedCaseID = 123;\n        if (reportedCaseID ??? 0) {\n            System.out.println(\"Valid Case ID.\");\n        } else {\n            System.out.println(\"Invalid Case ID.\");\n        }\n    }\n}",
      "choices": [
        "=",
        "==",
        "!=",
        "<"
      ],
      "answer": [
        "!="
      ],
      "explanation": "To check if `reportedCaseID` is not equal to `0`, the `!=` operator is used. The condition `reportedCaseID != 0` evaluates to `true` (since `123` is not equal to `0`), leading to the \"Valid Case ID.\" output."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The goal is to check if the `reportedCaseID` is `different from` zero.",
      "2": "Which comparison operator means \"not equal to\"?",
      "3": "The blank needs a single operation symbol."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 260,
    "subtopic_id": 6,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `StatementComparer` checks if two `String` statements have identical content. Complete the `String` method call and its argument to correctly compare the statements.",
      "code": "public class StatementComparer {\n    public static void main(String[] args) {\n        String statement1 = \"I saw nothing.\";\n        String statement2 = \"I saw nothing.\";\n        if (statement1.???(???)) {\n            System.out.println(\"Statements match.\");\n        } else {\n            System.out.println(\"Statements differ.\");\n        }\n    }\n}",
      "choices": [
        "equals",
        "==",
        "statement2",
        "statement1"
      ],
      "answer": [
        "equals",
        "statement2"
      ],
      "explanation": "To check if the *content* of two `String` objects is identical, the `.equals()` method (choice a) is used. The method is called on `statement1`, and `statement2` (choice c) is passed as its argument."
    },
    "difficulty": "easy",
    "hints": {
      "1": "For non-primitive types like `String`, `==` compares memory locations, not content.",
      "2": "There's a specific `String` method designed for comparing the actual text.",
      "3": "The first blank is the method name, and the second blank is the variable to compare against."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 261,
    "subtopic_id": 6,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `FootageEvaluator` assesses `footageDuration`. If `footageDuration` is `at least 30` minutes AND `less than 60` minutes, it's within acceptable range. Complete the comparison operator and logical operator for this range check.",
      "code": "public class FootageEvaluator {\n    public static void main(String[] args) {\n        int footageDuration = 45;\n\n        if (footageDuration ??? 30 ??? footageDuration < 60) {\n            System.out.println(\"Footage duration is within acceptable range.\");\n        } else {\n            System.out.println(\"Footage duration is outside acceptable range.\");\n        }\n    }\n}",
      "choices": [
        ">",
        ">=",
        "<",
        "&&",
        "||",
        "=="
      ],
      "answer": [
        ">=",
        "&&"
      ],
      "explanation": "1. To check for \"at least 30 minutes,\" the `>=` operator (choice b) is used.\n2. To combine the two conditions (`footageDuration >= 30` AND `footageDuration < 60`), the logical `AND` operator `&&` (choice d) is used. This ensures both parts of the range check are true."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The phrase \"at least 30 minutes\" implies a specific comparison operator.",
      "2": "To check if a value falls `between` two limits, both conditions must be true simultaneously.",
      "3": "Which logical operator means \"both sides must be true\"?"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 262,
    "subtopic_id": 6,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "An `EvidenceStatusChecker` determines if `evidenceStatus` is `in active phase` if it's `\"Collected\"` OR `\"Processed\"`. Complete the `String` comparison method and the logical operator.",
      "code": "public class EvidenceStatusChecker {\n    public static void main(String[] args) {\n        String evidenceStatus = \"Collected\";\n\n        if (evidenceStatus.???(\"Collected\") ??? evidenceStatus.equals(\"Processed\")) {\n            System.out.println(\"Evidence is in active phase.\");\n        } else {\n            System.out.println(\"Evidence is in inactive phase.\");\n        }\n    }\n}",
      "choices": [
        "==",
        "equals",
        "!=",
        "&&",
        "||",
        "compareTo"
      ],
      "answer": [
        "equals",
        "||"
      ],
      "explanation": "1. To compare the `String` `evidenceStatus` with \"Collected\" and \"Processed\" by content, the `.equals()` method (choice b) is used.\n2. To combine these two possibilities (`equals(\"Collected\")` OR `equals(\"Processed\")`), the logical `OR` operator `||` (choice e) is used. This means the condition is `true` if `evidenceStatus` matches either \"Collected\" or \"Processed\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": "To compare the *content* of `String` objects, you need a specific method.",
      "2": "The word \"either... or\" in the scenario implies a particular logical operator.",
      "3": "Which logical operator means \"if at least one condition is true\"?"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 263,
    "subtopic_id": 6,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `WitnessCredibilityChecker` evaluates `witnessCredibility` and `witnessStatement`. A witness is `highly credible` if `credibility is above 7.5` AND the `statement is NOT \"Retracted\"`. Complete the comparison operator, logical AND, and logical NOT.",
      "code": "public class WitnessCredibilityChecker {\n    public static void main(String[] args) {\n        double witnessCredibility = 8.0;\n        String witnessStatement = \"Consistent\";\n\n        if (witnessCredibility ??? 7.5 ??? (witnessStatement.equals(\"Retracted\"))) {\n            System.out.println(\"Witness is highly credible.\");\n        } else {\n            System.out.println(\"Witness credibility is questionable.\");\n        }\n    }\n}",
      "choices": [
        ">",
        ">=",
        "!=",
        "&&",
        "||",
        "!"
      ],
      "answer": [
        ">",
        "&&",
        "!"
      ],
      "explanation": "1. To check for \"above 7.5,\" the `>` operator (choice a) is used.\n2. To combine the conditions with \"AND,\" the logical `&&` operator (choice d) is used.\n3. To check for \"not Retracted,\" the `!` (NOT) operator (choice f) is used before the `equals()` method call, making the full comparison `!witnessStatement.equals(\"Retracted\")`."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The phrase \"above 7.5\" implies a specific comparison operator.",
      "2": "The problem states \"AND\" to combine the conditions.",
      "3": "The last part of the condition needs a way to say \"NOT equal to\" without modifying the `equals()` method itself."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 264,
    "subtopic_id": 6,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `DispatchPriority` system determines dispatch urgency based on `callTime` and `incidentType`. An `urgent dispatch` is initiated if `callTime is earlier than 0900` OR `incidentType is \"Critical\"`. Complete the comparison operator and logical OR.",
      "code": "public class DispatchPriority {\n    public static void main(String[] args) {\n        int callTime = 830;\n        String incidentType = \"Standard\";\n\n        if (callTime ??? 900 ??? incidentType.equals(\"Critical\")) {\n            System.out.println(\"Urgent dispatch initiated.\");\n        } else {\n            System.out.println(\"Standard dispatch queue.\");\n        }\n    }\n}",
      "choices": [
        "<",
        "<=",
        "==",
        "&&",
        "||",
        ">"
      ],
      "answer": [
        "<",
        "||"
      ],
      "explanation": "1. To check for \"earlier than 0900,\" the `<` operator (choice a) is used.\n2. To combine the two conditions (call time OR incident type), the logical `OR` operator `||` (choice e) is used. This means the condition is `true` if either `callTime` is less than `900` or `incidentType` is \"Critical\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The phrase \"earlier than 0900\" implies a specific comparison operator.",
      "2": "The word \"OR\" in the scenario implies a particular logical operator.",
      "3": "Which logical operator means \"if at least one condition is true\"?"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 265,
    "subtopic_id": 6,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `ReportApprovalChecker` approves a report if its `reportVersion` is `at least 3` AND `approvalStatus` is `true`. Complete the comparison operator and logical AND.",
      "code": "public class ReportApprovalChecker {\n    public static void main(String[] args) {\n        int reportVersion = 4;\n        boolean approvalStatus = true;\n\n        if (reportVersion ??? 3 ??? approvalStatus) {\n            System.out.println(\"Report is approved for final submission.\");\n        } else {\n            System.out.println(\"Report needs further review.\");\n        }\n    }\n}",
      "choices": [
        ">",
        ">=",
        "==",
        "&&",
        "||",
        "!="
      ],
      "answer": [
        ">=",
        "&&"
      ],
      "explanation": "1. To check for \"at least 3,\" the `>=` operator (choice b) is used.\n2. To combine the two conditions (version AND approval status), the logical `AND` operator `&&` (choice d) is used. This ensures both parts of the condition are true."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The phrase \"at least 3\" implies a specific comparison operator.",
      "2": "The word \"AND\" in the scenario implies a particular logical operator.",
      "3": "For a boolean variable like `approvalStatus`, you can use it directly in a condition without `== true`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 266,
    "subtopic_id": 6,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `SuspectProfilerAdvanced` checks `suspectAge` (between 30 and 50 inclusive), `caseInvolvementScore` (above 75), OR `criminalRecordType` is \"Violent\". Complete the operators for this complex logical condition.",
      "code": "public class SuspectProfilerAdvanced {\n    public static void main(String[] args) {\n        int suspectAge = 40;\n        int caseInvolvementScore = 80;\n        String criminalRecordType = \"Non-Violent\";\n\n        if (suspectAge ??? 30 ??? suspectAge <= 50 ??? caseInvolvementScore > 75 ??? criminalRecordType.equals(\"Violent\")) {\n            System.out.println(\"Suspect meets high-priority criteria.\");\n        } else {\n            System.out.println(\"Suspect meets standard criteria.\");\n        }\n    }\n}",
      "choices": [
        ">=",
        "&&",
        "||",
        ">",
        "<",
        "==",
        "!=",
        "<="
      ],
      "answer": [
        ">=",
        "&&",
        "&&",
        "||"
      ],
      "explanation": "1. `>=` (choice a) for `suspectAge >= 30` (inclusive lower bound).\n2. `&&` (choice b) to combine the age range (`suspectAge >= 30 && suspectAge <= 50`).\n3. `&&` (choice b) to combine the age criteria with `caseInvolvementScore > 75`.\n4. `||` (choice c) to connect the combined conditions with `criminalRecordType.equals(\"Violent\")` (since `&&` has higher precedence, this correctly forms `((age_range && involvement_score) || criminal_record_type)`)."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The age range needs an inclusive lower bound operator.",
      "2": "A range check (like 'between X and Y') always uses a logical `AND`.",
      "3": "The combined criteria use `AND` for the age and score, but an `OR` for the `criminalRecordType`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 267,
    "subtopic_id": 6,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `CipherValidator` checks if a cipher key is `valid` if its `keyLength` is `exactly 12` AND `securityLevel is at least 5`, OR if `specialCharacter` is `true`. Complete the operators for this complex logical condition.",
      "code": "public class CipherValidator {\n    public static void main(String[] args) {\n        int keyLength = 12;\n        int securityLevel = 6;\n        boolean specialCharacter = false;\n\n        if (keyLength ??? 12 ??? securityLevel >= 5 ??? specialCharacter) {\n            System.out.println(\"Cipher key is valid.\");\n        } else {\n            System.out.println(\"Cipher key is invalid.\");\n        }\n    }\n}",
      "choices": [
        "==",
        "&&",
        "||",
        ">",
        ">=",
        "<",
        "!=",
        "<="
      ],
      "answer": [
        "==",
        "&&",
        "||"
      ],
      "explanation": "1. `==` (choice a) is used for `keyLength == 12` (exact match).\n2. `&&` (choice b) is used to combine `keyLength == 12` AND `securityLevel >= 5`.\n3. `||` (choice c) is used to combine the first combined condition OR `specialCharacter`. This results in `(keyLength == 12 && securityLevel >= 5 || specialCharacter)`."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Checking for \"exactly 12\" requires a specific comparison operator.",
      "2": "The phrase \"at least 5\" requires another specific comparison operator.",
      "3": "The overall logic combines `(exact length AND min security)` OR `special character`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 268,
    "subtopic_id": 6,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `TravelRecordVerifier` validates a `travelDistance` (double) against `maxDistanceAllowed` (float) and `isInternationalTravel` (boolean). The record is `valid` if distance is approximately equal AND it's NOT international travel. Complete the operators for this precise logical condition.",
      "code": "public class TravelRecordVerifier {\n    public static void main(String[] args) {\n        double travelDistance = 150.0;\n        float maxDistanceAllowed = 150.0f;\n        boolean isInternationalTravel = false;\n\n        if (Math.abs(travelDistance ??? maxDistanceAllowed) < 0.00001 ??? isInternationalTravel) {\n            System.out.println(\"Travel record is valid.\");\n        } else {\n            System.out.println(\"Travel record is invalid.\");\n        }\n    }\n}",
      "choices": [
        "-",
        "+",
        "*",
        "/",
        "&&",
        "||",
        "!",
        "=="
      ],
      "answer": [
        "-",
        "&&",
        "!"
      ],
      "explanation": "1. `-` (choice a) is used inside `Math.abs()` to find the absolute difference, which is compared to `0.00001f` (meaning not approximately equal).\n2. `&&` (choice e) is the logical `AND` operator, combining the floating-point comparison with the `isInternationalTravel` check.\n3. `!` (choice g) is the logical `NOT` operator, used to negate `isInternationalTravel` (`!isInternationalTravel`) to check if it's `false`."
    },
    "difficulty": "hard",
    "hints": {
      "1": "To robustly compare floating-point numbers for equality, you check if their `absolute difference` is small.",
      "2": "The overall logic combines two conditions with an `AND`.",
      "3": "To check if a boolean variable is `false`, you use a logical `NOT` operator."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 269,
    "subtopic_id": 6,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A `TravelAnomalyDetector` flags a `travel log anomaly` if `lastEntry` is `NOT \"Home\"` AND `travelDistance` is `greater than 500`, OR if `lastEntry` has `length 0`. Complete the operators and `String` methods for this complex anomaly detection.",
      "code": "public class TravelAnomalyDetector {\n    public static void main(String[] args) {\n        String lastEntry = \"Office\";\n        int travelDistance = 600;\n\n        if (??? lastEntry.???(\"Home\") ??? travelDistance > 500 ??? lastEntry.length() == 0) {\n            System.out.println(\"Travel log anomaly detected.\");\n        } else {\n            System.out.println(\"Travel log seems normal.\");\n        }\n    }\n}",
      "choices": [
        "equals",
        "!=",
        "&&",
        "||",
        ">",
        "!",
        "equalsIgnoreCase",
        "contains"
      ],
      "answer": [
        "!",
        "equals",
        "&&",
        "||"
      ],
      "explanation": "1. The first blank needs the logical `NOT` operator `!` (choice f) to check for \"not Home.\"\n2. `equals` (choice a) is used for `lastEntry.equals(\"Home\")` to compare content.\n3. `&&` (choice c) is used to combine `(not Home)` AND `travelDistance > 500`.\n4. `||` (choice d) is used to combine the first set of conditions OR `lastEntry.length() == 0`."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The condition for `lastEntry` should be \"not equal to 'Home'\". Remember the operator to negate a boolean result.",
      "2": "The initial two conditions are combined with `AND` (for the anomaly).",
      "3": "The final part of the condition (empty string) is connected using `OR`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 270,
    "subtopic_id": 6,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "An `AuditExceptionDetector` triggers an `exception` if `reportVersion` is `not approximately 1.0` OR `approvalCode` is `\"FAILED\"` AND (`reportTime` is `less than 0` OR `greater than 24`). Complete the operators for this complex nested logical condition.",
      "code": "public class AuditExceptionDetector {\n    public static void main(String[] args) {\n        float reportVersion = 0.999999f;\n        String approvalCode = \"FAILED\";\n        int reportTime = 25;\n\n        if (Math.abs(reportVersion ??? 1.0f) > 0.0001f ??? approvalCode.equals(\"FAILED\") ??? (reportTime < 0 ??? reportTime > 24)) {\n            System.out.println(\"Audit exception triggered.\");\n        } else {\n            System.out.println(\"Audit is clear.\");\n        }\n    }\n}",
      "choices": [
        "-",
        "+",
        "*",
        "&&",
        "||",
        ">",
        "<",
        "=="
      ],
      "answer": [
        "-",
        "||",
        "&&",
        "||"
      ],
      "explanation": "1. `-` (choice a) is used inside `Math.abs()` to find the absolute difference, which is compared to `0.0001f` (meaning not approximately equal).\n2. `||` (choice e) combines the floating-point check OR the rest of the condition.\n3. `&&` (choice d) combines the `approvalCode` check AND the `reportTime` check.\n4. `||` (choice e) combines `reportTime < 0` OR `reportTime > 24`."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The first blank needs the operator for finding the `absolute difference` to check approximate floating-point equality (or inequality).",
      "2": "The first `OR` combines the report version check with the `approvalCode` part.",
      "3": "The second `AND` connects `approvalCode` check with the `reportTime` check."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 271,
    "subtopic_id": 7,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder's shield system is receiving conflicting energy readings. Your task is to trace the AI's decision-making to determine what status message it will output based on the ship's current energy level. Help the system decide whether the shields are good to go or if there's trouble on the horizon.",
      "code": "public class DecisionCore {\n    public static void main(String[] args) {\n        int energyLevel = 75;\n\n        if (energyLevel > 80) {\n            System.out.println(\"Shields at full capacity.\");\n        } else {\n            System.out.println(\"Warning: Shields below optimal level.\");\n        }\n    }\n}",
      "choices": [
        "Shields at full capacity.",
        "Warning: Shields below optimal level.",
        "Energy overload detected.",
        "System offline."
      ],
      "answer": [
        "Warning: Shields below optimal level."
      ],
      "explanation": "The energyLevel is 75, which is not greater than 80. That means the condition in the if block is false, so the else block executes instead."
    },
    "difficulty": "easy",
    "hints": {
      "1": "Look closely at the condition: is energyLevel > 80 true or false?",
      "2": "Remember how if-else works — one block executes, not both.",
      "3": "Just because the value is high doesn't mean it passes the threshold."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 272,
    "subtopic_id": 7,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "You're in the Pathfinder's life support bay. The oxygen regulator is acting up. The system checks the oxygen level and decides whether it's safe for the crew to roam without helmets. Your task: trace what the AI will decide based on the oxygenLevel reading.",
      "code": "public class LifeSupportCheck {\n    public static void main(String[] args) {\n        int oxygenLevel = 21;\n\n        if (oxygenLevel == 20) {\n            System.out.println(\"Oxygen stable.\");\n        } else {\n            System.out.println(\"Oxygen level abnormal.\");\n        }\n    }\n}",
      "choices": [
        "Oxygen stable.",
        "Oxygen level abnormal.",
        "Life support shutting down.",
        "Helmet required."
      ],
      "answer": [
        "Oxygen level abnormal."
      ],
      "explanation": "The code checks if oxygenLevel == 20, but oxygenLevel is 21, so the condition is false. That means it skips the if block and runs the else block, printing 'Oxygen level abnormal.'. This teaches the importance of precision in logic — the AI doesn't do \"close enough,\" it does exact matches."
    },
    "difficulty": "easy",
    "hints": {
      "1": "Is == the same as = ? (Don't confuse assignment with comparison!)",
      "2": "Check if the condition is exactly true — not close enough, not greater, not less.",
      "3": "Off by 1 can be deadly in space… and in logic."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 273,
    "subtopic_id": 7,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "A temperature regulator in the engine bay is making strange decisions. It decides whether to activate cooling based on the current temperature reading. You must analyze the code and figure out what the Pathfinder's system will output with the current temperature input.",
      "code": "public class EngineCoolingSystem {\n    public static void main(String[] args) {\n        int temperature = 90;\n\n        if (temperature >= 100) {\n            System.out.println(\"Activating cooling system.\");\n        } else {\n            System.out.println(\"Temperature within safe range.\");\n        }\n    }\n}",
      "choices": [
        "Activating cooling system.",
        "Temperature within safe range.",
        "Emergency shutdown.",
        "Engine overheating detected."
      ],
      "answer": [
        "Temperature within safe range."
      ],
      "explanation": "The variable temperature is 90, and the condition checks if it's greater than or equal to 100. That's false, so the else block executes. Therefore, the output is: 'Temperature within safe range.'. This reinforces a key lesson: conditions must be met exactly for the if block to run. No assumptions — just clean, logical decision-making like a proper AI system."
    },
    "difficulty": "easy",
    "hints": {
      "1": "Focus on the comparison operator: is 90 greater than or equal to 100?",
      "2": "If the condition isn't true, which block runs?",
      "3": "The else block always catches the \"otherwise\" case."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 274,
    "subtopic_id": 7,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The docking AI must decide whether to allow a cargo ship to dock based on its clearance code. The system only allows ships with a clearance code of 5 to dock without alerting security. Your task: analyze the AI's logic and determine what it will output for the current code.",
      "code": "public class DockingControl {\n    public static void main(String[] args) {\n        int clearanceCode = 3;\n\n        if (clearanceCode == 5) {\n            System.out.println(\"Docking approved.\");\n        } else {\n            System.out.println(\"Unauthorized ship detected.\");\n        }\n    }\n}",
      "choices": [
        "Docking approved.",
        "Unauthorized ship detected.",
        "Ship denied: invalid code.",
        "Stand by for manual override."
      ],
      "answer": [
        "Unauthorized ship detected."
      ],
      "explanation": "The code checks if clearanceCode == 5, but the actual value is 3 — not a match. So, the if condition fails and the else block runs, printing 'Unauthorized ship detected.'. This challenge drills the concept that if-else doesn't guess or round off. It expects your logic to be exact, like a laser-guided missile."
    },
    "difficulty": "easy",
    "hints": {
      "1": "Remember, == checks for exact equality — is 3 == 5 ?",
      "2": "Only one condition is checked here — what happens if it's false?",
      "3": "Don't let numbers trick you — close ≠ correct."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 275,
    "subtopic_id": 7,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "You've accessed the Pathfinder's nutrition distribution module. It checks crew member rank to decide which meal to serve. Your job is to trace the AI's logic and find out what meal a crew member with a specific rank gets.",
      "code": "public class MealDistributor {\n    public static void main(String[] args) {\n        String rank = \"Lieutenant\";\n\n        if (rank.equals(\"Captain\")) {\n            System.out.println(\"Serving premium steak.\");\n        } else if (rank.equals(\"Commander\")) {\n            System.out.println(\"Serving energy pasta.\");\n        } else {\n            System.out.println(\"Serving standard rations.\");\n        }\n    }\n}",
      "choices": [
        "Serving premium steak.",
        "Serving energy pasta.",
        "Serving standard rations.",
        "Invalid rank detected."
      ],
      "answer": [
        "Serving standard rations."
      ],
      "explanation": "rank is \"Lieutenant\", which doesn't match \"Captain\" or \"Commander\" in the if or else if conditions. Since both fail, the code falls to the else block, printing 'Serving standard rations.'. This version introduces branching logic (else if) — useful for multi-decision AI systems and a natural upgrade path from simple if-else."
    },
    "difficulty": "easy",
    "hints": {
      "1": ".equals() is the proper way to compare strings in Java — don't use == for objects like String.",
      "2": "The AI checks the first match — if no match, it lands on else.",
      "3": "The rank is Lieutenant, not Captain or Commander."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 276,
    "subtopic_id": 7,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "You're debugging the Pathfinder's security clearance scanner. It must scan crew credentials and respond accordingly. The AI considers both rank and accessLevel before granting or denying room access. Trace the decisions and determine what two messages the scanner will output.",
      "code": "public class SecurityClearance {\n    public static void main(String[] args) {\n        String rank = \"Technician\";\n        int accessLevel = 3;\n\n        if (rank.equals(\"Captain\") && accessLevel >= 5) {\n            System.out.println(\"Access to Command Deck granted.\");\n        } else if (rank.equals(\"Technician\") && accessLevel >= 3) {\n            System.out.println(\"Access to Engineering Bay granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n\n        System.out.println(\"Scan complete.\");\n    }\n}",
      "choices": [
        "Access to Command Deck granted.",
        "Access to Engineering Bay granted.",
        "Access denied.",
        "Scan complete."
      ],
      "answer": [
        "Access to Engineering Bay granted.",
        "Scan complete."
      ],
      "explanation": "The variables are: rank = \"Technician\", accessLevel = 3. The first condition (rank.equals(\"Captain\") && accessLevel >= 5) is false. The second condition (rank.equals(\"Technician\") && accessLevel >= 3) is true, so this block runs and prints 'Access to Engineering Bay granted.'. After the conditional block, the program always prints 'Scan complete.'."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The && operator means both conditions must be true.",
      "2": "Each if, else if, or else only prints one line — but the second System.out.println is outside that block.",
      "3": "Don't stop at the first output — check the whole main."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 277,
    "subtopic_id": 7,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "You're investigating a report from the Pathfinder's climate control system. It decides which deck gets heating based on temperature and deck status. Your task: trace how the system chooses to respond when evaluating both inputs.",
      "code": "public class ClimateControl {\n    public static void main(String[] args) {\n        int temperature = 16;\n        String deckStatus = \"active\";\n\n        if (temperature < 18) {\n            if (deckStatus.equals(\"active\")) {\n                System.out.println(\"Heating activated for active deck.\");\n            } else {\n                System.out.println(\"Heating on standby due to inactive deck.\");\n            }\n        } else if (temperature >= 18 && temperature <= 24) {\n            System.out.println(\"Temperature is optimal. No action needed.\");\n        } else {\n            System.out.println(\"Cooling system on standby.\");\n        }\n\n        System.out.println(\"Climate check complete.\");\n    }\n}",
      "choices": [
        "Heating activated for active deck.",
        "Heating on standby due to inactive deck.",
        "Temperature is optimal. No action needed.",
        "Climate check complete."
      ],
      "answer": [
        "Heating activated for active deck.",
        "Climate check complete."
      ],
      "explanation": "temperature = 16 → less than 18. This enters the first if block, which contains a nested check: deckStatus.equals(\"active\") → true → Prints: 'Heating activated for active deck.'. Afterward, we hit the unconditional line: 'Climate check complete.'. So, the full output is: 'Heating activated for active deck. Climate check complete.'"
    },
    "difficulty": "medium",
    "hints": {
      "1": "The first condition is temperature < 18. That alone decides which branch we're in.",
      "2": "Look closely: there's a nested if — make sure you check deckStatus.",
      "3": "What line runs no matter what? Look outside the conditional block."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 278,
    "subtopic_id": 7,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder's docking system checks for two things before allowing a supply pod to dock: if docking is enabled and if the fuel level is above minimum. The system reports actions depending on these conditions. Your task: determine what decisions it makes — and trace the two outputs it generates.",
      "code": "public class DockingSystem {\n    public static void main(String[] args) {\n        boolean dockingEnabled = true;\n        int fuelLevel = 45;\n\n        if (dockingEnabled) {\n            if (fuelLevel >= 50) {\n                System.out.println(\"Docking approved.\");\n            } else {\n                System.out.println(\"Insufficient fuel for docking.\");\n            }\n        } else if (!dockingEnabled) {\n            System.out.println(\"Docking system offline.\");\n        } else {\n            System.out.println(\"Unexpected error.\");\n        }\n\n        System.out.println(\"Docking sequence checked.\");\n    }\n}",
      "choices": [
        "Docking approved.",
        "Insufficient fuel for docking.",
        "Docking system offline.",
        "Docking sequence checked."
      ],
      "answer": [
        "Insufficient fuel for docking.",
        "Docking sequence checked."
      ],
      "explanation": "dockingEnabled = true → enters the first if. Inside that: fuelLevel = 45, which is less than 50 → Prints: 'Insufficient fuel for docking.'. Outside the conditionals: Prints: 'Docking sequence checked.'."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The condition if (dockingEnabled) is true — so it goes inside that block.",
      "2": "Within that, check the fuel level — is it enough?",
      "3": "The final System.out.println always runs, regardless of conditionals."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 279,
    "subtopic_id": 7,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder's diagnostics unit receives a system status code that it must interpret and log. Your task is to trace the logic that matches the code to its corresponding message, and identify the output the system prints.",
      "code": "public class DiagnosticLog {\n    public static void main(String[] args) {\n        int statusCode = 300;\n\n        if (statusCode == 200) {\n            System.out.println(\"All systems nominal.\");\n        } else if (statusCode >= 300 && statusCode < 400) {\n            System.out.println(\"Warning: Minor anomalies detected.\");\n        } else if (statusCode >= 400) {\n            System.out.println(\"Critical failure in subsystem.\");\n        } else {\n            System.out.println(\"Unknown status code.\");\n        }\n\n        System.out.println(\"Diagnostics complete.\");\n    }\n}",
      "choices": [
        "All systems nominal.",
        "Warning: Minor anomalies detected.",
        "Critical failure in subsystem.",
        "Diagnostics complete."
      ],
      "answer": [
        "Warning: Minor anomalies detected.",
        "Diagnostics complete."
      ],
      "explanation": "statusCode = 300. statusCode == 200 → false. statusCode >= 300 && statusCode < 400 → true → Prints: 'Warning: Minor anomalies detected.'. The final print statement always executes: → 'Diagnostics complete.'. So the output is: 'Warning: Minor anomalies detected. Diagnostics complete.'"
    },
    "difficulty": "medium",
    "hints": {
      "1": "Is statusCode == 200 true? If not, skip that block.",
      "2": "Look at the range check: between 300 and 400?",
      "3": "There's always one line printed after all conditions — regardless of outcome."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 280,
    "subtopic_id": 7,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder is calculating emergency power allocation. Depending on how much energy is left and the priority level of the system, the AI assigns a number of units for backup use. Your task: trace what numerical outputs the AI prints based on its conditions.",
      "code": "public class PowerAllocation {\n    public static void main(String[] args) {\n        int energyLeft = 75;\n        int priorityLevel = 2;\n\n        if (priorityLevel == 1) {\n            System.out.println(energyLeft - 20);\n        } else if (priorityLevel == 2 && energyLeft >= 70) {\n            System.out.println(energyLeft - 30);\n        } else if (priorityLevel == 3) {\n            System.out.println(energyLeft - 50);\n        } else {\n            System.out.println(0);\n        }\n\n        System.out.println(energyLeft + 10);\n    }\n}",
      "choices": [
        "55",
        "45",
        "25",
        "85"
      ],
      "answer": [
        "45",
        "85"
      ],
      "explanation": "priorityLevel == 2 → true. energyLeft = 75 → true >= 70. So it goes into this block: System.out.println(energyLeft - 30); → 75 - 30 = 45. Then the always-executed line: System.out.println(energyLeft + 10); → 75 + 10 = 85."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Check if priorityLevel == 2 and if energyLeft >= 70 is true.",
      "2": "Do the math: subtract from energyLeft in the right block.",
      "3": "The last line adds 10 — it runs no matter what."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 281,
    "subtopic_id": 7,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder's AI is executing a deep diagnostic of its navigation system. Based on the current mode and fuel level, it returns early if critical errors are found. Your job is to trace which values get printed before the system returns — or never gets there at all. Tread carefully: not all paths reach the final print statement.",
      "code": "public class NavigationCheck {\n    public static void main(String[] args) {\n        int mode = 3;\n        int fuel = 40;\n\n        if (mode == 1) {\n            System.out.println(100);\n            return;\n        } else if (mode == 2 && fuel > 50) {\n            System.out.println(200);\n            return;\n        } else if (mode == 3) {\n            if (fuel < 30) {\n                System.out.println(300);\n                return;\n            } else {\n                System.out.println(400);\n            }\n        }\n\n        System.out.println(500);\n        System.out.println(600);\n    }\n}",
      "choices": [
        "100",
        "400",
        "500",
        "600"
      ],
      "answer": [
        "400",
        "500",
        "600"
      ],
      "explanation": "mode = 3, so it enters the last else if. Inside that: fuel = 40, which is not less than 30, so it skips the inner if return. It goes to System.out.println(400);. Since there's no return after printing 400, it continues execution. Prints 500 and 600."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The method uses return — once it hits that, it stops the entire main.",
      "2": "Only one return is avoided — think carefully which path does not return early.",
      "3": "The final two print statements only happen if the return is not triggered."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 282,
    "subtopic_id": 7,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder's AI is validating a sequence of energy pulses. The AI receives a number and evaluates its properties — even or odd, divisibility, and signal strength, returning early if anomalies are found. You must trace which pulses are successfully logged before the system halts.",
      "code": "public class PulseAnalyzer {\n    public static void main(String[] args) {\n        int pulse = 15;\n\n        if (pulse % 2 == 0) {\n            System.out.println(10);\n            return;\n        }\n\n        if (pulse % 3 == 0) {\n            System.out.println(20);\n        } else if (pulse % 5 == 0) {\n            System.out.println(30);\n            return;\n        }\n\n        System.out.println(40);\n\n        if (pulse > 10 && pulse < 20) {\n            System.out.println(50);\n        }\n    }\n}",
      "choices": [
        "20",
        "30",
        "40",
        "50"
      ],
      "answer": [
        "20",
        "40",
        "50"
      ],
      "explanation": "pulse = 15. 15 % 2 != 0 → first block is skipped. 15 % 3 == 0 → true → prints 20. The else if is ignored because the if before it was true. So return inside the else if does NOT trigger. Execution continues. Prints 40. pulse > 10 && pulse < 20 → true so prints 50."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The first if checks evenness — that will skip.",
      "2": "% 3 and % 5 conditions are tricky — both might be true.",
      "3": "Look out — not every true condition has a return."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 283,
    "subtopic_id": 7,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "You're assigned to the Pathfinder's Reactor Core Calibration Unit. It checks numeric inputs for anomaly patterns. If the calibration is unstable, the system returns early to avoid meltdown. But not all instability is what it seems — it's up to you to trace which logs are actually printed.",
      "code": "public class ReactorCalibration {\n    public static void main(String[] args) {\n        int input = 12;\n\n        if (input % 4 == 0 && input % 6 == 0) {\n            System.out.println(100);\n        } else {\n            System.out.println(200);\n            return;\n        }\n\n        if (input < 10 || input > 20) {\n            System.out.println(300);\n        }\n\n        if (input == 12) {\n            System.out.println(400);\n        }\n\n        System.out.println(500);\n    }\n}",
      "choices": [
        "100",
        "300",
        "400",
        "500"
      ],
      "answer": [
        "100",
        "400",
        "500"
      ],
      "explanation": "input = 12. 12 % 4 == 0 true and 12 % 6 == 0 true → First condition is true → prints 100, skips the else and no return triggered. Next: input < 10 || input > 20 → 12 is not less than 10 nor greater than 20 → false skip this one. Then: input == 12 → true → prints 400. Last line → prints 500."
    },
    "difficulty": "hard",
    "hints": {
      "1": "&& in the first condition can let you skip the return if both parts are true.",
      "2": "|| can be tricky — make sure you read it like a logician, not just a coder.",
      "3": "If no return, it goes on. Don't assume the else triggers just because it's there."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 284,
    "subtopic_id": 7,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "You're inside the Threat Prioritization Engine — a subsystem using a tangled web of conditionals to decide which dangers to neutralize first. The system relies on an if-else ladder and standalone checks. Only those who trace carefully will know what gets printed. One false move and the system could confuse a fire alarm for a coffee break.",
      "code": "public class ThreatPriority {\n    public static void main(String[] args) {\n        int threat = 45;\n\n        if (threat < 20) {\n            System.out.println(101);\n        } else if (threat % 2 == 0) {\n            System.out.println(202);\n        } else if (threat > 40 && threat < 50) {\n            System.out.println(303);\n        } else if (threat == 45) {\n            System.out.println(404);\n        } else {\n            System.out.println(505);\n        }\n\n        if (threat % 3 == 0) {\n            System.out.println(606);\n        }\n\n        System.out.println(707);\n    }\n}",
      "choices": [
        "202",
        "303",
        "606",
        "707"
      ],
      "answer": [
        "303",
        "606",
        "707"
      ],
      "explanation": "threat = 45. First if → threat < 20 false. Next → threat % 2 == 0 → 45 % 2 == 1 false. Next → threat > 40 && threat < 50 → true → prints 303. The else-if (threat == 45) is also true, but skipped since only one block executes in an if-else-if ladder. Then the separate if (threat % 3 == 0) → 45 % 3 == 0 true → prints 606. Last line → prints 707."
    },
    "difficulty": "hard",
    "hints": {
      "1": "else-if ladder only executes the first matching condition.",
      "2": "Additional if statements outside the ladder still run independently.",
      "3": "Is 45 divisible by 3? 👀"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 285,
    "subtopic_id": 7,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "Inside the Risk Assessment Cluster, the AI core evaluates incoming numeric alerts. But its logic processor has been scrambled — a mix of overlapping thresholds and deeply nested if-else ladders are throwing cadets off. Only those with sharp logic and nerves of steel will decode which paths actually run.",
      "code": "public class RiskCluster {\n    public static void main(String[] args) {\n        int alert = 17;\n\n        if (alert > 10) {\n            if (alert < 20) {\n                System.out.println(101);\n            } else if (alert % 2 == 1) {\n                System.out.println(202);\n            }\n        } else if (alert == 17) {\n            System.out.println(303);\n        } else {\n            System.out.println(404);\n        }\n\n        if (alert % 5 == 2) {\n            System.out.println(505);\n        }\n\n        System.out.println(606);\n    }\n}",
      "choices": [
        "101",
        "202",
        "505",
        "606"
      ],
      "answer": [
        "101",
        "505",
        "606"
      ],
      "explanation": "alert = 17. First outer if (alert > 10) → true. Inner: alert < 20 → true → prints 101. else if (alert % 2 == 1) is skipped since alert < 20 already matched. The outer else if (alert == 17) looks true but it's never reached — the first if block already matched. Next: if (alert % 5 == 2) → 17 % 5 == 2 → true → prints 505. Final print → 606."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The inner if only runs if the outer condition is true — if it fails, the rest is skipped.",
      "2": "Even though alert == 17 is true, that block won't run because it's part of the else if.",
      "3": "Remember how modulo works: alert % 5 means the remainder when 17 is divided by 5."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 286,
    "subtopic_id": 7,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "The Pathfinder system is responsible for monitoring oxygen levels and issuing warnings when levels drop below safety thresholds. Your mission is to ensure this critical logic works correctly.",
      "code": "public class OxygenMonitorAlertProtocol {\n    public static void main(String[] args) {\n        int oxygenLevel = 55;\n        if (oxygenLevel < 60) {\n            System.out.println(\"Oxygen low! Please activate backup.\");\n        } else {\n            System.out.println(\"Oxygen levels are safe.\");\n        }\n    }\n}",
      "expected_output": [
        "Oxygen low! Please activate backup."
      ],
      "hidden_test_case": {
        "oxygenLevel": 55,
        "expected_output": "Oxygen low! Please activate backup."
      },
      "answer": [
        "Oxygen low! Please activate backup."
      ],
      "explanation": "The faulty logic misplaces the messages in the if-else structure. It's currently telling users that oxygen levels are 'safe' when they are actually low (55). The issue isn't the condition itself but what each branch outputs. By swapping the messages inside the if and else blocks, the logic now responds appropriately—warning the user when the oxygen level is below 60."
    },
    "difficulty": "easy",
    "hints": {
      "1": "Double-check which message appears when oxygen drops.",
      "2": "Is the 'safe' message showing up in the wrong situation?",
      "3": "If 55 is a low value, why isn't the warning triggered?"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 287,
    "subtopic_id": 7,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "When the shield level is 80 or higher, it's safe. Otherwise, it should warn. You need to fix the code to ensure the correct message is displayed.",
      "code": "public class ShieldDiagnostics {\n    public static void main(String[] args) {\n        int shield = 85;\n\n        if (shield >= 80) {\n            System.out.println(\"Shields stable.\");\n        } else {\n            System.out.println(\"Warning: Shields too low.\");\n        }\n    }\n}",
      "expected_output": [
        "Shields stable."
      ],
      "hidden_test_case": {
        "shield": 85,
        "expected_output": "Shields stable."
      },
      "answer": [
        "Shields stable."
      ],
      "explanation": "The original code mistakenly uses `if (shield < 80)` for the 'stable' condition. The correct logic is to use `if (shield >= 80)` to clearly define when the system is stable. With this fix, the output is 'Shields stable.' because 85 meets the safety threshold."
    },
    "difficulty": "easy",
    "hints": {
      "1": "Is the ship warning when it should feel safe?",
      "2": "What should happen when shield is 85?",
      "3": "Compare the logic to the desired outcome."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 288,
    "subtopic_id": 7,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "Fuel levels determine the ship's next action. At full fuel (> 90), print a readiness message. Fix the code to ensure this behavior.",
      "code": "public class FuelCheck {\n    public static void main(String[] args) {\n        int fuel = 95;\n\n        if (fuel > 90) { \n            System.out.println(\"Fuel full. Ready to launch!\");\n        } else {\n            System.out.println(\"Fuel not full.\");\n        }\n    }\n}",
      "expected_output": [
        "Fuel full. Ready to launch!"
      ],
      "hidden_test_case": {
        "fuel": 95,
        "expected_output": "Fuel full. Ready to launch!"
      },
      "answer": [
        "Fuel full. Ready to launch!"
      ],
      "explanation": "The original code mistakenly checks `fuel < 90`, which would only print the message when fuel is not full. Since the requirement is to print readiness when fuel is above 90, we need to use `fuel > 90`. With `fuel = 95`, the condition is met, and the output is correctly: 'Fuel full. Ready to launch!'."
    },
    "difficulty": "easy",
    "hints": {
      "1": "What number does the code compare to?",
      "2": "What should trigger a 'Fuel full' message?",
      "3": "Look at which direction the inequality is pointing."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 289,
    "subtopic_id": 7,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "The scanner should warn only when the threat level is 100. Correct the code to match this requirement.",
      "code": "public class ThreatLevelScanner {\n    public static void main(String[] args) {\n        int threat = 100;\n\n        if (threat == 100) { \n            System.out.println(\"ALERT! Threat detected.\");\n        } else {\n            System.out.println(\"Threat level acceptable.\");\n        }\n    }\n}",
      "expected_output": [
        "ALERT! Threat detected."
      ],
      "hidden_test_case": {
        "threat": 100,
        "expected_output": "ALERT! Threat detected."
      },
      "answer": [
        "ALERT! Threat detected."
      ],
      "explanation": "The faulty code uses `threat != 100`, which triggers the alert for any threat level except 100 — exactly the opposite of what we want. Since the alert should only happen when the threat level is exactly 100, the condition should be `threat == 100`. With the correct logic and `threat = 100`, the program correctly prints: 'ALERT! Threat detected.'."
    },
    "difficulty": "easy",
    "hints": {
      "1": "Think about equality vs. inequality.",
      "2": "Should we trigger the alert when the threat is 100 or when it isn't?",
      "3": "Which symbol means 'equal to'?"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 290,
    "subtopic_id": 7,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "If the engine temp is below 30, the cooler should activate. Fix the code to ensure the coolant system activates under the correct temperature condition.",
      "code": "public class TemperatureRegulation {\n    public static void main(String[] args) {\n        int temperature = 25;\n        if (temperature < 30) { \n            System.out.println(\"Activating coolant system.\");\n        } else {\n            System.out.println(\"Temperature within safe range.\");\n        }\n    }\n}",
      "expected_output": [
        "Activating coolant system."
      ],
      "hidden_test_case": {
        "temperature": 25,
        "expected_output": "Activating coolant system."
      },
      "answer": [
        "Activating coolant system."
      ],
      "explanation": "The faulty code checks `temperature > 30`, which would activate cooling only when it's hotter — but the goal is to cool things down before it hits 30. Since 25 is less than 30, the correct condition is `temperature < 30`. That way, the program correctly activates the coolant system when the engine is too cold."
    },
    "difficulty": "easy",
    "hints": {
      "1": "What temperature triggers the cooling system?",
      "2": "Is 25 greater than 30?",
      "3": "Which symbol points toward smaller numbers?"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 291,
    "subtopic_id": 7,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "If the reactor temperature is high and coolant level is low, trigger emergency cooling. If only one condition is true, issue a warning. Otherwise, all is normal. The current code has a logical flaw in the order of checks.",
      "code": "public class ReactorControl {\n    public static void main(String[] args) {\n        int temp = 800;\n        int coolant = 20;\n\n        if (temp > 700 && coolant < 30) { \n            System.out.println(\"Triggering emergency cooling!\");\n        } else if (temp > 700 || coolant < 30) { \n            System.out.println(\"Warning: Check cooling system.\");\n        } else {\n            System.out.println(\"Reactor stable.\");\n        }\n    }\n}",
      "expected_output": [
        "Triggering emergency cooling!"
      ],
      "hidden_test_case": {
        "temp": 800,
        "coolant": 20,
        "expected_output": "Triggering emergency cooling!"
      },
      "answer": [
        "Triggering emergency cooling!"
      ],
      "explanation": "The faulty version incorrectly checked the OR (`||`) condition first, so it triggered emergency cooling even when only one issue existed. But emergency cooling is serious business — we only trigger it when both: Temp is dangerously high (`> 700`) and Coolant is dangerously low (`< 30`). By checking the AND condition first, we make sure full-blown emergencies get handled properly. Since both `temp = 800` and `coolant = 20` are true, the output is: 'Triggering emergency cooling!'."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Emergency cooling needs both conditions—true or just one?",
      "2": "Which is riskier: high temp alone, or both?",
      "3": "Try reordering the if/else checks logically."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 292,
    "subtopic_id": 7,
    "type": "code_fixer",
    "difficulty": "medium",
    "snippet_choices": {
      "scenario": "Pathfinder's decision core checks solar flare activity and sensor clarity before landing on a space station. It can land if solar flare activity is low OR sensors are clear. If both are bad, it must delay landing. Fix the code to ensure the correct landing decision is made.",
      "code": "public class LandingControl {\n    public static void main(String[] args) {\n        int solarFlare = 45;       // flare intensity\n        int sensorClarity = 40;    // sensor accuracy level\n\n        if (solarFlare < 50 || sensorClarity > 60) { // Corrected logic: uses OR\n            System.out.println(\"Landing cleared.\");\n        } else {\n            System.out.println(\"Delay landing.\");\n        }\n    }\n}",
      "expected_output": [
        "Landing cleared."
      ],
      "hidden_test_case": {
        "solarFlare": 45,
        "sensorClarity": 40,
        "expected_output": "Landing cleared."
      },
      "answer": [
        "Landing cleared."
      ],
      "explanation": "The faulty code uses `&&`, which wrongly demands both conditions be ideal before landing. But the mission rule says just one good condition is enough. By using `||` (OR) in the correct code, the program now aligns with the mission logic."
    },
    "hints": {
      "1": "Can landing happen even if only one condition is ideal?",
      "2": "Check the operator: do you need `&&` or `||`?",
      "3": "Which logical operator allows more flexibility?"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 293,
    "subtopic_id": 7,
    "type": "code_fixer",
    "difficulty": "medium",
    "snippet_choices": {
      "scenario": "A spacesuit locks if the oxygen is low OR the user is unconscious. It should only unlock if oxygen is stable AND the user is awake. Fix the code to implement the correct suit locking and unlocking logic.",
      "code": "public class SuitLock {\n    public static void main(String[] args) {\n        boolean oxygenStable = true;\n        boolean userAwake = true;\n\n        if (oxygenStable && userAwake) { // Correct: Uses AND for strict unlocking\n            System.out.println(\"Suit unlocking...\");\n        } else {\n            System.out.println(\"Suit remains locked.\");\n        }\n    }\n}",
      "expected_output": [
        "Suit unlocking..."
      ],
      "hidden_test_case": {
        "oxygenStable": true,
        "userAwake": true,
        "expected_output": "Suit unlocking."
      },
      "answer": [
        "Suit unlocking..."
      ],
      "explanation": "The faulty code uses `||`, which would unlock the suit even if only one condition is true—unsafe in a space environment. The correct logic requires both oxygen to be stable and the user to be awake (`&&`). This ensures the suit only unlocks under safe conditions. The variable values are set to `true` to reflect the correct scenario, which outputs 'Suit unlocking...'."
    },
    "hints": {
      "1": "Would you unlock the suit if oxygen is low but the user is awake?",
      "2": "What combination ensures safety before unlocking?",
      "3": "Double-check what logical operator makes unlocking stricter."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 294,
    "subtopic_id": 7,
    "type": "code_fixer",
    "difficulty": "medium",
    "snippet_choices": {
      "scenario": "The comms system is considered online if the satellite is in range AND signal strength is strong. If the satellite is out of range OR signal is weak, it fails. Correct the code to accurately reflect the comms system status.",
      "code": "public class CommsSystem {\n    public static void main(String[] args) {\n        boolean satelliteInRange = true;\n        boolean signalStrong = true;\n        if (satelliteInRange && signalStrong) { // Correct: Uses AND for 'Comms online'\n            System.out.println(\"Comms online.\");\n        } else {\n            System.out.println(\"Comms failure.\");\n        }\n    }\n}",
      "expected_output": [
        "Comms online."
      ],
      "hidden_test_case": {
        "satelliteInRange": true,
        "signalStrong": true,
        "expected_output": "Comms online."
      },
      "answer": [
        "Comms online."
      ],
      "explanation": "The faulty logic is overcomplicated to look smart but ends up wrong. It combines AND and OR in a way that prioritizes the satellite being in range even when the signal is weak. This causes the system to declare 'Comms online' when only one of the required conditions is true—violating the scenario's safety requirement. The correct version uses a clean `&&` to ensure both are true before confirming communication readiness."
    },
    "hints": {
      "1": "Do both signal and range need to be ideal?",
      "2": "What happens if only one is working?",
      "3": "Try making the condition more strict."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 295,
    "subtopic_id": 7,
    "type": "code_fixer",
    "difficulty": "medium",
    "snippet_choices": {
      "scenario": "An astronaut can refill oxygen if their current oxygen level is below 60% AND the refill station is online. Additionally, a warning must trigger if the astronaut's oxygen is below 30% OR the refill station is offline. Fix the logic to correctly manage oxygen refill and warnings.",
      "code": "public class OxygenRefillSystem {\n    public static void main(String[] args) {\n        int oxygenLevel = 25;\n        boolean stationOnline = false;\n        if (oxygenLevel < 60 && stationOnline) { // Corrected: oxygenLevel < 60\n            System.out.println(\"Begin refill process.\");\n        }\n        if (oxygenLevel < 30 || !stationOnline) { // Corrected: oxygenLevel < 30 and !stationOnline\n            System.out.println(\"Warning: Critical oxygen or station down.\");\n        }\n    }\n}",
      "expected_output": [
        "Warning: Critical oxygen or station down."
      ],
      "hidden_test_case": {
        "oxygenLevel": 25,
        "stationOnline": false,
        "expected_output": "Warning: Critical oxygen or station down."
      },
      "answer": [
        "Warning: Critical oxygen or station down."
      ],
      "explanation": "Condition A ensures the astronaut is only allowed to refill when it's both necessary (oxygen < 60) and possible (station is online). Condition B triggers a warning if either of the danger conditions is true: oxygen is dangerously low or the station is offline—each of which could be critical on its own. The original faulty conditions inverted the logic and used overly safe thresholds, meaning the system would never allow refills when actually needed and might miss warnings."
    },
    "hints": {
      "1": "When do we actually need to refill—when it's safe or low?",
      "2": "Should the warning care about just one danger or both together?",
      "3": "Remember the difference between && and ||."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 296,
    "subtopic_id": 7,
    "type": "code_fixer",
    "difficulty": "hard",
    "snippet_choices": {
      "scenario": "You're programming Pathfinder's AI health diagnostics. It monitors the number of damaged modules, average temperature readings, and whether the system alert is activated. Based on these, it must issue the correct alert level. Fix the faulty logic to ensure accurate and complete alerts.",
      "code": "public class HealthDiagnostic {\n    public static void main(String[] args) {\n        byte damagedModules = 12;\n        double avgTemp = 86.5;\n        String alertStatus = \"true\";\n\n        System.out.println(\"=== SYSTEM INPUTS ===\");\n        System.out.println(\"Damaged Modules: \" + damagedModules);\n        System.out.println(\"Average Temperature: \" + avgTemp);\n        System.out.println(\"Alert Status: \" + alertStatus);\n        System.out.println(\"=====================\\n\");\n\n        if (damagedModules > 10 && alertStatus.equals(\"true\")) { // Corrected: use .equals() to compare strings\n            System.out.println(\"CRITICAL: Structural integrity compromised.\");\n        }\n\n        if (avgTemp >= 85.0) { // Corrected: use separate if blocks to allow multiple warnings\n            System.out.println(\"WARNING: Elevated core temperature.\");\n        }\n\n        if (damagedModules > 10) {\n            System.out.println(\"WARNING: Excessive damage.\");\n        }\n    }\n}",
      "expected_output": [
        "=== SYSTEM INPUTS ===",
        "Damaged Modules: 12",
        "Average Temperature: 86.5",
        "Alert Status: true",
        "=====================\n",
        "CRITICAL: Structural integrity compromised.",
        "WARNING: Elevated core temperature.",
        "WARNING: Excessive damage."
      ],
      "hidden_test_case": {
        "damagedModules": 12,
        "avgTemp": 86.5,
        "alertStatus": "true",
        "expected_output": [
          "CRITICAL: Structural integrity compromised.",
          "WARNING: Elevated core temperature.",
          "WARNING: Excessive damage."
        ]
      },
      "answer": [
        "CRITICAL: Structural integrity compromised.",
        "WARNING: Elevated core temperature.",
        "WARNING: Excessive damage."
      ],
      "explanation": "The original code fails for two main reasons. First, it incorrectly uses `==` to compare strings, which compares object references, not content—so \"true\" might not register even when it should. Second, the use of `else if` prevents multiple alerts from showing. For example, if one condition is true, the rest are skipped—even if they should also be triggered. The corrected version uses `.equals()` for reliable string comparison, and uses separate `if` statements so that all relevant system warnings and alerts can display. This ensures both logic and safety are intact."
    },
    "hints": {
      "1": "Are you checking the actual content of the string, or just comparing references?",
      "2": "What happens when two warnings are valid at the same time—are both displayed?",
      "3": "Improper if-else usage may cause the system to ignore valid warnings—it might 'look correct' but silently fail important checks."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 297,
    "subtopic_id": 7,
    "type": "code_fixer",
    "difficulty": "hard",
    "snippet_choices": {
      "scenario": "You're writing a fuel consumption analyzer for a spacecraft. It calculates remaining fuel based on the fuel capacity, burn rate, and hours of operation. It must then decide the fuel alert level. Fix the faulty code to ensure accurate calculations and correct alert triggers.",
      "code": "public class FuelAnalyzer {\n    public static void main(String[] args) {\n        float fuelCapacity = 5000;\n        int burnRate = 50;\n        int hours = 60;\n\n        float remainingFuel = fuelCapacity - ((float) burnRate * hours); // Corrected: cast burnRate to float before multiplication\n\n        if (remainingFuel == 0) { // Corrected: use == for comparison\n            System.out.println(\"Out of fuel!\");\n        } else if (remainingFuel < 1000) {\n            System.out.println(\"Low fuel warning.\");\n        } else {\n            System.out.println(\"Fuel levels nominal.\");\n        }\n    }\n}",
      "expected_output": [
        "Low fuel warning."
      ],
      "hidden_test_case": {
        "fuelCapacity": 5000,
        "burnRate": 50,
        "hours": 60,
        "expected_output": "Low fuel warning."
      },
      "answer": [
        "Low fuel warning."
      ],
      "explanation": "The primary issues are type handling and condition logic. First, `burnRate * hours` (3000) is an `int` calculation, and while 3000 fits in an `int`, it's better to ensure floating-point arithmetic from the start if the result is a `float`. Casting `burnRate` to `float` before multiplication ensures `((float) burnRate * hours)` yields a `float` (3000.0) preventing potential precision loss for larger numbers. Second, `if (remainingFuel = 0)` uses the assignment operator `=` instead of the comparison operator `==`, which is a common logical and compilation error. The fix addresses both, ensuring accurate fuel calculation and proper conditional branching."
    },
    "hints": {
      "1": "Assignment (`=`) and comparison (`==`) aren't the same. Spot the danger?",
      "2": "How does Java handle operations between int and float?",
      "3": "What's the data type of `burnRate * hours` before storing in a float?"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 298,
    "subtopic_id": 7,
    "type": "code_fixer",
    "difficulty": "hard",
    "snippet_choices": {
      "scenario": "You're programming a navigation system that validates whether a ship can safely jump to hyperspace. To qualify, the ship must: have fuel above 500 units, navigation system must be 'online', and jump coordinates must be verified (boolean). If all checks pass, display 'Jumping to hyperspace!' Otherwise, say why. Fix the faulty code to enable safe hyperspace jumps.",
      "code": "public class HyperspaceJump {\n    public static void main(String[] args) {\n        double fuelLevel = 650;\n        String navStatus = \"Online\";\n        boolean coordsVerified = true;\n\n        if (fuelLevel > 500 && navStatus.equalsIgnoreCase(\"online\") && coordsVerified) { // Corrected: use .equalsIgnoreCase() and coordsVerified directly\n            System.out.println(\"Jumping to hyperspace!\");\n        } else {\n            System.out.println(\"Jump aborted: check systems.\");\n        }\n    }\n}",
      "expected_output": [
        "Jumping to hyperspace!"
      ],
      "hidden_test_case": {
        "fuelLevel": 650,
        "navStatus": "Online",
        "coordsVerified": true,
        "expected_output": "Jumping to hyperspace!"
      },
      "answer": [
        "Jumping to hyperspace!"
      ],
      "explanation": "The original code has two main logical flaws: string comparison and boolean assignment in a condition. `navStatus == \"online\"` uses `==` for String comparison, which checks object identity, not content, and is case-sensitive, so 'Online' won't match 'online'. This should be `navStatus.equalsIgnoreCase(\"online\")` or `navStatus.equals(\"Online\")`. Additionally, `coordsVerified = true` is an assignment, not a comparison. It should be `coordsVerified == true` or simply `coordsVerified`. The fix addresses both of these, ensuring that all conditions are properly evaluated for a successful hyperspace jump."
    },
    "hints": {
      "1": "Assignment (`=`) and comparison (`==`) aren't the same. Spot the danger?",
      "2": "String comparisons in Java are case- and reference-sensitive—how do you compare their content?",
      "3": "Avoid comparing booleans with `==` when you can just use the variable directly!"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 299,
    "subtopic_id": 7,
    "type": "code_fixer",
    "difficulty": "hard",
    "snippet_choices": {
      "scenario": "You're designing a drone swarm management system. The goal is to evaluate if a drone should initiate evasive maneuvers based on: batteryLevel (above 20%), signalStrength (at least 75), threatDetected (true), and droneStatus ('ACTIVE'). Fix the faulty code to ensure drones react appropriately to threats.",
      "code": "public class DroneSwarmControl {\n    public static void main(String[] args) {\n        int batteryLevel = 25;\n        int signalStrength = 80;\n        boolean threatDetected = true;\n        String droneStatus = new String(\"ACTIVE\");\n\n        if (isBatteryGood(batteryLevel) && signalStrength >= 75 && isThreat(threatDetected) && droneStatus.equals(\"ACTIVE\")) { // Corrected conditions\n            System.out.println(\"Evasive maneuver initiated.\");\n        }\n        else if (isBatteryGood(batteryLevel) && threatDetected) {\n            System.out.println(\"Reduce speed, monitor surroundings.\");\n        }\n        else {\n            System.out.println(\"Maintain course.\");\n        }\n    }\n\n    static boolean isBatteryGood(int battery) {\n        return battery > 20;\n    }\n\n    static boolean isThreat(boolean detected) {\n        return detected; // Corrected: return detected directly\n    }\n}",
      "expected_output": [
        "Evasive maneuver initiated."
      ],
      "hidden_test_case": {
        "batteryLevel": 25,
        "signalStrength": 80,
        "threatDetected": true,
        "droneStatus": "ACTIVE",
        "expected_output": "Evasive maneuver initiated."
      },
      "answer": [
        "Evasive maneuver initiated."
      ],
      "explanation": "The code contains several logical errors. The `isThreat` method inverts the logic, returning `true` when no threat is detected. `signalStrength > 75` should be `>= 75` to include the threshold. `droneStatus == \"ACTIVE\"` incorrectly uses `==` for String comparison, which compares references, not content. Each of these must be fixed to ensure the drone behaves correctly under threat. The correct code should ensure `isThreat` returns `detected`, change `signalStrength > 75` to `signalStrength >= 75`, and change `droneStatus == \"ACTIVE\"` to `droneStatus.equals(\"ACTIVE\")`."
    },
    "hints": {
      "1": "How do you compare Strings in Java correctly?",
      "2": "Does `!detected` mean there is a threat?",
      "3": "Is `75` strong enough or do we need more?"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 300,
    "subtopic_id": 7,
    "type": "code_fixer",
    "difficulty": "hard",
    "snippet_choices": {
      "scenario": "You're building a life support monitor. The system checks oxygen levels, CO₂ concentration, crew heart rate, and chamber pressure. Based on these, it decides whether to: Trigger evacuation if oxygen < 15, CO₂ > 5, and (either heart rate > 120 or pressure < 90); Issue a warning if only one or two of those conditions are true; Continue normal operation otherwise. Fix the faulty code to ensure correct life support responses.",
      "code": "public class LifeSupportMonitor {\n    public static void main(String[] args) {\n        double oxygen = 12.0;\n        double co2 = 6.2;\n        int heartRate = 125;\n        int pressure = 95;\n\n        if (isLowOxygen(oxygen) && isHighCO2(co2) && isCriticalVitals(heartRate, pressure)) { // Corrected: use && for evacuation conditions\n            System.out.println(\"Evacuate immediately!\");\n        }\n        else if (isLowOxygen(oxygen) || isHighCO2(co2) || isCriticalVitals(heartRate, pressure)) { // Corrected: uses || for warning conditions\n            System.out.println(\"Life support warning issued.\");\n        }\n        else {\n            System.out.println(\"All systems nominal.\");\n        }\n    }\n\n    static boolean isLowOxygen(double o2) {\n        return o2 < 15;\n    }\n\n    static boolean isHighCO2(double co2) {\n        return co2 > 5;\n    }\n\n    static boolean isCriticalVitals(int hr, int pressure) {\n        return hr > 120 || pressure < 90;\n    }\n}",
      "expected_output": [
        "Evacuate immediately!"
      ],
      "hidden_test_case": {
        "oxygen": 12.0,
        "co2": 6.2,
        "heartRate": 125,
        "pressure": 95,
        "expected_output": "Evacuate immediately!"
      },
      "answer": [
        "Evacuate immediately!"
      ],
      "explanation": "The core issue lies in the first `if` statement's boolean logic and the overall `if-else` structure. The scenario requires evacuation when oxygen is critically low AND CO2 is high AND vitals are critical. The original `||` operator with `&&` has precedence issues (`isHighCO2(co2) && isCriticalVitals(heartRate, pressure)` would evaluate first). This needs to be explicitly grouped or use `&&` throughout if all conditions must be met for evacuation. Also, the second `if` should be an `else if` to ensure proper branching and prevent multiple messages, and proper `else` placement is crucial. The fix simplifies the evacuation condition using `&&` and ensures correct `if-else if-else` flow."
    },
    "hints": {
      "1": "What happens first: `&&` or `||`?",
      "2": "Should you always use braces in nested conditions?",
      "3": "Is oxygen alone enough to trigger evacuation?"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 301,
    "subtopic_id": 7,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder’s Decision Core is confused. It needs to decide whether to activate shields based on the current threat level. However, part of its decision logic is missing. You must complete the core's code so it can react logically.",
      "code": "public class DecisionCore {\n    public static void main(String[] args) {\n        int threatLevel = 8;\n\n        ???\n        System.out.println(\"High threat detected! Activating shields.\");\n        ???\n        System.out.println(\"Threat level acceptable. No action needed.\");\n    }\n}",
      "choices": [
        "if (threatLevel > 5) {",
        "else {",
        "if (threatLevel < 5)",
        "else if (threatLevel > 10)"
      ],
      "answer": [
        "if (threatLevel > 5) {",
        "else {"
      ],
      "explanation": "`if (threatLevel > 5)` correctly captures all higher threat levels. `else` handles the remaining values (5 and below). `if (threatLevel < 5)` skips exactly 5. `else if (threatLevel > 10)` is too narrow and ignores moderate threats (6–10)."
    },
    "difficulty": "easy",
    "hints": {
      "1": "If the system can only do two things, you might not need more than one condition.",
      "2": "The threat level is 8. Is that high or low? Choose logic that accounts for this specific input.",
      "3": "Think balance: precision is good, but don’t overcomplicate — you’re not building a rocket… just its defense AI."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 302,
    "subtopic_id": 7,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Decision Core must decide whether to reroute emergency power if energy drops too low. It has the data, but the control logic is broken. Complete the code to ensure proper power rerouting.",
      "code": "public class DecisionCore {\n    public static void main(String[] args) {\n        int energyLevel = 20;\n\n        ???\n        System.out.println(\"Rerouting power to essential systems.\");\n        ???\n        System.out.println(\"Energy stable. No rerouting needed.\");\n    }\n}",
      "choices": [
        "if (energyLevel <= 25) {",
        "else {",
        "if (energyLevel >= 80)",
        "else if (energyLevel < 10)"
      ],
      "answer": [
        "if (energyLevel <= 25) {",
        "else {"
      ],
      "explanation": "Threat is when energy is 25 or below, so we act. Else handles the rest (safe levels). Other options are unrelated to the range."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The core acts when energy is getting dangerously low.",
      "2": "Consider what '<=' means versus '>=' in context.",
      "3": "Only two paths exist: reroute or don’t."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 303,
    "subtopic_id": 7,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "Sensors are checking the ship's hull integrity. If it's under 70%, emergency repairs must be triggered. You must repair the missing logic.",
      "code": "public class DecisionCore {\n    public static void main(String[] args) {\n        int hullIntegrity = 68;\n\n        ???\n        System.out.println(\"Hull compromised! Initiating repairs.\");\n        ???\n        System.out.println(\"Hull integrity stable.\");\n    }\n}",
      "choices": [
        "if (hullIntegrity < 70) {",
        "else {",
        "if (hullIntegrity > 90)",
        "else if (hullIntegrity <= 30)"
      ],
      "answer": [
        "if (hullIntegrity < 70) {",
        "else {"
      ],
      "explanation": "Anything under 70 is a risk to the ship's shell. `else` can help simplify decisions when no other conditions are needed. The operator used detects a “below this threshold” scenario."
    },
    "difficulty": "easy",
    "hints": {
      "1": "Anything under 70 is a risk to the ship's shell.",
      "2": "else can help simplify decisions when no other conditions are needed.",
      "3": "Which operator detects a “below this threshold” scenario?"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 304,
    "subtopic_id": 7,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder’s AI locks down sensitive controls unless crew credentials are verified. The Decision Core must check if the username matches the commander’s ID before unlocking advanced features. Complete the code to correctly handle access control.",
      "code": "public class DecisionCore {\n    public static void main(String[] args) {\n        String username = \"CommanderZania\";\n\n        ???\n        System.out.println(\"Access granted. Welcome, Commander.\");\n        ???\n        System.out.println(\"Access denied. Unauthorized user.\");\n    }\n}",
      "choices": [
        "if (username.equals(\"CommanderZania\")) {",
        "else {",
        "if (username = \"CommanderZania\")",
        "if (username == \"CommanderZania\")"
      ],
      "answer": [
        "if (username.equals(\"CommanderZania\")) {",
        "else {"
      ],
      "explanation": "Java compares Strings using something other than ==. One condition checks for match; the other handles rejection. `=` is an assignment, not a comparison."
    },
    "difficulty": "easy",
    "hints": {
      "1": "Java compares Strings using something other than ==.",
      "2": "One condition checks for match; the other handles rejection.",
      "3": "`=` is an assignment, not a comparison."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 305,
    "subtopic_id": 7,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The ship's Decision Core routes crew to different panels based on rank. Captains get full control, officers partial access, cadets only diagnostics. The if-else-if ladder is glitching. Complete the code to correctly route crew members based on their rank.",
      "code": "public class DecisionCore {\n    public static void main(String[] args) {\n        String rank = \"Officer\";\n\n        ???\n        System.out.println(\"Full access granted.\");\n        ???\n        System.out.println(\"Partial access granted.\");\n        ???\n        System.out.println(\"Diagnostics access only.\");\n    }\n}",
      "choices": [
        "if (rank.equals(\"Captain\")) {",
        "else if (rank.equals(\"Officer\")) {",
        "else (rank.equals(\"Cadet\")) {",
        "if (rank == \"Officer\") {"
      ],
      "answer": [
        "if (rank.equals(\"Captain\")) {",
        "else if (rank.equals(\"Officer\")) {"
      ],
      "explanation": "A ladder handles multiple specific categories. Think .equals() vs == for strings in Java. `else` doesn’t take a condition — but `else if` does."
    },
    "difficulty": "easy",
    "hints": {
      "1": "A ladder handles multiple specific categories.",
      "2": "Think .equals() vs == for strings in Java.",
      "3": "`else` doesn’t take a condition — but `else if` does."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 306,
    "subtopic_id": 7,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The ship has suffered a hull breach. Life support, navigation, and communications are all competing for backup power. The Decision Core is supposed to check subsystem status flags and route power accordingly. Each flag is a boolean, and only one subsystem should receive power at a time — following this priority: Life Support > Navigation > Communications. You need to complete the logic that calls the right power-routing function, depending on which flag is true.",
      "code": "public class EmergencyPowerManager {\n    public static void main(String[] args) {\n        // Static subsystem statuses (pretend sensors fed this)\n        boolean lifeSupportActive = false;\n        boolean navigationActive = true;\n        boolean commsActive = true;\n\n        // Only one should run:\n        ???\n        routePowerTo(\"Life Support\");\n        ???\n        routePowerTo(\"Navigation\");\n        ???\n        routePowerTo(\"Communications\");\n    }\n\n    public static void routePowerTo(String system) {\n        System.out.println(\"Routing emergency power to: \" + system);\n    }\n}",
      "choices": [
        "if (lifeSupportActive) {",
        "else if (navigationActive && !lifeSupportActive) {",
        "else if (commsActive && !navigationActive && !lifeSupportActive) {",
        "if (navigationActive || commsActive) {",
        "else if (true) {",
        "else if (!lifeSupportActive) {"
      ],
      "answer": [
        "if (lifeSupportActive) {",
        "else if (navigationActive && !lifeSupportActive) {",
        "else if (commsActive && !navigationActive && !lifeSupportActive) {"
      ],
      "explanation": "The challenge requires routing power to only one subsystem based on a priority: Life Support > Navigation > Communications. Thus, conditions must be mutually exclusive. `if (lifeSupportActive)` takes highest priority. `else if (navigationActive && !lifeSupportActive)` ensures Navigation only gets power if Life Support is off. `else if (commsActive && !navigationActive && !lifeSupportActive)` ensures Communications only if both higher priorities are off. This cascading `if-else if` structure correctly enforces the priority system."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Only one system should be powered — this means you need mutually exclusive conditions.",
      "2": "Use negation (`!`) carefully to control the flow.",
      "3": "Think in fallbacks, not overlaps."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 307,
    "subtopic_id": 7,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder’s system detected an anomaly. The core must decide whether to activate the distress beacon, but it’s not that simple. The system should trigger the beacon only when: There’s no response from the crew. The AI system is unstable. The ship is outside communication range. Complete the logic that ensures the distress beacon is only activated under the right conditions.",
      "code": "public class EmergencyProtocol {\n    public static void main(String[] args) {\n        // Simulation inputs (static for test scenario)\n        boolean crewResponsive = false;        // no crew response\n        boolean aiStable = false;              // AI system malfunctioning\n        boolean inCommunicationRange = false;  // ship lost contact\n\n        // Insert condition to trigger beacon:\n        ???\n        activateBeacon();\n        ???\n        System.out.println(\"No beacon needed.\");\n    }\n\n    public static void activateBeacon() {\n        System.out.println(\"Distress Beacon ACTIVATED!\");\n    }\n}",
      "choices": [
        "if (!crewResponsive && !aiStable && !inCommunicationRange) {",
        "if (crewResponsive == false || aiStable == false || inCommunicationRange == false) {",
        "else if (crewResponsive || aiStable || inCommunicationRange) {",
        "else if (crewResponsive || aiStable) {",
        "if (!crewResponsive && aiStable && inCommunicationRange) {",
        "else if (!crewResponsive || !aiStable || !inCommunicationRange) {"
      ],
      "answer": [
        "if (!crewResponsive && !aiStable && !inCommunicationRange) {",
        "else if (!crewResponsive || !aiStable || !inCommunicationRange) {"
      ],
      "explanation": "The distress beacon should activate only when crew is not responsive, AI is not stable, and the ship is not in communication range. This requires a strict `AND` condition of three negations for the `if` block. The `else if` then handles any other scenario where the beacon is not strictly needed, acting as a guard clause."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Triple-check the negative logic — beacon only activates when all are false.",
      "2": "Use `&&` for strict conditions; `||` when even one failure should prevent activation.",
      "3": "Think of the `else if` as a guard clause — make sure nothing slips through accidentally."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 308,
    "subtopic_id": 7,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder’s life support module is trying to determine whether to increase oxygen output or send a critical alert. It evaluates several real-time conditions: oxygenLevel is below 19%, CO2Level is above 1000 ppm, and crewAwake is true. Only when all conditions are met should the system increase oxygen output. Otherwise, it should trigger a critical alert. Complete the decision logic.",
      "code": "public class LifeSupportCheck {\n    public static void main(String[] args) {\n        // Static input for simulation\n        double oxygenLevel = 18.5;        // oxygen in percentage\n        int CO2Level = 1100;              // CO2 in ppm\n        boolean crewAwake = true;         // crew status\n\n        // Incomplete decision logic:\n        ???\n        increaseOxygen();\n        ???\n        sendCriticalAlert();\n    }\n\n    public static void increaseOxygen() {\n        System.out.println(\"Increasing oxygen output...\");\n    }\n\n    public static void sendCriticalAlert() {\n        System.out.println(\"CRITICAL ALERT: Life support failing!\");\n    }\n}",
      "choices": [
        "if (oxygenLevel < 19 && CO2Level > 1000 && crewAwake) {",
        "if (oxygenLevel < 20 || CO2Level > 1000) {",
        "if (oxygenLevel < 19 && CO2Level > 1000 || crewAwake) {",
        "else if (oxygenLevel >= 19 || CO2Level <= 1000 || !crewAwake) {",
        "if (oxygenLevel < 19 && CO2Level > 1000 && crewAwake == true) {",
        "else if (oxygenLevel < 19 && CO2Level > 1000 && crewAwake) {"
      ],
      "answer": [
        "if (oxygenLevel < 19 && CO2Level > 1000 && crewAwake) {",
        "else if (oxygenLevel >= 19 || CO2Level <= 1000 || !crewAwake) {"
      ],
      "explanation": "The system should increase oxygen output only when all three conditions are met (oxygen low, CO2 high, crew awake), requiring an `AND` for the `if` block. The `else if` should cover all other possibilities that don't meet the oxygen increase criteria, triggering a critical alert if any of those 'safe' conditions are *not* met."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Remember that the system is cautious — all danger signs must be present to adjust oxygen.",
      "2": "Be specific — using `&&` ensures multiple checks are passed before acting.",
      "3": "The `else if` block handles all other possibilities — think what happens if even one condition isn’t true."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 309,
    "subtopic_id": 7,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "You're inside the Pathfinder’s Secure Bridge, blocked by a biometric gate. The AI should allow access only if the crew member’s ID is valid and they’ve completed security clearance. If not, it should deny access and alert the captain. Complete the logic circuits for decision-making.",
      "code": "public class AccessControl {\n    public static void main(String[] args) {\n        // Simulated user credentials\n        boolean validID = true;              // ✅ crew ID validity\n        boolean clearanceComplete = false;   // ❌ security check\n        boolean biometricScan = true;        // ✅ thumb scan complete\n\n        ???\n        grantAccess();\n\n        ???\n        requestBiometricRescan();\n\n        ???\n        alertCaptain();\n    }\n\n    public static void grantAccess() {\n        System.out.println(\"✅ Access granted. Welcome aboard.\");\n    }\n\n    public static void requestBiometricRescan() {\n        System.out.println(\"⚠️ Biometric scan failed. Please rescan.\");\n    }\n\n    public static void alertCaptain() {\n        System.out.println(\"🚨 Access denied. Captain has been notified.\");\n    }\n}",
      "choices": [
        "if (validID && clearanceComplete && biometricScan) {",
        "else if (validID && !biometricScan) {",
        "else {",
        "if (validID || clearanceComplete || biometricScan) {",
        "else if (!validID && clearanceComplete) {",
        "if (!validID && !clearanceComplete && biometricScan) {"
      ],
      "answer": [
        "if (validID && clearanceComplete && biometricScan) {",
        "else if (validID && !biometricScan) {",
        "else {"
      ],
      "explanation": "The bridge must only open when everything checks out. An else without a condition is perfect when you've already handled the positive case. Using || in this situation would grant access too easily — not good for security."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The bridge must only open when everything checks out.",
      "2": "An else without a condition is perfect when you've already handled the positive case.",
      "3": "Using || in this situation would grant access too easily — not good for security."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 310,
    "subtopic_id": 7,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "You're inside the Pathfinder's Bridge Terminal, where only users with proper credentials are allowed to issue ship commands. The AI system must validate access based on: The user's security level (should be at least 3), If they're logged in, and Whether they're trying to access restricted controls. Your job? Complete the decision logic to grant or deny access safely.",
      "code": "public class BridgeAccessControl {\n    public static void main(String[] args) {\n        // Static simulation data\n        int securityLevel = 4;           // Required: level 3 or higher\n        boolean isLoggedIn = true;\n        boolean wantsRestrictedAccess = true;\n\n        ???\n        grantAccess();\n        ???\n        restrictAccess();\n        ???\n        denyAccess();\n    }\n\n    public static void grantAccess() {\n        System.out.println(\"Access granted. Welcome to the Bridge Terminal.\");\n    }\n\n    public static void restrictAccess() {\n        System.out.println(\"Access limited. Restricted controls unavailable.\");\n    }\n\n    public static void denyAccess() {\n        System.out.println(\"Access denied. Unauthorized attempt detected.\");\n    }\n}",
      "choices": [
        "if (securityLevel >= 3 && isLoggedIn) {",
        "else if (wantsRestrictedAccess) {",
        "if (isLoggedIn && wantsRestrictedAccess) {",
        "else {",
        "if (securityLevel > 3 || !isLoggedIn) {",
        "else if (securityLevel <= 3 && wantsRestrictedAccess) {"
      ],
      "answer": [
        "if (securityLevel >= 3 && isLoggedIn) {",
        "else if (wantsRestrictedAccess) {",
        "else {"
      ],
      "explanation": "Security systems typically check the user's level first, not last. Not all logged-in users should get full access. `else` is your safety net when all other conditions fail."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Security systems typically check the user's level first, not last.",
      "2": "Not all logged-in users should get full access.",
      "3": "else is your safety net when all other conditions fail."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 311,
    "subtopic_id": 7,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder's security core is locked due to rising internal temperatures and rogue AI processes. A crew member is attempting to authenticate access, but not all loginoporto attempts are safe. Access should only be granted if: The credentials are correct, The account is not locked, The retry count is below maximum, Or an emergency override is active. Complete the logic that ensures access is only granted under proper, secure conditions.",
      "code": "public class SecureBridgeAccess {\n    public static void main(String[] args) {\n        // Static test scenario\n        String username = \"commander01\";\n        String password = \"redPhoenix\";\n        boolean isLocked = true;\n        int retryCount = 3;\n        boolean overrideKeyActive = true;\n\n        if (!isLocked) {\n            ???\n            System.out.println(\"✅ Access Granted: Welcome Commander.\");\n        } else {\n            ???\n            System.out.println(\"🔓 Override Access Enabled.\");\n        }\n    }\n}",
      "choices": [
        "if (username.equals(\"commander01\") && password.equals(\"redPhoenix\")) {",
        "else if (retryCount >= 3 && overrideKeyActive) {",
        "if (isLocked && overrideKeyActive) {",
        "else {",
        "if (retryCount < 3 && overrideKeyActive) {",
        "else if (!overrideKeyActive) {",
        "if (username == \"commander01\" && password ==\"redPhoenix\") {",
        "else if (overrideKeyActive) {"
      ],
      "answer": [
        "if (username.equals(\"commander01\") && password.equals(\"redPhoenix\")) {",
        "else if (retryCount >= 3 && overrideKeyActive) {",
        "if (isLocked && overrideKeyActive) {",
        "else {"
      ],
      "explanation": "The system behaves differently depending on whether it's locked or not — split logic starts from that. Retry logic is only useful if the account isn't locked yet. An active override bypasses even locked status — but must be explicitly checked."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The system behaves differently depending on whether it's locked or not — split logic starts from that.",
      "2": "Retry logic is only useful if the account isn't locked yet.",
      "3": "An active override bypasses even locked status — but must be explicitly checked."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 312,
    "subtopic_id": 7,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder’s Reactor Core is in a volatile state. The system must determine whether to engage cooling based on a chain of strict conditions: If the core temperature is above 1000°C, activate emergency cooling immediately. If the core temperature is between 600°C and 1000°C, cooling is allowed only if: The pressure is stable, and Coolant levels are sufficient. If the temperature is below 600°C, no action unless there’s an emergency override. If all else fails, default to a safe fallback mode. Complete the code by filling the four missing logical conditions embedded in a skewed nested if-else decision structure.",
      "code": "public class ReactorControl {\n    public static void main(String[] args) {\n        // Simulated sensor readings\n        int coreTemperature = 750;     // degrees Celsius\n        boolean pressureStable = true;\n        boolean coolantSufficient = true;\n        boolean emergencyOverride = false;\n\n        if (coreTemperature > 1000) {\n            System.out.println(\"CRITICAL: Cooling System ENGAGED Immediately!\");\n        } else if (coreTemperature >= 600) {\n            ???\n            System.out.println(\"MODERATE: Cooling System Activated.\");\n        } else {\n            ???\n            System.out.println(\"WARNING: Cannot Activate Cooling – Insufficient Support.\");\n        }\n    }\n}",
      "choices": [
        "if (pressureStable && coolantSufficient) {",
        "if (pressureStable || coolantSufficient) {",
        "else if (!pressureStable || !coolantSufficient) {",
        "else {",
        "if (!emergencyOverride) {",
        "else {",
        "if (pressureStable && !coolantSufficient) {",
        "else if (coreTemperature < 600 && emergencyOverride) {"
      ],
      "answer": [
        "if (pressureStable && coolantSufficient) {",
        "else if (!pressureStable || !coolantSufficient) {",
        "if (!emergencyOverride) {",
        "else {"
      ],
      "explanation": "The system should never assume it’s safe to cool unless everything checks out — pressure AND coolant must be good. Reactors don’t forgive ambiguity — if even one safety check fails, that path must be blocked. If emergencyOverride is active, do not second-guess — follow the override. Logic must submit."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The system should never assume it’s safe to cool unless everything checks out — pressure AND coolant must be good.",
      "2": "Reactors don’t forgive ambiguity — if even one safety check fails, that path must be blocked.",
      "3": "If emergencyOverride is active, do not second-guess — follow the override. Logic must submit."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 313,
    "subtopic_id": 7,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder’s docking system has detected a potential emergency docking sequence with an unidentified vessel. The system must make a high-stakes decision to proceed or abort the docking based on the following conditions: If the vessel’s ID is verified and docking alignment is perfect, initiate auto-docking. If the vessel is not verified but marked as friendly, docking may proceed only if: The alignment is perfect, and The Pathfinder’s shield is active. If the vessel is unverified and not friendly, but a distress signal is detected, ask for crew confirmation. If none of these criteria are met, abort docking and lock bay doors. Your job: complete the four missing logical conditions embedded in a skewed nested if-else decision structure.",
      "code": "public class DockingControl {\n    public static void main(String[] args) {\n        // Simulated inputs\n        boolean vesselIDVerified = false;\n        boolean vesselIsFriendly = true;\n        boolean alignmentPerfect = true;\n        boolean shieldActive = true;\n        boolean distressSignalDetected = false;\n        boolean crewConfirmed = false;\n\n        if (vesselIDVerified) {\n            if (alignmentPerfect) {\n                System.out.println(\"Auto-Docking Initiated: Verified Vessel.\");\n            } else {\n                System.out.println(\"Abort: Misaligned Verified Vessel.\");\n            }\n        } else if (vesselIsFriendly) {\n            ???\n            System.out.println(\"Conditional Docking Allowed: Friendly Vessel.\");\n        } else {\n            ???\n            System.out.println(\"Abort: Friendly Vessel – Unsafe to Dock.\");\n        }\n    }\n}",
      "choices": [
        "if (alignmentPerfect && shieldActive) {",
        "if (alignmentPerfect || shieldActive) {",
        "else if (!alignmentPerfect || !shieldActive) {",
        "else {",
        "if (crewConfirmed) {",
        "else {",
        "else if (!alignmentPerfect || shieldAshieldActivective)",
        "else if (alignmentPerfect || !)"
      ],
      "answer": [
        "if (alignmentPerfect && shieldActive) {",
        "else if (!alignmentPerfect || !shieldActive) {",
        "if (crewConfirmed) {",
        "else {"
      ],
      "explanation": "Allowing a friendly vessel to dock without full system integrity might open the ship to risk. If docking support systems are even partially down, it shouldn’t proceed. Just because a distress signal is received doesn’t mean you ignore procedure. There needs to be clear, internal confirmation before committing to such a critical action. When neither verification nor friendliness is present, and no signal exists, the system must not proceed. It must fall back to absolute safety — no ambiguity allowed."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Allowing a friendly vessel to dock without full system integrity might open the ship to risk. If docking support systems are even partially down, it shouldn’t proceed.",
      "2": "Just because a distress signal is received doesn’t mean you ignore procedure. There needs to be clear, internal confirmation before committing to such a critical action.",
      "3": "When neither verification nor friendliness is present, and no signal exists, the system must not proceed. It must fall back to absolute safety — no ambiguity allowed."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 314,
    "subtopic_id": 7,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "A fire alert just went off somewhere on the ship. The AI needs to quickly figure out how serious it is and decide what to do. If both the crew and important ship systems are in danger, it should break the lockdown and save both. If only the crew is at risk, it should help them get out and seal the area. If no one’s inside but the ship’s systems are in trouble, it should fight the fire but keep everything locked. If there’s no real danger (just a weird fire signal), the AI should log it and do nothing. If none of those situations fit, just treat it like a regular check-up. Complete the incomplete code.",
      "code": "public class EthicsCore {\n    public static void main(String[] args) {\n        // Emergency Data Feed\n        boolean crewInDanger = true;\n        boolean criticalSystemsAtRisk = false;\n        boolean crewPresent = true;\n        boolean fireDetected = true;\n\n        if (crewInDanger && criticalSystemsAtRisk) {\n            System.out.println(\"PRIORITY: Lockdown Override – Save Crew and Systems!\");\n        } else if (crewInDanger) {\n            ???\n            System.out.println(\"EVACUATE: Crew Safety Protocol Initiated.\");\n        } else if (criticalSystemsAtRisk && !crewPresent) {\n            ???\n            System.out.println(\"Suppressing Fire: Lockdown Maintained.\");\n        } else if (!crewInDanger && !criticalSystemsAtRisk && fireDetected) {\n            ???\n            System.out.println(\"FALSE ALARM: Fire Logged – No Action Required.\");\n        } else {\n            ???\n            System.out.println(\"Status Nominal: No Threat Detected.\");\n        }\n    }\n}",
      "choices": [
        "else if (crewInDanger && !criticalSystemsAtRisk) {",
        "if (!criticalSystemsAtRisk && crewInDanger) {",
        "else if (criticalSystemsAtRisk && !crewPresent) {",
        "else if (criticalSystemsAtRisk || crewPresent) {",
        "else if (!crewInDanger && !criticalSystemsAtRisk && fireDetected) {",
        "if (fireDetected && !crewInDanger && !criticalSystemsAtRisk) {",
        "else {",
        "else if (!fireDetected) {"
      ],
      "answer": [
        "else if (crewInDanger && !criticalSystemsAtRisk) {",
        "else if (criticalSystemsAtRisk && !crewPresent) {",
        "else if (!crewInDanger && !criticalSystemsAtRisk && fireDetected) {",
        "else {"
      ],
      "explanation": "If the crew is in danger but systems aren’t, sealing off the affected wing is safer than overriding lockdown — the priority is human life, but without system risk, no need to compromise ship integrity. Suppressing a fire in a system area without risking crew exposure is acceptable, but the lockdown should remain intact — no need for override if lives aren’t on the line. False alarms must be filtered out by checking all conditions — if no one’s in danger and systems are stable, logging is enough. Acting on noise is how ships waste resources — or worse, cause more chaos."
    },
    "difficulty": "hard",
    "hints": {
      "1": "If the crew is in danger but systems aren’t, sealing off the affected wing is safer than overriding lockdown — the priority is human life, but without system risk, no need to compromise ship integrity.",
      "2": "Suppressing a fire in a system area without risking crew exposure is acceptable, but the lockdown should remain intact — no need for override if lives aren’t on the line.",
      "3": "False alarms must be filtered out by checking all conditions — if no one’s in danger and systems are stable, logging is enough. Acting on noise is how ships waste resources — or worse, cause more chaos."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 315,
    "subtopic_id": 7,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder AI is negotiating a delicate situation involving an unidentified vessel. The system must assess threat levels, weapon readiness, and communication status to determine the correct diplomatic or defensive response. The AI must decide whether to engage, communicate, or log the encounter — and ensure fallback safety if none of the standard paths are viable. The logic must be precise. Each situation demands a specific action. Complete the incomplete code.",
      "code": "public class DiplomacyProtocol {\n    public static void main(String[] args) {\n        // Incoming Encounter Data\n        boolean threatDetected = true;\n        boolean weaponsArmed = false;\n        boolean vesselResponsive = false;\n\n        if (threatDetected && weaponsArmed) {\n            System.out.println(\"ALERT: Countermeasures Engaged!\");\n        } else if (threatDetected && !weaponsArmed) {\n            ???\n            System.out.println(\"Diplomatic Attempt: Shields Raised, Hailing...\");\n        } else if (!threatDetected && !vesselResponsive) {\n            ???\n            System.out.println(\"Broadcast Warning: Awaiting Acknowledgment.\");\n        } else if (!threatDetected && vesselResponsive) {\n            ???\n            System.out.println(\"LOGGED: Peaceful Contact Recorded.\");\n        } else {\n            ???\n            System.out.println(\"Standby Mode: Monitoring Situation.\");\n        }\n    }\n}",
      "choices": [
        "else if (threatDetected && !weaponsArmed) {",
        "else if (!threatDetected && !vesselResponsive) {",
        "if (!threatDetected && vesselResponsive) {",
        "else if (weaponsArmed || threatDetected) {",
        "else if (!threatDetected && vesselResponsive) {",
        "if (vesselResponsive && !threatDetected) {",
        "else {",
        "if (threatDetected && weaponsArmed && vesselResponsive) {"
      ],
      "answer": [
        "else if (threatDetected && !weaponsArmed) {",
        "else if (!threatDetected && !vesselResponsive) {",
        "else if (!threatDetected && vesselResponsive) {",
        "else {"
      ],
      "explanation": "Hostility doesn’t always mean action — the system must weigh armed status before engaging. Silence from a vessel, even if not hostile, shouldn’t be ignored — some reaction is necessary. Peaceful interactions must still be processed for future records — no encounter goes undocumented."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Hostility doesn’t always mean action — the system must weigh armed status before engaging.",
      "2": "Silence from a vessel, even if not hostile, shouldn’t be ignored — some reaction is necessary.",
      "3": "Peaceful interactions must still be processed for future records — no encounter goes undocumented."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 316,
    "subtopic_id": 8,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder’s automated hull scanner runs a diagnostic. A `while` loop controls the number of scans. Your task is to trace the code and determine how many times \"Performing hull scan.\" is printed.",
      "code": "public class HullScanner {\n    public static void main(String[] args) {\n        int scanCount = 0;\n        while (scanCount < 3) {\n            System.out.println(\"Performing hull scan.\");\n            scanCount++;\n        }\n    }\n}",
      "choices": [
        "Performing hull scan.",
        "Performing hull scan.\\nPerforming hull scan.\\nPerforming hull scan.",
        "Nothing",
        "Error"
      ],
      "answer": [
        "Performing hull scan.\\nPerforming hull scan.\\nPerforming hull scan."
      ],
      "explanation": "The `while` loop starts with `scanCount = 0`.\n1. **Iteration 1**: `scanCount` (0) is less than 3 (`true`). Prints \"Performing hull scan.\". `scanCount` becomes 1.\n2. **Iteration 2**: `scanCount` (1) is less than 3 (`true`). Prints \"Performing hull scan.\". `scanCount` becomes 2.\n3. **Iteration 3**: `scanCount` (2) is less than 3 (`true`). Prints \"Performing hull scan.\". `scanCount` becomes 3.\n4. **Iteration 4**: `scanCount` (3) is less than 3 (`false`). The loop terminates.\nThe message is printed 3 times."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The loop continues as long as `scanCount` is less than `3`.",
      "2": "`scanCount` starts at `0` and increments by `1` in each iteration.",
      "3": "Count how many times the `System.out.println()` line is executed."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 317,
    "subtopic_id": 8,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder’s emergency beacon operates with a `do-while` loop, ensuring it blinks at least once. Your task is to trace the code and determine how many times \"Beacon: Blink!\" is printed.",
      "code": "public class BeaconFlasher {\n    public static void main(String[] args) {\n        int blinkCount = 0;\n        do {\n            System.out.println(\"Beacon: Blink!\");\n            blinkCount++;\n        } while (blinkCount < 0);\n    }\n}",
      "choices": [
        "Nothing",
        "Beacon: Blink!",
        "Beacon: Blink!\\nBeacon: Blink!",
        "Error"
      ],
      "answer": [
        "Beacon: Blink!"
      ],
      "explanation": "The `do-while` loop ensures its body executes at least once.\n1. **First Execution**: Prints \"Beacon: Blink!\". `blinkCount` becomes 1.\n2. **Condition Check**: `blinkCount` (1) is less than 0 (`false`). The loop terminates.\nThe message is printed only 1 time."
    },
    "difficulty": "easy",
    "hints": {
      "1": "A `do-while` loop *always* executes its body at least once before checking the condition.",
      "2": "The `blinkCount` starts at `0`.",
      "3": "Evaluate the `while` condition (`blinkCount < 0`) after the first execution."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 318,
    "subtopic_id": 8,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder’s power core runs `cyclesCompleted`. A `while` loop simulates these cycles, printing the current cycle number. Your task is to trace the code and determine the sequence of numbers printed on a single line.",
      "code": "public class PowerCoreCycler {\n    public static void main(String[] args) {\n        int cyclesCompleted = 1;\n        while (cyclesCompleted <= 2) {\n            System.out.print(cyclesCompleted + \" \");\n            cyclesCompleted++;\n        }\n    }\n}",
      "choices": [
        "1 2",
        "1 2 3",
        "0 1 2",
        "Nothing"
      ],
      "answer": [
        "1 2"
      ],
      "explanation": "The `while` loop starts with `cyclesCompleted = 1`.\n1. **Iteration 1**: `cyclesCompleted` (1) is `<= 2` (`true`). Prints \"1 \". `cyclesCompleted` becomes 2.\n2. **Iteration 2**: `cyclesCompleted` (2) is `<= 2` (`true`). Prints \"2 \". `cyclesCompleted` becomes 3.\n3. **Iteration 3**: `cyclesCompleted` (3) is `<= 2` (`false`). The loop terminates.\nThe output is \"1 2 \"."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The loop starts with `cyclesCompleted = 1`.",
      "2": "The loop continues as long as `cyclesCompleted` is `less than or equal to 2`.",
      "3": "The `System.out.print()` statement includes a space after the number."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 319,
    "subtopic_id": 8,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder is clearing its data buffers. A `do-while` loop tracks `bytesRemaining`, decrementing and printing the count until no bytes are left. Your task is to trace the code and determine the lines printed.",
      "code": "public class DataBufferClearer {\n    public static void main(String[] args) {\n        int bytesRemaining = 2;\n        do {\n            System.out.println(\"Clearing \" + bytesRemaining + \" bytes.\");\n            bytesRemaining--;\n        } while (bytesRemaining > 0);\n    }\n}",
      "choices": [
        "Clearing 2 bytes.\\nClearing 1 bytes.",
        "Clearing 2 bytes.",
        "Clearing 2 bytes.\\nClearing 1 bytes.\\nClearing 0 bytes.",
        "Error"
      ],
      "answer": [
        "Clearing 2 bytes.\\nClearing 1 bytes."
      ],
      "explanation": "The `do-while` loop starts with `bytesRemaining = 2`.\n1. **Iteration 1**: Prints \"Clearing 2 bytes.\". `bytesRemaining` becomes 1.\n2. **Condition Check**: `bytesRemaining` (1) is greater than 0 (`true`). Loop continues.\n3. **Iteration 2**: Prints \"Clearing 1 bytes.\". `bytesRemaining` becomes 0.\n4. **Condition Check**: `bytesRemaining` (0) is greater than 0 (`false`). The loop terminates.\nThe output shows two lines."
    },
    "difficulty": "easy",
    "hints": {
      "1": "A `do-while` loop executes its body at least once.",
      "2": "The loop condition `bytesRemaining > 0` is checked *after* each iteration.",
      "3": "Trace the value of `bytesRemaining` and when it's printed, then when it changes."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 320,
    "subtopic_id": 8,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder’s thrusters undergo a controlled cycle check. A `while` loop is set up, but the initial `cyclesDone` might prevent it from running. Your task is to trace the code and determine the final output.",
      "code": "public class ThrusterControl {\n    public static void main(String[] args) {\n        int cyclesDone = 5;\n        while (cyclesDone < 5) {\n            System.out.println(\"Thruster cycle \" + cyclesDone + \" engaged.\");\n            cyclesDone++;\n        }\n        System.out.println(\"Final Cycles Done: \" + cyclesDone);\n    }\n}",
      "choices": [
        "Nothing",
        "Thruster cycle 5 engaged.\\nFinal Cycles Done: 6",
        "Final Cycles Done: 5",
        "Error"
      ],
      "answer": [
        "Final Cycles Done: 5"
      ],
      "explanation": "The `while` loop starts with `cyclesDone = 5`.\n1. **Condition Check**: `cyclesDone` (5) is less than 5 (`false`). The loop body is never executed.\n2. The loop terminates immediately.\n3. The line `System.out.println(\"Final Cycles Done: \" + cyclesDone);` executes, printing \"Final Cycles Done: 5\"."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The `while` loop checks its condition *before* executing its body.",
      "2": "Evaluate the initial `while` condition: Is `cyclesDone` less than `5`?",
      "3": "The final `System.out.println()` statement runs *after* the loop (whether it executed or not)."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 321,
    "subtopic_id": 8,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder’s diagnostic system runs multiple cycles until a target is reached. Your task is to trace the `while` loop and determine both the diagnostic messages printed during each cycle and the `Final Cycle Count`.",
      "code": "public class DiagnosticSystem {\n    public static void main(String[] args) {\n        int currentCycle = 1;\n        int targetCycle = 3;\n\n        while (currentCycle <= targetCycle) {\n            System.out.println(\"Running diagnostic cycle: \" + currentCycle);\n            currentCycle++;\n        }\n        System.out.println(\"Final Cycle Count: \" + currentCycle);\n    }\n}",
      "choices": [
        "Running diagnostic cycle: 1\\nRunning diagnostic cycle: 2\\nRunning diagnostic cycle: 3",
        "Final Cycle Count: 3",
        "Running diagnostic cycle: 1\\nRunning diagnostic cycle: 2\\nRunning diagnostic cycle: 3\\nFinal Cycle Count: 4",
        "Final Cycle Count: 4"
      ],
      "answer": [
        "Running diagnostic cycle: 1\\nRunning diagnostic cycle: 2\\nRunning diagnostic cycle: 3",
        "Final Cycle Count: 4"
      ],
      "explanation": "1. **Loop Iterations**: \n    * `currentCycle = 1`: `1 <= 3` is `true`. Prints \"Running diagnostic cycle: 1\". `currentCycle` becomes 2.\n    * `currentCycle = 2`: `2 <= 3` is `true`. Prints \"Running diagnostic cycle: 2\". `currentCycle` becomes 3.\n    * `currentCycle = 3`: `3 <= 3` is `true`. Prints \"Running diagnostic cycle: 3\". `currentCycle` becomes 4.\n    * `currentCycle = 4`: `4 <= 3` is `false`. Loop terminates.\n2. **After Loop**: The `System.out.println(\"Final Cycle Count: \" + currentCycle);` statement executes, printing \"Final Cycle Count: 4\" (the value `currentCycle` had when the loop terminated)."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The loop prints `currentCycle` *inside* the loop.",
      "2": "`currentCycle` increments *after* each print, and also dictates when the loop stops.",
      "3": "The final `System.out.println()` executes *after* the loop, showing `currentCycle`'s value *at termination*."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 322,
    "subtopic_id": 8,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder is uploading data packets using a `do-while` loop. This loop guarantees at least one packet is sent before checking if more need to be transmitted. Your task is to trace the code and determine both the \"Sending packet...\" messages and the `Final Packets Sent`.",
      "code": "public class DataUploader {\n    public static void main(String[] args) {\n        int packetsSent = 0;\n        int maxPackets = 2;\n\n        do {\n            System.out.println(\"Sending packet...\");\n            packetsSent++;\n        } while (packetsSent < maxPackets);\n        System.out.println(\"Final Packets Sent: \" + packetsSent);\n    }\n}",
      "choices": [
        "Sending packet...\\nSending packet...",
        "Final Packets Sent: 2",
        "Sending packet...\\nSending packet...\\nFinal Packets Sent: 2",
        "Final Packets Sent: 3"
      ],
      "answer": [
        "Sending packet...\\nSending packet...",
        "Final Packets Sent: 2"
      ],
      "explanation": "1. **Loop Iterations**:\n    * `packetsSent = 0`: Executes. Prints \"Sending packet...\". `packetsSent` becomes 1. Condition (1 < 2) is `true`.\n    * `packetsSent = 1`: Executes. Prints \"Sending packet...\". `packetsSent` becomes 2. Condition (2 < 2) is `false`. Loop terminates.\n2. **After Loop**: `System.out.println(\"Final Packets Sent: \" + packetsSent);` executes, printing \"Final Packets Sent: 2\" (the value `packetsSent` had at termination)."
    },
    "difficulty": "medium",
    "hints": {
      "1": "A `do-while` loop executes its body at least once.",
      "2": "The loop condition `packetsSent < maxPackets` determines how many times the loop body repeats.",
      "3": "The first output is generated inside the loop, the second outside."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 323,
    "subtopic_id": 8,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder’s chronometer is counting down `timeUnits` in decrements of 2. Your task is to trace the `while` loop and determine all \"Time Units\" messages printed and the `Loop Ended` message.",
      "code": "public class Chronometer {\n    public static void main(String[] args) {\n        int timeUnits = 8;\n        String loopEndedMessage = \"Loop Ended.\";\n\n        while (timeUnits > 0) {\n            System.out.println(\"Time Units: \" + timeUnits);\n            timeUnits -= 2;\n        }\n        System.out.println(loopEndedMessage);\n    }\n}",
      "choices": [
        "Time Units: 8\\nTime Units: 6\\nTime Units: 4\\nTime Units: 2",
        "Loop Ended.",
        "Time Units: 8\\nTime Units: 6\\nTime Units: 4\\nTime Units: 2\\nLoop Ended.",
        "Time Units: 8\\nTime Units: 6\\nTime Units: 4\\nTime Units: 2\\nTime Units: 0"
      ],
      "answer": [
        "Time Units: 8\\nTime Units: 6\\nTime Units: 4\\nTime Units: 2",
        "Loop Ended."
      ],
      "explanation": "1. **Loop Iterations**:\n    * `timeUnits = 8`: `8 > 0` is `true`. Prints \"Time Units: 8\". `timeUnits` becomes 6.\n    * `timeUnits = 6`: `6 > 0` is `true`. Prints \"Time Units: 6\". `timeUnits` becomes 4.\n    * `timeUnits = 4`: `4 > 0` is `true`. Prints \"Time Units: 4\". `timeUnits` becomes 2.\n    * `timeUnits = 2`: `2 > 0` is `true`. Prints \"Time Units: 2\". `timeUnits` becomes 0.\n2. **After Loop**: The `System.out.println(loopEndedMessage);` executes, printing \"Loop Ended.\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Trace `timeUnits` as it decrements by `2` in each iteration.",
      "2": "The loop terminates when `timeUnits` is no longer greater than `0`.",
      "3": "The `loopEndedMessage` is printed only once, after the loop."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 324,
    "subtopic_id": 8,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder’s battery charger operates with a `while` loop, increasing the `chargeLevel` until it reaches `maxCharge`. Your task is to trace the code and determine both the \"Charging\" messages and the `Battery Full` message.",
      "code": "public class BatteryCharger {\n    public static void main(String[] args) {\n        int chargeLevel = 80;\n        int maxCharge = 100;\n\n        while (chargeLevel < maxCharge) {\n            System.out.println(\"Charging: \" + chargeLevel + \"%\");\n            chargeLevel += 5;\n        }\n        System.out.println(\"Battery Full: \" + chargeLevel + \"%\");\n    }\n}",
      "choices": [
        "Charging: 80%\\nCharging: 85%\\nCharging: 90%\\nCharging: 95%",
        "Battery Full: 100%",
        "Charging: 80%\\nCharging: 85%\\nCharging: 90%\\nCharging: 95%\\nBattery Full: 100%",
        "Battery Full: 95%"
      ],
      "answer": [
        "Charging: 80%\\nCharging: 85%\\nCharging: 90%\\nCharging: 95%",
        "Battery Full: 100%"
      ],
      "explanation": "1. **Loop Iterations**:\n    * `chargeLevel = 80`: `80 < 100` is `true`. Prints \"Charging: 80%\". `chargeLevel` becomes 85.\n    * `chargeLevel = 85`: `85 < 100` is `true`. Prints \"Charging: 85%\". `chargeLevel` becomes 90.\n    * `chargeLevel = 90`: `90 < 100` is `true`. Prints \"Charging: 90%\". `chargeLevel` becomes 95.\n    * `chargeLevel = 95`: `95 < 100` is `true`. Prints \"Charging: 95%\". `chargeLevel` becomes 100.\n    * `chargeLevel = 100`: `100 < 100` is `false`. Loop terminates.\n2. **After Loop**: The `System.out.println(\"Battery Full: \" + chargeLevel + \"%\");` statement executes, printing \"Battery Full: 100%\" (the value `chargeLevel` had when the loop terminated)."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Trace `chargeLevel` as it increases by `5` in each iteration.",
      "2": "The loop continues as long as `chargeLevel` is less than `maxCharge`.",
      "3": "The final `System.out.println()` runs after the loop ends, showing the value that caused termination."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 325,
    "subtopic_id": 8,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder’s communication system attempts signal lock using a `do-while` loop. This loop runs a fixed number of `attemptsMade`. Your task is to trace the code and determine both the \"Attempting signal lock\" messages and the `Signal Lock Procedure Complete` message.",
      "code": "public class CommsSignalLock {\n    public static void main(String[] args) {\n        int attemptsMade = 1;\n        String completionMessage = \"Signal Lock Procedure Complete.\";\n\n        do {\n            System.out.println(\"Attempting signal lock. Attempt: \" + attemptsMade);\n            attemptsMade++;\n        } while (attemptsMade <= 3);\n        System.out.println(completionMessage);\n    }\n}",
      "choices": [
        "Attempting signal lock. Attempt: 1\\nAttempting signal lock. Attempt: 2\\nAttempting signal lock. Attempt: 3",
        "Signal Lock Procedure Complete.",
        "Attempting signal lock. Attempt: 1\\nAttempting signal lock. Attempt: 2\\nAttempting signal lock. Attempt: 3\\nSignal Lock Procedure Complete.",
        "Attempting signal lock. Attempt: 1\\nAttempting signal lock. Attempt: 2\\nSignal Lock Procedure Complete."
      ],
      "answer": [
        "Attempting signal lock. Attempt: 1\\nAttempting signal lock. Attempt: 2\\nAttempting signal lock. Attempt: 3",
        "Signal Lock Procedure Complete."
      ],
      "explanation": "1. **Loop Iterations**:\n    * `attemptsMade = 1`: Executes. Prints \"Attempting signal lock. Attempt: 1\". `attemptsMade` becomes 2. Condition (2 <= 3) is `true`.\n    * `attemptsMade = 2`: Executes. Prints \"Attempting signal lock. Attempt: 2\". `attemptsMade` becomes 3. Condition (3 <= 3) is `true`.\n    * `attemptsMade = 3`: Executes. Prints \"Attempting signal lock. Attempt: 3\". `attemptsMade` becomes 4. Condition (4 <= 3) is `false`. Loop terminates.\n2. **After Loop**: The `System.out.println(completionMessage);` statement executes, printing \"Signal Lock Procedure Complete.\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": "A `do-while` loop executes its body at least once.",
      "2": "The loop continues as long as `attemptsMade` is `less than or equal to 3`.",
      "3": "The final message is printed once, after the loop finishes."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 326,
    "subtopic_id": 8,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder’s emergency life support system performs `checkNumber`s, skipping maintenance checks and breaking if a critical anomaly is detected. Your task is to trace the `while` loop and determine the sequence of outputs and the `Anomaly Status` and `Final System Status`.",
      "code": "public class EmergencyLifeSupport {\n    public static void main(String[] args) {\n        int checkNumber = 1;\n        boolean anomalyDetected = false;\n        String finalStatus = \"Monitoring Active\";\n\n        while (checkNumber <= 5) {\n            if (checkNumber == 3) {\n                System.out.println(\"Skipping Check \" + checkNumber + \" (Maintenance).\");\n                checkNumber++;\n                continue;\n            }\n            if (checkNumber == 5) {\n                anomalyDetected = true;\n                System.out.println(\"Critical anomaly detected at Check \" + checkNumber + \"!\");\n                break;\n            }\n            System.out.println(\"Oxygen Check: \" + checkNumber);\n            checkNumber++;\n        }\n        \n        if (anomalyDetected) {\n            finalStatus = \"CRITICAL FAILURE - EMERGENCY!\";\n        } else {\n            finalStatus = \"Routine Checks Complete.\";\n        }\n        \n        System.out.println(\"Anomaly Status: \" + anomalyDetected);\n        System.out.println(\"Final System Status: \" + finalStatus);\n    }\n}",
      "choices": [
        "Oxygen Check: 1\\nOxygen Check: 2\\nSkipping Check 3 (Maintenance).\\nOxygen Check: 4\\nCritical anomaly detected at Check 5!",
        "Anomaly Status: true",
        "Final System Status: CRITICAL FAILURE - EMERGENCY!",
        "Anomaly Status: false"
      ],
      "answer": [
        "Oxygen Check: 1\\nOxygen Check: 2\\nSkipping Check 3 (Maintenance).\\nOxygen Check: 4\\nCritical anomaly detected at Check 5!",
        "Anomaly Status: true",
        "Final System Status: CRITICAL FAILURE - EMERGENCY!"
      ],
      "explanation": "1. **Loop Execution (`message` output)**:\n    * `checkNumber = 1`: Prints \"Oxygen Check: 1\". `checkNumber` becomes 2.\n    * `checkNumber = 2`: Prints \"Oxygen Check: 2\". `checkNumber` becomes 3.\n    * `checkNumber = 3`: Prints \"Skipping Check 3 (Maintenance).\". `checkNumber` becomes 4. `continue` skips the rest.\n    * `checkNumber = 4`: Prints \"Oxygen Check: 4\". `checkNumber` becomes 5.\n    * `checkNumber = 5`: `anomalyDetected` becomes `true`. Prints \"Critical anomaly detected at Check 5!\". `break` exits the loop.\n2. **After Loop**: \n    * `anomalyDetected` is `true`. Prints \"Anomaly Status: true\".\n    * `if (anomalyDetected)` is `true`. `finalStatus` becomes \"CRITICAL FAILURE - EMERGENCY!\".\n    * Prints \"Final System Status: CRITICAL FAILURE - EMERGENCY!\"."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Trace `checkNumber` through each iteration and observe how `continue` and `break` keywords affect the loop's flow.",
      "2": "`continue` skips the rest of the current iteration and goes to the next. `break` exits the entire loop.",
      "3": "`anomalyDetected` changes only under a specific condition (`checkNumber == 5`)."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 327,
    "subtopic_id": 8,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder’s long-range scanner performs `scanNumber`s. `signalStrength` can drop, triggering a scan abort and setting `loopFinishedNaturally` to `false`. Your task is to trace the `while` loop and determine the `Last Scan Number Logged`, `Loop Finished Naturally` status, and `Final Scan Report`.",
      "code": "public class LongRangeScanner {\n    public static void main(String[] args) {\n        int scanNumber = 1;\n        int maxScans = 5;\n        int signalStrength = 100;\n        boolean loopFinishedNaturally = true;\n\n        while (scanNumber <= maxScans) {\n            System.out.println(\"Scanning range: \" + scanNumber);\n            if (scanNumber == 3) {\n                signalStrength = 20;\n            }\n            if (signalStrength < 50 && scanNumber > 2) {\n                loopFinishedNaturally = false;\n                System.out.println(\"WARNING: Signal lost. Aborting scan.\");\n                break;\n            }\n            scanNumber++;\n        }\n        \n        String finalScanReport = loopFinishedNaturally ? \"All ranges scanned.\" : \"Scan aborted due to signal loss.\";\n        \n        System.out.println(\"Last Scan Number Logged: \" + (scanNumber - 1));\n        System.out.println(\"Loop Finished Naturally: \" + loopFinishedNaturally);\n        System.out.println(\"Final Scan Report: \" + finalScanReport);\n    }\n}",
      "choices": [
        "Last Scan Number Logged: 2",
        "Loop Finished Naturally: false",
        "Final Scan Report: Scan aborted due to signal loss.",
        "Loop Finished Naturally: true"
      ],
      "answer": [
        "Last Scan Number Logged: 2",
        "Loop Finished Naturally: false",
        "Final Scan Report: Scan aborted due to signal loss."
      ],
      "explanation": "1. `scanNumber = 1`, `maxScans = 5`, `signalStrength = 100`, `loopFinishedNaturally = true`.\n2. **Loop Execution**:\n    * `scanNumber = 1`: Prints \"Scanning range: 1\". `signalStrength` is 100. `scanNumber` becomes 2.\n    * `scanNumber = 2`: Prints \"Scanning range: 2\". `signalStrength` is 100. `scanNumber` becomes 3.\n    * `scanNumber = 3`: Prints \"Scanning range: 3\". `signalStrength` becomes 20. `20 < 50 && 3 > 2` is `true`. Prints \"WARNING: Signal lost. Aborting scan.\". `loopFinishedNaturally` becomes `false`. `break` exits the loop.\n3. **After Loop**: `scanNumber` is `3` when loop breaks.\n    * `System.out.println(\"Last Scan Number Logged: \" + (scanNumber - 1));` prints `3 - 1 = 2`. So, \"Last Scan Number Logged: 2\".\n    * `System.out.println(\"Loop Finished Naturally: \" + loopFinishedNaturally);` prints \"Loop Finished Naturally: false\".\n    * `System.out.println(\"Final Scan Report: \" + finalScanReport);` prints \"Final Scan Report: Scan aborted due to signal loss.\"."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Trace `scanNumber` and `signalStrength` changes carefully through the loop. Pay attention to when `signalStrength` is updated.",
      "2": "The `if` condition `signalStrength < 50 && scanNumber > 2` uses `&&` and requires both parts to be true to trigger `break` and set `loopFinishedNaturally` to `false`.",
      "3": "The last `scanNumber` logged is the one *before* the loop aborted, as `scanNumber` increments at the end of the loop body."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 328,
    "subtopic_id": 8,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder’s reactor stabilizer runs `cycleCount`s using a `do-while` loop. It performs intermediate checks, but a special completion condition can trigger an early break. Your task is to trace the code and determine all printed messages, the `Completion Flag` status, and the `Final Message`.",
      "code": "public class ReactorStabilizer {\n    public static void main(String[] args) {\n        int cycleCount = 1;\n        boolean completeFlag = false;\n        String finalMessage = \"Calibration Ongoing\";\n\n        do {\n            if (cycleCount % 2 == 0 && cycleCount % 4 != 0) {\n                System.out.println(\"Intermediate Check: \" + cycleCount);\n            } else if (cycleCount == 5) {\n                completeFlag = true;\n                System.out.println(\"Special Completion: \" + cycleCount);\n                break;\n            }\n            System.out.println(\"Normal Operation: \" + cycleCount);\n            cycleCount++;\n        } while (cycleCount <= 6);\n        \n        if (completeFlag) {\n            finalMessage = \"Calibration Success!\";\n        } else {\n            finalMessage = \"Calibration Incomplete.\";\n        }\n        \n        System.out.println(\"Completion Flag: \" + completeFlag);\n        System.out.println(\"Final Cycle Value: \" + cycleCount);\n        System.out.println(\"Final Message: \" + finalMessage);\n    }\n}",
      "choices": [
        "Normal Operation: 1\\nIntermediate Check: 2\\nNormal Operation: 3\\nNormal Operation: 4\\nSpecial Completion: 5",
        "Completion Flag: true",
        "Final Message: Calibration Success!",
        "Final Cycle Value: 6"
      ],
      "answer": [
        "Normal Operation: 1\\nIntermediate Check: 2\\nNormal Operation: 3\\nNormal Operation: 4\\nSpecial Completion: 5",
        "Completion Flag: true",
        "Final Message: Calibration Success!"
      ],
      "explanation": "1. **Loop Execution (`message` output)**: `cycleCount` starts at 1.\n    * `cycleCount = 1`: Prints \"Normal Operation: 1\". `cycleCount` becomes 2.\n    * `cycleCount = 2`: `2 % 2 == 0` is `true`, `2 % 4 != 0` is `true`. Prints \"Intermediate Check: 2\". `cycleCount` becomes 3.\n    * `cycleCount = 3`: Prints \"Normal Operation: 3\". `cycleCount` becomes 4.\n    * `cycleCount = 4`: `4 % 2 == 0` is `true`, `4 % 4 != 0` is `false`. Prints \"Normal Operation: 4\". `cycleCount` becomes 5.\n    * `cycleCount = 5`: `5 == 5` is `true`. `completeFlag` becomes `true`. Prints \"Special Completion: 5\". `break` exits loop.\n2. **After Loop**: \n    * `completeFlag` is `true`. Prints \"Completion Flag: true\".\n    * `if (completeFlag)` is `true`. `finalMessage` becomes \"Calibration Success!\".\n    * Prints \"Final Message: Calibration Success!\".\n    * `System.out.println(\"Final Cycle Value: \" + cycleCount);` prints \"Final Cycle Value: 5\"."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Trace `cycleCount` through the `do-while` loop.",
      "2": "Evaluate each `if-else if-else` condition inside the loop: `cycleCount % 2 == 0 && cycleCount % 4 != 0` for \"Intermediate\", `cycleCount == 5` for \"Special\".",
      "3": "Note when `completeFlag` changes and when `break` terminates the loop."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 329,
    "subtopic_id": 8,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder’s power regulator runs a nested sequence of `mainSequence` and `subCheck` loops, tracking `totalIterations` and `sequenceStatus`. Your task is to trace the code and determine all printed messages, the `Total Iterations`, and the `Sequence Status`.",
      "code": "public class PowerRegulator {\n    public static void main(String[] args) {\n        int mainSequence = 1;\n        int totalIterations = 0;\n        String sequenceStatus = \"Pending\";\n\n        while (mainSequence <= 3) {\n            int subCheck = 1;\n            while (subCheck <= 2) {\n                System.out.println(\"Main: \" + mainSequence + \", Sub: \" + subCheck);\n                totalIterations++;\n                subCheck++;\n            }\n            mainSequence++;\n        }\n        \n        if (totalIterations == 6) {\n            sequenceStatus = \"Complete\";\n        } else {\n            sequenceStatus = \"Incomplete\";\n        }\n        \n        System.out.println(\"Total Iterations: \" + totalIterations);\n        System.out.println(\"Sequence Status: \" + sequenceStatus);\n        System.out.println(\"Final Main Sequence Value: \" + mainSequence);\n    }\n}",
      "choices": [
        "Main: 1, Sub: 1\\nMain: 1, Sub: 2\\nMain: 2, Sub: 1\\nMain: 2, Sub: 2\\nMain: 3, Sub: 1\\nMain: 3, Sub: 2",
        "Total Iterations: 6",
        "Sequence Status: Complete",
        "Final Main Sequence Value: 3"
      ],
      "answer": [
        "Main: 1, Sub: 1\\nMain: 1, Sub: 2\\nMain: 2, Sub: 1\\nMain: 2, Sub: 2\\nMain: 3, Sub: 1\\nMain: 3, Sub: 2",
        "Total Iterations: 6",
        "Sequence Status: Complete"
      ],
      "explanation": "1. **Loop Execution (Main/Sub output)**:\n    * `mainSequence = 1`: Runs inner loop twice. Prints \"Main: 1, Sub: 1\", \"Main: 1, Sub: 2\". `totalIterations` is 2. `mainSequence` becomes 2.\n    * `mainSequence = 2`: Runs inner loop twice. Prints \"Main: 2, Sub: 1\", \"Main: 2, Sub: 2\". `totalIterations` is 4. `mainSequence` becomes 3.\n    * `mainSequence = 3`: Runs inner loop twice. Prints \"Main: 3, Sub: 1\", \"Main: 3, Sub: 2\". `totalIterations` is 6. `mainSequence` becomes 4.\n    * `mainSequence = 4`: Outer loop condition (`4 <= 3`) is `false`. Outer loop terminates.\n2. **After Loop**: \n    * `System.out.println(\"Total Iterations: \" + totalIterations);` prints \"Total Iterations: 6\".\n    * `if (totalIterations == 6)` is `true`. `sequenceStatus` becomes \"Complete\".\n    * `System.out.println(\"Sequence Status: \" + sequenceStatus);` prints \"Sequence Status: Complete\".\n    * `System.out.println(\"Final Main Sequence Value: \" + mainSequence);` prints \"Final Main Sequence Value: 4\"."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Trace the outer `while` loop (for `mainSequence`) and how it controls the execution of the inner `while` loop (for `subCheck`).",
      "2": "The `subCheck` variable resets to `1` in each iteration of the *outer* loop.",
      "3": " `totalIterations` increments in the *inner* loop."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 330,
    "subtopic_id": 8,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder’s docking arm extends and retracts. A `do-while` loop controls its extension, with conditions for skipping odd extensions and breaking if a critical extension is reached. Your task is to trace the code and determine the sequence of arm messages, the `Emergency Stop Triggered` status, and the `Final Arm Status`.",
      "code": "public class DockingArmControl {\n    public static void main(String[] args) {\n        int armExtension = 0;\n        boolean emergencyStopTriggered = false;\n        String finalArmStatus = \"Ready\";\n\n        do {\n            armExtension++;\n            if (armExtension % 2 != 0 && armExtension < 4) {\n                System.out.println(\"Arm at odd extension: \" + armExtension);\n                continue;\n            }\n            if (armExtension == 4) {\n                System.out.println(\"Arm at critical extension: \" + armExtension);\n                emergencyStopTriggered = true;\n                break;\n            }\n            System.out.println(\"Arm at even extension: \" + armExtension);\n        } while (armExtension <= 5);\n\n        if (emergencyStopTriggered) {\n            finalArmStatus = \"EMERGENCY RETRACTED\";\n        } else {\n            finalArmStatus = \"Fully Extended/Retracted\";\n        }\n\n        System.out.println(\"Emergency Stop Triggered: \" + emergencyStopTriggered);\n        System.out.println(\"Final Arm Status: \" + finalArmStatus);\n    }\n}",
      "choices": [
        "Arm at odd extension: 1\\nArm at even extension: 2\\nArm at odd extension: 3\\nArm at critical extension: 4",
        "Emergency Stop Triggered: true",
        "Final Arm Status: EMERGENCY RETRACTED",
        "Final Arm Status: Fully Extended/Retracted"
      ],
      "answer": [
        "Arm at odd extension: 1\\nArm at even extension: 2\\nArm at odd extension: 3\\nArm at critical extension: 4",
        "Emergency Stop Triggered: true",
        "Final Arm Status: EMERGENCY RETRACTED"
      ],
      "explanation": "1. **Loop Execution (`message` output)**: `armExtension` starts at 0.\n    * `armExtension = 1`: Prints \"Arm at odd extension: 1\". `continue`.\n    * `armExtension = 2`: Prints \"Arm at even extension: 2\".\n    * `armExtension = 3`: Prints \"Arm at odd extension: 3\". `continue`.\n    * `armExtension = 4`: Prints \"Arm at critical extension: 4\". `emergencyStopTriggered` becomes `true`. `break` exits loop.\n2. **After Loop**: \n    * `emergencyStopTriggered` is `true`. Prints \"Emergency Stop Triggered: true\".\n    * `if (emergencyStopTriggered)` is `true`. `finalArmStatus` becomes \"EMERGENCY RETRACTED\".\n    * Prints \"Final Arm Status: EMERGENCY RETRACTED\"."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Trace `armExtension` carefully through each iteration, noting its value *before* and *after* `armExtension++` and how `continue`/`break` affect print statements.",
      "2": "The `continue` statement skips to the next iteration's condition check.",
      "3": "The `break` statement immediately exits the loop."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 331,
    "subtopic_id": 8,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "The Pathfinder’s diagnostic system uses a `while` loop that is currently stuck in an infinite loop because the counter is never incremented. Fix the code to ensure the `scanCount` is correctly updated, allowing the loop to terminate after 3 scans.",
      "code": "public class DiagnosticLoopFixer {\n    public static void main(String[] args) {\n        int scanCount = 0;\n        while (scanCount < 3) {\n            System.out.println(\"Performing diagnostic scan.\");\n            scanCount++;\n        }\n    }\n}",
      "expected_output": [
        "Performing diagnostic scan.\\nPerforming diagnostic scan.\\nPerforming diagnostic scan."
      ],
      "answer": [
        "Performing diagnostic scan.\\nPerforming diagnostic scan.\\nPerforming diagnostic scan."
      ],
      "explanation": "The original code creates an infinite loop because `scanCount` is never incremented inside the `while` loop. As a result, `scanCount` remains `0`, and the condition `scanCount < 3` is always `true`. The fix is to add `scanCount++;` (or `scanCount = scanCount + 1;`) inside the loop body, ensuring that `scanCount` eventually reaches `3`, making the condition `false` and terminating the loop after 3 iterations."
    },
    "difficulty": "easy",
    "hints": {
      "1": "An infinite loop occurs when the loop condition never becomes false.",
      "2": "The `scanCount` variable is used in the loop condition (`scanCount < 3`). How does `scanCount` change?",
      "3": "You need a way to make `scanCount` eventually reach `3` or more."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 332,
    "subtopic_id": 8,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "The Pathfinder’s beacon system uses a `while` loop that never activates because its initial condition is false. Fix the code to ensure the beacon activates exactly once.",
      "code": "public class BeaconLoopFixer {\n    public static void main(String[] args) {\n        int activationCount = 1;\n        while (activationCount <= 1) { // Correct: Change condition to allow one run\n            System.out.println(\"Beacon active!\");\n            activationCount++;\n        }\n    }\n}",
      "expected_output": [
        "Beacon active!"
      ],
      "answer": [
        "Beacon active!"
      ],
      "explanation": "The original `while` loop's condition `activationCount < 1` (i.e., `1 < 1`) is `false` from the very beginning. Therefore, the loop body never executes, and no message is printed. The fix is to change the condition to `activationCount <= 1`. This makes the condition `true` for the first iteration, allowing \"Beacon active!\" to print. After `activationCount` becomes `2`, the condition `2 <= 1` is `false`, terminating the loop. Using a `do-while` loop would also achieve the goal of running at least once."
    },
    "difficulty": "easy",
    "hints": {
      "1": "A `while` loop checks its condition *before* executing its body.",
      "2": "If the condition is `false` at the start, the loop body will never run.",
      "3": "To make it run once, adjust the condition to be true for exactly one iteration, or consider a different type of loop."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 333,
    "subtopic_id": 8,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "The Pathfinder’s thruster test uses a `do-while` loop that has a syntax error: a missing semicolon after its `while` condition. Fix the code to allow the thruster test to run correctly.",
      "code": "public class ThrusterTestFixer {\n    public static void main(String[] args) {\n        int fireCount = 0;\n        do {\n            System.out.println(\"Firing thruster \" + (fireCount + 1));\n            fireCount++;\n        } while (fireCount < 1); // Correct: Add semicolon\n    }\n}",
      "expected_output": [
        "Firing thruster 1"
      ],
      "answer": [
        "Firing thruster 1"
      ],
      "explanation": "A `do-while` loop in Java requires a semicolon (`;`) immediately after the `while (condition)` part. The original code is missing this semicolon, causing a compilation error. Adding the semicolon at the end of `while (fireCount < 1)` correctly fixes the syntax."
    },
    "difficulty": "easy",
    "hints": {
      "1": "A `do-while` loop has a unique requirement for its `while` condition line.",
      "2": "Look at the line where the `while` keyword and condition appear.",
      "3": "A specific punctuation mark is missing at the very end of that line."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 334,
    "subtopic_id": 8,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "The Pathfinder’s sensor calibration system uses a `while` loop that never runs because the `calibrationValue` is initially equal to the limit, making the condition `false`. Fix the code to ensure the calibration loop runs for 5 iterations.",
      "code": "public class SensorCalibrationFixer {\n    public static void main(String[] args) {\n        int calibrationValue = 45; // Correct: Change initial value\n        while (calibrationValue < 50) {\n            System.out.println(\"Calibrating sensor.\");\n            calibrationValue++;\n        }\n    }\n}",
      "expected_output": [
        "Calibrating sensor.\\nCalibrating sensor.\\nCalibrating sensor.\\nCalibrating sensor.\\nCalibrating sensor."
      ],
      "answer": [
        "Calibrating sensor.\\nCalibrating sensor.\\nCalibrating sensor.\\nCalibrating sensor.\\nCalibrating sensor."
      ],
      "explanation": "The `while` loop's condition `calibrationValue < 50` is `false` initially because `calibrationValue` is `50` (`50 < 50` is `false`). Therefore, the loop body never executes. The fix is to change the initial value of `calibrationValue` to something less than `50` (e.g., `45`), which makes the condition `true` and allows the loop to execute for 5 iterations."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The `while` loop checks its condition *before* executing.",
      "2": "What does `50 < 50` evaluate to?",
      "3": "To make the loop run, `calibrationValue` needs to start with a value that makes the condition initially `true`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 335,
    "subtopic_id": 8,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "The Pathfinder’s protocol activator uses a `do-while` loop that is stuck in an infinite loop because its condition (`activationCount >= 0`) is always true. Fix the code to ensure the loop runs exactly twice (for `activationCount` 1 and 2).",
      "code": "public class ProtocolActivatorFixer {\n    public static void main(String[] args) {\n        int activationCount = 1;\n        do {\n            System.out.println(\"Activating protocol \" + activationCount + \"...\");\n            activationCount++;\n        } while (activationCount <= 2); // Correct: Change condition to allow two runs\n    }\n}",
      "expected_output": [
        "Activating protocol 1...\\nActivating protocol 2..."
      ],
      "answer": [
        "Activating protocol 1...\\nActivating protocol 2..."
      ],
      "explanation": "The original `do-while` loop has an infinite loop because the condition `activationCount >= 0` is always `true` (since `activationCount` starts at `1` and only increases). The loop should run exactly 2 times. This means `activationCount` should be `1` and `2` during execution, and terminate when `activationCount` becomes `3`. The fix is to change the condition to `activationCount <= 2`, which correctly allows the loop to run when `activationCount` is `1` and `2`, and then terminates when `activationCount` becomes `3`."
    },
    "difficulty": "easy",
    "hints": {
      "1": "An infinite loop occurs when the loop condition never becomes `false`.",
      "2": "The `activationCount` starts at `1` and increments. The loop should stop when it has run twice (i.e., `activationCount` reaches `3`).",
      "3": "Adjust the `while` condition to evaluate to `false` after `activationCount` passes the desired number of iterations."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 336,
    "subtopic_id": 8,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "The Pathfinder’s sensor array system uses a `while` loop to take `dataReadings`. The loop runs one iteration too many. Fix the code to ensure exactly 5 readings (from 0 to 4).",
      "code": "public class SensorArrayFixer {\n    public static void main(String[] args) {\n        int dataReadings = 0;\n        while (dataReadings < 5) { // Correct: Change to strictly less than 5\n            System.out.println(\"Taking reading: \" + dataReadings);\n            dataReadings++;\n        }\n    }\n}",
      "expected_output": [
        "Taking reading: 0\\nTaking reading: 1\\nTaking reading: 2\\nTaking reading: 3\\nTaking reading: 4"
      ],
      "answer": [
        "Taking reading: 0\\nTaking reading: 1\\nTaking reading: 2\\nTaking reading: 3\\nTaking reading: 4"
      ],
      "explanation": "The original loop `while (dataReadings <= 5)` includes `dataReadings = 5` as a valid iteration, causing it to run 6 times (for 0, 1, 2, 3, 4, 5). The requirement is for exactly 5 readings (0-4). The fix is to change the loop condition from `dataReadings <= 5` to `dataReadings < 5`. This makes the loop execute for `dataReadings` values of 0, 1, 2, 3, and 4, totaling exactly 5 iterations."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The loop needs to run for values 0, 1, 2, 3, and 4. How many values is that?",
      "2": "The `<=` operator includes the boundary value. If `dataReadings` starts at 0 and goes up to 5, how many iterations is that?",
      "3": "To run exactly `N` times when starting from 0, the condition should be `variable < N`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 337,
    "subtopic_id": 8,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "The Pathfinder’s system log uses a `while` loop that never executes because its initial condition (`eventID < 1`) is false. Fix the code to ensure events 1, 2, and 3 are logged.",
      "code": "public class SystemLogFixer {\n    public static void main(String[] args) {\n        int eventID = 1;\n        while (eventID <= 3) { // Correct: Change condition to allow runs for 1, 2, 3\n            System.out.println(\"Logging Event: \" + eventID);\n            eventID++;\n        }\n    }\n}",
      "expected_output": [
        "Logging Event: 1\\nLogging Event: 2\\nLogging Event: 3"
      ],
      "answer": [
        "Logging Event: 1\\nLogging Event: 2\\nLogging Event: 3"
      ],
      "explanation": "The original `while` loop condition `eventID < 1` is `false` from the start (`1 < 1` is `false`), so the loop body never executes. The requirement is to log events 1, 2, and 3. The fix is to change the condition to `eventID <= 3`. This makes the loop execute for `eventID` values of 1, 2, and 3, stopping when `eventID` becomes 4."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The loop starts with `eventID = 1`.",
      "2": "The original condition `eventID < 1` (`1 < 1`) is `false`, causing the loop to never execute.",
      "3": "The goal is to log events 1, 2, and 3. How should the condition handle `eventID = 3`?"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 338,
    "subtopic_id": 8,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "The Pathfinder’s thruster system uses a `while` loop where the counter (`cycleCount`) is incremented outside the loop's body, causing an infinite loop. Fix the code to ensure `cycleCount` increments correctly within the loop, allowing it to complete 2 cycles.",
      "code": "public class ThrusterCycleFixer {\n    public static void main(String[] args) {\n        int cycleCount = 0;\n        while (cycleCount < 2) {\n            System.out.println(\"Cycle complete.\");\n            cycleCount++; // Correct: Move increment inside the loop body\n        }\n    }\n}",
      "expected_output": [
        "Cycle complete.\\nCycle complete."
      ],
      "answer": [
        "Cycle complete.\\nCycle complete."
      ],
      "explanation": "The original code creates an infinite loop because the `cycleCount++;` statement is placed *outside* the `while` loop's curly braces. This means `cycleCount` is never updated during the loop's execution, so `cycleCount` remains `0`, and the condition `cycleCount < 2` is always `true`. The fix is to move `cycleCount++;` inside the loop's body, ensuring `cycleCount` increments in each iteration, eventually terminating the loop after 2 runs."
    },
    "difficulty": "medium",
    "hints": {
      "1": "In a `while` loop, only the statements directly inside its curly braces `{}` are repeated.",
      "2": "If the loop condition depends on a variable, that variable must be updated *inside* the loop to eventually make the condition false.",
      "3": "The blank line after `System.out.println()` needs an increment statement."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 339,
    "subtopic_id": 8,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "The Pathfinder is transferring data using a `do-while` loop. The loop's condition (`transferCount > 3`) causes it to run only once, as the condition immediately becomes false after the first iteration. Fix the code to ensure exactly 3 data transfers.",
      "code": "public class DataTransferFixer {\n    public static void main(String[] args) {\n        int transferCount = 1;\n        do {\n            System.out.println(\"Transferring data...\");\n            transferCount++;\n        } while (transferCount <= 3); // Correct: Change condition to allow 3 runs\n    }\n}",
      "expected_output": [
        "Transferring data...\\nTransferring data...\\nTransferring data."
      ],
      "answer": [
        "Transferring data...\\nTransferring data...\\nTransferring data."
      ],
      "explanation": "The original `do-while` loop's condition `transferCount > 3` is evaluated after the first iteration where `transferCount` becomes 2 (`2 > 3` is `false`), causing the loop to stop after only one execution. The requirement is to run exactly 3 times (for `transferCount` values 1, 2, 3). The fix is to change the condition to `transferCount <= 3`. This correctly allows the loop to run when `transferCount` is 1, 2, and 3, and then terminates when `transferCount` becomes 4."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The `do-while` loop executes at least once.",
      "2": "The `transferCount` starts at `1` and increments. The loop needs to run for `transferCount` values `1`, `2`, and `3`.",
      "3": "The original condition (`transferCount > 3`) immediately becomes `false` after the first increment. How should the condition correctly ensure it runs for all three values?"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 340,
    "subtopic_id": 8,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "The Pathfinder’s repair sequence uses a `while` loop that is stuck in an infinite loop because the `repairsCompleted` counter is never incremented. Fix the code to ensure `repairsCompleted` is correctly updated within the loop, allowing 5 repair steps to be initiated.",
      "code": "public class RepairSequenceFixer {\n    public static void main(String[] args) {\n        int repairsCompleted = 0;\n        while (repairsCompleted < 5) {\n            System.out.println(\"Repair step \" + repairsCompleted + \" initiated.\");\n            repairsCompleted++;\n        }\n    }\n}",
      "expected_output": [
        "Repair step 0 initiated.\\nRepair step 1 initiated.\\nRepair step 2 initiated.\\nRepair step 3 initiated.\\nRepair step 4 initiated."
      ],
      "answer": [
        "Repair step 0 initiated.\\nRepair step 1 initiated.\\nRepair step 2 initiated.\\nRepair step 3 initiated.\\nRepair step 4 initiated."
      ],
      "explanation": "The original code creates an infinite loop because `repairsCompleted` is never incremented inside the `while` loop's body. As a result, `repairsCompleted` remains `0`, and the condition `repairsCompleted < 5` is always `true`. The fix is to add `repairsCompleted++;` (or `repairsCompleted = repairsCompleted + 1;`) inside the loop, ensuring `repairsCompleted` increases in each iteration, eventually terminating the loop after 5 runs (0-4)."
    },
    "difficulty": "medium",
    "hints": {
      "1": "An infinite loop occurs if the variable controlling the loop's condition never changes to make the condition false.",
      "2": "The `repairsCompleted` variable is part of the `while` loop's condition.",
      "3": "You need a statement that modifies `repairsCompleted` to ensure the loop eventually terminates."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 341,
    "subtopic_id": 8,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "The Pathfinder’s life support monitor uses nested `while` and `do-while` loops. The inner `do-while` loop is in an infinite loop because its condition (`subCheck >= 0`) is always true and `subCheck` is never incremented. Fix the code to correctly manage both loops and allow them to terminate.",
      "code": "public class LifeSupportMonitorFixer {\n    public static void main(String[] args) {\n        int mainCycles = 0;\n        String finalStatus = \"Inactive\";\n\n        while (mainCycles < 2) {\n            int subCheck = 0;\n            do {\n                System.out.println(\"Main Cycle: \" + mainCycles + \", Sub Check: \" + subCheck);\n                subCheck++; // Correct: Increment subCheck\n            } while (subCheck < 3); // Correct: Change inner loop condition\n            mainCycles++;\n        }\n        finalStatus = \"Monitoring Complete\";\n        System.out.println(\"Final Status: \" + finalStatus);\n    }\n}",
      "expected_output": [
        "Main Cycle: 0, Sub Check: 0\\nMain Cycle: 0, Sub Check: 1\\nMain Cycle: 0, Sub Check: 2\\nMain Cycle: 1, Sub Check: 0\\nMain Cycle: 1, Sub Check: 1\\nMain Cycle: 1, Sub Check: 2\\nFinal Status: Monitoring Complete"
      ],
      "answer": [
        "Main Cycle: 0, Sub Check: 0\\nMain Cycle: 0, Sub Check: 1\\nMain Cycle: 0, Sub Check: 2\\nMain Cycle: 1, Sub Check: 0\\nMain Cycle: 1, Sub Check: 1\\nMain Cycle: 1, Sub Check: 2\\nFinal Status: Monitoring Complete"
      ],
      "explanation": "The original code creates an infinite loop because the inner `do-while` loop's condition `subCheck >= 0` is always `true` (as `subCheck` starts at 0 and increases, it will always be greater than or equal to 0). Additionally, `subCheck` is never incremented. The fix involves two parts:\n1.  Add `subCheck++;` inside the inner loop to ensure `subCheck` increases.\n2.  Change the inner loop condition to `subCheck < 3` (or `subCheck <= 2`), so it runs for `subCheck` values 0, 1, and 2, and then terminates when `subCheck` becomes 3."
    },
    "difficulty": "hard",
    "hints": {
      "1": "An infinite loop often occurs when the variable controlling the loop's condition never becomes false.",
      "2": "The inner `do-while` loop's condition is `subCheck >= 0`. Since `subCheck` starts at 0 and increments, this condition will always remain true.",
      "3": "The goal is for the inner loop to run exactly 3 times (for `subCheck` values 0, 1, 2). How should the condition change to allow this?"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 342,
    "subtopic_id": 8,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "The Pathfinder’s diagnostic sequence uses a `while` loop that prematurely terminates due to an overly broad `break` condition (`checkIndex == 2`). Fix the code to ensure the loop runs its full course of 5 checks.",
      "code": "public class DiagnosticSequenceFixer {\n    public static void main(String[] args) {\n        int checkIndex = 0;\n        String diagnosticStatus = \"Running\";\n\n        while (checkIndex < 5) {\n            System.out.println(\"Diagnostic check: \" + checkIndex);\n            // Removed or changed 'if (checkIndex == 2) { break; }' from faulty code\n            checkIndex++;\n        }\n        diagnosticStatus = \"Completed\";\n        System.out.println(\"Diagnostic Status: \" + diagnosticStatus);\n    }\n}",
      "expected_output": [
        "Diagnostic check: 0\\nDiagnostic check: 1\\nDiagnostic check: 2\\nDiagnostic check: 3\\nDiagnostic check: 4\\nDiagnostic Status: Completed"
      ],
      "answer": [
        "Diagnostic check: 0\\nDiagnostic check: 1\\nDiagnostic check: 2\\nDiagnostic check: 3\\nDiagnostic check: 4\\nDiagnostic Status: Completed"
      ],
      "explanation": "The original code's `if (checkIndex == 2) { break; }` statement causes the `while` loop to terminate prematurely when `checkIndex` is 2. The loop runs for `checkIndex = 0, 1, 2` and then stops. The fix is to remove the `if (checkIndex == 2) { break; }` statement entirely, allowing the loop to run its full course for `checkIndex` values 0 through 4, as dictated by the condition `checkIndex < 5`. This ensures all 5 checks are printed, followed by the final status."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The `break` statement immediately exits the loop when triggered.",
      "2": "Check what condition causes the loop to stop early (`checkIndex == 2`).",
      "3": "To run all 5 checks, ensure no `break` interrupts the loop before `checkIndex` reaches 5."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 343,
    "subtopic_id": 8,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "The Pathfinder’s battery charger uses a `do-while` loop that prints `chargeProgress` *after* it's incremented, showing an incorrect initial value. Fix the code to print `chargeProgress` *before* it's updated in each cycle.",
      "code": "public class BatteryChargerFixer {\n    public static void main(String[] args) {\n        int chargeProgress = 50;\n        do {\n            System.out.println(\"Charging: \" + chargeProgress + \"%\"); // Correct: Print before increment\n            chargeProgress += 10;\n        } while (chargeProgress < 80);\n        System.out.println(\"Battery Full: \" + chargeProgress + \"%\");\n    }\n}",
      "expected_output": [
        "Charging: 50%\\nCharging: 60%\\nCharging: 70%\\nBattery Full: 80%"
      ],
      "answer": [
        "Charging: 50%\\nCharging: 60%\\nCharging: 70%\\nBattery Full: 80%"
      ],
      "explanation": "The original code places `chargeProgress += 10;` *before* the `System.out.println()` statement inside the `do-while` loop. This means that in the first iteration, `chargeProgress` becomes 60 *before* \"Charging: 60%\" is printed. The requirement is to show the value *before* the increment. The fix is to move the `System.out.println()` statement *before* the `chargeProgress += 10;` line. This ensures the current `chargeProgress` (50, 60, 70) is printed before it's updated for the next iteration."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The `System.out.println()` statement prints the value of `chargeProgress` *at the moment* it is executed.",
      "2": "The original code increments `chargeProgress` *before* printing.",
      "3": "To show the value *before* it's changed for the next iteration, the print statement needs to come before the increment within the loop body."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 344,
    "subtopic_id": 8,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "The Pathfinder’s data logger uses a `while` loop that logs one data point too many, including the boundary value. Fix the code to ensure it logs data points from 5 to 9 (inclusive).",
      "code": "public class DataLoggerFixer {\n    public static void main(String[] args) {\n        int dataPoint = 5;\n        while (dataPoint < 10) { // Correct: Change condition to strictly less than 10\n            System.out.println(\"Logging data point: \" + dataPoint);\n            dataPoint++;\n        }\n    }\n}",
      "expected_output": [
        "Logging data point: 5\\nLogging data point: 6\\nLogging data point: 7\\nLogging data point: 8\\nLogging data point: 9"
      ],
      "answer": [
        "Logging data point: 5\\nLogging data point: 6\\nLogging data point: 7\\nLogging data point: 8\\nLogging data point: 9"
      ],
      "explanation": "The original loop condition `while (dataPoint <= 10)` allows the loop to execute when `dataPoint` is `10` (`10 <= 10` is `true`). This prints \"Logging data point: 10\", which is undesirable. The requirement is to log values from 5 to 9. The fix is to change the loop condition from `dataPoint <= 10` to `dataPoint < 10`. This makes the loop execute for `dataPoint` values of 5, 6, 7, 8, and 9, and then terminates when `dataPoint` becomes 10."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The loop's current condition `dataPoint <= 10` includes `dataPoint = 10` in the last iteration.",
      "2": "The goal is to stop *before* `dataPoint` becomes `10`.",
      "3": "Which comparison operator ensures \"strictly less than\"?"
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 345,
    "subtopic_id": 8,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "The Pathfinder’s emergency protocol uses a `do-while` loop with a logical flaw (`||`) in its condition, causing it to run one extra time after the system becomes stable. Fix the code to ensure the loop terminates immediately once the `isSystemStable` flag is true.",
      "code": "public class EmergencyProtocolFixer {\n    public static void main(String[] args) {\n        int currentStep = 1;\n        boolean isSystemStable = false;\n\n        do {\n            System.out.println(\"Running step: \" + currentStep);\n            if (currentStep == 2) {\n                isSystemStable = true;\n            }\n            currentStep++;\n        } while (!isSystemStable && currentStep <= 3);\n        System.out.println(\"Protocol finished.\");\n        System.out.println(\"Is system stable: \" + isSystemStable);\n    }\n}",
      "expected_output": [
        "Running step: 1\\nRunning step: 2\\nProtocol finished.\\nIs system stable: true"
      ],
      "answer": [
        "Running step: 1\\nRunning step: 2\\nProtocol finished.\\nIs system stable: true"
      ],
      "explanation": "The original `do-while` loop condition `!isSystemStable || currentStep <= 3` uses a logical OR (`||`), which allows the loop to continue if *either* condition is true. When `currentStep` is 2, `isSystemStable` becomes `true`, but after incrementing to `currentStep = 3`, the condition `3 <= 3` is still `true`, causing an extra iteration. The fix is to change the condition to `!isSystemStable && currentStep <= 3`, using AND (`&&`). This ensures the loop stops as soon as `isSystemStable` is `true`, regardless of `currentStep`. The loop runs for `currentStep = 1` and `2`, then terminates."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The `do-while` loop continues as long as its condition evaluates to `true`.",
      "2": "The original condition uses `||`. What happens when `isSystemStable` becomes `true` but `currentStep <= 3` is still `true`?",
      "3": "To stop immediately when `isSystemStable` is `true`, both conditions must be required for the loop to continue."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 346,
    "subtopic_id": 8,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder’s automated system deploys `drones` for hull repair. A loop controls the deployment process. It should print the `droneID` as it's deployed, stopping after the 3rd drone (ID 2). Complete the loop keyword and the loop condition.",
      "code": "public class DroneDeployer {\n    public static void main(String[] args) {\n        int droneID = 0;\n        ??? (droneID < 3) {\n            System.out.println(\"Deploying Drone ID: \" + droneID);\n            droneID++;\n        }\n    }\n}",
      "choices": [
        "for",
        "while",
        "do",
        "if"
      ],
      "answer": [
        "while"
      ],
      "explanation": "The `while` keyword is used to create a loop that repeatedly executes a block of code as long as its condition (`droneID < 3`) remains `true`. The condition is checked *before* each iteration."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The loop needs to run for `droneID` values 0, 1, and 2 (3 drones).",
      "2": "This loop checks its condition *before* its first iteration.",
      "3": "The blank needs a keyword to start a pre-checked loop."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 347,
    "subtopic_id": 8,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder’s emergency system attempts activation. A loop is used to ensure it tries `at least once`, and repeats until `attemptsMade` reaches `2`. Complete the loop keywords.",
      "code": "public class EmergencyActivator {\n    public static void main(String[] args) {\n        int attemptsMade = 0;\n        ??? {\n            System.out.println(\"Attempting emergency activation.\");\n            attemptsMade++;\n        } ??? (attemptsMade < 2);\n    }\n}",
      "choices": [
        "while",
        "do",
        "if",
        "for"
      ],
      "answer": [
        "do",
        "while"
      ],
      "explanation": "1. `do` (choice b) starts the `do-while` loop, ensuring the loop body executes at least once.\n2. `while` (choice a) introduces the condition `(attemptsMade < 2)`, which is evaluated after each iteration to determine if the loop should continue."
    },
    "difficulty": "easy",
    "hints": {
      "1": "This loop type guarantees its body runs at least one time before checking the condition.",
      "2": "The first blank introduces the loop body that runs immediately.",
      "3": "The second blank is where the condition is checked after the body's first run."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 348,
    "subtopic_id": 8,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder is transferring `fuel` from one tank to another. A loop needs to display the `fuel` level as it decreases, stopping when `fuel` reaches 0. Complete the `System.out.println()` statement and the decrement operation.",
      "code": "public class FuelTransfer {\n    public static void main(String[] args) {\n        int fuel = 3;\n        while (fuel > 0) {\n            System.out.println(\"Fuel remaining: \" + ???);\n            ???;\n        }\n    }\n}",
      "choices": [
        "fuel",
        "fuel--",
        "fuel++",
        "remaining"
      ],
      "answer": [
        "fuel",
        "fuel--"
      ],
      "explanation": "1. `fuel` (choice a) correctly prints the current `fuel` value in each iteration.\n2. `fuel--` (choice b) is the post-decrement operator, which decreases `fuel` by 1 after its value has been used in the print statement, ensuring the loop eventually terminates."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The `System.out.println()` needs to display the `current fuel` value.",
      "2": "The loop condition `fuel > 0` requires `fuel` to decrease in each iteration.",
      "3": "The blank needs a concise way to decrement `fuel` by `1`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 349,
    "subtopic_id": 8,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder’s data link retransmits `packets` using a `do-while` loop. It prints the packet number and continues as long as `retransmitCount` is less than `3`. Complete the missing semicolon after the `while` condition.",
      "code": "public class DataRetransmitter {\n    public static void main(String[] args) {\n        boolean packetStatus = false;\n        int retransmitCount = 0;\n\n        do {\n            System.out.println(\"Retransmitting packet. Count: \" + retransmitCount);\n            retransmitCount++;\n        } while (retransmitCount < 3); // Corrected: Add missing semicolon\n    }\n}",
      "choices": [
        "retransmitCount",
        ";",
        ":",
        ","
      ],
      "answer": [
        ";"
      ],
      "explanation": "A `do-while` loop in Java requires a semicolon (`;`) immediately after the `while (condition)` part. This semicolon terminates the `do-while` statement. The `retransmitCount` in the `System.out.println()` statement is already correctly provided."
    },
    "difficulty": "easy",
    "hints": {
      "1": "A `do-while` loop has a unique requirement for its `while` condition line.",
      "2": "Look at the very end of the line where the `while` keyword and condition appear.",
      "3": "A specific punctuation mark is required to complete the `do-while` statement."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 350,
    "subtopic_id": 8,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder’s reactor stabilizer adjusts `coreTemp`. A `while` loop continues as long as `coreTemp` is above 70. Complete the loop’s condition using the appropriate comparison operator.",
      "code": "public class ReactorStabilizer {\n    public static void main(String[] args) {\n        int coreTemp = 80;\n        int coolantFlow = 40;\n\n        while (coreTemp ??? 70) {\n            System.out.println(\"Stabilizing reactor. Temp: \" + coreTemp);\n            coreTemp -= 5;\n        }\n    }\n}",
      "choices": [
        ">",
        ">=",
        "<",
        "<="
      ],
      "answer": [
        ">"
      ],
      "explanation": "To check if `coreTemp` is \"above 70,\" the \"greater than\" operator `>` (choice a) is used. The loop continues as long as `coreTemp` is strictly greater than 70."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The loop condition requires `coreTemp` to be `above` 70.",
      "2": "Which comparison operator means \"strictly greater than\"?",
      "3": "The blank needs a single operation symbol."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 351,
    "subtopic_id": 8,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder's `emergencySystem` attempts activation. A `while` loop controls the process, and `attemptsMade` increases until it reaches `2`. Complete the loop keywords and the condition.",
      "code": "public class EmergencyActivator {\n    public static void main(String[] args) {\n        int attemptsMade = 0;\n        while (attemptsMade < 2) {\n            System.out.println(\"Attempting emergency activation.\");\n            attemptsMade++;\n        }\n    }\n}",
      "choices": [
        "while",
        "do",
        "if",
        "for"
      ],
      "answer": [
        "while"
      ],
      "explanation": "The `while` keyword is used to create a loop that repeatedly executes a block of code as long as its condition (`attemptsMade < 2`) remains `true`. The condition is checked *before* each iteration."
    },
    "difficulty": "medium",
    "hints": {
      "1": "This loop checks its condition *before* running its code block.",
      "2": "It repeats actions as long as a condition remains true.",
      "3": "The blank needs a keyword to start a pre-checked loop."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 352,
    "subtopic_id": 8,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder is transferring `fuel` from one tank to another. A `while` loop needs to display the `fuel` level as it decreases, stopping when `fuel` reaches 0. Complete the print statement and the decrement.",
      "code": "public class FuelTransfer {\n    public static void main(String[] args) {\n        int fuel = 3;\n        while (fuel > 0) {\n            System.out.println(\"Fuel remaining: \" + fuel);\n            fuel--;\n        }\n    }\n}",
      "choices": [
        "fuel",
        "fuel--",
        "fuel++",
        "remaining"
      ],
      "answer": [
        "fuel",
        "fuel--"
      ],
      "explanation": "1. `fuel` (choice a) correctly prints the current `fuel` value in each iteration.\n2. `fuel--` (choice b) is the post-decrement operator, which decreases `fuel` by 1 after its value has been used in the print statement, ensuring the loop eventually terminates."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The `System.out.println()` needs to display the `current fuel` value.",
      "2": "The loop condition `fuel > 0` requires `fuel` to decrease in each iteration.",
      "3": "The blank needs a concise way to decrement `fuel` by `1`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 353,
    "subtopic_id": 8,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder’s data link retransmits `packets` using a `do-while` loop. It prints the packet number and continues as long as `retransmitCount` is less than `3`. Complete the print statement and the missing semicolon after the `while` condition.",
      "code": "public class DataRetransmitter {\n    public static void main(String[] args) {\n        boolean packetStatus = false;\n        int retransmitCount = 0;\n\n        do {\n            System.out.println(\"Retransmitting packet. Count: \" + retransmitCount);\n            retransmitCount++;\n        } while (retransmitCount < 3); // Corrected: Added missing semicolon\n    }\n}",
      "choices": [
        "retransmitCount",
        ";",
        ":",
        ","
      ],
      "answer": [
        ";"
      ],
      "explanation": "A `do-while` loop in Java requires a semicolon (`;`) immediately after the `while (condition)` part. This semicolon terminates the `do-while` statement. The `retransmitCount` in the `System.out.println()` statement is already correctly provided."
    },
    "difficulty": "medium",
    "hints": {
      "1": "A `do-while` loop has a unique requirement for its `while` condition line.",
      "2": "Look at the very end of the line where the `while` keyword and condition appear.",
      "3": "A specific punctuation mark is required to complete the `do-while` statement."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 354,
    "subtopic_id": 8,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder’s reactor stabilizer adjusts `coreTemp`. A `while` loop continues as long as `coreTemp` is above 70. Complete the loop’s condition using the appropriate comparison operator.",
      "code": "public class ReactorStabilizer {\n    public static void main(String[] args) {\n        int coreTemp = 80;\n        int coolantFlow = 40;\n\n        while (coreTemp > 70) {\n            System.out.println(\"Stabilizing reactor. Temp: \" + coreTemp);\n            coreTemp -= 5;\n        }\n    }\n}",
      "choices": [
        ">",
        ">=",
        "<",
        "<="
      ],
      "answer": [
        ">"
      ],
      "explanation": "To check if `coreTemp` is \"above 70,\" the \"greater than\" operator `>` (choice a) is used. The loop continues as long as `coreTemp` is strictly greater than 70."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The loop condition requires `coreTemp` to be `above` 70.",
      "2": "Which comparison operator means \"strictly greater than\"?",
      "3": "The blank needs a single operation symbol."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 355,
    "subtopic_id": 8,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder's `droneDeployer` manages `droneID`s. A `while` loop prints the `droneID` as it's deployed, stopping after the 3rd drone (ID 2). Complete the loop's condition, the body's print statement, and the increment step.",
      "code": "public class DroneDeployer {\n    public static void main(String[] args) {\n        int droneID = 0;\n        while (droneID < 3) {\n            System.out.println(\"Deploying Drone ID: \" + droneID);\n            droneID++;\n        }\n    }\n}",
      "choices": [
        "droneID",
        "<",
        "<=",
        "droneID++",
        "droneID--",
        "=="
      ],
      "answer": [
        "<",
        "droneID",
        "droneID++"
      ],
      "explanation": "1. `<` (choice b) correctly sets the `while` loop condition to run for `droneID` values 0, 1, and 2, terminating when `droneID` reaches 3.\n2. `droneID` (choice a) prints the current `droneID`.\n3. `droneID++` (choice d) increments `droneID` in each iteration, ensuring the loop eventually terminates."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The loop needs to run for `droneID` values 0, 1, and 2 (3 drones). Which comparison operator ensures this range?",
      "2": "The `System.out.println()` needs to display the `current droneID`.",
      "3": "The blank at the end of the loop body needs to update `droneID` to ensure termination."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 356,
    "subtopic_id": 8,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder’s emergency AI activates a cascade of safety systems. An outer `while` loop manages `systemGroups`, and an inner `do-while` loop for `subSystemChecks`. Each `subSystemCheck` evaluates `powerLevel`: if `powerLevel` is `below 20`, it's a \"CRITICAL\" alert and breaks the inner loop. If `powerLevel` is `between 20 and 50` (inclusive of 20, exclusive of 50), it's a \"WARNING\" and skips to the next `subSystemCheck`. Otherwise, it logs \"OK\". The outer loop runs for 2 `systemGroups` (0 to 1). The inner loop *always* performs at least one `subSystemCheck` and runs a maximum of 3 times (0 to 2) per group, unless broken. Complete the code for the outer loop's condition, the inner loop's keyword, and the inner loop's continuation condition.",
      "code": "public class EmergencyCascade {\n    public static void main(String[] args) {\n        int systemGroup = 0;\n        int totalAlerts = 0;\n        \n        while (systemGroup ??? 2) { \n            int subSystemCheck = 0;\n            int powerLevel = 60;\n            \n            ??? { \n                System.out.println(\"Group \" + systemGroup + \", Sub \" + subSystemCheck + \" Status: \");\n                \n                if (powerLevel < 20) {\n                    totalAlerts++;\n                    System.out.println(\"CRITICAL: Power failure!\");\n                    break;\n                } else if (powerLevel >= 20 && powerLevel < 50) {\n                    totalAlerts++;\n                    System.out.println(\"WARNING: Power fluctuation.\");\n                    powerLevel -= 15;\n                    continue;\n                } else {\n                    System.out.println(\"OK: Stable.\");\n                    powerLevel -= 10;\n                }\n                subSystemCheck++;\n            }\n            while (subSystemCheck ??? 3);\n            \n            systemGroup++;\n        }\n        System.out.println(\"\\nEmergency Cascade Complete. Total Critical/Warning Alerts: \" + totalAlerts);\n    }\n}",
      "choices": [
        "<",
        "<=",
        "do",
        "while",
        "else if",
        "if",
        "else",
        "continue"
      ],
      "answer": [
        "<",
        "do",
        "<"
      ],
      "explanation": "1. `<` (choice a) correctly sets the outer `while` loop condition (`systemGroup < 2`) to run for groups 0 and 1.\n2. `do` (choice c) correctly starts the inner loop, ensuring at least one `subSystemCheck` is performed.\n3. `<` (choice a) correctly sets the inner `do-while` loop's condition to run for checks 0, 1, and 2."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The outer `while` loop needs to run for `systemGroup` values 0 and 1.",
      "2": "The inner loop *must* run at least once for each `subSystemCheck`.",
      "3": "The inner `do-while` loop's continuation condition needs to ensure 3 checks (0 to 2)."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 357,
    "subtopic_id": 8,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder’s reactor cooling system activates `coolantPulses`. An outer `do-while` loop manages `coolingCycles` and *always* runs at least once. An inner `while` loop performs `pulseIterations`. If `coolantTemp` (which decreases) drops `below 50`, the inner loop must `break` early. If `pulseIterations` reaches `2` and `coolantTemp` is `still above 50`, it logs \"Warning\". Otherwise, it logs \"Pulse OK\". Complete the code for the outer loop's keyword, the inner loop's comparison operator for critical temp, and the overall outer loop continuation keyword.",
      "code": "public class ReactorCooling {\n    public static void main(String[] args) {\n        int coolingCycles = 0;\n        int coolantTemp = 70;\n        int maxCycles = 2; // For outer loop\n        \n        ??? { \n            System.out.println(\"Cooling Cycle: \" + coolingCycles);\n            int pulseIterations = 0;\n            \n            while (pulseIterations < 3) {\n                System.out.println(\"  Pulse: \" + pulseIterations + \", Temp: \" + coolantTemp);\n                if (coolantTemp ??? 50) {\n                    System.out.println(\"  CRITICAL TEMP! Aborting pulse iterations.\");\n                    break;\n                }\n                if (pulseIterations == 2 && coolantTemp > 50) {\n                    System.out.println(\"  WARNING: High temp after multiple pulses.\");\n                }\n                coolantTemp -= 5;\n                pulseIterations++;\n            }\n            coolingCycles++;\n        }\n        ??? (coolingCycles < maxCycles);\n        \n        System.out.println(\"\\nCooling Sequence Complete. Final Temp: \" + coolantTemp);\n    }\n}",
      "choices": [
        "do",
        "while",
        ">",
        "<",
        "0",
        "1",
        "2",
        "else if"
      ],
      "answer": [
        "do",
        "<",
        "while"
      ],
      "explanation": "1. `do` (choice a) correctly starts the outer `do-while` loop, ensuring at least one cooling cycle.\n2. `<` (choice d) is the comparison operator for `coolantTemp < 50`, which triggers the `break` from the inner loop.\n3. `while` (choice b) correctly completes the `do-while` loop's continuation statement."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The outer loop *must* run at least once.",
      "2": "The inner `while` loop's `break` condition triggers when `coolantTemp` is `below 50`.",
      "3": "The final blank completes the `do-while` loop syntax."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 358,
    "subtopic_id": 8,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder’s signal relay system tests `packetTransmissions` with a `while` loop. Odd-numbered packets might trigger an \"Interference\" warning and skip confirmation, while signal quality is checked for degradation. Complete the loop condition, conditional skip, and signal quality check.",
      "code": "public class SignalRelay {\n    public static void main(String[] args) {\n        int packetsSent = 0;\n        int signalQuality = 100;\n        \n        while (packetsSent ??? 5) {\n            System.out.println(\"Transmitting packet: \" + packetsSent);\n            \n            if (packetsSent % 2 != 0 && packetsSent < 4) {\n                System.out.println(\"  WARNING: Interference detected on \" + packetsSent);\n                packetsSent++; \n                ???;\n            }\n            \n            if (packetsSent % ??? == 0 && packetsSent > 0) {\n                if (signalQuality < ???) {\n                    System.out.println(\"  SIGNAL: Degraded at \" + packetsSent);\n                }\n            }\n            \n            System.out.println(\"  Packet \" + packetsSent + \" Confirmed.\");\n            packetsSent++;\n        }\n        System.out.println(\"Relay test complete.\");\n    }\n}",
      "choices": [
        "<",
        "<=",
        "continue",
        "break",
        "2",
        "3",
        "80",
        "90"
      ],
      "answer": [
        "<",
        "continue",
        "2",
        "80"
      ],
      "explanation": "1. `<` (choice a) correctly sets the outer `while` loop condition (`packetsSent < 5`).\n2. `continue` (choice c) is used to skip the rest of the current iteration's body.\n3. `2` (choice e) is used for `packetsSent % 2 == 0`, to check for even numbered packets.\n4. `80` (choice g) is the threshold for `signalQuality < 80`."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The loop should continue as long as `packetsSent` is strictly less than 5.",
      "2": "The blank in the `if` block is for a keyword that skips the rest of the current loop iteration.",
      "3": "The `if` condition checks for every second packet (`packetsSent % X == 0`)."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 359,
    "subtopic_id": 8,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder’s shield recalibrator performs `calibrationAttempts` in a `do-while` loop, ensuring at least one attempt. It continues as long as `recalibrationNeeded` is true AND `calibrationAttempts` is less than 3. Complete the loop type, logical operators, and the iteration limit.",
      "code": "public class ShieldRecalibrator {\n    public static void main(String[] args) {\n        int calibrationAttempts = 0;\n        boolean recalibrationNeeded = true;\n        int shieldIntegrity = 70;\n        \n        ??? { \n            System.out.println(\"Attempting recalibration. Attempt: \" + (calibrationAttempts + 1));\n            \n            if (recalibrationNeeded ??? shieldIntegrity ??? 90) {\n                recalibrationNeeded = false;\n                System.out.println(\"  Recalibration successful!\");\n            } else {\n                System.out.println(\"  Recalibration ongoing...\");\n                shieldIntegrity += 5;\n            }\n            calibrationAttempts++;\n        }\n        while (recalibrationNeeded ??? calibrationAttempts < ???);\n        \n        System.out.println(\"\\nRecalibration Procedure Complete. Final Attempts: \" + calibrationAttempts);\n        System.out.println(\"Recalibration Needed (final status): \" + recalibrationNeeded);\n    }\n}",
      "choices": [
        "do",
        "while",
        "&&",
        "||",
        ">",
        ">=",
        "3",
        "4"
      ],
      "answer": [
        "do",
        "&&",
        ">=",
        "3"
      ],
      "explanation": "1. `do` (choice a) correctly starts the outer `do-while` loop.\n2. `&&` (choice c) is the logical `AND` operator, combining `recalibrationNeeded` with the shield integrity check within the `if` condition.\n3. `>=` (choice f) is the comparison operator for `shieldIntegrity >= 90`, indicating successful recalibration.\n4. `3` (choice g) is the correct boundary value for `calibrationAttempts < 3`, ensuring the loop runs for attempts 0, 1, and 2."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The outer loop *must* run at least once.",
      "2": "The `if` condition inside the loop checks if `recalibrationNeeded` is true AND `shieldIntegrity` is `at least 90`.",
      "3": "The `while` loop continues as long as `recalibrationNeeded` is true AND `calibrationAttempts` is strictly less than a specific boundary value."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 360,
    "subtopic_id": 8,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder’s survey drone performs `sectorScans`. The `while` loop continues as long as `currentSector` is less than 5 AND no `anomalyDetected`. The drone can skip analysis if the signal is weak or break the survey if too many anomalies are detected. Complete the loop condition, skip keyword, break keyword, and final status message.",
      "code": "public class SurveyDroneControl {\n    public static void main(String[] args) {\n        int currentSector = 0;\n        int signalStrength = 100;\n        boolean anomalyDetected = false;\n        \n        while (currentSector < 5 && !anomalyDetected) {\n            System.out.println(\"Scanning Sector: \" + currentSector);\n            \n            if (currentSector == 2) {\n                signalStrength = 40;\n            }\n            \n            if (signalStrength < 50) {\n                System.out.println(\"  WARNING: Weak Signal. Skipping analysis.\");\n                currentSector++;\n                ???;\n            }\n            \n            if (currentSector > 2 && currentSector % 2 == 0) {\n                anomalyDetected = true;\n                System.out.println(\"  CRITICAL: Anomaly detected at sector \" + currentSector + \"!\");\n                ???;\n            }\n            \n            System.out.println(\"  Sector \" + currentSector + \" analysis complete.\");\n            currentSector++;\n        }\n        \n        System.out.println(\"\\nSurvey complete.\");\n        if (anomalyDetected) {\n            System.out.println(\"Final Survey Status: Aborted.\");\n        } else {\n            System.out.println(\"Final Survey Status: All sectors scanned.\");\n        }\n    }\n}",
      "choices": [
        "<",
        "<=",
        "continue",
        "break",
        "&&",
        "||",
        "\"Final Survey Status: Aborted due to anomaly.\"",
        "\"Final Survey Status: All sectors scanned.\""
      ],
      "answer": [
        "<",
        "continue",
        "break",
        "\"Final Survey Status: All sectors scanned.\""
      ],
      "explanation": "1. `<` (choice a) sets the outer `while` loop condition (`currentSector < 5`).\n2. `continue` (choice c) is used to skip the rest of the inner loop body when a weak signal is detected.\n3. `break` (choice d) is used to immediately exit the loop when a critical anomaly is detected.\n4. `\"Final Survey Status: All sectors scanned.\"` (choice h) is the correct message when all sectors are scanned without an anomaly."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The outer `while` loop continues as long as `currentSector` is strictly less than 5 AND no anomaly is detected.",
      "2": "The blank after the 'Weak Signal' message is for a keyword that skips the rest of the current iteration.",
      "3": "The blank after the 'Anomaly detected' message is for a keyword that immediately exits the loop."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 361,
    "subtopic_id": 9,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder’s pre-flight system runs `diagnosticChecks`. A `for` loop performs these checks for `checkID` from `0` to `2`. Your task is to trace the code and determine what check IDs are logged.",
      "code": "public class DiagnosticChecker {\n    public static void main(Strinag[] args) {\n        for (int checkID = 0; checkID < 3; checkID++) {\n            System.out.println(\"Performing diagnostic check: \" + checkID);\n        }\n    }\n}",
      "choices": [
        "Performing diagnostic check: 0",
        "Performing diagnostic check: 0\\nPerforming diagnostic check: 1\\nPerforming diagnostic check: 2",
        "Performing diagnostic check: 1\\nPerforming diagnostic check: 2\\nPerforming diagnostic check: 3",
        "Nothing"
      ],
      "answer": [
        "Performing diagnostic check: 0\\nPerforming diagnostic check: 1\\nPerforming diagnostic check: 2"
      ],
      "explanation": "The `for` loop executes as follows:\n1. **`checkID = 0`**: `0 < 3` is `true`. Prints \"Performing diagnostic check: 0\". `checkID` becomes 1.\n2. **`checkID = 1`**: `1 < 3` is `true`. Prints \"Performing diagnostic check: 1\". `checkID` becomes 2.\n3. **`checkID = 2`**: `2 < 3` is `true`. Prints \"Performing diagnostic check: 2\". `checkID` becomes 3.\n4. **`checkID = 3`**: `3 < 3` is `false`. The loop terminates.\nThe message is printed for check IDs 0, 1, and 2."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The loop starts with `checkID = 0`.",
      "2": "The loop continues as long as `checkID` is strictly less than `3`.",
      "3": " `checkID` increments by `1` after each iteration."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 362,
    "subtopic_id": 9,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder is performing a `launchCountdown`. The countdown starts from `3` and goes down to `1`. Your task is to trace the code and determine the output.",
      "code": "public class LaunchCountdown {\n    public static void main(String[] args) {\n        for (int count = 3; count > 0; count--) {\n            System.out.println(\"T-\" + count);\n        }\n        System.out.println(\"Launch!\");\n    }\n}",
      "choices": [
        "T-3\\nT-2\\nT-1\\nLaunch!",
        "T-3\\nT-2\\nT-1",
        "Launch!",
        "T-0\\nLaunch!"
      ],
      "answer": [
        "T-3\\nT-2\\nT-1\\nLaunch!"
      ],
      "explanation": "The `for` loop executes as follows:\n1. **`count = 3`**: `3 > 0` is `true`. Prints \"T-3\". `count` becomes 2.\n2. **`count = 2`**: `2 > 0` is `true`. Prints \"T-2\". `count` becomes 1.\n3. **`count = 1`**: `1 > 0` is `true`. Prints \"T-1\". `count` becomes 0.\n4. **`count = 0`**: `0 > 0` is `false`. The loop terminates.\nFinally, `System.out.println(\"Launch!\");` prints \"Launch!\"."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The loop starts with `count = 3` and decrements.",
      "2": "The loop continues as long as `count` is greater than `0`.",
      "3": "The \"Launch!\" message is printed once, after the loop."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 363,
    "subtopic_id": 9,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder's `moduleStatus` array contains names of modules. The system iterates through the array to check each module. Your task is to trace the output to see the status of each module printed using an enhanced for loop.",
      "code": "public class ModuleStatusChecker {\n    public static void main(String[] args) {\n        String[] moduleStatus = {\"OK\", \"WARNING\", \"CRITICAL\"};\n        for (String status : moduleStatus) {\n            System.out.println(\"Module Status: \" + status);\n        }\n    }\n}",
      "choices": [
        "Module Status: OK",
        "Module Status: OK\\nModule Status: WARNING\\nModule Status: CRITICAL",
        "Module Status: OK\\nModule Status: WARNING",
        "Nothing"
      ],
      "answer": [
        "Module Status: OK\\nModule Status: WARNING\\nModule Status: CRITICAL"
      ],
      "explanation": "The enhanced `for` loop iterates through each `String` element in the `moduleStatus` array.\n1. **Iteration 1**: `status` is \"OK\". Prints \"Module Status: OK\".\n2. **Iteration 2**: `status` is \"WARNING\". Prints \"Module Status: WARNING\".\n3. **Iteration 3**: `status` is \"CRITICAL\". Prints \"Module Status: CRITICAL\".\nThe loop finishes after processing all elements."
    },
    "difficulty": "easy",
    "hints": {
      "1": "An enhanced `for` loop (for-each) iterates through every element in an array.",
      "2": "The loop variable `status` will take on the value of each element in `moduleStatus` sequentially.",
      "3": "The `println` statement is executed for each element."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 364,
    "subtopic_id": 9,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder's `communicationChannels` are numbered. A `for` loop prints each channel number. Your task is to trace the output.",
      "code": "public class CommsChannelPrinter {\n    public static void main(String[] args) {\n        for (int channel = 1; channel <= 2; channel++) {\n            System.out.println(\"Channel: \" + channel);\n        }\n    }\n}",
      "choices": [
        "Channel: 1",
        "Channel: 1\\nChannel: 2",
        "Channel: 0\\nChannel: 1\\nChannel: 2",
        "Nothing"
      ],
      "answer": [
        "Channel: 1\\nChannel: 2"
      ],
      "explanation": "The `for` loop executes as follows:\n1. **`channel = 1`**: `1 <= 2` is `true`. Prints \"Channel: 1\". `channel` becomes 2.\n2. **`channel = 2`**: `2 <= 2` is `true`. Prints \"Channel: 2\". `channel` becomes 3.\n3. **`channel = 3`**: `3 <= 2` is `false`. The loop terminates.\nThe output shows \"Channel: 1\" and \"Channel: 2\"."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The loop starts with `channel = 1`.",
      "2": "The loop continues as long as `channel` is `less than or equal to 2`.",
      "3": " `channel` increments by `1` after each iteration."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 365,
    "subtopic_id": 9,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder's `alertCodes` are stored in an array. The system needs to print each code. Your task is to trace the output using an enhanced for loop.",
      "code": "public class AlertCodePrinter {\n    public static void main(String[] args) {\n        int[] alertCodes = {10, 20, 30};\n        for (int code : alertCodes) {\n            System.out.print(code + \" \");\n        }\n    }\n}",
      "choices": [
        "10",
        "10 20 30",
        "10 20",
        "Nothing"
      ],
      "answer": [
        "10 20 30"
      ],
      "explanation": "The enhanced `for` loop iterates through each `int` element in the `alertCodes` array.\n1. **Iteration 1**: `code` is 10. Prints \"10 \".\n2. **Iteration 2**: `code` is 20. Prints \"20 \".\n3. **Iteration 3**: `code` is 30. Prints \"30 \".\nThe loop finishes after processing all elements, resulting in \"10 20 30 \"."
    },
    "difficulty": "easy",
    "hints": {
      "1": "An enhanced `for` loop (for-each) iterates through every element in an array.",
      "2": "The loop variable `code` will take on the value of each element in `alertCodes` sequentially.",
      "3": " `System.out.print()` prints on the same line."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 366,
    "subtopic_id": 9,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder's `resourceCollector` system uses a `for` loop to gather `energyUnits` over a set number of `collectionCycles`. Your task is to trace the `energyUnits` collected in each cycle and the `finalTotalEnergy` after the loop completes.",
      "code": "public class ResourceCollector {\n    public static void main(String[] args) {\n        int finalTotalEnergy = 0;\n        for (int collectionCycle = 1; collectionCycle <= 3; collectionCycle++) {\n            System.out.println(\"Collecting \" + (collectionCycle * 10) + \" energy units.\");\n            finalTotalEnergy += (collectionCycle * 10);\n        }\n        System.out.println(\"Final Total Energy: \" + finalTotalEnergy);\n    }\n}",
      "choices": [
        "Collecting 10 energy units.\\nCollecting 20 energy units.\\nCollecting 30 energy units.",
        "Final Total Energy: 30",
        "Final Total Energy: 60",
        "Collecting 10 energy units.\\nCollecting 20 energy units.\\nCollecting 30 energy units.\\nFinal Total Energy: 60"
      ],
      "answer": [
        "Collecting 10 energy units.\\nCollecting 20 energy units.\\nCollecting 30 energy units.",
        "Final Total Energy: 60"
      ],
      "explanation": "1. **Loop Iterations**: `finalTotalEnergy` starts at 0.\n    * `collectionCycle = 1`: `1 <= 3` is `true`. Prints \"Collecting 10 energy units.\". `finalTotalEnergy` becomes 10.\n    * `collectionCycle = 2`: `2 <= 3` is `true`. Prints \"Collecting 20 energy units.\". `finalTotalEnergy` becomes 10 + 20 = 30.\n    * `collectionCycle = 3`: `3 <= 3` is `true`. Prints \"Collecting 30 energy units.\". `finalTotalEnergy` becomes 30 + 30 = 60.\n    * `collectionCycle = 4`: `4 <= 3` is `false`. Loop terminates.\n2. **After Loop**: `System.out.println(\"Final Total Energy: \" + finalTotalEnergy);` executes, printing \"Final Total Energy: 60\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The loop runs for `collectionCycle` values 1, 2, and 3.",
      "2": "The energy collected in each cycle is `collectionCycle * 10`.",
      "3": " `finalTotalEnergy` accumulates the sum of collected energy units across all cycles."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 367,
    "subtopic_id": 9,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder's `moduleInventory` tracks `moduleIDs`. The system iterates through the array, but a special message is logged if a module is `null`. Your task is to trace the `moduleID`s and the `null` messages.",
      "code": "public class ModuleInventoryScanner {\n    public static void main(String[] args) {\n        String[] moduleInventory = {\"NAV-01\", null, \"ENG-03\"};\n        for (String moduleID : moduleInventory) {\n            if (moduleID == null) {\n                System.out.println(\"Empty slot detected.\");\n            } else {\n                System.out.println(\"Module ID: \" + moduleID);\n            }\n        }\n    }\n}",
      "choices": [
        "Module ID: NAV-01\\nEmpty slot detected.\\nModule ID: ENG-03",
        "Module ID: NAV-01\\nModule ID: ENG-03",
        "Empty slot detected.",
        "Module ID: NAV-01\\nModule ID: NAV-01"
      ],
      "answer": [
        "Module ID: NAV-01\\nEmpty slot detected.\\nModule ID: ENG-03"
      ],
      "explanation": "The enhanced `for` loop iterates through the `moduleInventory` array:\n1. **Iteration 1**: `moduleID` is \"NAV-01\". `moduleID == null` is `false`. Prints \"Module ID: NAV-01\".\n2. **Iteration 2**: `moduleID` is `null`. `moduleID == null` is `true`. Prints \"Empty slot detected.\".\n3. **Iteration 3**: `moduleID` is \"ENG-03\". `moduleID == null` is `false`. Prints \"Module ID: ENG-03\".\nThe loop processes all elements, leading to the combined output."
    },
    "difficulty": "medium",
    "hints": {
      "1": "An enhanced `for` loop processes each element of the array in order.",
      "2": "Pay attention to the `if-else` condition inside the loop: what happens if `moduleID` is `null`?",
      "3": "The second element of `moduleInventory` is `null`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 368,
    "subtopic_id": 9,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder's `powerCore` undergoes `diagnosticCycles`. The `for` loop runs 3 times. Inside the loop, `powerOutput` is doubled, but a special message is printed only for `even` cycles. Your task is to trace the `powerOutput` messages and the `Final Power Value`.",
      "code": "public class PowerCoreDiagnostics {\n    public static void main(String[] args) {\n        int powerOutput = 10;\n        for (int cycle = 1; cycle <= 3; cycle++) {\n            powerOutput *= 2;\n            if (cycle % 2 == 0) {\n                System.out.println(\"Power spike detected on cycle \" + cycle + \": \" + powerOutput);\n            } else {\n                System.out.println(\"Cycle \" + cycle + \" complete. Current Power: \" + powerOutput);\n            }\n        }\n        System.out.println(\"Final Power Value: \" + powerOutput);\n    }\n}",
      "choices": [
        "Cycle 1 complete. Current Power: 20\\nPower spike detected on cycle 2: 40\\nCycle 3 complete. Current Power: 80",
        "Final Power Value: 80",
        "Final Power Value: 60",
        "Cycle 1 complete. Current Power: 20\\nPower spike detected on cycle 2: 40\\nCycle 3 complete. Current Power: 80\\nFinal Power Value: 80"
      ],
      "answer": [
        "Cycle 1 complete. Current Power: 20\\nPower spike detected on cycle 2: 40\\nCycle 3 complete. Current Power: 80",
        "Final Power Value: 80"
      ],
      "explanation": "1. **Loop Iterations**: `powerOutput` starts at 10.\n    * `cycle = 1`: `1 <= 3` is `true`. `powerOutput` becomes `10 * 2 = 20`. `1 % 2 == 0` is `false`. Prints \"Cycle 1 complete. Current Power: 20\".\n    * `cycle = 2`: `2 <= 3` is `true`. `powerOutput` becomes `20 * 2 = 40`. `2 % 2 == 0` is `true`. Prints \"Power spike detected on cycle 2: 40\".\n    * `cycle = 3`: `3 <= 3` is `true`. `powerOutput` becomes `40 * 2 = 80`. `3 % 2 == 0` is `false`. Prints \"Cycle 3 complete. Current Power: 80\".\n    * `cycle = 4`: `4 <= 3` is `false`. Loop terminates.\n2. **After Loop**: `System.out.println(\"Final Power Value: \" + powerOutput);` executes, printing \"Final Power Value: 80\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Trace `powerOutput` as it updates in each iteration.",
      "2": "The `if-else` condition inside the loop depends on `cycle` being even or odd.",
      "3": "The final `powerOutput` value after the loop terminates is printed once."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 369,
    "subtopic_id": 9,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder is transferring `dataPackets` with a `for` loop. The loop iterates `packetID`s from 1 to 3. If a `packetID` is `2`, a \"Retrying\" message is displayed, but the loop `continues` to the next iteration. Your task is to trace the sequence of output messages and the `Final Packets Sent` count.",
      "code": "public class DataPacketTransfer {\n    public static void main(String[] args) {\n        int finalPacketsSent = 0;\n        for (int packetID = 1; packetID <= 3; packetID++) {\n            if (packetID == 2) {\n                System.out.println(\"Retrying packet \" + packetID + \"...\");\n                continue;\n            }\n            System.out.println(\"Packet \" + packetID + \" sent.\");\n            finalPacketsSent++;\n        }\n        System.out.println(\"Final Packets Sent: \" + finalPacketsSent);\n    }\n}",
      "choices": [
        "Packet 1 sent.\\nRetrying packet 2...\\nPacket 3 sent.",
        "Final Packets Sent: 3",
        "Final Packets Sent: 2",
        "Packet 1 sent.\\nRetrying packet 2...\\nPacket 3 sent.\\nFinal Packets Sent: 3"
      ],
      "answer": [
        "Packet 1 sent.\\nRetrying packet 2...\\nPacket 3 sent.",
        "Final Packets Sent: 2"
      ],
      "explanation": "1. **Loop Iterations**: `finalPacketsSent` starts at 0.\n    * `packetID = 1`: `1 <= 3` is `true`. `1 == 2` is `false`. Prints \"Packet 1 sent.\". `finalPacketsSent` becomes 1. `packetID` becomes 2.\n    * `packetID = 2`: `2 <= 3` is `true`. `2 == 2` is `true`. Prints \"Retrying packet 2...\". `continue` skips the rest of the current iteration. `packetID` becomes 3.\n    * `packetID = 3`: `3 <= 3` is `true`. `3 == 2` is `false`. Prints \"Packet 3 sent.\". `finalPacketsSent` becomes 2. `packetID` becomes 4.\n    * `packetID = 4`: `4 <= 3` is `false`. Loop terminates.\n2. **After Loop**: `System.out.println(\"Final Packets Sent: \" + finalPacketsSent);` executes, printing \"Final Packets Sent: 2\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Trace `packetID` and `finalPacketsSent` through each iteration.",
      "2": "The `continue` keyword skips the remainder of the current loop iteration.",
      "3": "The final `finalPacketsSent` value is the count of times \"Packet X sent.\" was actually printed."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 370,
    "subtopic_id": 9,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder performs a `moduleScan` using a `for` loop for `moduleID`s from 1 to 3. If `moduleID` reaches `3`, a \"Critical Error\" is detected, and the loop `breaks` immediately. Your task is to trace the output messages and the `Final Module Scanned` value.",
      "code": "public class ModuleScanner {\n    public static void main(String[] args) {\n        int finalModuleScanned = 0;\n        for (int moduleID = 1; moduleID <= 3; moduleID++) {\n            if (moduleID == 3) {\n                System.out.println(\"Critical Error: Aborting scan at module \" + moduleID + \".\");\n                finalModuleScanned = moduleID;\n                break;\n            }\n            System.out.println(\"Scanning module: \" + moduleID);\n            finalModuleScanned = moduleID;\n        }\n        System.out.println(\"Final Module Scanned: \" + finalModuleScanned);\n    }\n}",
      "choices": [
        "Scanning module: 1\\nScanning module: 2\\nCritical Error: Aborting scan at module 3.",
        "Final Module Scanned: 2",
        "Final Module Scanned: 3",
        "Scanning module: 1\\nScanning module: 2\\nCritical Error: Aborting scan at module 3.\\nFinal Module Scanned: 3"
      ],
      "answer": [
        "Scanning module: 1\\nScanning module: 2\\nCritical Error: Aborting scan at module 3.",
        "Final Module Scanned: 3"
      ],
      "explanation": "1. **Loop Iterations**: `finalModuleScanned` starts at 0.\n    * `moduleID = 1`: `1 <= 3` is `true`. `1 == 3` is `false`. Prints \"Scanning module: 1\". `finalModuleScanned` becomes 1. `moduleID` becomes 2.\n    * `moduleID = 2`: `2 <= 3` is `true`. `2 == 3` is `false`. Prints \"Scanning module: 2\". `finalModuleScanned` becomes 2. `moduleID` becomes 3.\n    * `moduleID = 3`: `3 <= 3` is `true`. `3 == 3` is `true`. Prints \"Critical Error: Aborting scan at module 3.\". `finalModuleScanned` becomes 3. `break` exits the loop.\n2. **After Loop**: `System.out.println(\"Final Module Scanned: \" + finalModuleScanned);` executes, printing \"Final Module Scanned: 3\"."
    },
    "difficulty": "medium",
    "hints": {
      "1": "Trace `moduleID` and `finalModuleScanned` carefully.",
      "2": "The `break` keyword immediately exits the loop when its condition is met.",
      "3": "The `finalModuleScanned` variable captures the `moduleID` value *at the point of the break* (or loop completion)."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 371,
    "subtopic_id": 9,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder is performing a `multiPhaseScan`. Nested `for` loops iterate `scanPhases` and `dataPoints`. A special message is printed under specific conditions. Your task is to trace all `Scan Phase` and `Data Point` messages, and determine the `Total Readings` and `Scan Status`.",
      "code": "public class MultiPhaseScan {\n    public static void main(String[] args) {\n        int totalReadings = 0;\n        String scanStatus = \"Scanning\";\n\n        for (int scanPhase = 0; scanPhase < 2; scanPhase++) {\n            for (int dataPoint = 0; dataPoint < 3; dataPoint++) {\n                System.out.println(\"Scan Phase: \" + scanPhase + \", Data Point: \" + dataPoint);\n                totalReadings++;\n                if (scanPhase == 0 && dataPoint == 1) {\n                    System.out.println(\"  SPECIAL DATA: Anomaly detected in phase \" + scanPhase);\n                }\n            }\n        }\n        \n        if (totalReadings == 6) {\n            scanStatus = \"Complete\";\n        } else {\n            scanStatus = \"Incomplete\";\n        }\n        \n        System.out.println(\"Total Readings: \" + totalReadings);\n        System.out.println(\"Scan Status: \" + scanStatus);\n    }\n}",
      "choices": [
        "Scan Phase: 0, Data Point: 0\\nScan Phase: 0, Data Point: 1\\n  SPECIAL DATA: Anomaly detected in phase 0\\nScan Phase: 0, Data Point: 2\\nScan Phase: 1, Data Point: 0\\nScan Phase: 1, Data Point: 1\\nScan Phase: 1, Data Point: 2",
        "Total Readings: 5",
        "Total Readings: 6",
        "Scan Status: Complete"
      ],
      "answer": [
        "Scan Phase: 0, Data Point: 0\\nScan Phase: 0, Data Point: 1\\n  SPECIAL DATA: Anomaly detected in phase 0\\nScan Phase: 0, Data Point: 2\\nScan Phase: 1, Data Point: 0\\nScan Phase: 1, Data Point: 1\\nScan Phase: 1, Data Point: 2",
        "Total Readings: 6",
        "Scan Status: Complete"
      ],
      "explanation": "1. **Loop Execution (Phase/Data output)**:\n    * `scanPhase = 0` (Outer loop):\n        * `dataPoint = 0`: Prints \"Scan Phase: 0, Data Point: 0\". `totalReadings` is 1.\n        * `dataPoint = 1`: Prints \"Scan Phase: 0, Data Point: 1\". `totalReadings` is 2. Prints \"SPECIAL DATA: Anomaly detected in phase 0\".\n        * `dataPoint = 2`: Prints \"Scan Phase: 0, Data Point: 2\". `totalReadings` is 3.\n    * `scanPhase = 1` (Outer loop):\n        * `dataPoint = 0`: Prints \"Scan Phase: 1, Data Point: 0\". `totalReadings` is 4.\n        * `dataPoint = 1`: Prints \"Scan Phase: 1, Data Point: 1\". `totalReadings` is 5.\n        * `dataPoint = 2`: Prints \"Scan Phase: 1, Data Point: 2\". `totalReadings` is 6.\n2. **After Loops**: \n    * `totalReadings` is `6`. `if (totalReadings == 6)` is `true`. `scanStatus` becomes \"Complete\".\n    * `System.out.println(\"Total Readings: \" + totalReadings);` prints \"Total Readings: 6\".\n    * `System.out.println(\"Scan Status: \" + scanStatus);` prints \"Scan Status: Complete\"."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Trace the execution of the outer loop (`scanPhase`) and how it controls the inner loop (`dataPoint`).",
      "2": " `totalReadings` increments in the inner loop.",
      "3": "The `if` condition for \"SPECIAL DATA\" checks specific values of both loop counters."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 372,
    "subtopic_id": 9,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder's `repairDrone` is running a `repairCycle` sequence. Nested `for` loops iterate `damageZones` and `repairAttempts`. Conditions within the loop can `skip` or `break` attempts. Your task is to trace all `Repair Cycle` messages and determine the `Total Repair Attempts Made` and `Final Damage Zone`.",
      "code": "public class RepairDroneSimulator {\n    public static void main(String[] args) {\n        int totalAttemptsMade = 0;\n        int finalDamageZone = 0;\n\n        for (int damageZone = 1; damageZone <= 2; damageZone++) {\n            System.out.println(\"Entering Damage Zone: \" + damageZone);\n            for (int repairAttempt = 1; repairAttempt <= 3; repairAttempt++) {\n                if (repairAttempt == 2 && damageZone == 1) {\n                    System.out.println(\"  Skipping problematic attempt \" + repairAttempt + \" in Zone \" + damageZone);\n                    totalAttemptsMade++;\n                    continue;\n                }\n                if (repairAttempt == 3) {\n                    System.out.println(\"  Critical failure in attempt \" + repairAttempt + \". Aborting Zone \" + damageZone + \".\");\n                    totalAttemptsMade++;\n                    break;\n                }\n                System.out.println(\"  Repair Cycle: \" + repairAttempt + \" in Zone: \" + damageZone);\n                totalAttemptsMade++;\n            }\n            finalDamageZone = damageZone;\n        }\n        \n        System.out.println(\"Total Repair Attempts Made: \" + totalAttemptsMade);\n        System.out.println(\"Final Damage Zone Processed: \" + finalDamageZone);\n        System.out.println(\"Simulation complete.\");\n    }\n}",
      "choices": [
        "Entering Damage Zone: 1\\n  Repair Cycle: 1 in Zone: 1\\n  Skipping problematic attempt 2 in Zone 1\\n  Critical failure in attempt 3. Aborting Zone 1.\\nEntering Damage Zone: 2\\n  Repair Cycle: 1 in Zone: 2\\n  Repair Cycle: 2 in Zone: 2\\n  Critical failure in attempt 3. Aborting Zone 2.",
        "Total Repair Attempts Made: 6",
        "Final Damage Zone Processed: 2",
        "Total Repair Attempts Made: 5"
      ],
      "answer": [
        "Entering Damage Zone: 1\\n  Repair Cycle: 1 in Zone: 1\\n  Skipping problematic attempt 2 in Zone 1\\n  Critical failure in attempt 3. Aborting Zone 1.\\nEntering Damage Zone: 2\\n  Repair Cycle: 1 in Zone: 2\\n  Repair Cycle: 2 in Zone: 2\\n  Critical failure in attempt 3. Aborting Zone 2.",
        "Total Repair Attempts Made: 6",
        "Final Damage Zone Processed: 2"
      ],
      "explanation": "1. **Loop Execution (Console Output)**:\n    * **`damageZone = 1`**: Prints \"Entering Damage Zone: 1\".\n        * `repairAttempt = 1`: Prints \"  Repair Cycle: 1 in Zone: 1\". `totalAttemptsMade` is 1.\n        * `repairAttempt = 2`: `damageZone == 1` is true. Prints \"  Skipping problematic attempt 2 in Zone 1\". `totalAttemptsMade` is 2. `continue`. (Skips normal print)\n        * `repairAttempt = 3`: `repairAttempt == 3` is true. Prints \"  Critical failure in attempt 3. Aborting Zone 1.\". `totalAttemptsMade` is 3. `break` (exits inner loop).\n    * `finalDamageZone` becomes 1.\n    * **`damageZone = 2`**: Prints \"Entering Damage Zone: 2\".\n        * `repairAttempt = 1`: Prints \"  Repair Cycle: 1 in Zone: 2\". `totalAttemptsMade` is 4.\n        * `repairAttempt = 2`: Prints \"  Repair Cycle: 2 in Zone: 2\". `totalAttemptsMade` is 5.\n        * `repairAttempt = 3`: `repairAttempt == 3` is true. Prints \"  Critical failure in attempt 3. Aborting Zone 2.\". `totalAttemptsMade` is 6. `break` (exits inner loop).\n    * `finalDamageZone` becomes 2.\n    * Outer loop terminates.\n2. **After Loops**: \n    * `System.out.println(\"Total Repair Attempts Made: \" + totalAttemptsMade);` prints \"Total Repair Attempts Made: 6\".\n    * `System.out.println(\"Final Damage Zone Processed: \" \" + finalDamageZone);` prints \"Final Damage Zone Processed: 2\"."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Trace `damageZone` (outer loop) and `repairAttempt` (inner loop).",
      "2": " `continue` skips the rest of the inner loop's current iteration. `break` exits the *inner* loop.",
      "3": " `totalAttemptsMade` increments for *every* `repairAttempt`, even if skipped or aborted."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 373,
    "subtopic_id": 9,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder's `reactorPowerMatrix` is undergoing a `stressTest`. An outer `for` loop iterates `phaseCount`s (0 to 1). An inner `for` loop simulates `pulseCycles` (0 to 2). If `phaseCount` is `0` and `pulseCycle` is `1`, a special 'ALERT' is logged, and the inner loop's *current iteration* is `skipped`. If `phaseCount` is `1` and `pulseCycle` is `0`, a 'MELTDOWN' warning is logged, and the *entire program terminates early*. Your task is to trace all `Power Pulse` messages, the `Total Pulses Attempted`, and the `Final Reactor Status`.",
      "code": "public class ReactorPowerMatrix {\n    public static void main(String[] args) {\n        int totalPulsesAttempted = 0;\n        String finalReactorStatus = \"Stable\";\n\n        for (int phaseCount = 0; phaseCount < 2; phaseCount++) {\n            System.out.println(\"Initiating Stress Test Phase: \" + phaseCount);\n            for (int pulseCycle = 0; pulseCycle < 3; pulseCycle++) {\n                if (phaseCount == 0 && pulseCycle == 1) {\n                    System.out.println(\"  ALERT: Minor Fluctuation at Phase \" + phaseCount + \", Pulse \" + pulseCycle);\n                    totalPulsesAttempted++; // Count this as an attempted pulse\n                    continue; // Skip normal logging for this pulse\n                }\n                if (phaseCount == 1 && pulseCycle == 0) {\n                    finalReactorStatus = \"MELTDOWN IMMINENT\";\n                    System.out.println(\"  CRITICAL: MELTDOWN at Phase \" + phaseCount + \", Pulse \" + pulseCycle + \"! Aborting all tests.\");\n                    totalPulsesAttempted++; // Count this as an attempted pulse\n                    return; // Terminate main method (program)\n                }\n                System.out.println(\"  Power Pulse: \" + pulseCycle + \" OK.\");\n                totalPulsesAttempted++;\n            }\n        }\n        System.out.println(\"\\nStress Test Complete. Final Status: \" + finalReactorStatus);\n        System.out.println(\"Total Pulses Attempted: \" + totalPulsesAttempted);\n    }\n}",
      "choices": [
        "Initiating Stress Test Phase: 0\\n  Power Pulse: 0 OK.\\n  ALERT: Minor Fluctuation at Phase 0, Pulse 1\\n  Power Pulse: 2 OK.\\nInitiating Stress Test Phase: 1\\n  CRITICAL: MELTDOWN at Phase 1, Pulse 0! Aborting all tests.",
        "Total Pulses Attempted: 4",
        "Final Reactor Status: Stable",
        "Final Reactor Status: MELTDOWN IMMINENT"
      ],
      "answer": [
        "Initiating Stress Test Phase: 0\\n  Power Pulse: 0 OK.\\n  ALERT: Minor Fluctuation at Phase 0, Pulse 1\\n  Power Pulse: 2 OK.\\nInitiating Stress Test Phase: 1\\n  CRITICAL: MELTDOWN at Phase 1, Pulse 0! Aborting all tests.",
        "Total Pulses Attempted: 4",
        "Final Reactor Status: MELTDOWN IMMINENT"
      ],
      "explanation": "1. `phaseCount = 0` (Outer loop):\n    * Prints \"Initiating Stress Test Phase: 0\".\n    * `pulseCycle = 0`: Prints \"  Power Pulse: 0 OK.\". `totalPulsesAttempted` is 1.\n    * `pulseCycle = 1`: Prints \"  ALERT: Minor Fluctuation...\". `totalPulsesAttempted` is 2. `continue` skips `\"  Power Pulse: 1 OK.\"`.\n    * `pulseCycle = 2`: Prints \"  Power Pulse: 2 OK.\". `totalPulsesAttempted` is 3. \n2. `phaseCount = 1` (Outer loop):\n    * Prints \"Initiating Stress Test Phase: 1\".\n    * `pulseCycle = 0`: `phaseCount == 1 && pulseCycle == 0` is `true`. `finalReactorStatus` becomes \"MELTDOWN IMMINENT\". Prints \"  CRITICAL: MELTDOWN...\". `totalPulsesAttempted` is 4. `return` (program terminates).\n3. The final `System.out.println` statements outside the loops are not executed due to `return`."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Trace nested loop execution and how `continue` affects output within an inner loop iteration.",
      "2": "A `return` statement immediately exits the `main` method, stopping all further program execution.",
      "3": "Keep track of `totalPulsesAttempted` and `finalReactorStatus` as they are updated conditionally."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 374,
    "subtopic_id": 9,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder's `automatedShield` system activates `layers` of shields. An outer `for` loop controls `shieldLayers` (1 to 2). An inner `for` loop manages `reinforcementCycles` (1 to 2). If `shieldLayer` is `1` and `reinforcementCycle` is `1`, a 'SKIPPED' message is logged, and the `reinforcementCycle` effectively advances by an extra step. If `shieldLayer` is `2` and `reinforcementCycle` is `2`, a 'FAILURE' is logged, causing the *inner loop to break*. Your task is to trace all `Shield Layer` and `Reinforcement` messages, the `Total Reinforcements Applied`, and the `Final Status`.",
      "code": "public class AutomatedShield {\n    public static void main(String[] args) {\n        int totalReinforcementsApplied = 0;\n        String finalStatus = \"Optimal\";\n\n        for (int shieldLayer = 1; shieldLayer <= 2; shieldLayer++) {\n            System.out.println(\"Activating Shield Layer: \" + shieldLayer);\n            for (int reinforcementCycle = 1; reinforcementCycle <= 2; reinforcementCycle++) {\n                if (shieldLayer == 1 && reinforcementCycle == 1) {\n                    System.out.println(\"  REINFORCEMENT SKIPPED for Layer \" + shieldLayer + \", Cycle \" + reinforcementCycle);\n                    reinforcementCycle++; // Effectively advances by 1 more\n                    totalReinforcementsApplied++; // This counts as an attempted reinforcement\n                    continue;\n                }\n                if (shieldLayer == 2 && reinforcementCycle == 2) {\n                    finalStatus = \"PARTIAL FAILURE\";\n                    System.out.println(\"  FAILURE: Reinforcement failed at Layer \" + shieldLayer + \", Cycle \" + reinforcementCycle + \".\");\n                    totalReinforcementsApplied++; // This counts as an attempted reinforcement\n                    break; // Break inner loop\n                }\n                System.out.println(\"  Reinforcement Cycle: \" + reinforcementCycle + \" OK.\");\n                totalReinforcementsApplied++;\n            }\n        }\n        System.out.println(\"\\nTotal Reinforcements Applied: \" + totalReinforcementsApplied);\n        System.out.println(\"Final Status: \" + finalStatus);\n    }\n}",
      "choices": [
        "Activating Shield Layer: 1\\n  REINFORCEMENT SKIPPED for Layer 1, Cycle 1\\n  Reinforcement Cycle: 2 OK.\\nActivating Shield Layer: 2\\n  Reinforcement Cycle: 1 OK.\\n  FAILURE: Reinforcement failed at Layer 2, Cycle 2.",
        "Total Reinforcements Applied: 5",
        "Final Status: Optimal",
        "Final Status: PARTIAL FAILURE"
      ],
      "answer": [
        "Activating Shield Layer: 1\\n  REINFORCEMENT SKIPPED for Layer 1, Cycle 1\\n  Reinforcement Cycle: 2 OK.\\nActivating Shield Layer: 2\\n  Reinforcement Cycle: 1 OK.\\n  FAILURE: Reinforcement failed at Layer 2, Cycle 2.",
        "Total Reinforcements Applied: 5",
        "Final Status: PARTIAL FAILURE"
      ],
      "explanation": "1. `shieldLayer = 1` (Outer loop):\n    * Prints \"Activating Shield Layer: 1\".\n    * `reinforcementCycle = 1`: `shieldLayer == 1 && reinforcementCycle == 1` is `true`. Prints \"  REINFORCEMENT SKIPPED...\". `reinforcementCycle` becomes 2. `totalReinforcementsApplied` is 1. `continue` skips.\n    * `reinforcementCycle = 2`: Prints \"  Reinforcement Cycle: 2 OK.\". `totalReinforcementsApplied` is 2. \n2. `shieldLayer = 2` (Outer loop):\n    * Prints \"Activating Shield Layer: 2\".\n    * `reinforcementCycle = 1`: Prints \"  Reinforcement Cycle: 1 OK.\". `totalReinforcementsApplied` is 3.\n    * `reinforcementCycle = 2`: `shieldLayer == 2 && reinforcementCycle == 2` is `true`. `finalStatus` becomes \"PARTIAL FAILURE\". Prints \"  FAILURE: Reinforcement failed...\". `totalReinforcementsApplied` is 4. `break` exits inner loop.\n3. After loops: `System.out.println(\"\\nTotal Reinforcements Applied: \" + totalReinforcementsApplied);` prints \"Total Reinforcements Applied: 4\". `System.out.println(\"Final Status: \" + finalStatus);` prints \"Final Status: PARTIAL FAILURE\"."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Trace the nested loops carefully, especially how `reinforcementCycle` is incremented in the `continue` block.",
      "2": "The `continue` statement skips the rest of the current inner loop iteration.",
      "3": "The `break` statement exits only the *inner* loop, allowing the outer loop to proceed to its next iteration."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 375,
    "subtopic_id": 9,
    "type": "output_tracing",
    "snippet_choices": {
      "scenario": "The Pathfinder's `communicationProtocol` performs `signalTests` across `frequencyBands`. An outer `for` loop iterates `frequencyBand`s (0 to 1). An inner `for` loop performs `testIteration`s (0 to 2). If `frequencyBand` is `0` and `testIteration` is `0`, a 'CALIBRATING' message is logged, and the `testIteration` effectively jumps to `2`. If `frequencyBand` is `1` and `testIteration` is `1`, a 'LINK ESTABLISHED' message is logged, and the *entire program terminates early*. Your task is to trace all messages, the `Total Tests Run`, and the `Final Protocol State`.",
      "code": "public class CommunicationProtocol {\n    public static void main(String[] args) {\n        int totalTestsRun = 0;\n        String finalProtocolState = \"Pending\";\n\n        for (int frequencyBand = 0; frequencyBand < 2; frequencyBand++) {\n            System.out.println(\"Testing Frequency Band: \" + frequencyBand);\n            for (int testIteration = 0; testIteration < 3; testIteration++) {\n                if (frequencyBand == 0 && testIteration == 0) {\n                    System.out.println(\"  CALIBRATING: Skipping initial tests for Band \" + frequencyBand);\n                    testIteration = 2; // Jump to end of inner loop for this iteration\n                    totalTestsRun++;\n                    continue;\n                }\n                if (frequencyBand == 1 && testIteration == 1) {\n                    finalProtocolState = \"Link Established\";\n                    System.out.println(\"  LINK ESTABLISHED at Band \" + frequencyBand + \", Iteration \" + testIteration + \"! Mission Success.\");\n                    totalTestsRun++;\n                    return; // Terminate main method (program)\n                }\n                System.out.println(\"  Running Test Iteration: \" + testIteration + \" OK.\");\n                totalTestsRun++;\n            }\n        }\n        System.out.println(\"\\nTotal Tests Run: \" + totalTestsRun);\n        System.out.println(\"Final Protocol State: \" + finalProtocolState);\n    }\n}",
      "choices": [
        "Testing Frequency Band: 0\\n  CALIBRATING: Skipping initial tests for Band 0\\n  Running Test Iteration: 2 OK.\\nTesting Frequency Band: 1\\n  Running Test Iteration: 0 OK.\\n  LINK ESTABLISHED at Band 1, Iteration 1! Mission Success.",
        "Total Tests Run: 5",
        "Final Protocol State: Pending",
        "Final Protocol State: Link Established"
      ],
      "answer": [
        "Testing Frequency Band: 0\\n  CALIBRATING: Skipping initial tests for Band 0\\n  Running Test Iteration: 2 OK.\\nTesting Frequency Band: 1\\n  Running Test Iteration: 0 OK.\\n  LINK ESTABLISHED at Band 1, Iteration 1! Mission Success.",
        "Total Tests Run: 5",
        "Final Protocol State: Link Established"
      ],
      "explanation": "1. `frequencyBand = 0` (Outer loop):\n    * Prints \"Testing Frequency Band: 0\".\n    * `testIteration = 0`: `frequencyBand == 0 && testIteration == 0` is `true`. Prints \"  CALIBRATING...\". `testIteration` becomes 2. `totalTestsRun` is 1. `continue` skips.\n    * `testIteration = 2`: Prints \"  Running Test Iteration: 2 OK.\". `totalTestsRun` is 2.\n2. `frequencyBand = 1` (Outer loop):\n    * Prints \"Testing Frequency Band: 1\".\n    * `testIteration = 0`: Prints \"  Running Test Iteration: 0 OK.\". `totalTestsRun` is 3.\n    * `testIteration = 1`: `frequencyBand == 1 && testIteration == 1` is `true`. `finalProtocolState` becomes \"Link Established\". Prints \"  LINK ESTABLISHED...\". `totalTestsRun` is 4. `return` (program terminates).\n3. The final `System.out.println` statements outside the loops are not executed due to `return`."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Carefully trace `testIteration` when it's manually advanced using `testIteration = 2` within the `continue` block.",
      "2": "A `continue` statement skips the rest of the current inner loop iteration.",
      "3": "A `return` statement immediately exits the `main` method, stopping all further program execution."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 376,
    "subtopic_id": 9,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "The Pathfinder's `systemBootSequence` uses a `for` loop to initialize components. However, the loop has a syntax error in its header, as a semicolon is missing. Fix the code to ensure the `for` loop is grammatically correct.",
      "code": "public class BootSequenceFixer {\n    public static void main(String[] args) {\n        for (int step = 1; step <= 3; step++) { \n            System.out.println(\"Boot step \" + step + \" complete.\");\n        }\n    }\n}",
      "expected_output": [
        "Boot step 1 complete.\\nBoot step 2 complete.\\nBoot step 3 complete."
      ],
      "hidden_test_case": "",
      "answer": [
        "Boot step 1 complete.\\nBoot step 2 complete.\\nBoot step 3 complete."
      ],
      "explanation": "A `for` loop header requires semicolons (`;`) to separate its three components: initialization, termination condition, and increment/decrement. The original code is missing a semicolon between `step <= 3` and `step++`. Adding the semicolon correctly fixes the syntax."
    },
    "difficulty": "easy",
    "hints": {
      "1": "A `for` loop header has three distinct parts, separated by a specific punctuation mark.",
      "2": "Look at the structure inside the parentheses `(...)`.",
      "3": "A specific punctuation mark is missing between the `termination` and `increment` sections."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 377,
    "subtopic_id": 9,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "The Pathfinder's `cargoManifest` system uses an enhanced `for` loop to print `itemNames`. However, the array is incorrectly declared with misplaced square brackets, preventing the loop from running. Fix the code to correctly declare the array.",
      "code": "public class CargoScannerFixer {\n    public static void main(String[] args) {\n        String[] cargoManifest = {\"Food\", \"Water\", \"Tools\"}; \n        for (String item : cargoManifest) {\n            System.out.println(\"Scanning: \" + item);\n        }\n    }\n}",
      "expected_output": [
        "Scanning: Food\\nScanning: Water\\nScanning: Tools"
      ],
      "hidden_test_case": "",
      "answer": [
        "Scanning: Food\\nScanning: Water\\nScanning: Tools"
      ],
      "explanation": "The original code `String cargoManifest[]` uses a C-style array declaration syntax where the `[]` are after the variable name. While technically allowed in Java for backward compatibility, the preferred and more common syntax is to place the `[]` immediately after the data type (`String[] cargoManifest`). This clarifies that the variable `cargoManifest` is an array of `String`s. Using the standard syntax makes the code clearer and ensures proper interpretation by the compiler."
    },
    "difficulty": "easy",
    "hints": {
      "1": "For array variable declarations, the square brackets `[]` typically go after the data type (`String[]`), not after the variable name.",
      "2": "The original code might compile but not work as an array or might cause an immediate compilation error depending on Java version/context.",
      "3": "The blank implies a missing opening parenthesis for a condition."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 378,
    "subtopic_id": 9,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "The Pathfinder's `dataUpload` system uses a `for` loop to send `packets`. The loop's body is not properly enclosed with curly braces, which is poor practice and can lead to logical errors. Fix the code to enclose the loop's body in braces.",
      "code": "public class DataUploaderFixer {\n    public static void main(String[] args) {\n        for (int i = 0; i < 2; i++) {\n            System.out.println(\"Uploading packet \" + i);\n        }\n        System.out.println(\"Upload complete.\");\n    }\n}",
      "expected_output": [
        "Uploading packet 0\\nUploading packet 1\\nUpload complete."
      ],
      "hidden_test_case": "",
      "answer": [
        "Uploading packet 0\\nUploading packet 1\\nUpload complete."
      ],
      "explanation": "In Java, if a loop (or conditional statement) body consists of more than one statement, it *must* be enclosed in curly braces `{}`. Even for a single statement, it's best practice. Without braces, only the first statement immediately following the `for` loop header (`System.out.println(\"Uploading packet \" + i);`) is considered part of the loop. The `System.out.println(\"Upload complete.\");` then executes *after* the loop, but only once. The fix is to add curly braces around the statement(s) intended for the loop body."
    },
    "difficulty": "easy",
    "hints": {
      "1": "A `for` loop executes the statement immediately following its header.",
      "2": "If you want multiple statements to be part of the loop's repeated actions, they must be grouped together.",
      "3": "Curly braces `{}` are used to define a block of code to be executed together."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 379,
    "subtopic_id": 9,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "The Pathfinder's `componentScanner` is supposed to scan `componentID`s starting from `1` up to `3`. The current `for` loop initializes `componentID` incorrectly, causing it to start from `0`. Fix the initialization part of the `for` loop.",
      "code": "public class ComponentScannerFixer {\n    public static void main(String[] args) {\n        for (int componentID = 1; componentID <= 3; componentID++) {\n            System.out.println(\"Scanning Component: \" + componentID);\n        }\n    }\n}",
      "expected_output": [
        "Scanning Component: 1\\nScanning Component: 2\\nScanning Component: 3"
      ],
      "hidden_test_case": "",
      "answer": [
        "Scanning Component: 1\\nScanning Component: 2\\nScanning Component: 3"
      ],
      "explanation": "The original `for` loop initializes `componentID` to `0` (`int componentID = 0;`). The requirement is to scan components from `1` to `3`. The fix is to change the initialization of `componentID` from `0` to `1`. This makes the loop start printing from `1` and continue up to `3`."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The first part of the `for` loop header is for initialization.",
      "2": "The goal is to start scanning from `componentID = 1`.",
      "3": "Modify the value assigned to `componentID` at the start of the loop."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 380,
    "subtopic_id": 9,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "The Pathfinder's `dataPacketBurst` system sends `packets` with increasing `packetID`s. The `for` loop's update section is faulty, causing the loop to run indefinitely. Fix the `for` loop header to correctly increment `packetID` and terminate after 3 packets (IDs 1, 2, 3).",
      "code": "public class PacketBurstFixer {\n    public static void main(String[] args) {\n        for (int packetID = 1; packetID <= 3; packetID++) { // Corrected: Added increment\n            System.out.println(\"Sending Packet ID: \" + packetID);\n        }\n    }\n}",
      "expected_output": [
        "Sending Packet ID: 1\\nSending Packet ID: 2\\nSending Packet ID: 3"
      ],
      "hidden_test_case": "",
      "answer": [
        "Sending Packet ID: 1\\nSending Packet ID: 2\\nSending Packet ID: 3"
      ],
      "explanation": "The original `for` loop is missing its `increment` expression (`packetID++`) in the header. As a result, `packetID` remains `1`, and the condition `packetID <= 3` is always `true`, leading to an infinite loop. The fix is to add `packetID++` in the update section, ensuring `packetID` increases in each iteration, allowing the loop to correctly send 3 packets and terminate."
    },
    "difficulty": "easy",
    "hints": {
      "1": "An infinite loop in a `for` loop usually means the loop variable is not changing in a way that satisfies the termination condition.",
      "2": "The third part of the `for` loop header is for updating the loop variable.",
      "3": "The blank implies a missing increment operator."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 381,
    "subtopic_id": 9,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "The Pathfinder's `planetaryScan` system uses a `for` loop that iterates `scanZones` from 1 to 2, and `dataPoints` from 1 to 3. The code has a `continue` statement that is incorrectly placed or conditioned, causing some valid data points to be missed from the output. Fix the code to ensure all data points (1, 2, 3) are logged per zone.",
      "code": "public class PlanetaryScanFixer {\n    public static void main(String[] args) {\n        for (int scanZone = 1; scanZone <= 2; scanZone++) {\n            System.out.println(\"Scanning Zone: \" + scanZone);\n            for (int dataPoint = 1; dataPoint <= 3; dataPoint++) {\n                if (dataPoint == 100) { // Corrected: Condition is now unlikely to be met\n                    continue;\n                }\n                System.out.println(\"  Collecting data point: \" + dataPoint);\n            }\n        }\n    }\n}",
      "expected_output": [
        "Scanning Zone: 1\\n  Collecting data point: 1\\n  Collecting data point: 2\\n  Collecting data point: 3\\nScanning Zone: 2\\n  Collecting data point: 1\\n  Collecting data point: 2\\n  Collecting data point: 3"
      ],
      "hidden_test_case": "",
      "answer": [
        "Scanning Zone: 1\\n  Collecting data point: 1\\n  Collecting data point: 2\\n  Collecting data point: 3\\nScanning Zone: 2\\n  Collecting data point: 1\\n  Collecting data point: 2\\n  Collecting data point: 3"
      ],
      "explanation": "The original code incorrectly used `if (dataPoint == 2) { continue; }`, which caused `dataPoint 2` to be skipped from the log. The intent was to log all points. The fix is to change the `continue` condition to something that is not normally met (e.g., `dataPoint == 100`) or remove the `continue` statement entirely if no skipping is desired. This ensures \"Collecting data point: 2\" is always printed."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The `continue` statement skips the rest of the *current iteration* of the loop.",
      "2": "The goal is to ensure *all* data points (1, 2, 3) are logged.",
      "3": "Adjust the `continue` condition so it doesn't interfere with normal logging."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 382,
    "subtopic_id": 9,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "The Pathfinder's `emergencyProtocol` runs `steps` in a `for` loop. The loop is designed to log each `step` and `break` only if a critical `errorDetected` is `true`. However, the current code's `break` condition is too broad (`step == 3` always triggers it), causing the loop to terminate prematurely. Fix the code to ensure the `break` only triggers under a truly critical condition.",
      "code": "public class EmergencyProtocolTerminator {\n    public static void main(String[] args) {\n        boolean errorDetected = false;\n        for (int step = 1; step <= 5; step++) {\n            System.out.println(\"Protocol Step: \" + step);\n            if (errorDetected) { // Corrected: Only break if actual error\n                System.out.println(\"  CRITICAL: Aborting protocol due to error.\");\n                break;\n            }\n        }\n        System.out.println(\"Protocol Status: Completed.\");\n    }\n}",
      "expected_output": [
        "Protocol Step: 1\\nProtocol Step: 2\\nProtocol Step: 3\\nProtocol Step: 4\\nProtocol Step: 5\\nProtocol Status: Completed."
      ],
      "hidden_test_case": "",
      "answer": [
        "Protocol Step: 1\\nProtocol Step: 2\\nProtocol Step: 3\\nProtocol Step: 4\\nProtocol Step: 5\\nProtocol Status: Completed."
      ],
      "explanation": "The original code's `if (step == 3 || errorDetected)` statement caused the `for` loop to terminate prematurely when `step` was `3`. The `step == 3` part of the condition was too broad and triggered an early `break`. The fix is to remove `step == 3` from the `if` condition, ensuring the loop only breaks if `errorDetected` becomes `true` (which it doesn't in this snippet, so the loop runs to completion)."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The `break` statement immediately exits the entire loop.",
      "2": "The goal is for the loop to complete all 5 steps unless `errorDetected` is `true`.",
      "3": "Adjust the `if` condition for `break` so it's only met for a genuinely critical error."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 383,
    "subtopic_id": 9,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "The Pathfinder's `arrayScan` iterates through a `sensorDataArray`. The loop's update section (`i = i + 0`) is incorrect, causing an infinite loop. Fix the loop to correctly iterate through all elements of `sensorDataArray` from beginning to end.",
      "code": "public class ArrayScanFixer {\n    public static void main(String[] args) {\n        double[] sensorDataArray = {10.5, 20.2, 30.8, 40.1};\n        for (int i = 0; i < sensorDataArray.length; i++) { // Corrected: Use i++ for standard increment\n            System.out.println(\"Reading sensor data at index: \" + i + \" = \" + sensorDataArray[i]);\n        }\n    }\n}",
      "expected_output": [
        "Reading sensor data at index: 0 = 10.5\\nReading sensor data at index: 1 = 20.2\\nReading sensor data at index: 2 = 30.8\\nReading sensor data at index: 3 = 40.1"
      ],
      "hidden_test_case": "",
      "answer": [
        "Reading sensor data at index: 0 = 10.5\\nReading sensor data at index: 1 = 20.2\\nReading sensor data at index: 2 = 30.8\\nReading sensor data at index: 3 = 40.1"
      ],
      "explanation": "The original `for` loop's update section was `i = i + 0`. This expression always evaluates to `i` itself, effectively never changing the value of `i`. As a result, `i` remains `0`, and the loop condition `i < sensorDataArray.length` is always `true` (assuming `sensorDataArray.length` is greater than 0), leading to an infinite loop. The fix is to change the update expression to `i++` (or `i = i + 1`), which correctly increments `i` by 1 in each iteration, allowing the loop to process all array elements and terminate."
    },
    "difficulty": "medium",
    "hints": {
      "1": "A `for` loop's `increment` section is responsible for moving to the next iteration.",
      "2": "If the increment doesn't change the loop variable, it can lead to an infinite loop.",
      "3": "The expression `i = i + 0` is essentially `i = i`, which doesn't change `i`."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 384,
    "subtopic_id": 9,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "The Pathfinder's `missionLog` filters `eventCodes` using an enhanced `for` loop. The code incorrectly uses `break` to skip non-critical events, causing premature loop termination. Fix the code to correctly *skip* non-critical events and display only critical ones.",
      "code": "public class MissionLogFilterFixer {\n    public static void main(String[] args) {\n        int[] missionLog = {100, 500, 250, 600, 400};\n        for (int eventCode : missionLog) {\n            if (eventCode < 500) {\n                continue; // Corrected: use continue to skip\n            }\n            System.out.println(\"Critical Event: \" + eventCode);\n        }\n    }\n}",
      "expected_output": [
        "Critical Event: 500\\nCritical Event: 600"
      ],
      "hidden_test_case": "",
      "answer": [
        "Critical Event: 500\\nCritical Event: 600"
      ],
      "explanation": "The original code uses `if (eventCode < 500) { break; }`. This causes the loop to terminate prematurely as soon as it encounters a non-critical event (`100`), preventing any subsequent critical events (`500`, `600`) from being processed. The intent is to *skip* non-critical events and continue to the next, not to abort the entire log processing. The fix is to change `break` to `continue`. The `continue` statement skips the rest of the current iteration (the `System.out.println()`) but allows the loop to proceed to the next element in the array, correctly filtering and printing only critical events."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The `break` statement immediately exits the entire loop. If the goal is to *skip* certain iterations but continue the loop, a different keyword is needed.",
      "2": "The `if` condition `eventCode < 500` identifies non-critical events.",
      "3": "The desired behavior is to process all elements but only *print* those that meet the critical criteria (500 or higher)."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 385,
    "subtopic_id": 9,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "The Pathfinder's `payloadScanner` inspects `cargoWeight` entries using nested `for` loops. The code has logic flaws (incorrect conditions or variable updates) causing it to incorrectly report \"Scan Complete\" when a critical payload (weight > 150) should abort the scan. Fix the code to correctly detect and report an aborted scan.",
      "code": "public class PayloadScannerFixer {\n    public static void main(String[] args) {\n        int criticalThreshold = 100;\n        boolean scanAborted = false;\n        \n        for (int scanCycle = 0; scanCycle < 2; scanCycle++) {\n            System.out.println(\"Starting Scan Cycle: \" + scanCycle);\n            for (int payloadItem = 0; payloadItem < 3; payloadItem++) {\n                int itemWeight = 50 + (payloadItem * 30);\n                if (itemWeight > criticalThreshold) { // Corrected: Condition to break if itemWeight is *above* threshold\n                    System.out.println(\"  CRITICAL PAYLOAD DETECTED: \" + itemWeight + \"kg. Aborting scan.\");\n                    scanAborted = true;\n                    break;\n                }\n                System.out.println(\"  Checking Item: \" + payloadItem + \", Weight: \" + itemWeight);\n            }\n            if (scanAborted) {\n                break;\n            }\n        }\n        \n        if (scanAborted) {\n            System.out.println(\"Scan Status: Scan Aborted.\");\n        } else {\n            System.out.println(\"Scan Status: Scan Complete.\");\n        }\n    }\n}",
      "expected_output": [
        "Starting Scan Cycle: 0\\n  Checking Item: 0, Weight: 50\\n  Checking Item: 1, Weight: 80\\n  CRITICAL PAYLOAD DETECTED: 110kg. Aborting scan.\\nScan Status: Scan Aborted."
      ],
      "hidden_test_case": "",
      "answer": [
        "Starting Scan Cycle: 0\\n  Checking Item: 0, Weight: 50\\n  Checking Item: 1, Weight: 80\\n  CRITICAL PAYLOAD DETECTED: 110kg. Aborting scan.\\nScan Status: Scan Aborted."
      ],
      "explanation": "The original code has several flaws:\n1.  **Incorrect `break` condition:** `if (itemWeight < criticalThreshold)` incorrectly breaks the inner loop if the weight is *below* threshold, when it should break if `itemWeight` is *above* it. This would cause early breaks for normal items.\n2.  **Missing `scanAborted` flag update:** The `scanAborted` boolean is never set to `true` inside the loop, so the final `if (scanAborted)` always evaluates to `false`.\n3.  **No outer loop termination:** Even if `scanAborted` were set correctly, breaking the inner loop only exits that loop; the outer loop would continue to the next `scanCycle`.\n\nThe fix addresses these:\n1.  Changes `itemWeight < criticalThreshold` to `itemWeight > criticalThreshold` for the `break` condition.\n2.  Adds `scanAborted = true;` inside the `break` block of the inner loop.\n3.  Adds an `if (scanAborted) { break; }` check *after* the inner loop completes (but still within the outer loop's body) to ensure the outer loop also terminates when a critical payload is found. This correctly sets the `scanAborted` flag and allows the final status message to reflect an aborted scan."
    },
    "difficulty": "medium",
    "hints": {
      "1": "The `break` statement in the inner loop exits *only* the inner loop. If an outer loop also needs to stop, an additional check or `break` is needed in the outer loop's body.",
      "2": "The critical condition for breaking the loop is `itemWeight > criticalThreshold`.",
      "3": "The `scanAborted` flag needs to be set to `true` when the critical condition is met."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 386,
    "subtopic_id": 9,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "The Pathfinder's `systemDeployment` involves multiple stages and sub-routines using nested `for` loops. A `WARNING` is logged for specific anomalies, and a `CRITICAL FAILURE` (breaking both loops) occurs under other conditions. The code has flaws in its nested loop control flow. Fix the code to ensure correct warning and critical failure triggers, including properly breaking both inner and outer loops.",
      "code": "public class SystemDeployment {\n    public static void main(String[] args) {\n        boolean criticalErrorDetected = false;\n        \n        for (int systemStage = 0; systemStage < 2; systemStage++) {\n            System.out.println(\"Deploying Stage: \" + systemStage);\n            for (int routineCheck = 0; routineCheck < 3; routineCheck++) {\n                System.out.println(\"  Running Routine Check: \" + routineCheck);\n                \n                if (systemStage == 0 && routineCheck == 1) {\n                    System.out.println(\"  WARNING: Minor anomaly detected.\");\n                } else if (systemStage == 1 && routineCheck == 0) {\n                    criticalErrorDetected = true;\n                    System.out.println(\"  CRITICAL FAILURE: Aborting deployment!\");\n                    break;\n                }\n            }\n            if (criticalErrorDetected) {\n                break;\n            }\n        }\n        \n        if (criticalErrorDetected) {\n            System.out.println(\"\\nDeployment Aborted due to critical error.\");\n        } else {\n            System.out.println(\"\\nDeployment completed successfully.\");\n        }\n    }\n}",
      "expected_output": [
        "Deploying Stage: 0\\n  Running Routine Check: 0\\n  Running Routine Check: 1\\n  WARNING: Minor anomaly detected.\\n  Running Routine Check: 2\\nDeploying Stage: 1\\n  Running Routine Check: 0\\n  CRITICAL FAILURE: Aborting deployment!\\n\\nDeployment Aborted due to critical error."
      ],
      "hidden_test_case": "",
      "answer": [
        "Deploying Stage: 0\\n  Running Routine Check: 0\\n  Running Routine Check: 1\\n  WARNING: Minor anomaly detected.\\n  Running Routine Check: 2\\nDeploying Stage: 1\\n  Running Routine Check: 0\\n  CRITICAL FAILURE: Aborting deployment!\\n\\nDeployment Aborted due to critical error."
      ],
      "explanation": "The original code had correct `if-else if` logic for warnings and critical failures within the inner loop. The `criticalErrorDetected` flag was also correctly set. The missing pieces were ensuring the outer loop also terminates. The fix adds an `if (criticalErrorDetected) { break; }` check immediately after the inner loop. This ensures that if a critical error caused the inner loop to `break`, the outer loop also `breaks`, leading to an overall `Deployment Aborted` status."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The `break` statement only exits the *innermost* loop it is in. To exit an outer loop, a mechanism like a flag and an outer `break` is needed.",
      "2": "Identify where the outer loop needs to check if the inner loop caused an abort.",
      "3": "Ensure the `criticalErrorDetected` flag is set correctly and then checked in the appropriate place in the outer loop."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 387,
    "subtopic_id": 9,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "The Pathfinder's `repairDrone` performs `repairCycles` across `damageZones` using nested `for` loops. The drone can `skip` analysis for problematic attempts or `break` the current zone's repair on critical failure. The current code has issues that prevent the correct skipping and breaking behavior. Fix the code to ensure `skippedAttempts` increment correctly and `abortedZones` are tracked when inner loops `break`.",
      "code": "public class RepairDroneControl {\n    public static void main(String[] args) {\n        int skippedAttempts = 0;\n        int abortedZones = 0;\n        \n        for (int damageZone = 1; damageZone <= 2; damageZone++) {\n            System.out.println(\"Processing Damage Zone: \" + damageZone);\n            for (int repairAttempt = 1; repairAttempt <= 3; repairAttempt++) {\n                if (repairAttempt == 2 && damageZone == 1) {\n                    System.out.println(\"  Skipping problematic attempt \" + repairAttempt + \" in Zone \" + damageZone);\n                    skippedAttempts++;\n                    continue;\n                }\n                if (repairAttempt == 3) {\n                    System.out.println(\"  CRITICAL FAILURE: Aborting attempts in Zone \" + damageZone);\n                    abortedZones++;\n                    break;\n                }\n                System.out.println(\"  Repair attempt \" + repairAttempt + \" in Zone \" + damageZone + \" OK.\");\n            }\n        }\n        System.out.println(\"\\nTotal Skipped Attempts: \" + skippedAttempts);\n        System.out.println(\"Total Aborted Zones: \" + abortedZones);\n    }\n}",
      "expected_output": [
        "Processing Damage Zone: 1\\n  Repair attempt 1 in Zone 1 OK.\\n  Skipping problematic attempt 2 in Zone 1\\n  CRITICAL FAILURE: Aborting attempts in Zone 1.\\nProcessing Damage Zone: 2\\n  Repair attempt 1 in Zone 2 OK.\\n  Repair attempt 2 in Zone 2 OK.\\n  CRITICAL FAILURE: Aborting attempts in Zone 2.\\n\\nTotal Skipped Attempts: 1\\nTotal Aborted Zones: 2"
      ],
      "hidden_test_case": "",
      "answer": [
        "Processing Damage Zone: 1\\n  Repair attempt 1 in Zone 1 OK.\\n  Skipping problematic attempt 2 in Zone 1\\n  CRITICAL FAILURE: Aborting attempts in Zone 1.\\nProcessing Damage Zone: 2\\n  Repair attempt 1 in Zone 2 OK.\\n  Repair attempt 2 in Zone 2 OK.\\n  CRITICAL FAILURE: Aborting attempts in Zone 2.\\n\\nTotal Skipped Attempts: 1\\nTotal Aborted Zones: 2"
      ],
      "explanation": "The original code correctly uses `continue` to skip the rest of the inner loop body and `break` to exit the inner loop for critical failures. The problem's description of faulty behavior regarding `skippedAttempts` and `abortedZones` implies an issue in their increment logic or final print, but the provided correct snippet shows standard and correct incrementing of `skippedAttempts` when `continue` is used, and `abortedZones` when `break` is used. This challenge tests careful tracing of `continue` and `break` impacts on counters."
    },
    "difficulty": "hard",
    "hints": {
      "1": "Carefully trace how `skippedAttempts` increments: does the `continue` prevent its increment or only the rest of the loop body?",
      "2": "The `break` statement exits only the *inner* loop. `abortedZones` should increment every time an inner loop `break` is triggered.",
      "3": "Simulate the execution step by step for both `damageZone` loops to get the final counts."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 388,
    "subtopic_id": 9,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "The Pathfinder's `nestedSystemScan` performs checks in `systemLayers` and `subScanPoints`. A `WARNING` (using `continue`) occurs at (Layer 0, SubScan 1), and a `CRITICAL` anomaly (using `break`) at (Layer 1, SubScan 0), which should stop both loops. The code has flaws preventing correct `continue` and `break` behavior in nested loops. Fix the code to ensure proper skip and abort logic.",
      "code": "public class NestedSystemScan {\n    public static void main(String[] args) {\n        boolean scanAborted = false;\n        \n        for (int systemLayer = 0; systemLayer < 2; systemLayer++) {\n            System.out.println(\"Scanning System Layer: \" + systemLayer);\n            for (int subScanPoint = 0; subScanPoint < 3; subScanPoint++) {\n                if (systemLayer == 0 && subScanPoint == 1) {\n                    System.out.println(\"  WARNING: Minor anomaly at (\" + systemLayer + \",\" + subScanPoint + \").\");\n                    continue; // Corrected: continue to skip rest of iteration\n                }\n                \n                if (systemLayer == 1 && subScanPoint == 0) {\n                    scanAborted = true;\n                    System.out.println(\"  CRITICAL: Major anomaly at (\" + systemLayer + \",\" + subScanPoint + \"). Aborting scan.\");\n                    break; // Corrected: break inner loop\n                }\n                \n                System.out.println(\"  Scan Point: \" + subScanPoint + \" OK.\");\n            }\n            if (scanAborted) {\n                break; // Corrected: break outer loop if flag is set\n            }\n        }\n        \n        System.out.println(\"\\nScan Status: \" + (scanAborted ? \"Aborted\" : \"Complete\"));\n    }\n}",
      "expected_output": [
        "Scanning System Layer: 0\\n  Scan Point: 0 OK.\\n  WARNING: Minor anomaly at (0,1).\\n  Scan Point: 2 OK.\\nScanning System Layer: 1\\n  CRITICAL: Major anomaly at (1,0). Aborting scan.\\n\\nScan Status: Aborted"
      ],
      "hidden_test_case": "",
      "answer": [
        "Scanning System Layer: 0\\n  Scan Point: 0 OK.\\n  WARNING: Minor anomaly at (0,1).\\n  Scan Point: 2 OK.\\nScanning System Layer: 1\\n  CRITICAL: Major anomaly at (1,0). Aborting scan.\\n\\nScan Status: Aborted"
      ],
      "explanation": "The original code had correct conditions for warning (`continue`) and critical (`break`). The main issue was ensuring the outer loop also terminates when the critical anomaly is detected in the inner loop. The fix involves adding an `if (scanAborted) { break; }` check inside the outer loop, immediately after the inner loop completes. This check ensures that if the `scanAborted` flag was set by a `break` in the inner loop, the outer loop also terminates, leading to the correct overall 'Aborted' status."
    },
    "difficulty": "hard",
    "hints": {
      "1": "A `continue` statement skips the rest of the current inner loop iteration.",
      "2": "A `break` statement only exits the innermost loop it's in. To exit an outer loop, an additional `break` based on a flag is needed.",
      "3": "Ensure the `scanAborted` flag is correctly set to `true` when the critical condition is met, and then checked by the outer loop."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 389,
    "subtopic_id": 9,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "The Pathfinder's `droneFleetDeployment` system uses nested `for` loops. The outer loop iterates `droneGroups`. The inner loop performs `deployments`. If `droneGroup` is `1` and `deployment` is `2`, it signifies 'Resupply Needed' and should `skip` the remaining logging for that deployment but still count it. If `droneGroup` is `2` and `deployment` is `1`, it indicates 'Critical Maintenance' and should `break` the inner loop. The original code has flaws in skipping or breaking behavior. Fix the code to ensure correct loop control and accurate `totalDeployments` counting.",
      "code": "public class DroneFleetDeployment {\n    public static void main(String[] args) {\n        int totalDeployments = 0;\n        \n        for (int droneGroup = 1; droneGroup <= 2; droneGroup++) {\n            System.out.println(\"Deploying Drone Group: \" + droneGroup);\n            for (int deployment = 1; deployment <= 3; deployment++) {\n                if (droneGroup == 1 && deployment == 2) {\n                    System.out.println(\"  Resupply Needed: Skipping deployment \" + deployment);\n                    totalDeployments++; \n                    continue;\n                }\n                if (droneGroup == 2 && deployment == 1) {\n                    System.out.println(\"  CRITICAL MAINTENANCE: Aborting deployments in group \" + deployment);\n                    totalDeployments++;\n                    break;\n                }\n                System.out.println(\"  Drone \" + deployment + \" deployed.\");\n                totalDeployments++;\n            }\n        }\n        System.out.println(\"\\nTotal Fleet Deployments: \" + totalDeployments);\n    }\n}",
      "expected_output": [
        "Deploying Drone Group: 1\\n  Drone 1 deployed.\\n  Resupply Needed: Skipping deployment 2\\n  Drone 3 deployed.\\nDeploying Drone Group: 2\\n  CRITICAL MAINTENANCE: Aborting deployments in group 1.\\n\\nTotal Fleet Deployments: 5"
      ],
      "hidden_test_case": "",
      "answer": [
        "Deploying Drone Group: 1\\n  Drone 1 deployed.\\n  Resupply Needed: Skipping deployment 2\\n  Drone 3 deployed.\\nDeploying Drone Group: 2\\n  CRITICAL MAINTENANCE: Aborting deployments in group 1.\\n\\nTotal Fleet Deployments: 5"
      ],
      "explanation": "The original code had correct `continue` and `break` logic for skipping and breaking the inner loop. The problem's description of faulty behavior implies that these were not working as intended. This challenge tests careful tracing of how `continue` prevents the rest of the current iteration's code from executing (including the regular 'Drone deployed' message) and how `break` stops the inner loop entirely for a given group. The fix ensures these keywords are correctly positioned to achieve the precise output and `totalDeployments` count."
    },
    "difficulty": "hard",
    "hints": {
      "1": "A `continue` statement skips the rest of the current loop iteration, but the loop continues to the next iteration.",
      "2": "A `break` statement exits the *innermost* loop immediately.",
      "3": "Carefully trace how `totalDeployments` is incremented in each conditional branch and outside the `if` statements."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 390,
    "subtopic_id": 9,
    "type": "code_fixer",
    "snippet_choices": {
      "scenario": "The Pathfinder's `dynamicSectorScan` processes `sectorZones` and `subScans` using nested `for` loops. The code should skip analysis for weak signals (`continue`) or abort the entire survey for critical anomalies (`break`). The original code has flaws in its control flow that prevent correct `continue` or `break` behavior. Fix the code to ensure proper skip and abort logic for survey scans.",
      "code": "public class DynamicSectorScan {\n    public static void main(String[] args) {\n        int anomalyCount = 0;\n        int signalStrength = 100; // Starts strong\n        boolean surveyAborted = false;\n        \n        for (int sectorZone = 0; sectorZone < 2; sectorZone++) {\n            System.out.println(\"Initiating Sector Zone Scan: \" + sectorZone);\n            for (int subScan = 0; subScan < 3; subScan++) {\n                if (sectorZone == 1 && subScan == 1) {\n                    anomalyCount++;\n                    System.out.println(\"  ANOMALY DETECTED at (\" + sectorZone + \",\" + subScan + \")! Anomalies: \" + anomalyCount);\n                    continue; // Corrected: Continue to skip normal processing\n                }\n                \n                if (signalStrength < 50) {\n                    System.out.println(\"  WARNING: Weak Signal. Skipping analysis.\");\n                    continue; // Corrected: Continue to skip normal processing\n                }\n\n                if (anomalyCount >= 2) { // Changed to >= 2 to break only when 2+ anomalies\n                    surveyAborted = true;\n                    System.out.println(\"  SURVEY ABORTED: Too many anomalies detected.\");\n                    break; // Corrected: Break inner loop\n                }\n                \n                System.out.println(\"  Sub-Scan \" + subScan + \" OK.\");\n            }\n            if (surveyAborted) {\n                break; // Corrected: Break outer loop if flag is set\n            }\n        }\n        \n        System.out.println(\"\\nSurvey complete.\");\n        if (surveyAborted) {\n            System.out.println(\"Final Survey Status: Aborted.\");\n        } else {\n            System.out.println(\"Final Survey Status: All sectors scanned.\");\n        }\n    }\n}",
      "expected_output": [
        "Initiating Sector Zone Scan: 0\\n  Sub-Scan 0 OK.\\n  Sub-Scan 1 OK.\\n  Sub-Scan 2 OK.\\nInitiating Sector Zone Scan: 1\\n  Sub-Scan 0 OK.\\n  ANOMALY DETECTED at (1,1)! Anomalies: 1\\n  Sub-Scan 2 OK.\\n\\nSurvey complete.\\nFinal Survey Status: All sectors scanned."
      ],
      "hidden_test_case": "",
      "answer": [
        "Initiating Sector Zone Scan: 0\\n  Sub-Scan 0 OK.\\n  Sub-Scan 1 OK.\\n  Sub-Scan 2 OK.\\nInitiating Sector Zone Scan: 1\\n  Sub-Scan 0 OK.\\n  ANOMALY DETECTED at (1,1)! Anomalies: 1\\n  Sub-Scan 2 OK.\\n\\nSurvey complete.\\nFinal Survey Status: All sectors scanned."
      ],
      "explanation": "The original code had various issues in its `continue` and `break` conditions, leading to incorrect behavior. The fixes ensure that:\n1. `continue` is correctly used for 'Anomaly Detected' and 'Weak Signal' conditions to skip the rest of the current inner loop iteration without breaking the loop.\n2. `break` is correctly used for `anomalyCount >= 2` to exit the inner loop, and `surveyAborted` is set. \n3. An `if (surveyAborted) { break; }` is added to the outer loop to ensure the entire survey aborts if a critical anomaly is found. This ensures the output reflects successful completion as `anomalyCount` does not reach 2 in this specific test case."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The `continue` keyword skips the rest of the current inner loop iteration, moving to the next iteration.",
      "2": "The `break` keyword exits the *innermost* loop it's in immediately.",
      "3": "To abort an outer loop based on a condition inside an inner loop, a flag and an outer `break` are often needed."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 391,
    "subtopic_id": 9,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder's `diagnosticRoutine` performs checks on various `systemParts`. A `for` loop is used to iterate through the `systemParts` array by index. Complete the loop's condition to iterate through all elements.",
      "code": "public class DiagnosticRoutine {\n    public static void main(String[] args) {\n        String[] systemParts = {\"Engine\", \"Navigation\", \"Life Support\"};\n        for (int i = 0; ???; i++) {\n            System.out.println(\"Checking: \" + systemParts[i]);\n        }\n    }\n}",
      "choices": [
        "i < systemParts.length",
        "i <= systemParts.length",
        "i > 0",
        "i == systemParts.length"
      ],
      "answer": [
        "i < systemParts.length"
      ],
      "explanation": "The loop needs to iterate through all valid indices of the `systemParts` array, which are from `0` to `length - 1`. The condition `i < systemParts.length` correctly ensures this, stopping before `i` becomes equal to the array's length, thus preventing an `ArrayIndexOutOfBoundsException`."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The loop should iterate through all valid indices of the `systemParts` array.",
      "2": "Arrays are zero-indexed, so the highest valid index is `length - 1`.",
      "3": "The blank requires a comparison operator and the array's length property."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 392,
    "subtopic_id": 9,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder's `powerCore` needs diagnostics run in reverse order, from `5 down to 1`. Complete the `for` loop's initialization.",
      "code": "public class PowerCoreDiagnostics {\n    public static void main(String[] args) {\n        for (int diagnosticID = ???; diagnosticID > 0; diagnosticID--) {\n            System.out.println(\"Running diagnostic for ID: \" + diagnosticID);\n        }\n    }\n}",
      "choices": [
        "0",
        "5",
        "1",
        "diagnosticID"
      ],
      "answer": [
        "5"
      ],
      "explanation": "The countdown should start from `5`. Therefore, `5` is the correct initial value for `diagnosticID` to begin the countdown sequence."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The countdown should start from `5`.",
      "2": "The blank is for the initial value of the loop counter.",
      "3": "The loop decrements, indicating a countdown."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 393,
    "subtopic_id": 9,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder's `commsLog` contains `messageCodes`. The system uses a `for` loop to iterate through these codes. If a `messageCode` is `below 100`, it should be `skipped` (not printed). Complete the loop's `if` condition with the correct comparison operator.",
      "code": "public class CommsLogFilter {\n    public static void main(String[] args) {\n        int[] commsLog = {50, 120, 80, 150};\n        for (int i = 0; i < commsLog.length; i++) {\n            if (commsLog[i] ??? 100) {\n                continue;\n            }\n            System.out.println(\"Processing message: \" + commsLog[i]);\n        }\n    }\n}",
      "choices": [
        "<",
        "<=",
        ">",
        "=="
      ],
      "answer": [
        "<"
      ],
      "explanation": "The condition for skipping needs to check if `messageCode` is `below` 100. Therefore, `<` is the correct comparison operator to identify messages below the threshold, causing the `continue` statement to skip the current iteration."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The condition for skipping needs to check if `messageCode` is `below` 100.",
      "2": "Which comparison operator means 'less than'?",
      "3": "The blank requires a single operation symbol."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 394,
    "subtopic_id": 9,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder's `mainDiagnostics` runs `checkNumber`s. If `checkNumber` reaches `3`, it indicates a critical system failure, and the loop must `abort` immediately. Complete the keyword to abort the loop.",
      "code": "public class MainDiagnostics {\n    public static void main(String[] args) {\n        for (int checkNumber = 0; checkNumber < 5; checkNumber++) {\n            System.out.println(\"Running check: \" + checkNumber);\n            if (checkNumber == 3) {\n                System.out.println(\"Critical failure detected! Aborting.\");\n                ???;\n            }\n        }\n    }\n}",
      "choices": [
        "break",
        "continue",
        "return",
        "exit"
      ],
      "answer": [
        "break"
      ],
      "explanation": "The `break` keyword is used to immediately terminate the entire `for` loop, aborting further diagnostics, which is the required behavior for a critical system failure."
    },
    "difficulty": "easy",
    "hints": {
      "1": "The loop needs to exit completely when `checkNumber` is `3`.",
      "2": "Which keyword immediately terminates the entire loop?",
      "3": "The blank needs a single control flow keyword."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 395,
    "subtopic_id": 9,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder's personnel system processes `crewRanks` using an enhanced `for` loop. If a `rank` is `null`, it should print \"Empty Rank Slot\" and `continue` to the next. Complete the `if` condition with the correct comparison operator.",
      "code": "public class CrewRankProcessor {\n    public static void main(String[] args) {\n        String[] crewRanks = {\"Captain\", \"Lieutenant\", null, \"Engineer\"};\n        for (String rank : crewRanks) {\n            if (rank ??? null) {\n                System.out.println(\"Empty Rank Slot.\");\n                continue;\n            }\n            System.out.println(\"Processing Rank: \" + rank);\n        }\n    }\n}",
      "choices": [
        "==",
        "!=",
        "equals",
        "not"
      ],
      "answer": [
        "=="
      ],
      "explanation": "To check if a non-primitive variable (like a `String`) is pointing to `null` (nothing), the `==` operator is used. This correctly identifies empty rank slots."
    },
    "difficulty": "easy",
    "hints": {
      "1": "To check if a variable points to 'nothing', you compare it to a specific keyword.",
      "2": "Which comparison operator checks for exact equality to `null`?",
      "3": "The blank requires a single operation symbol."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 396,
    "subtopic_id": 9,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder's `systemDeployment` involves multiple stages and sub-routines using nested `for` loops. A `WARNING` is logged for specific anomalies, and a `CRITICAL FAILURE` occurs under other conditions. Complete the inner loop's `break` keyword and the outer loop's final status check keyword.",
      "code": "public class SystemDeployment {\n    public static void main(String[] args) {\n        boolean criticalErrorDetected = false;\n        \n        for (int systemStage = 0; systemStage < 2; systemStage++) {\n            System.out.println(\"Deploying Stage: \" + systemStage);\n            for (int routineCheck = 0; routineCheck < 3; routineCheck++) {\n                System.out.println(\"  Running Routine Check: \" + routineCheck);\n                \n                if (systemStage == 0 && routineCheck == 1) {\n                    System.out.println(\"  WARNING: Minor anomaly detected.\");\n                } else if (systemStage == 1 && routineCheck == 0) {\n                    criticalErrorDetected = true;\n                    System.out.println(\"  CRITICAL FAILURE: Aborting deployment!\");\n                    break;\n                }\n            }\n            if (criticalErrorDetected) {\n                break;\n            }\n        }\n        \n        if (criticalErrorDetected) {\n            System.out.println(\"\\nDeployment Aborted due to critical error.\");\n        } else {\n            System.out.println(\"\\nDeployment completed successfully.\");\n        }\n    }\n}",
      "choices": [
        "<",
        "<=",
        "1",
        "2",
        "0",
        "continue",
        "else if",
        "break"
      ],
      "answer": [
        "break",
        "else if",
        "continue",
        "break"
      ]
    },
    "difficulty": "medium",
    "hints": {
      "1": "The inner loop needs a `break` to exit immediately on critical failure.",
      "2": "The `else if` is used to chain the warning condition.",
      "3": "The `continue` keyword is used to skip the rest of the current iteration."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 397,
    "subtopic_id": 9,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder's `repairDrone` performs `repairCycles` across `damageZones` using nested `for` loops. The drone can `skip` analysis for problematic attempts or `break` the current zone's repair on critical failure. The system also tracks `skippedAttempts` and `abortedZones`. Complete the inner loop's `continue` keyword, the inner loop's `break` keyword, and the outer loop's `if` condition check.",
      "code": "public class RepairDroneControl {\n    public static void main(String[] args) {\n        int skippedAttempts = 0;\n        int abortedZones = 0;\n        \n        for (int damageZone = 1; damageZone <= 2; damageZone++) {\n            System.out.println(\"Processing Damage Zone: \" + damageZone);\n            for (int repairAttempt = 1; repairAttempt <= 3; repairAttempt++) {\n                if (repairAttempt == 2 && damageZone == 1) {\n                    System.out.println(\"  Skipping problematic attempt \" + repairAttempt + \" in Zone \" + damageZone);\n                    skippedAttempts++;\n                    continue;\n                }\n                if (repairAttempt == 3) {\n                    System.out.println(\"  CRITICAL FAILURE: Aborting attempts in Zone \" + damageZone);\n                    abortedZones++;\n                    break;\n                }\n                System.out.println(\"  Repair attempt \" + repairAttempt + \" in Zone \" + damageZone + \" OK.\");\n            }\n            if (abortedZones > 0) { // Corrected: outer loop condition for abort\n                break;\n            }\n        }\n        System.out.println(\"\\nTotal Skipped Attempts: \" + skippedAttempts);\n        System.out.println(\"Total Aborted Zones: \" + abortedZones);\n    }\n}",
      "choices": [
        "0",
        "1",
        "continue",
        "break",
        "abortedZones",
        "totalAttempts",
        "while",
        "else"
      ],
      "answer": [
        "continue",
        "break",
        "abortedZones"
      ]
    },
    "difficulty": "medium",
    "hints": {
      "1": "The blank for 'Skipping' requires a keyword to skip the current inner loop iteration.",
      "2": "The blank for 'Aborting' requires a keyword to exit the inner loop immediately.",
      "3": "The outer loop needs a condition to check if any `abortedZones` occurred, to `break` early."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 398,
    "subtopic_id": 9,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder runs a `nestedSystemScan` over `systemLayers` and `subScanPoints`. If a \"WARNING\" (`Layer 0, Step 1`) occurs, it `skips` further logging for that step. If a \"CRITICAL\" (`Layer 1, Step 0`) occurs, it `breaks` the *current layer's* scan. Complete the inner loop's `continue` keyword, the inner loop's `break` keyword, and the final status logic.",
      "code": "public class NestedSystemScan {\n    public static void main(String[] args) {\n        boolean scanAborted = false;\n        \n        for (int systemLayer = 0; systemLayer < 2; systemLayer++) {\n            System.out.println(\"Scanning System Layer: \" + systemLayer);\n            for (int subScanPoint = 0; subScanPoint < 3; subScanPoint++) {\n                if (systemLayer == 0 && subScanPoint == 1) {\n                    System.out.println(\"  WARNING: Minor anomaly at (\" + systemLayer + \",\" + subScanPoint + \").\");\n                    continue;\n                }\n                \n                if (systemLayer == 1 && subScanPoint == 0) {\n                    scanAborted = true;\n                    System.out.println(\"  CRITICAL: Major anomaly at (\" + systemLayer + \",\" + subScanPoint + \"). Aborting scan.\");\n                    break;\n                }\n                \n                System.out.println(\"  Scan Point: \" + subScanPoint + \" OK.\");\n            }\n            if (scanAborted) {\n                break;\n            }\n        }\n        \n        System.out.println(\"\\nScan Status: \" + (scanAborted ? \"Aborted\" : \"Complete\"));\n    }\n}",
      "choices": [
        "continue",
        "break",
        "else if",
        "if",
        "true",
        "false",
        "null",
        "String"
      ],
      "answer": [
        "continue",
        "break",
        "scanAborted"
      ]
    },
    "difficulty": "medium",
    "hints": {
      "1": "The blank for 'WARNING' needs a keyword to skip the rest of the inner loop iteration.",
      "2": "The blank for 'CRITICAL' needs a keyword to exit the inner loop immediately.",
      "3": "The final `Scan Status` output uses a ternary operator based on the `scanAborted` flag."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 399,
    "subtopic_id": 9,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder deploys a fleet of `drones`. Nested `for` loops manage `droneGroups` and `deployments`. Specific conditions cause a `skip` or `break` in deployments. The system tracks `totalDeployments`. Complete the inner loop's `continue` keyword, the inner loop's `break` keyword, and the final total deployments.",
      "code": "public class DroneFleetDeployment {\n    public static void main(String[] args) {\n        int totalDeployments = 0;\n        \n        for (int droneGroup = 1; droneGroup <= 2; droneGroup++) {\n            System.out.println(\"Deploying Drone Group: \" + droneGroup);\n            for (int deployment = 1; deployment <= 3; deployment++) {\n                if (droneGroup == 1 && deployment == 2) {\n                    System.out.println(\"  Resupply Needed: Skipping deployment \" + deployment);\n                    totalDeployments++;\n                    continue;\n                }\n                if (droneGroup == 2 && deployment == 1) {\n                    System.out.println(\"  CRITICAL MAINTENANCE: Aborting deployments in group \" + deployment);\n                    totalDeployments++;\n                    break;\n                }\n                System.out.println(\"  Drone \" + deployment + \" deployed.\");\n                totalDeployments++;\n            }\n        }\n        System.out.println(\"\\nTotal Fleet Deployments: \" + totalDeployments);\n    }\n}",
      "choices": [
        "0",
        "1",
        "continue",
        "break",
        "totalDeployments",
        "droneGroup",
        "deployment",
        "2"
      ],
      "answer": [
        "continue",
        "break",
        "totalDeployments"
      ]
    },
    "difficulty": "medium",
    "hints": {
      "1": "The blank for 'Resupply Needed' requires a keyword to skip to the next deployment attempt.",
      "2": "The blank for 'Critical Maintenance' requires a keyword to exit the inner loop immediately.",
      "3": "The final `println` should display the `totalDeployments` counter."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 400,
    "subtopic_id": 9,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder's `surveyDrone` performs `sectorScans`. Nested `for` loops manage `sectorZones` and `subScans`. The drone logs `anomalyCount` and handles `skip` or `break` based on conditions. Complete the `skip` keyword, the `break` keyword, and the final status message.",
      "code": "public class SurveyAnomalyReport {\n    public static void main(String[] args) {\n        int anomalyCount = 0;\n        \n        for (int sectorZone = 0; sectorZone < 2; sectorZone++) {\n            System.out.println(\"Initiating Sector Zone Scan: \" + sectorZone);\n            for (int subScan = 0; subScan < 3; subScan++) {\n                if (sectorZone == 1 && subScan == 1) {\n                    anomalyCount++;\n                    System.out.println(\"  ANOMALY DETECTED at (\" + sectorZone + \",\" + subScan + \")! Anomalies: \" + anomalyCount);\n                    continue;\n                }\n                \n                if (anomalyCount == 2) {\n                    System.out.println(\"  SURVEY ABORTED: Too many anomalies detected.\");\n                    break;\n                }\n                \n                System.out.println(\"  Sub-Scan \" + subScan + \" OK.\");\n            }\n            if (anomalyCount == 2) {\n                System.out.println(\"  Exiting Sector Zone \" + sectorZone + \" early.\");\n                break;\n            }\n        }\n        \n        System.out.println(\"\\nSurvey complete.\");\n        if (anomalyCount == 2) {\n            System.out.println(\"Final Survey Status: Aborted.\");\n        } else {\n            System.out.println(\"Final Survey Status: Completed.\");\n        }\n    }\n}",
      "choices": [
        "continue",
        "break",
        "2",
        "System.out.println(\"Final Survey Status: Completed.\");",
        "else if",
        "null",
        "3",
        "totalCount"
      ],
      "answer": [
        "continue",
        "break",
        "System.out.println(\"Final Survey Status: Completed.\");"
      ]
    },
    "difficulty": "medium",
    "hints": {
      "1": "The blank needs the keyword to skip the current inner loop iteration.",
      "2": "The blank needs the keyword to exit the inner loop immediately.",
      "3": "The final `System.out.println()` displays the success message if no anomaly caused an early exit."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 401,
    "subtopic_id": 9,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder launches `surveyDrones` to map a planetary grid. The process involves an outer `for` loop for `gridRows` and an inner `for` loop for `gridColumns`. If a \"Hazard Zone\" is found (Row 0, Column 1), the drone logs a warning and `skips` that column's analysis. If a \"Critical Anomaly\" is found (Row 1, Column 0), it logs a critical alert and `breaks` the inner loop, aborting the entire survey. Complete the code for the outer loop's initialization value, the inner loop's `skip` keyword, and the inner loop's `break` keyword.",
      "code": "public class PlanetaryGridSurvey {\n    public static void main(String[] args) {\n        boolean surveyAborted = false;\n        \n        for (int gridRow = 0; gridRow < 2; gridRow++) {\n            System.out.println(\"Surveying Grid Row: \" + gridRow);\n            for (int gridColumn = 0; gridColumn < 3; gridColumn++) {\n                if (gridRow == 0 && gridColumn == 1) {\n                    System.out.println(\"  WARNING: Hazard Zone at (\" + gridRow + \",\" + gridColumn + \"). Skipping analysis.\");\n                    gridColumn++;\n                    continue;\n                }\n                if (gridRow == 1 && gridColumn == 0) {\n                    System.out.println(\"  CRITICAL: Anomaly detected at (\" + gridRow + \",\" + gridColumn + \"). Aborting grid row.\");\n                    surveyAborted = true;\n                    break;\n                }\n                System.out.println(\"  Analyzing Grid Point: (\" + gridRow + \",\" + gridColumn + \").\");\n            }\n            if (surveyAborted) {\n                System.out.println(\"  Survey Aborted for subsequent rows.\");\n                break;\n            }\n        }\n        \n        System.out.println(\"\\nSurvey complete.\");\n        if (surveyAborted) {\n            System.out.println(\"Final Survey Status: Aborted.\");\n        } else {\n            System.out.println(\"Final Survey Status: All points mapped.\");\n        }\n    }\n}",
      "choices": [
        "0",
        "1",
        "continue",
        "break",
        "System.out.println(\"Final Survey Status: All points mapped.\");",
        "System.out.println(\"Final Survey Status: Review Data.\");",
        "gridRow++",
        "gridColumn++"
      ],
      "answer": [
        "0",
        "continue",
        "break"
      ],
      "explanation": "1. `0` (choice a) is the correct initialization for `gridRow` to start from 0.\n2. `continue` (choice c) is used to skip the rest of the inner loop body when a hazard zone is detected.\n3. `break` (choice d) is used to immediately exit the inner loop when a critical anomaly is detected."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The outer loop for `gridRow` should start from `0`.",
      "2": "The blank for 'Hazard Zone' requires a keyword to skip the current grid column's analysis.",
      "3": "The blank for 'Critical Anomaly' requires a keyword to exit the inner loop immediately."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 402,
    "subtopic_id": 9,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder's `maintenanceScheduler` generates a `schedule`. An outer `for` loop iterates through `systemAreas`. An inner `for` loop iterates `taskIDs` per area. If a task is 'Urgent' (Area 0, Task 2), the `taskID` should `reset` to `1` (causing it to repeat task 1). If a task is 'Blocked' (Area 1, Task 1), the inner loop should `break`. Complete the code for the outer loop's initialization value, the inner loop's conditional `reset`, and the inner loop's `break` keyword.",
      "code": "public class MaintenanceScheduler {\n    public static void main(String[] args) {\n        int urgentTasks = 0;\n        \n        for (int systemArea = 0; systemArea < 2; systemArea++) {\n            System.out.println(\"Generating schedule for System Area: \" + systemArea);\n            for (int taskID = 1; taskID <= 2; taskID++) {\n                if (systemArea == 0 && taskID == 2) {\n                    urgentTasks++;\n                    System.out.println(\"  URGENT: Maintenance task \" + taskID + \" in area \" + systemArea + \". Rescheduling for Task 1.\");\n                    taskID = 1; // Corrected: Reset taskID to 1\n                    continue;\n                }\n                if (systemArea == 1 && taskID == 1) {\n                    System.out.println(\"  BLOCKED: Task \" + taskID + \" in area \" + systemArea + \" blocked. Aborting area schedule.\");\n                    break;\n                }\n                System.out.println(\"  Schedule Task: \" + taskID + \" in Area: \" + systemArea);\n            }\n        }\n        System.out.println(\"\\nMaintenance Schedule Generation Complete. Urgent Tasks: \" + urgentTasks);\n        if (urgentTasks > 0) {\n            System.out.println(\"Final Status: Review Needed.\");\n        } else {\n            System.out.println(\"Final Status: Schedule OK.\");\n        }\n    }\n}",
      "choices": [
        "0",
        "1",
        "break",
        "continue",
        "urgentTasks",
        "\"Schedule OK\"",
        "\"Review Needed\"",
        "null"
      ],
      "answer": [
        "1",
        "break",
        "urgentTasks"
      ],
      "explanation": "1. `1` (choice b) is the correct value to reset `taskID` to 1, causing it to repeat task 1.\n2. `break` (choice c) is used to immediately exit the inner loop when a task is blocked.\n3. `urgentTasks` (choice e) is the variable to print for the final count of urgent tasks."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The `taskID` needs to be reset to `1` for rescheduling.",
      "2": "The blank for 'Blocked' task requires a keyword to exit the inner loop.",
      "3": "The final `println` displays the `urgentTasks` counter."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 403,
    "subtopic_id": 9,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder's `commsRelay` system tests communication links between `baseStations` and `relayPoints`. Nested `for` loops iterate these. If a link is 'Degraded' (Base 1, Relay 2), it `skips` the test. If a link is 'Broken' (Base 2, Relay 1), it `breaks` the current station's tests. Complete the code for the outer loop's initialization value, the inner loop's `skip` keyword, and the inner loop's `break` keyword.",
      "code": "public class CommsRelayTest {\n    public static void main(String[] args) {\n        int totalLinksTested = 0;\n        \n        for (int baseStation = 1; baseStation <= 2; baseStation++) {\n            System.out.println(\"Testing Base Station: \" + baseStation);\n            for (int relayPoint = 1; relayPoint <= 3; relayPoint++) {\n                if (baseStation == 1 && relayPoint == 2) {\n                    System.out.println(\"  Link Degraded at (\" + baseStation + \",\" + relayPoint + \"). Skipping test.\");\n                    totalLinksTested++;\n                    continue;\n                }\n                if (baseStation == 2 && relayPoint == 1) {\n                    System.out.println(\"  LINK BROKEN at (\" + baseStation + \",\" + relayPoint + \"). Aborting current station tests.\");\n                    totalLinksTested++;\n                    break;\n                }\n                System.out.println(\"  Link to Relay Point: (\" + baseStation + \",\" + relayPoint + \") OK.\");\n                totalLinksTested++;\n            }\n        }\n        System.out.println(\"\\nCommunication Test Complete. Total Links Tested: \" + totalLinksTested);\n    }\n}",
      "choices": [
        "0",
        "1",
        "continue",
        "break",
        "totalLinksTested",
        "baseStation",
        "relayPoint",
        "2"
      ],
      "answer": [
        "1",
        "continue",
        "break"
      ],
      "explanation": "1. `1` (choice b) is the correct initial value for `baseStation`.\n2. `continue` (choice c) skips the rest of the inner loop's current iteration when a link is degraded.\n3. `break` (choice d) immediately exits the inner loop when a link is broken."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The outer loop for `baseStation` should start from `1`.",
      "2": "The blank for 'Link Degraded' requires a keyword to skip to the next `relayPoint` test.",
      "3": "The blank for 'LINK BROKEN' requires a keyword to exit the inner loop immediately."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 404,
    "subtopic_id": 9,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder's `cargoManifest` lists `itemWeights`. Nested `for` loops iterate `cargoBays` and `itemIDs`. If `itemWeight` is `above 100`, it's a 'Heavy Item' warning and `continues`. If `itemWeight` is `above 150`, it's an 'Overload' alert and `breaks` the inner loop. Complete the code for the outer loop's initialization, the inner loop's `continue` keyword, and the inner loop's `break` keyword.",
      "code": "public class CargoManifestUpdater {\n    public static void main(String[] args) {\n        boolean overloadDetected = false;\n        \n        for (int cargoBay = 0; cargoBay < 2; cargoBay++) {\n            System.out.println(\"Processing Cargo Bay: \" + cargoBay);\n            for (int itemID = 0; itemID < 3; itemID++) {\n                int itemWeight = 50 + (itemID * 60);\n                if (itemWeight > 100 && itemWeight <= 150) {\n                    System.out.println(\"  WARNING: Heavy Item (\" + itemWeight + \"kg) at (\" + cargoBay + \",\" + itemID + \").\");\n                    itemID++;\n                    continue;\n                }\n                if (itemWeight > 150) {\n                    System.out.println(\"  OVERLOAD: Item \" + itemID + \" (\" + itemWeight + \"kg) exceeds capacity! Aborting bay scan.\");\n                    overloadDetected = true;\n                    break;\n                }\n                System.out.println(\"  Item: (\" + cargoBay + \",\" + itemID + \") weight OK.\");\n            }\n            if (overloadDetected) {\n                break;\n            }\n        }\n        \n        System.out.println(\"\\nManifest scan complete.\");\n        if (overloadDetected) {\n            System.out.println(\"Final Manifest Status: Overload Detected.\");\n        } else {\n            System.out.println(\"Final Manifest Status: OK.\");\n        }\n    }\n}",
      "choices": [
        "0",
        "1",
        "continue",
        "break",
        "System.out.println(\"Final Manifest Status: OK.\");",
        "System.out.println(\"Final Manifest Status: Partial Scan.\");",
        "cargoBay",
        "itemID"
      ],
      "answer": [
        "0",
        "continue",
        "break"
      ],
      "explanation": "1. `0` (choice a) is the correct initialization for `cargoBay`.\n2. `continue` (choice c) is used to skip the rest of the inner loop body when a heavy item is detected.\n3. `break` (choice d) is used to immediately exit the inner loop when an overload is detected."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The outer loop for `cargoBay` should start from `0`.",
      "2": "The blank for 'Heavy Item' requires a keyword to skip to the next item ID.",
      "3": "The blank for 'Overload' requires a keyword to exit the inner loop immediately."
    },
    "timer": 300,
    "points": 10
  },
  {
    "id": 405,
    "subtopic_id": 9,
    "type": "code_completion",
    "snippet_choices": {
      "scenario": "The Pathfinder's `finalDiagnosticSweep` performs nested `for` loop `sweeps` over `zones` and `subZones`. It tracks `successfulSweeps` and logs anomalies. If a critical anomaly occurs, it uses `continue` to skip the rest of the sub-zone processing. The final status message depends on the outcome. Complete the `continue` keyword, the `successfulSweeps` variable for counting, and the final completion message.",
      "code": "public class FinalDiagnosticSweep {\n    public static void main(String[] args) {\n        int successfulSweeps = 0;\n        \n        for (int zone = 0; zone < 2; zone++) {\n            for (int subZone = 0; subZone < 3; subZone++) {\n                if (zone == 1 && subZone == 1) {\n                    System.out.println(\"Anomaly in Zone \" + zone + \", SubZone \" + subZone + \".\");\n                    successfulSweeps++;\n                    continue; \n                }\n                \n                System.out.println(\"Sweep OK for Zone \" + zone + \", SubZone \" + subZone + \".\");\n                successfulSweeps++;\n            }\n            System.out.println(\"Zone \" + zone + \" processed. Sweeps in zone: \" + (zone == 0 ? 3 : 2));\n        }\n        \n        System.out.println(\"\\nTotal Successful Sweeps: \" + successfulSweeps);\n        System.out.println(\"Final Status: \" + \"Sweep Complete\");\n    }\n}",
      "choices": [
        "continue",
        "break",
        "successfulSweeps",
        "\"Sweep Complete\"",
        "\"Sweep Interrupted\"",
        "zone",
        "subZone",
        "totalSweeps"
      ],
      "answer": [
        "continue",
        "successfulSweeps",
        "\"Sweep Complete\""
      ],
      "explanation": "1. `continue` (choice a) is the keyword to skip the rest of the inner loop's current iteration when an anomaly is detected.\n2. `successfulSweeps` (choice c) is the variable holding the total count of sweeps.\n3. `\"Sweep Complete\"` (choice d) is the string literal for the final status message."
    },
    "difficulty": "hard",
    "hints": {
      "1": "The first blank needs the keyword to skip the current inner loop iteration.",
      "2": "The second blank needs the variable holding the total count of successful sweeps.",
      "3": "The third blank needs the string literal for the final status message."
    },
    "timer": 300,
    "points": 10
  }
]
